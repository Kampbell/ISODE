/*************************************************************/
/* Copyright (C) 2015 OSS Nokalva, Inc.  All rights reserved.*/
/*************************************************************/

/* THIS FILE IS PROPRIETARY MATERIAL OF OSS NOKALVA, INC.
 * AND MAY BE USED ONLY BY DIRECT LICENSEES OF OSS NOKALVA, INC.
 * THIS FILE MAY NOT BE DISTRIBUTED. */

/* This file was generated by a TRIAL version of the OSS ASN.1 Tools.
 * Applications built using this file can be executed only on the machine
 * on which you run the OSS ASN.1 compiler. */

/* Generated for: Kampbell (Trial), License: 70040Z. */
/* Abstract syntax: SMASE_A_ASSOCIATE_Information */
/* Created: Fri Jan 02 07:11:58 2015 */
/* ASN.1/C++ compiler version: 6.0 */
/* Code generated for runtime version 6.0 or later */
/* Compiler operating system: Windows */
/* Compiler machine type: Intel x86 */
/* Target operating system: Windows */
/* Target machine type: Intel x86 */
/* C++ compiler options required: -Zp8 (Microsoft) */
/* ASN.1 compiler options and file names specified:
 * -output Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/csn\CMIP -modlistingfile
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/csn\CMIP.lst -gendirectives
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/csn\CMIP.gen -per -uper -ber
 * -der -root -messageFormat msvc -namespace CMIP -allow universaltags
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/asn/CMIP-1.asn
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/asn/CMIP-A-ABORT-Information.asn
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/asn/CMIP-A-ASSOCIATE-Information.asn
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/asn/CMISE-ROSE-SMASE-ASN1Module.asn
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/asn/Remote-Operations-Abstract-Syntaxes.asn
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/asn/Remote-Operations-Generic-ROS-PDUs.asn
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/asn/Remote-Operations-Information-Objects.asn
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/asn/Remote-Operations-Information-Objects-extensions.asn
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/asn/Remote-Operations-Realizations.asn
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/asn/Remote-Operations-Useful-Definitions.asn
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/asn/SMASE-A-ASSOCIATE-Information.asn
 */

#define OSS_COMPILER_API_LEVEL 31
#define _OSS_CODE_FILE
#define OSS_TOED_BER
#define OSS_TOED_PER
#include "CMIP.h"
#include "string.h"

#include "osstype.h"

#if OSSDEBUG > 1
#define OSS_CNTX_INIT _Context_Element _element;  _element._occurrence = 0;
#define OSS_CNTX_INITZERO _Context_Element _element = {NULL, NULL, 0};
#define OSS_CNTX_ZEROOCC  _element._occurrence = 0;
#define OSS_CNTX_INCOCC  _element._occurrence++;
#define OSS_CNTX_SETOCC(OCC) _element._occurrence = OCC;
#define OSS_CNTX_DEF _Context_Element _element;
#define OSS_CNTX_POP(OSSCNAME) OSSCNAME->_oss_context_anchor._last = _element._parent;
#define OSS_CNTX_PUSH(OSSCNAME,CNTXID) _element._id = (_Context_Id *)&_context_id[CNTXID];\
    _element._parent = OSSCNAME->_oss_context_anchor._last;\
    OSSCNAME->_oss_context_anchor._last = &_element;
#define OSS_CNTX_SET(CNTXID) _element._id = (_Context_Id *)&_context_id[CNTXID];
#define OSS_CNTX_NEW(OSSCNAME,CNTXID) _Context_Element _element;\
    _element._occurrence = 0;\
    _element._id = (_Context_Id *)&_context_id[CNTXID];\
    _element._parent = OSSCNAME->_oss_context_anchor._last;\
    OSSCNAME->_oss_context_anchor._last = &_element;
#define OSS_CNTX_ANCHOR_SET(PDU,CNTXID) \
    _element._parent = _oss_c->_oss_context_anchor._last;\
    _element._id = (_Context_Id *)&_context_id[CNTXID];\
    _oss_c->_oss_context_anchor._last = &_element;\
    if (!_oss_c->_oss_context_anchor._pdu_number) {\
        _oss_c->_oss_context_anchor._pdu_number = PDU;\
        _oss_c->_oss_context_anchor._pdu_id = _element._id;\
    }
#define OSS_CNTX_OSSC_DEF _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#else
#define OSS_CNTX_INIT
#define OSS_CNTX_INITZERO
#define OSS_CNTX_ZEROOCC
#define OSS_CNTX_INCOCC
#define OSS_CNTX_SETOCC(OCC)
#define OSS_CNTX_DEF
#define OSS_CNTX_POP(OSSCNAME)
#define OSS_CNTX_PUSH(OSSCNAME,CNTXID)
#define OSS_CNTX_SET(CNTXID)
#define OSS_CNTX_NEW(OSSCNAME,CNTXID)
#define OSS_CNTX_ANCHOR_SET(PDU,CNTXID) _oss_c->_oss_context_anchor._pdu_number = 0;
#endif
using namespace CMIP;
namespace CMIP {

/* Control table object */

class SMASE_A_ASSOCIATE_Information_TableType : public OssControlTable {
public:
    static void *internal;
    SMASE_A_ASSOCIATE_Information_TableType();
    int destroy(void *data, OssTypeIndex typeindex);
    int copy(void *src, void **dst, OssTypeIndex typeindex);
    int equal(void *data1, void *data2, OssTypeIndex typeindex);
};

SMASE_A_ASSOCIATE_Information_TableType::SMASE_A_ASSOCIATE_Information_TableType() : OssControlTable(internal) {
}

int SMASE_A_ASSOCIATE_Information_TableType::destroy(void *data, OssTypeIndex typeindex) {
    switch (typeindex) {
	case 1:
	    delete (ActionArgument *)data;
	    break;
	case 2:
	    delete (ActionResult *)data;
	    break;
	case 3:
	    delete (Attribute *)data;
	    break;
	case 4:
	    delete (AttributeId *)data;
	    break;
	case 5:
	    delete (BaseManagedObjectId *)data;
	    break;
	case 6:
	    delete (CMISFilter *)data;
	    break;
	case 7:
	    asn1Free(data);
	    break;
	case 8:
	    delete (ComplexityLimitation *)data;
	    break;
	case 9:
	    delete (CreateArgument *)data;
	    break;
	case 10:
	    delete (CreateResult *)data;
	    break;
	case 11:
	    delete (DeleteArgument *)data;
	    break;
	case 12:
	    delete (DeleteResult *)data;
	    break;
	case 13:
	    delete (EventReportArgument *)data;
	    break;
	case 14:
	    delete (EventReportResult *)data;
	    break;
	case 15:
	    delete (GetArgument *)data;
	    break;
	case 16:
	    delete (GetListError *)data;
	    break;
	case 17:
	    delete (GetResult *)data;
	    break;
	case 18:
	    delete (InvalidArgumentValue *)data;
	    break;
	case 19:
	    delete (InvokeIDType *)data;
	    break;
	case 20:
	    delete (LinkedReplyArgument *)data;
	    break;
	case 21:
	    delete (NoSuchAction *)data;
	    break;
	case 22:
	    delete (NoSuchArgument *)data;
	    break;
	case 23:
	    delete (NoSuchEventType *)data;
	    break;
	case 24:
	    delete (ObjectClass *)data;
	    break;
	case 25:
	    delete (ObjectInstance *)data;
	    break;
	case 26:
	    delete (ProcessingFailure *)data;
	    break;
	case 27:
	    delete (Scope *)data;
	    break;
	case 28:
	    delete (SetArgument *)data;
	    break;
	case 29:
	    delete (SetListError *)data;
	    break;
	case 30:
	    delete (SetResult *)data;
	    break;
	case 31:
	    delete (ROSEapdus *)data;
	    break;
	case 32:
	    delete (CMIPAbortInfo *)data;
	    break;
	case 33:
	    delete (CMIPUserInfo *)data;
	    break;
	case 34:
	    delete (CmipPduReceivingSupport *)data;
	    break;
	case 35:
	    delete (CmipPduSendingSupport *)data;
	    break;
	case 36:
	    delete (CmiseFunctionalUnitsSelected *)data;
	    break;
	case 37:
	    delete (CmiseFunctionalUnitsSupported *)data;
	    break;
	case 38:
	    delete (InvokeldsOutstanding *)data;
	    break;
	case 39:
	    delete (InvokeIdsPerforming *)data;
	    break;
	case 40:
	    asn1Free(data);
	    break;
	case 41:
	    delete (ProtocolVersionSupported *)data;
	    break;
	case 42:
	    delete (SmaseFunctionalUnits *)data;
	    break;
	case 43:
	    delete (SmUserInfoSent *)data;
	    break;
	case 44:
	    delete (SmUserInfoReceived *)data;
	    break;
	case 45:
	    delete (ROSEInvokeIds *)data;
	    break;
	case 46:
	    delete (NoInvokeId *)data;
	    break;
	case 47:
	    delete (SMASEUserData *)data;
	    break;
	case 48:
	    asn1Free(data);
	    break;
	case 49:
	    asn1Free(data);
	    break;
	case 50:
	    asn1Free(data);
	    break;
	case 51:
	    asn1Free(data);
	    break;
	case 52:
	    asn1Free(data);
	    break;
	case 53:
	    asn1Free(data);
	    break;
	case 54:
	    asn1Free(data);
	    break;
	case 55:
	    asn1Free(data);
	    break;
	case 56:
	    asn1Free(data);
	    break;
	case 57:
	    asn1Free(data);
	    break;
	case 58:
	    asn1Free(data);
	    break;
	case 59:
	    asn1Free(data);
	    break;
	case 60:
	    asn1Free(data);
	    break;
	case 61:
	    asn1Free(data);
	    break;
	case 62:
	    asn1Free(data);
	    break;
	case 63:
	    asn1Free(data);
	    break;
	case 64:
	    asn1Free(data);
	    break;
	case 65:
	    delete (MissingAttributeValue_PARAMETER *)data;
	    break;
	case 66:
	    asn1Free(data);
	    break;
	case 67:
	    asn1Free(data);
	    break;
	case 68:
	    asn1Free(data);
	    break;
	case 69:
	    asn1Free(data);
	    break;
	case 70:
	    asn1Free(data);
	    break;
	case 71:
	    asn1Free(data);
	    break;
	case 72:
	    asn1Free(data);
	    break;
	case 73:
	    delete (Acse_RealizationParameter *)data;
	    break;
	case 74:
	    delete (Acse_with_concatenation_RealizationParameter *)data;
	    break;
	case 75:
	    delete (Association_by_RTSE_RealizationParameter *)data;
	    break;
	case 76:
	    delete (PData_RealizationParameter *)data;
	    break;
	case 77:
	    delete (PData_with_concatenation_RealizationParameter *)data;
	    break;
	case 78:
	    delete (Transfer_by_RTSE_RealizationParameter *)data;
	    break;
	default:
	    return oss_call_error(OSS_UNKNOWN_TYPE);
    }
    return 0;
}

int SMASE_A_ASSOCIATE_Information_TableType::copy(void *src, void **dst, OssTypeIndex typeindex) {
    switch (typeindex) {
	case 1:
	    *dst = new ActionArgument(*(ActionArgument *)src);
	    break;
	case 2:
	    *dst = new ActionResult(*(ActionResult *)src);
	    break;
	case 3:
	    *dst = new Attribute(*(Attribute *)src);
	    break;
	case 4:
	    *dst = new AttributeId(*(AttributeId *)src);
	    break;
	case 5:
	    *dst = new BaseManagedObjectId(*(BaseManagedObjectId *)src);
	    break;
	case 6:
	    *dst = new CMISFilter(*(CMISFilter *)src);
	    break;
	case 7:
	    *dst = osscppMalloc(sizeof(CMISSync));
	    if (*dst)
		**(CMISSync **)dst = *(CMISSync *)src;
	    break;
	case 8:
	    *dst = new ComplexityLimitation(*(ComplexityLimitation *)src);
	    break;
	case 9:
	    *dst = new CreateArgument(*(CreateArgument *)src);
	    break;
	case 10:
	    *dst = new CreateResult(*(CreateResult *)src);
	    break;
	case 11:
	    *dst = new DeleteArgument(*(DeleteArgument *)src);
	    break;
	case 12:
	    *dst = new DeleteResult(*(DeleteResult *)src);
	    break;
	case 13:
	    *dst = new EventReportArgument(*(EventReportArgument *)src);
	    break;
	case 14:
	    *dst = new EventReportResult(*(EventReportResult *)src);
	    break;
	case 15:
	    *dst = new GetArgument(*(GetArgument *)src);
	    break;
	case 16:
	    *dst = new GetListError(*(GetListError *)src);
	    break;
	case 17:
	    *dst = new GetResult(*(GetResult *)src);
	    break;
	case 18:
	    *dst = new InvalidArgumentValue(*(InvalidArgumentValue *)src);
	    break;
	case 19:
	    *dst = new InvokeIDType(*(InvokeIDType *)src);
	    break;
	case 20:
	    *dst = new LinkedReplyArgument(*(LinkedReplyArgument *)src);
	    break;
	case 21:
	    *dst = new NoSuchAction(*(NoSuchAction *)src);
	    break;
	case 22:
	    *dst = new NoSuchArgument(*(NoSuchArgument *)src);
	    break;
	case 23:
	    *dst = new NoSuchEventType(*(NoSuchEventType *)src);
	    break;
	case 24:
	    *dst = new ObjectClass(*(ObjectClass *)src);
	    break;
	case 25:
	    *dst = new ObjectInstance(*(ObjectInstance *)src);
	    break;
	case 26:
	    *dst = new ProcessingFailure(*(ProcessingFailure *)src);
	    break;
	case 27:
	    *dst = new Scope(*(Scope *)src);
	    break;
	case 28:
	    *dst = new SetArgument(*(SetArgument *)src);
	    break;
	case 29:
	    *dst = new SetListError(*(SetListError *)src);
	    break;
	case 30:
	    *dst = new SetResult(*(SetResult *)src);
	    break;
	case 31:
	    *dst = new ROSEapdus(*(ROSEapdus *)src);
	    break;
	case 32:
	    *dst = new CMIPAbortInfo(*(CMIPAbortInfo *)src);
	    break;
	case 33:
	    *dst = new CMIPUserInfo(*(CMIPUserInfo *)src);
	    break;
	case 34:
	    *dst = new CmipPduReceivingSupport(*(CmipPduReceivingSupport *)src);
	    break;
	case 35:
	    *dst = new CmipPduSendingSupport(*(CmipPduSendingSupport *)src);
	    break;
	case 36:
	    *dst = new CmiseFunctionalUnitsSelected(*(CmiseFunctionalUnitsSelected *)src);
	    break;
	case 37:
	    *dst = new CmiseFunctionalUnitsSupported(*(CmiseFunctionalUnitsSupported *)src);
	    break;
	case 38:
	    *dst = new InvokeldsOutstanding(*(InvokeldsOutstanding *)src);
	    break;
	case 39:
	    *dst = new InvokeIdsPerforming(*(InvokeIdsPerforming *)src);
	    break;
	case 40:
	    *dst = osscppMalloc(sizeof(MaxEncodedCmipPduReceiveSize));
	    if (*dst)
		**(MaxEncodedCmipPduReceiveSize **)dst = *(MaxEncodedCmipPduReceiveSize *)src;
	    break;
	case 41:
	    *dst = new ProtocolVersionSupported(*(ProtocolVersionSupported *)src);
	    break;
	case 42:
	    *dst = new SmaseFunctionalUnits(*(SmaseFunctionalUnits *)src);
	    break;
	case 43:
	    *dst = new SmUserInfoSent(*(SmUserInfoSent *)src);
	    break;
	case 44:
	    *dst = new SmUserInfoReceived(*(SmUserInfoReceived *)src);
	    break;
	case 45:
	    *dst = new ROSEInvokeIds(*(ROSEInvokeIds *)src);
	    break;
	case 46:
	    *dst = new NoInvokeId(*(NoInvokeId *)src);
	    break;
	case 47:
	    *dst = new SMASEUserData(*(SMASEUserData *)src);
	    break;
	case 48:
	    *dst = osscppMalloc(sizeof(AccessDenied_PRIORITY));
	    if (*dst)
		**(AccessDenied_PRIORITY **)dst = *(AccessDenied_PRIORITY *)src;
	    break;
	case 49:
	    *dst = osscppMalloc(sizeof(ClassInstanceConflict_PRIORITY));
	    if (*dst)
		**(ClassInstanceConflict_PRIORITY **)dst = *(ClassInstanceConflict_PRIORITY *)src;
	    break;
	case 50:
	    *dst = osscppMalloc(sizeof(ComplexityLimitation_PRIORITY));
	    if (*dst)
		**(ComplexityLimitation_PRIORITY **)dst = *(ComplexityLimitation_PRIORITY *)src;
	    break;
	case 51:
	    *dst = osscppMalloc(sizeof(InvalidScope_PRIORITY));
	    if (*dst)
		**(InvalidScope_PRIORITY **)dst = *(InvalidScope_PRIORITY *)src;
	    break;
	case 52:
	    *dst = osscppMalloc(sizeof(InvalidArgumentValue_PRIORITY));
	    if (*dst)
		**(InvalidArgumentValue_PRIORITY **)dst = *(InvalidArgumentValue_PRIORITY *)src;
	    break;
	case 53:
	    *dst = osscppMalloc(sizeof(InvalidFilter_PRIORITY));
	    if (*dst)
		**(InvalidFilter_PRIORITY **)dst = *(InvalidFilter_PRIORITY *)src;
	    break;
	case 54:
	    *dst = osscppMalloc(sizeof(NoSuchAction_PRIORITY));
	    if (*dst)
		**(NoSuchAction_PRIORITY **)dst = *(NoSuchAction_PRIORITY *)src;
	    break;
	case 55:
	    *dst = osscppMalloc(sizeof(NoSuchArgument_PRIORITY));
	    if (*dst)
		**(NoSuchArgument_PRIORITY **)dst = *(NoSuchArgument_PRIORITY *)src;
	    break;
	case 56:
	    *dst = osscppMalloc(sizeof(NoSuchObjectClass_PRIORITY));
	    if (*dst)
		**(NoSuchObjectClass_PRIORITY **)dst = *(NoSuchObjectClass_PRIORITY *)src;
	    break;
	case 57:
	    *dst = osscppMalloc(sizeof(NoSuchObjectInstance_PRIORITY));
	    if (*dst)
		**(NoSuchObjectInstance_PRIORITY **)dst = *(NoSuchObjectInstance_PRIORITY *)src;
	    break;
	case 58:
	    *dst = osscppMalloc(sizeof(ProcessingFailure_PRIORITY));
	    if (*dst)
		**(ProcessingFailure_PRIORITY **)dst = *(ProcessingFailure_PRIORITY *)src;
	    break;
	case 59:
	    *dst = osscppMalloc(sizeof(SyncNotSupported_PRIORITY));
	    if (*dst)
		**(SyncNotSupported_PRIORITY **)dst = *(SyncNotSupported_PRIORITY *)src;
	    break;
	case 60:
	    *dst = osscppMalloc(sizeof(MistypedOperation_PRIORITY));
	    if (*dst)
		**(MistypedOperation_PRIORITY **)dst = *(MistypedOperation_PRIORITY *)src;
	    break;
	case 61:
	    *dst = osscppMalloc(sizeof(NoSuchInvokeId_PRIORITY));
	    if (*dst)
		**(NoSuchInvokeId_PRIORITY **)dst = *(NoSuchInvokeId_PRIORITY *)src;
	    break;
	case 62:
	    *dst = osscppMalloc(sizeof(DuplicateManagedObjectInstance_PRIORITY));
	    if (*dst)
		**(DuplicateManagedObjectInstance_PRIORITY **)dst = *(DuplicateManagedObjectInstance_PRIORITY *)src;
	    break;
	case 63:
	    *dst = osscppMalloc(sizeof(InvalidAttributeValue_PRIORITY));
	    if (*dst)
		**(InvalidAttributeValue_PRIORITY **)dst = *(InvalidAttributeValue_PRIORITY *)src;
	    break;
	case 64:
	    *dst = osscppMalloc(sizeof(InvalidObjectInstance_PRIORITY));
	    if (*dst)
		**(InvalidObjectInstance_PRIORITY **)dst = *(InvalidObjectInstance_PRIORITY *)src;
	    break;
	case 65:
	    *dst = new MissingAttributeValue_PARAMETER(*(MissingAttributeValue_PARAMETER *)src);
	    break;
	case 66:
	    *dst = osscppMalloc(sizeof(MissingAttributeValue_PRIORITY));
	    if (*dst)
		**(MissingAttributeValue_PRIORITY **)dst = *(MissingAttributeValue_PRIORITY *)src;
	    break;
	case 67:
	    *dst = osscppMalloc(sizeof(NoSuchAttribute_PRIORITY));
	    if (*dst)
		**(NoSuchAttribute_PRIORITY **)dst = *(NoSuchAttribute_PRIORITY *)src;
	    break;
	case 68:
	    *dst = osscppMalloc(sizeof(NoSuchReferenceObject_PRIORITY));
	    if (*dst)
		**(NoSuchReferenceObject_PRIORITY **)dst = *(NoSuchReferenceObject_PRIORITY *)src;
	    break;
	case 69:
	    *dst = osscppMalloc(sizeof(NoSuchEventType_PRIORITY));
	    if (*dst)
		**(NoSuchEventType_PRIORITY **)dst = *(NoSuchEventType_PRIORITY *)src;
	    break;
	case 70:
	    *dst = osscppMalloc(sizeof(GetListError_PRIORITY));
	    if (*dst)
		**(GetListError_PRIORITY **)dst = *(GetListError_PRIORITY *)src;
	    break;
	case 71:
	    *dst = osscppMalloc(sizeof(OperationCancelled_PRIORITY));
	    if (*dst)
		**(OperationCancelled_PRIORITY **)dst = *(OperationCancelled_PRIORITY *)src;
	    break;
	case 72:
	    *dst = osscppMalloc(sizeof(SetListError_PRIORITY));
	    if (*dst)
		**(SetListError_PRIORITY **)dst = *(SetListError_PRIORITY *)src;
	    break;
	case 73:
	    *dst = new Acse_RealizationParameter(*(Acse_RealizationParameter *)src);
	    break;
	case 74:
	    *dst = new Acse_with_concatenation_RealizationParameter(*(Acse_with_concatenation_RealizationParameter *)src);
	    break;
	case 75:
	    *dst = new Association_by_RTSE_RealizationParameter(*(Association_by_RTSE_RealizationParameter *)src);
	    break;
	case 76:
	    *dst = new PData_RealizationParameter(*(PData_RealizationParameter *)src);
	    break;
	case 77:
	    *dst = new PData_with_concatenation_RealizationParameter(*(PData_with_concatenation_RealizationParameter *)src);
	    break;
	case 78:
	    *dst = new Transfer_by_RTSE_RealizationParameter(*(Transfer_by_RTSE_RealizationParameter *)src);
	    break;
	default:
	    return oss_call_error(OSS_UNKNOWN_TYPE);
    }
    if (*dst == 0)
	return OSS_NO_MEMORY;
    return 0;
}

int SMASE_A_ASSOCIATE_Information_TableType::equal(void *data1, void *data2, OssTypeIndex typeindex) {
    switch (typeindex) {
	case 1:
	    return *(ActionArgument *)data1 == *(ActionArgument *)data2;
	case 2:
	    return *(ActionResult *)data1 == *(ActionResult *)data2;
	case 3:
	    return *(Attribute *)data1 == *(Attribute *)data2;
	case 4:
	    return *(AttributeId *)data1 == *(AttributeId *)data2;
	case 5:
	    return *(BaseManagedObjectId *)data1 == *(BaseManagedObjectId *)data2;
	case 6:
	    return *(CMISFilter *)data1 == *(CMISFilter *)data2;
	case 7:
	    return *(CMISSync *)data1 == *(CMISSync *)data2;
	case 8:
	    return *(ComplexityLimitation *)data1 == *(ComplexityLimitation *)data2;
	case 9:
	    return *(CreateArgument *)data1 == *(CreateArgument *)data2;
	case 10:
	    return *(CreateResult *)data1 == *(CreateResult *)data2;
	case 11:
	    return *(DeleteArgument *)data1 == *(DeleteArgument *)data2;
	case 12:
	    return *(DeleteResult *)data1 == *(DeleteResult *)data2;
	case 13:
	    return *(EventReportArgument *)data1 == *(EventReportArgument *)data2;
	case 14:
	    return *(EventReportResult *)data1 == *(EventReportResult *)data2;
	case 15:
	    return *(GetArgument *)data1 == *(GetArgument *)data2;
	case 16:
	    return *(GetListError *)data1 == *(GetListError *)data2;
	case 17:
	    return *(GetResult *)data1 == *(GetResult *)data2;
	case 18:
	    return *(InvalidArgumentValue *)data1 == *(InvalidArgumentValue *)data2;
	case 19:
	    return *(InvokeIDType *)data1 == *(InvokeIDType *)data2;
	case 20:
	    return *(LinkedReplyArgument *)data1 == *(LinkedReplyArgument *)data2;
	case 21:
	    return *(NoSuchAction *)data1 == *(NoSuchAction *)data2;
	case 22:
	    return *(NoSuchArgument *)data1 == *(NoSuchArgument *)data2;
	case 23:
	    return *(NoSuchEventType *)data1 == *(NoSuchEventType *)data2;
	case 24:
	    return *(ObjectClass *)data1 == *(ObjectClass *)data2;
	case 25:
	    return *(ObjectInstance *)data1 == *(ObjectInstance *)data2;
	case 26:
	    return *(ProcessingFailure *)data1 == *(ProcessingFailure *)data2;
	case 27:
	    return *(Scope *)data1 == *(Scope *)data2;
	case 28:
	    return *(SetArgument *)data1 == *(SetArgument *)data2;
	case 29:
	    return *(SetListError *)data1 == *(SetListError *)data2;
	case 30:
	    return *(SetResult *)data1 == *(SetResult *)data2;
	case 31:
	    return *(ROSEapdus *)data1 == *(ROSEapdus *)data2;
	case 32:
	    return *(CMIPAbortInfo *)data1 == *(CMIPAbortInfo *)data2;
	case 33:
	    return *(CMIPUserInfo *)data1 == *(CMIPUserInfo *)data2;
	case 34:
	    return *(CmipPduReceivingSupport *)data1 == *(CmipPduReceivingSupport *)data2;
	case 35:
	    return *(CmipPduSendingSupport *)data1 == *(CmipPduSendingSupport *)data2;
	case 36:
	    return *(CmiseFunctionalUnitsSelected *)data1 == *(CmiseFunctionalUnitsSelected *)data2;
	case 37:
	    return *(CmiseFunctionalUnitsSupported *)data1 == *(CmiseFunctionalUnitsSupported *)data2;
	case 38:
	    return *(InvokeldsOutstanding *)data1 == *(InvokeldsOutstanding *)data2;
	case 39:
	    return *(InvokeIdsPerforming *)data1 == *(InvokeIdsPerforming *)data2;
	case 40:
	    return *(MaxEncodedCmipPduReceiveSize *)data1 == *(MaxEncodedCmipPduReceiveSize *)data2;
	case 41:
	    return *(ProtocolVersionSupported *)data1 == *(ProtocolVersionSupported *)data2;
	case 42:
	    return *(SmaseFunctionalUnits *)data1 == *(SmaseFunctionalUnits *)data2;
	case 43:
	    return *(SmUserInfoSent *)data1 == *(SmUserInfoSent *)data2;
	case 44:
	    return *(SmUserInfoReceived *)data1 == *(SmUserInfoReceived *)data2;
	case 45:
	    return *(ROSEInvokeIds *)data1 == *(ROSEInvokeIds *)data2;
	case 46:
	    return *(NoInvokeId *)data1 == *(NoInvokeId *)data2;
	case 47:
	    return *(SMASEUserData *)data1 == *(SMASEUserData *)data2;
	case 48:
	    return *(AccessDenied_PRIORITY *)data1 == *(AccessDenied_PRIORITY *)data2;
	case 49:
	    return *(ClassInstanceConflict_PRIORITY *)data1 == *(ClassInstanceConflict_PRIORITY *)data2;
	case 50:
	    return *(ComplexityLimitation_PRIORITY *)data1 == *(ComplexityLimitation_PRIORITY *)data2;
	case 51:
	    return *(InvalidScope_PRIORITY *)data1 == *(InvalidScope_PRIORITY *)data2;
	case 52:
	    return *(InvalidArgumentValue_PRIORITY *)data1 == *(InvalidArgumentValue_PRIORITY *)data2;
	case 53:
	    return *(InvalidFilter_PRIORITY *)data1 == *(InvalidFilter_PRIORITY *)data2;
	case 54:
	    return *(NoSuchAction_PRIORITY *)data1 == *(NoSuchAction_PRIORITY *)data2;
	case 55:
	    return *(NoSuchArgument_PRIORITY *)data1 == *(NoSuchArgument_PRIORITY *)data2;
	case 56:
	    return *(NoSuchObjectClass_PRIORITY *)data1 == *(NoSuchObjectClass_PRIORITY *)data2;
	case 57:
	    return *(NoSuchObjectInstance_PRIORITY *)data1 == *(NoSuchObjectInstance_PRIORITY *)data2;
	case 58:
	    return *(ProcessingFailure_PRIORITY *)data1 == *(ProcessingFailure_PRIORITY *)data2;
	case 59:
	    return *(SyncNotSupported_PRIORITY *)data1 == *(SyncNotSupported_PRIORITY *)data2;
	case 60:
	    return *(MistypedOperation_PRIORITY *)data1 == *(MistypedOperation_PRIORITY *)data2;
	case 61:
	    return *(NoSuchInvokeId_PRIORITY *)data1 == *(NoSuchInvokeId_PRIORITY *)data2;
	case 62:
	    return *(DuplicateManagedObjectInstance_PRIORITY *)data1 == *(DuplicateManagedObjectInstance_PRIORITY *)data2;
	case 63:
	    return *(InvalidAttributeValue_PRIORITY *)data1 == *(InvalidAttributeValue_PRIORITY *)data2;
	case 64:
	    return *(InvalidObjectInstance_PRIORITY *)data1 == *(InvalidObjectInstance_PRIORITY *)data2;
	case 65:
	    return *(MissingAttributeValue_PARAMETER *)data1 == *(MissingAttributeValue_PARAMETER *)data2;
	case 66:
	    return *(MissingAttributeValue_PRIORITY *)data1 == *(MissingAttributeValue_PRIORITY *)data2;
	case 67:
	    return *(NoSuchAttribute_PRIORITY *)data1 == *(NoSuchAttribute_PRIORITY *)data2;
	case 68:
	    return *(NoSuchReferenceObject_PRIORITY *)data1 == *(NoSuchReferenceObject_PRIORITY *)data2;
	case 69:
	    return *(NoSuchEventType_PRIORITY *)data1 == *(NoSuchEventType_PRIORITY *)data2;
	case 70:
	    return *(GetListError_PRIORITY *)data1 == *(GetListError_PRIORITY *)data2;
	case 71:
	    return *(OperationCancelled_PRIORITY *)data1 == *(OperationCancelled_PRIORITY *)data2;
	case 72:
	    return *(SetListError_PRIORITY *)data1 == *(SetListError_PRIORITY *)data2;
	case 73:
	    return *(Acse_RealizationParameter *)data1 == *(Acse_RealizationParameter *)data2;
	case 74:
	    return *(Acse_with_concatenation_RealizationParameter *)data1 == *(Acse_with_concatenation_RealizationParameter *)data2;
	case 75:
	    return *(Association_by_RTSE_RealizationParameter *)data1 == *(Association_by_RTSE_RealizationParameter *)data2;
	case 76:
	    return *(PData_RealizationParameter *)data1 == *(PData_RealizationParameter *)data2;
	case 77:
	    return *(PData_with_concatenation_RealizationParameter *)data1 == *(PData_with_concatenation_RealizationParameter *)data2;
	case 78:
	    return *(Transfer_by_RTSE_RealizationParameter *)data1 == *(Transfer_by_RTSE_RealizationParameter *)data2;
    }
    return 0;
}

static SMASE_A_ASSOCIATE_Information_TableType SMASE_A_ASSOCIATE_Information_Table;

/* Representation types */

__choice1::__choice1() {
    memset(this, 0, sizeof(__choice1));
}

__choice1::__choice1(const __choice1 & that) {
    memset(this, 0, sizeof(__choice1));
    operator =(that);
}

__choice1::~__choice1() {
    cleanup();
}

__choice1 & __choice1::operator = (const __choice1 & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case single_ASN1_type_chosen:
	    *(single_ASN1_type *)&single_ASN1_type_field = *(single_ASN1_type *)&that.single_ASN1_type_field;
	    break;
	case octet_aligned_chosen:
	    *(octet_aligned *)&octet_aligned_field = *(octet_aligned *)&that.octet_aligned_field;
	    break;
	case arbitrary_chosen:
	    *(arbitrary *)&arbitrary_field = *(arbitrary *)&that.arbitrary_field;
	    break;
    }
    return *this;
}

int __choice1::operator == (const __choice1 & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case single_ASN1_type_chosen:
	    return *(single_ASN1_type *)&single_ASN1_type_field == *(single_ASN1_type *)&that.single_ASN1_type_field;
	case octet_aligned_chosen:
	    return *(octet_aligned *)&octet_aligned_field == *(octet_aligned *)&that.octet_aligned_field;
	case arbitrary_chosen:
	    return *(arbitrary *)&arbitrary_field == *(arbitrary *)&that.arbitrary_field;
    }

    return 1;
}

int __choice1::operator != (const __choice1 & that) const {
    return !(operator ==(that));
}

__choice1::single_ASN1_type *__choice1::get_single_ASN1_type() {
    if (_choice == single_ASN1_type_chosen)
	return (single_ASN1_type *)&single_ASN1_type_field;
    else
	return 0;
}

const __choice1::single_ASN1_type *__choice1::get_single_ASN1_type() const {
    if (_choice == single_ASN1_type_chosen)
	return (const single_ASN1_type *)&single_ASN1_type_field;
    else
	return 0;
}

void __choice1::set_single_ASN1_type(const single_ASN1_type & single_ASN1_type_val) {
    cleanup();
    *(single_ASN1_type *)&single_ASN1_type_field = single_ASN1_type_val;
    _choice = single_ASN1_type_chosen;
}

__choice1::octet_aligned *__choice1::get_octet_aligned() {
    if (_choice == octet_aligned_chosen)
	return (octet_aligned *)&octet_aligned_field;
    else
	return 0;
}

const __choice1::octet_aligned *__choice1::get_octet_aligned() const {
    if (_choice == octet_aligned_chosen)
	return (const octet_aligned *)&octet_aligned_field;
    else
	return 0;
}

void __choice1::set_octet_aligned(const octet_aligned & octet_aligned_val) {
    cleanup();
    *(octet_aligned *)&octet_aligned_field = octet_aligned_val;
    _choice = octet_aligned_chosen;
}

__choice1::arbitrary *__choice1::get_arbitrary() {
    if (_choice == arbitrary_chosen)
	return (arbitrary *)&arbitrary_field;
    else
	return 0;
}

const __choice1::arbitrary *__choice1::get_arbitrary() const {
    if (_choice == arbitrary_chosen)
	return (const arbitrary *)&arbitrary_field;
    else
	return 0;
}

void __choice1::set_arbitrary(const arbitrary & arbitrary_val) {
    cleanup();
    *(arbitrary *)&arbitrary_field = arbitrary_val;
    _choice = arbitrary_chosen;
}

void __choice1::cleanup() {
    switch (_choice) {
	case single_ASN1_type_chosen:
	    ((single_ASN1_type *)&single_ASN1_type_field)->~OssOpen();
	    break;
	case octet_aligned_chosen:
	    ((octet_aligned *)&octet_aligned_field)->~OssString();
	    break;
	case arbitrary_chosen:
	    ((arbitrary *)&arbitrary_field)->~OssBitString();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

void *__shared2::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared2::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared2::__shared2() {
    memset(this, 0, sizeof(__shared2));
}

__shared2::__shared2(const __shared2 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	direct_reference_field = that.direct_reference_field;
	indirect_reference_field = that.indirect_reference_field;
	data_value_descriptor_field = that.data_value_descriptor_field;
	encoding_field = that.encoding_field;
    } OSSCLEAN(__shared2)
}

__shared2::__shared2(const direct_reference & direct_reference_val, indirect_reference indirect_reference_val, 
    const data_value_descriptor & data_value_descriptor_val, const encoding & encoding_val) {
    OSSTRY {
	bit_mask = 0xe0000000;
	direct_reference_field = direct_reference_val;
	indirect_reference_field = indirect_reference_val;
	data_value_descriptor_field = data_value_descriptor_val;
	encoding_field = encoding_val;
    } OSSCLEAN(__shared2)
}

__shared2::__shared2(const encoding & encoding_val) {
    OSSTRY {
	bit_mask = 0;
	encoding_field = encoding_val;
    } OSSCLEAN(__shared2)
}

__shared2 & __shared2::operator = (const __shared2 & that) {
    if (this == &that)
	return *this;
    this->~__shared2();
    bit_mask = that.bit_mask;
    direct_reference_field = that.direct_reference_field;
    indirect_reference_field = that.indirect_reference_field;
    data_value_descriptor_field = that.data_value_descriptor_field;
    encoding_field = that.encoding_field;
    return *this;
}

int __shared2::operator == (const __shared2 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (direct_reference_field != that.direct_reference_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (indirect_reference_field != that.indirect_reference_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (data_value_descriptor_field != that.data_value_descriptor_field)
	    return 0;
    }
    if (encoding_field != that.encoding_field)
	return 0;
    return 1;
}

int __shared2::operator != (const __shared2 & that) const {
    return !(operator ==(that));
}

__shared2::direct_reference *__shared2::get_direct_reference() {
    if (bit_mask & 0x80000000)
	return &direct_reference_field;
    else
	return 0;
}

const __shared2::direct_reference *__shared2::get_direct_reference() const {
    if (bit_mask & 0x80000000)
	return &direct_reference_field;
    else
	return 0;
}

void __shared2::set_direct_reference(const direct_reference & direct_reference_val) {
    bit_mask |= 0x80000000;
    direct_reference_field = direct_reference_val;
}

int __shared2::direct_reference_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void __shared2::omit_direct_reference() {
    direct_reference_field.~OssEncOID();
    bit_mask &= ~0x80000000;
}

__shared2::indirect_reference *__shared2::get_indirect_reference() {
    if (bit_mask & 0x40000000)
	return &indirect_reference_field;
    else
	return 0;
}

const __shared2::indirect_reference *__shared2::get_indirect_reference() const {
    if (bit_mask & 0x40000000)
	return &indirect_reference_field;
    else
	return 0;
}

void __shared2::set_indirect_reference(indirect_reference indirect_reference_val) {
    bit_mask |= 0x40000000;
    indirect_reference_field = indirect_reference_val;
}

int __shared2::indirect_reference_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void __shared2::omit_indirect_reference() {
    bit_mask &= ~0x40000000;
}

__shared2::data_value_descriptor *__shared2::get_data_value_descriptor() {
    if (bit_mask & 0x20000000)
	return &data_value_descriptor_field;
    else
	return 0;
}

const __shared2::data_value_descriptor *__shared2::get_data_value_descriptor() const {
    if (bit_mask & 0x20000000)
	return &data_value_descriptor_field;
    else
	return 0;
}

void __shared2::set_data_value_descriptor(const data_value_descriptor & data_value_descriptor_val) {
    bit_mask |= 0x20000000;
    data_value_descriptor_field = data_value_descriptor_val;
}

int __shared2::data_value_descriptor_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void __shared2::omit_data_value_descriptor() {
    data_value_descriptor_field.~OssString();
    bit_mask &= ~0x20000000;
}

__shared2::encoding & __shared2::get_encoding() {
    return encoding_field;
}

const __shared2::encoding & __shared2::get_encoding() const {
    return encoding_field;
}

void __shared2::set_encoding(const encoding & encoding_val) {
    encoding_field = encoding_val;
}

__shared3::__shared3() {
    memset(this, 0, sizeof(__shared3));
}

__shared3::__shared3(const __shared3 & that) {
    memset(this, 0, sizeof(__shared3));
    operator =(that);
}

__shared3::~__shared3() {
    cleanup();
}

__shared3 & __shared3::operator = (const __shared3 & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case globalForm_chosen:
	    *(globalForm *)&globalForm_field = *(globalForm *)&that.globalForm_field;
	    break;
	case localForm_chosen:
	    *(localForm *)&localForm_field = *(localForm *)&that.localForm_field;
	    break;
    }
    return *this;
}

int __shared3::operator == (const __shared3 & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case globalForm_chosen:
	    return *(globalForm *)&globalForm_field == *(globalForm *)&that.globalForm_field;
	case localForm_chosen:
	    return *(localForm *)&localForm_field == *(localForm *)&that.localForm_field;
    }

    return 1;
}

int __shared3::operator != (const __shared3 & that) const {
    return !(operator ==(that));
}

__shared3::globalForm *__shared3::get_globalForm() {
    if (_choice == globalForm_chosen)
	return (globalForm *)&globalForm_field;
    else
	return 0;
}

const __shared3::globalForm *__shared3::get_globalForm() const {
    if (_choice == globalForm_chosen)
	return (const globalForm *)&globalForm_field;
    else
	return 0;
}

void __shared3::set_globalForm(const globalForm & globalForm_val) {
    cleanup();
    *(globalForm *)&globalForm_field = globalForm_val;
    _choice = globalForm_chosen;
}

__shared3::localForm *__shared3::get_localForm() {
    if (_choice == localForm_chosen)
	return (localForm *)&localForm_field;
    else
	return 0;
}

const __shared3::localForm *__shared3::get_localForm() const {
    if (_choice == localForm_chosen)
	return (const localForm *)&localForm_field;
    else
	return 0;
}

void __shared3::set_localForm(localForm localForm_val) {
    cleanup();
    *(localForm *)&localForm_field = localForm_val;
    _choice = localForm_chosen;
}

void __shared3::cleanup() {
    switch (_choice) {
	case globalForm_chosen:
	    ((globalForm *)&globalForm_field)->~OssEncOID();
	    break;
	case localForm_chosen:
	    break;
    }
    memset(this, 0, sizeof(*this));
}

/* Auxiliary data structures and functions for class __shared6 */

class __shared6_member {
public:
    __shared6_member *next;
    __shared6::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared6_member();
    __shared6_member(const __shared6::component & val);
};

void *__shared6_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared6_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared6_member::__shared6_member() {
}

__shared6_member::__shared6_member(const __shared6::component & val) {
    value = val;
}

static void *__shared6_copy(void *that) {
    return new __shared6_member(((__shared6_member *)that)->value);
}

static void __shared6_destroy(void *that) {
    delete (__shared6_member *)that;
}

static int __shared6_compare(void *val1, void *val2) {
    return (((__shared6_member *)val1)->value == ((__shared6_member *)val2)->value);
}

/* Constructors */

__shared6::__shared6() {
}

__shared6::__shared6(const __shared6 & that) {
    OSSTRY {
	do_copy(that, &__shared6_copy);
    } OSSCLEAN(__shared6)
}

/* Destructor */

__shared6::~__shared6() {
    do_destroy(&__shared6_destroy);
}

/* Operators: assignment, equality, inequality */

__shared6 & __shared6::operator = (const __shared6 & that) {
    do_destroy(&__shared6_destroy);
    do_copy(that, &__shared6_copy);
    return *this;
}

int __shared6::operator == (const __shared6 & that) const {
    return do_compare(that, &__shared6_compare);
}

int __shared6::operator != (const __shared6 & that) const {
    return !do_compare(that, &__shared6_compare);
}

/* Locate ("At" etc) methods */

__shared6::component *__shared6::at(OssIndex pos) {
    return &((__shared6_member *)pos)->value;
}

const __shared6::component *__shared6::at(OssIndex pos) const {
    return &((__shared6_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared6::prepend(const component & val) {
    __shared6_member *newrec = new __shared6_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared6::prepend(__shared6 *seq) {
    return do_prepend(seq);
}

OssIndex __shared6::insert_after(OssIndex pos, const component & val) {
    __shared6_member *newrec = new __shared6_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared6::insert_after(OssIndex pos, __shared6 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared6::remove_front() {
    __shared6_member *extr = (__shared6_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared6_destroy(extr);
    return 0;
}

int __shared6::remove_after(OssIndex pos) {
    __shared6_member *extr = (__shared6_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared6_destroy(extr);
    return 0;
}

/* Extract methods */

__shared6 *__shared6::extract_after(OssIndex begin, OssIndex end) {
    return (__shared6 *)do_extract_after(begin, end);
}

ObjectInstance::ObjectInstance() {
    memset(this, 0, sizeof(ObjectInstance));
}

ObjectInstance::ObjectInstance(const ObjectInstance & that) {
    memset(this, 0, sizeof(ObjectInstance));
    operator =(that);
}

ObjectInstance::~ObjectInstance() {
    cleanup();
}

ObjectInstance & ObjectInstance::operator = (const ObjectInstance & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case distinguishedName_chosen:
	    *(distinguishedName *)&distinguishedName_field = *(distinguishedName *)&that.distinguishedName_field;
	    break;
	case nonSpecificForm_chosen:
	    *(nonSpecificForm *)&nonSpecificForm_field = *(nonSpecificForm *)&that.nonSpecificForm_field;
	    break;
	case localDistinguishedName_chosen:
	    *(localDistinguishedName *)&localDistinguishedName_field = *(localDistinguishedName *)&that.localDistinguishedName_field;
	    break;
    }
    return *this;
}

int ObjectInstance::operator == (const ObjectInstance & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case distinguishedName_chosen:
	    return *(distinguishedName *)&distinguishedName_field == *(distinguishedName *)&that.distinguishedName_field;
	case nonSpecificForm_chosen:
	    return *(nonSpecificForm *)&nonSpecificForm_field == *(nonSpecificForm *)&that.nonSpecificForm_field;
	case localDistinguishedName_chosen:
	    return *(localDistinguishedName *)&localDistinguishedName_field == *(localDistinguishedName *)&that.localDistinguishedName_field;
    }

    return 1;
}

int ObjectInstance::operator != (const ObjectInstance & that) const {
    return !(operator ==(that));
}

ObjectInstance::distinguishedName *ObjectInstance::get_distinguishedName() {
    if (_choice == distinguishedName_chosen)
	return (distinguishedName *)&distinguishedName_field;
    else
	return 0;
}

const ObjectInstance::distinguishedName *ObjectInstance::get_distinguishedName() const {
    if (_choice == distinguishedName_chosen)
	return (const distinguishedName *)&distinguishedName_field;
    else
	return 0;
}

void ObjectInstance::set_distinguishedName(const distinguishedName & distinguishedName_val) {
    cleanup();
    *(distinguishedName *)&distinguishedName_field = distinguishedName_val;
    _choice = distinguishedName_chosen;
}

ObjectInstance::nonSpecificForm *ObjectInstance::get_nonSpecificForm() {
    if (_choice == nonSpecificForm_chosen)
	return (nonSpecificForm *)&nonSpecificForm_field;
    else
	return 0;
}

const ObjectInstance::nonSpecificForm *ObjectInstance::get_nonSpecificForm() const {
    if (_choice == nonSpecificForm_chosen)
	return (const nonSpecificForm *)&nonSpecificForm_field;
    else
	return 0;
}

void ObjectInstance::set_nonSpecificForm(const nonSpecificForm & nonSpecificForm_val) {
    cleanup();
    *(nonSpecificForm *)&nonSpecificForm_field = nonSpecificForm_val;
    _choice = nonSpecificForm_chosen;
}

ObjectInstance::localDistinguishedName *ObjectInstance::get_localDistinguishedName() {
    if (_choice == localDistinguishedName_chosen)
	return (localDistinguishedName *)&localDistinguishedName_field;
    else
	return 0;
}

const ObjectInstance::localDistinguishedName *ObjectInstance::get_localDistinguishedName() const {
    if (_choice == localDistinguishedName_chosen)
	return (const localDistinguishedName *)&localDistinguishedName_field;
    else
	return 0;
}

void ObjectInstance::set_localDistinguishedName(const localDistinguishedName & localDistinguishedName_val) {
    cleanup();
    *(localDistinguishedName *)&localDistinguishedName_field = localDistinguishedName_val;
    _choice = localDistinguishedName_chosen;
}

void ObjectInstance::cleanup() {
    switch (_choice) {
	case distinguishedName_chosen:
	    ((distinguishedName *)&distinguishedName_field)->~__shared6();
	    break;
	case nonSpecificForm_chosen:
	    ((nonSpecificForm *)&nonSpecificForm_field)->~OssString();
	    break;
	case localDistinguishedName_chosen:
	    ((localDistinguishedName *)&localDistinguishedName_field)->~__shared6();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

Scope::Scope() {
    memset(this, 0, sizeof(Scope));
}

Scope::Scope(const Scope & that) {
    memset(this, 0, sizeof(Scope));
    operator =(that);
}

Scope & Scope::operator = (const Scope & that) {
    if (this == &that)
	return *this;
    _choice = that._choice;
    switch (_choice) {
	case namedNumbers_chosen:
	    *(namedNumbers *)&namedNumbers_field = *(namedNumbers *)&that.namedNumbers_field;
	    break;
	case individualLevels_chosen:
	    *(individualLevels *)&individualLevels_field = *(individualLevels *)&that.individualLevels_field;
	    break;
	case baseToNthLevel_chosen:
	    *(baseToNthLevel *)&baseToNthLevel_field = *(baseToNthLevel *)&that.baseToNthLevel_field;
	    break;
    }
    return *this;
}

int Scope::operator == (const Scope & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case namedNumbers_chosen:
	    return *(namedNumbers *)&namedNumbers_field == *(namedNumbers *)&that.namedNumbers_field;
	case individualLevels_chosen:
	    return *(individualLevels *)&individualLevels_field == *(individualLevels *)&that.individualLevels_field;
	case baseToNthLevel_chosen:
	    return *(baseToNthLevel *)&baseToNthLevel_field == *(baseToNthLevel *)&that.baseToNthLevel_field;
    }

    return 1;
}

int Scope::operator != (const Scope & that) const {
    return !(operator ==(that));
}

Scope::namedNumbers *Scope::get_namedNumbers() {
    if (_choice == namedNumbers_chosen)
	return (namedNumbers *)&namedNumbers_field;
    else
	return 0;
}

const Scope::namedNumbers *Scope::get_namedNumbers() const {
    if (_choice == namedNumbers_chosen)
	return (const namedNumbers *)&namedNumbers_field;
    else
	return 0;
}

void Scope::set_namedNumbers(namedNumbers namedNumbers_val) {
    *(namedNumbers *)&namedNumbers_field = namedNumbers_val;
    _choice = namedNumbers_chosen;
}

Scope::individualLevels *Scope::get_individualLevels() {
    if (_choice == individualLevels_chosen)
	return (individualLevels *)&individualLevels_field;
    else
	return 0;
}

const Scope::individualLevels *Scope::get_individualLevels() const {
    if (_choice == individualLevels_chosen)
	return (const individualLevels *)&individualLevels_field;
    else
	return 0;
}

void Scope::set_individualLevels(individualLevels individualLevels_val) {
    *(individualLevels *)&individualLevels_field = individualLevels_val;
    _choice = individualLevels_chosen;
}

Scope::baseToNthLevel *Scope::get_baseToNthLevel() {
    if (_choice == baseToNthLevel_chosen)
	return (baseToNthLevel *)&baseToNthLevel_field;
    else
	return 0;
}

const Scope::baseToNthLevel *Scope::get_baseToNthLevel() const {
    if (_choice == baseToNthLevel_chosen)
	return (const baseToNthLevel *)&baseToNthLevel_field;
    else
	return 0;
}

void Scope::set_baseToNthLevel(baseToNthLevel baseToNthLevel_val) {
    *(baseToNthLevel *)&baseToNthLevel_field = baseToNthLevel_val;
    _choice = baseToNthLevel_chosen;
}

AvaSet_Value::AvaSet_Value()
{
}

AvaSet_Value::AvaSet_Value(const AvaSet_Value & that)
{
    operator =(that);
}

AvaSet_Value::~AvaSet_Value()
{
    cleanup_decoded();
}

AvaSet_Value & AvaSet_Value::operator = (const AvaSet_Value & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = SMASE_A_ASSOCIATE_Information_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int AvaSet_Value::operator == (const AvaSet_Value & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return SMASE_A_ASSOCIATE_Information_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int AvaSet_Value::operator != (const AvaSet_Value & that) const
{
    return !(operator ==(that));
}

int AvaSet_Value::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = SMASE_A_ASSOCIATE_Information_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int AvaSet_Value::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int AvaSet_Value::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int AvaSet_Value::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int AvaSet_Value::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

void AvaSet_Value::cleanup_decoded()
{
    if (pdunum && decoded) {
	SMASE_A_ASSOCIATE_Information_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *Attribute::operator new(size_t size) {
    return ossNewFunc(size);
}

void Attribute::operator delete(void *ptr) {
    asn1Free(ptr);
}

Attribute::Attribute() {
    memset(this, 0, sizeof(Attribute));
}

Attribute::Attribute(const Attribute & that) {
    OSSTRY {
	id_field = that.id_field;
	value_field = that.value_field;
    } OSSCLEAN(Attribute)
}

Attribute::Attribute(const id & id_val, const value & value_val) {
    OSSTRY {
	id_field = id_val;
	value_field = value_val;
    } OSSCLEAN(Attribute)
}

Attribute & Attribute::operator = (const Attribute & that) {
    if (this == &that)
	return *this;
    id_field = that.id_field;
    value_field = that.value_field;
    return *this;
}

int Attribute::operator == (const Attribute & that) const {
    if (id_field != that.id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int Attribute::operator != (const Attribute & that) const {
    return !(operator ==(that));
}

Attribute::id & Attribute::get_id() {
    return id_field;
}

const Attribute::id & Attribute::get_id() const {
    return id_field;
}

void Attribute::set_id(const id & id_val) {
    id_field = id_val;
}

Attribute::value & Attribute::get_value() {
    return value_field;
}

const Attribute::value & Attribute::get_value() const {
    return value_field;
}

void Attribute::set_value(const value & value_val) {
    value_field = value_val;
}

/* Auxiliary data structures and functions for class __seqof1 */

class __seqof1_member {
public:
    __seqof1_member *next;
    __seqof1::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __seqof1_member();
    __seqof1_member(const __seqof1::component & val);
};

void *__seqof1_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof1_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seqof1_member::__seqof1_member() {
}

__seqof1_member::__seqof1_member(const __seqof1::component & val) {
    value = val;
}

static void *__seqof1_copy(void *that) {
    return new __seqof1_member(((__seqof1_member *)that)->value);
}

static void __seqof1_destroy(void *that) {
    delete (__seqof1_member *)that;
}

static int __seqof1_compare(void *val1, void *val2) {
    return (((__seqof1_member *)val1)->value == ((__seqof1_member *)val2)->value);
}

/* Constructors */

__seqof1::__seqof1() {
}

__seqof1::__seqof1(const __seqof1 & that) {
    OSSTRY {
	do_copy(that, &__seqof1_copy);
    } OSSCLEAN(__seqof1)
}

/* Destructor */

__seqof1::~__seqof1() {
    do_destroy(&__seqof1_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof1 & __seqof1::operator = (const __seqof1 & that) {
    do_destroy(&__seqof1_destroy);
    do_copy(that, &__seqof1_copy);
    return *this;
}

int __seqof1::operator == (const __seqof1 & that) const {
    return do_compare(that, &__seqof1_compare);
}

int __seqof1::operator != (const __seqof1 & that) const {
    return !do_compare(that, &__seqof1_compare);
}

/* Locate ("At" etc) methods */

__seqof1::component *__seqof1::at(OssIndex pos) {
    return &((__seqof1_member *)pos)->value;
}

const __seqof1::component *__seqof1::at(OssIndex pos) const {
    return &((__seqof1_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof1::prepend(const component & val) {
    __seqof1_member *newrec = new __seqof1_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __seqof1::prepend(__seqof1 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof1::insert_after(OssIndex pos, const component & val) {
    __seqof1_member *newrec = new __seqof1_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof1::insert_after(OssIndex pos, __seqof1 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof1::remove_front() {
    __seqof1_member *extr = (__seqof1_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof1_destroy(extr);
    return 0;
}

int __seqof1::remove_after(OssIndex pos) {
    __seqof1_member *extr = (__seqof1_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof1_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof1 *__seqof1::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof1 *)do_extract_after(begin, end);
}

FilterItem::FilterItem() {
    memset(this, 0, sizeof(FilterItem));
}

FilterItem::FilterItem(const FilterItem & that) {
    memset(this, 0, sizeof(FilterItem));
    operator =(that);
}

FilterItem::~FilterItem() {
    cleanup();
}

FilterItem & FilterItem::operator = (const FilterItem & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case equality_chosen:
	    if (that.equality_field)
		equality_field = new equality(*that.equality_field);
	    break;
	case substrings_chosen:
	    *(substrings *)&substrings_field = *(substrings *)&that.substrings_field;
	    break;
	case greaterOrEqual_chosen:
	    if (that.greaterOrEqual_field)
		greaterOrEqual_field = new greaterOrEqual(*that.greaterOrEqual_field);
	    break;
	case lessOrEqual_chosen:
	    if (that.lessOrEqual_field)
		lessOrEqual_field = new lessOrEqual(*that.lessOrEqual_field);
	    break;
	case present_chosen:
	    if (that.present_field)
		present_field = new present(*that.present_field);
	    break;
	case subsetOf_chosen:
	    if (that.subsetOf_field)
		subsetOf_field = new subsetOf(*that.subsetOf_field);
	    break;
	case supersetOf_chosen:
	    if (that.supersetOf_field)
		supersetOf_field = new supersetOf(*that.supersetOf_field);
	    break;
	case nonNullSetIntersection_chosen:
	    if (that.nonNullSetIntersection_field)
		nonNullSetIntersection_field = new nonNullSetIntersection(*that.nonNullSetIntersection_field);
	    break;
    }
    return *this;
}

int FilterItem::operator == (const FilterItem & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case equality_chosen:
	    if ((equality_field) && (that.equality_field))
		return (*equality_field == *(that.equality_field));
	    else if (!((!equality_field) && (!that.equality_field)))
		return 0;
	    break;
	case substrings_chosen:
	    return *(substrings *)&substrings_field == *(substrings *)&that.substrings_field;
	case greaterOrEqual_chosen:
	    if ((greaterOrEqual_field) && (that.greaterOrEqual_field))
		return (*greaterOrEqual_field == *(that.greaterOrEqual_field));
	    else if (!((!greaterOrEqual_field) && (!that.greaterOrEqual_field)))
		return 0;
	    break;
	case lessOrEqual_chosen:
	    if ((lessOrEqual_field) && (that.lessOrEqual_field))
		return (*lessOrEqual_field == *(that.lessOrEqual_field));
	    else if (!((!lessOrEqual_field) && (!that.lessOrEqual_field)))
		return 0;
	    break;
	case present_chosen:
	    if ((present_field) && (that.present_field))
		return (*present_field == *(that.present_field));
	    else if (!((!present_field) && (!that.present_field)))
		return 0;
	    break;
	case subsetOf_chosen:
	    if ((subsetOf_field) && (that.subsetOf_field))
		return (*subsetOf_field == *(that.subsetOf_field));
	    else if (!((!subsetOf_field) && (!that.subsetOf_field)))
		return 0;
	    break;
	case supersetOf_chosen:
	    if ((supersetOf_field) && (that.supersetOf_field))
		return (*supersetOf_field == *(that.supersetOf_field));
	    else if (!((!supersetOf_field) && (!that.supersetOf_field)))
		return 0;
	    break;
	case nonNullSetIntersection_chosen:
	    if ((nonNullSetIntersection_field) && (that.nonNullSetIntersection_field))
		return (*nonNullSetIntersection_field == *(that.nonNullSetIntersection_field));
	    else if (!((!nonNullSetIntersection_field) && (!that.nonNullSetIntersection_field)))
		return 0;
	    break;
    }

    return 1;
}

int FilterItem::operator != (const FilterItem & that) const {
    return !(operator ==(that));
}

FilterItem::equality *FilterItem::get_equality() {
    if (_choice == equality_chosen)
	return (equality *)equality_field;
    else
	return 0;
}

const FilterItem::equality *FilterItem::get_equality() const {
    if (_choice == equality_chosen)
	return (const equality *)equality_field;
    else
	return 0;
}

void FilterItem::set_equality(const equality & equality_val) {
    cleanup();
    equality_field = new equality(equality_val);
    _choice = equality_chosen;
}

FilterItem::substrings *FilterItem::get_substrings() {
    if (_choice == substrings_chosen)
	return (substrings *)&substrings_field;
    else
	return 0;
}

const FilterItem::substrings *FilterItem::get_substrings() const {
    if (_choice == substrings_chosen)
	return (const substrings *)&substrings_field;
    else
	return 0;
}

void FilterItem::set_substrings(const substrings & substrings_val) {
    cleanup();
    *(substrings *)&substrings_field = substrings_val;
    _choice = substrings_chosen;
}

FilterItem::greaterOrEqual *FilterItem::get_greaterOrEqual() {
    if (_choice == greaterOrEqual_chosen)
	return (greaterOrEqual *)greaterOrEqual_field;
    else
	return 0;
}

const FilterItem::greaterOrEqual *FilterItem::get_greaterOrEqual() const {
    if (_choice == greaterOrEqual_chosen)
	return (const greaterOrEqual *)greaterOrEqual_field;
    else
	return 0;
}

void FilterItem::set_greaterOrEqual(const greaterOrEqual & greaterOrEqual_val) {
    cleanup();
    greaterOrEqual_field = new greaterOrEqual(greaterOrEqual_val);
    _choice = greaterOrEqual_chosen;
}

FilterItem::lessOrEqual *FilterItem::get_lessOrEqual() {
    if (_choice == lessOrEqual_chosen)
	return (lessOrEqual *)lessOrEqual_field;
    else
	return 0;
}

const FilterItem::lessOrEqual *FilterItem::get_lessOrEqual() const {
    if (_choice == lessOrEqual_chosen)
	return (const lessOrEqual *)lessOrEqual_field;
    else
	return 0;
}

void FilterItem::set_lessOrEqual(const lessOrEqual & lessOrEqual_val) {
    cleanup();
    lessOrEqual_field = new lessOrEqual(lessOrEqual_val);
    _choice = lessOrEqual_chosen;
}

FilterItem::present *FilterItem::get_present() {
    if (_choice == present_chosen)
	return (present *)present_field;
    else
	return 0;
}

const FilterItem::present *FilterItem::get_present() const {
    if (_choice == present_chosen)
	return (const present *)present_field;
    else
	return 0;
}

void FilterItem::set_present(const present & present_val) {
    cleanup();
    present_field = new present(present_val);
    _choice = present_chosen;
}

FilterItem::subsetOf *FilterItem::get_subsetOf() {
    if (_choice == subsetOf_chosen)
	return (subsetOf *)subsetOf_field;
    else
	return 0;
}

const FilterItem::subsetOf *FilterItem::get_subsetOf() const {
    if (_choice == subsetOf_chosen)
	return (const subsetOf *)subsetOf_field;
    else
	return 0;
}

void FilterItem::set_subsetOf(const subsetOf & subsetOf_val) {
    cleanup();
    subsetOf_field = new subsetOf(subsetOf_val);
    _choice = subsetOf_chosen;
}

FilterItem::supersetOf *FilterItem::get_supersetOf() {
    if (_choice == supersetOf_chosen)
	return (supersetOf *)supersetOf_field;
    else
	return 0;
}

const FilterItem::supersetOf *FilterItem::get_supersetOf() const {
    if (_choice == supersetOf_chosen)
	return (const supersetOf *)supersetOf_field;
    else
	return 0;
}

void FilterItem::set_supersetOf(const supersetOf & supersetOf_val) {
    cleanup();
    supersetOf_field = new supersetOf(supersetOf_val);
    _choice = supersetOf_chosen;
}

FilterItem::nonNullSetIntersection *FilterItem::get_nonNullSetIntersection() {
    if (_choice == nonNullSetIntersection_chosen)
	return (nonNullSetIntersection *)nonNullSetIntersection_field;
    else
	return 0;
}

const FilterItem::nonNullSetIntersection *FilterItem::get_nonNullSetIntersection() const {
    if (_choice == nonNullSetIntersection_chosen)
	return (const nonNullSetIntersection *)nonNullSetIntersection_field;
    else
	return 0;
}

void FilterItem::set_nonNullSetIntersection(const nonNullSetIntersection & nonNullSetIntersection_val) {
    cleanup();
    nonNullSetIntersection_field = new nonNullSetIntersection(nonNullSetIntersection_val);
    _choice = nonNullSetIntersection_chosen;
}

void FilterItem::cleanup() {
    switch (_choice) {
	case equality_chosen:
	    if (equality_field)
		delete equality_field;
	    break;
	case substrings_chosen:
	    ((substrings *)&substrings_field)->~__seqof1();
	    break;
	case greaterOrEqual_chosen:
	    if (greaterOrEqual_field)
		delete greaterOrEqual_field;
	    break;
	case lessOrEqual_chosen:
	    if (lessOrEqual_field)
		delete lessOrEqual_field;
	    break;
	case present_chosen:
	    if (present_field)
		delete present_field;
	    break;
	case subsetOf_chosen:
	    if (subsetOf_field)
		delete subsetOf_field;
	    break;
	case supersetOf_chosen:
	    if (supersetOf_field)
		delete supersetOf_field;
	    break;
	case nonNullSetIntersection_chosen:
	    if (nonNullSetIntersection_field)
		delete nonNullSetIntersection_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

/* Auxiliary data structures and functions for class __shared7 */

class __shared7_member {
public:
    __shared7_member *next;
    __shared7::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared7_member();
    __shared7_member(const __shared7::component & val);
};

void *__shared7_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared7_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared7_member::__shared7_member() {
}

__shared7_member::__shared7_member(const __shared7::component & val) {
    value = val;
}

static void *__shared7_copy(void *that) {
    return new __shared7_member(((__shared7_member *)that)->value);
}

static void __shared7_destroy(void *that) {
    delete (__shared7_member *)that;
}

static int __shared7_compare(void *val1, void *val2) {
    return (((__shared7_member *)val1)->value == ((__shared7_member *)val2)->value);
}

/* Constructors */

__shared7::__shared7() {
}

__shared7::__shared7(const __shared7 & that) {
    OSSTRY {
	do_copy(that, &__shared7_copy);
    } OSSCLEAN(__shared7)
}

/* Destructor */

__shared7::~__shared7() {
    do_destroy(&__shared7_destroy);
}

/* Operators: assignment, equality, inequality */

__shared7 & __shared7::operator = (const __shared7 & that) {
    do_destroy(&__shared7_destroy);
    do_copy(that, &__shared7_copy);
    return *this;
}

int __shared7::operator == (const __shared7 & that) const {
    return do_compare(that, &__shared7_compare);
}

int __shared7::operator != (const __shared7 & that) const {
    return !do_compare(that, &__shared7_compare);
}

/* Locate ("At" etc) methods */

__shared7::component *__shared7::at(OssIndex pos) {
    return &((__shared7_member *)pos)->value;
}

const __shared7::component *__shared7::at(OssIndex pos) const {
    return &((__shared7_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared7::prepend(const component & val) {
    __shared7_member *newrec = new __shared7_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared7::prepend(__shared7 *seq) {
    return do_prepend(seq);
}

OssIndex __shared7::insert_after(OssIndex pos, const component & val) {
    __shared7_member *newrec = new __shared7_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared7::insert_after(OssIndex pos, __shared7 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared7::remove_front() {
    __shared7_member *extr = (__shared7_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared7_destroy(extr);
    return 0;
}

int __shared7::remove_after(OssIndex pos) {
    __shared7_member *extr = (__shared7_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared7_destroy(extr);
    return 0;
}

/* Extract methods */

__shared7 *__shared7::extract_after(OssIndex begin, OssIndex end) {
    return (__shared7 *)do_extract_after(begin, end);
}

CMISFilter::CMISFilter() {
    memset(this, 0, sizeof(CMISFilter));
}

CMISFilter::CMISFilter(const CMISFilter & that) {
    memset(this, 0, sizeof(CMISFilter));
    operator =(that);
}

CMISFilter::~CMISFilter() {
    cleanup();
}

CMISFilter & CMISFilter::operator = (const CMISFilter & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case item_chosen:
	    if (that.item_field)
		item_field = new item(*that.item_field);
	    break;
	case CMISFilter_and_chosen:
	    *(CMISFilter_and *)&CMISFilter_and_field = *(CMISFilter_and *)&that.CMISFilter_and_field;
	    break;
	case CMISFilter_or_chosen:
	    *(CMISFilter_or *)&CMISFilter_or_field = *(CMISFilter_or *)&that.CMISFilter_or_field;
	    break;
	case CMISFilter_not_chosen:
	    if (that.CMISFilter_not_field)
		CMISFilter_not_field = new CMISFilter_not(*that.CMISFilter_not_field);
	    break;
    }
    return *this;
}

int CMISFilter::operator == (const CMISFilter & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case item_chosen:
	    if ((item_field) && (that.item_field))
		return (*item_field == *(that.item_field));
	    else if (!((!item_field) && (!that.item_field)))
		return 0;
	    break;
	case CMISFilter_and_chosen:
	    return *(CMISFilter_and *)&CMISFilter_and_field == *(CMISFilter_and *)&that.CMISFilter_and_field;
	case CMISFilter_or_chosen:
	    return *(CMISFilter_or *)&CMISFilter_or_field == *(CMISFilter_or *)&that.CMISFilter_or_field;
	case CMISFilter_not_chosen:
	    if ((CMISFilter_not_field) && (that.CMISFilter_not_field))
		return (*CMISFilter_not_field == *(that.CMISFilter_not_field));
	    else if (!((!CMISFilter_not_field) && (!that.CMISFilter_not_field)))
		return 0;
	    break;
    }

    return 1;
}

int CMISFilter::operator != (const CMISFilter & that) const {
    return !(operator ==(that));
}

CMISFilter::item *CMISFilter::get_item() {
    if (_choice == item_chosen)
	return (item *)item_field;
    else
	return 0;
}

const CMISFilter::item *CMISFilter::get_item() const {
    if (_choice == item_chosen)
	return (const item *)item_field;
    else
	return 0;
}

void CMISFilter::set_item(const item & item_val) {
    cleanup();
    item_field = new item(item_val);
    _choice = item_chosen;
}

CMISFilter::CMISFilter_and *CMISFilter::get_CMISFilter_and() {
    if (_choice == CMISFilter_and_chosen)
	return (CMISFilter_and *)&CMISFilter_and_field;
    else
	return 0;
}

const CMISFilter::CMISFilter_and *CMISFilter::get_CMISFilter_and() const {
    if (_choice == CMISFilter_and_chosen)
	return (const CMISFilter_and *)&CMISFilter_and_field;
    else
	return 0;
}

void CMISFilter::set_CMISFilter_and(const CMISFilter_and & CMISFilter_and_val) {
    cleanup();
    *(CMISFilter_and *)&CMISFilter_and_field = CMISFilter_and_val;
    _choice = CMISFilter_and_chosen;
}

CMISFilter::CMISFilter_or *CMISFilter::get_CMISFilter_or() {
    if (_choice == CMISFilter_or_chosen)
	return (CMISFilter_or *)&CMISFilter_or_field;
    else
	return 0;
}

const CMISFilter::CMISFilter_or *CMISFilter::get_CMISFilter_or() const {
    if (_choice == CMISFilter_or_chosen)
	return (const CMISFilter_or *)&CMISFilter_or_field;
    else
	return 0;
}

void CMISFilter::set_CMISFilter_or(const CMISFilter_or & CMISFilter_or_val) {
    cleanup();
    *(CMISFilter_or *)&CMISFilter_or_field = CMISFilter_or_val;
    _choice = CMISFilter_or_chosen;
}

CMISFilter::CMISFilter_not *CMISFilter::get_CMISFilter_not() {
    if (_choice == CMISFilter_not_chosen)
	return (CMISFilter_not *)CMISFilter_not_field;
    else
	return 0;
}

const CMISFilter::CMISFilter_not *CMISFilter::get_CMISFilter_not() const {
    if (_choice == CMISFilter_not_chosen)
	return (const CMISFilter_not *)CMISFilter_not_field;
    else
	return 0;
}

void CMISFilter::set_CMISFilter_not(const CMISFilter_not & CMISFilter_not_val) {
    cleanup();
    CMISFilter_not_field = new CMISFilter_not(CMISFilter_not_val);
    _choice = CMISFilter_not_chosen;
}

void CMISFilter::cleanup() {
    switch (_choice) {
	case item_chosen:
	    if (item_field)
		delete item_field;
	    break;
	case CMISFilter_and_chosen:
	    ((CMISFilter_and *)&CMISFilter_and_field)->~__shared7();
	    break;
	case CMISFilter_or_chosen:
	    ((CMISFilter_or *)&CMISFilter_or_field)->~__shared7();
	    break;
	case CMISFilter_not_chosen:
	    if (CMISFilter_not_field)
		delete CMISFilter_not_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

void *__shared8::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared8::operator delete(void *ptr) {
    asn1Free(ptr);
}

ossBoolean __shared8::get_default_concatenation() {
    return __shared8::default_concatenation;
}

__shared8::__shared8() {
    memset(this, 0, sizeof(__shared8));
}

__shared8::__shared8(const __shared8 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	realization_type_field = that.realization_type_field;
	concatenation_field = that.concatenation_field;
    } OSSCLEAN(__shared8)
}

__shared8::__shared8(realization_type realization_type_val, concatenation concatenation_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	realization_type_field = realization_type_val;
	concatenation_field = concatenation_val;
    } OSSCLEAN(__shared8)
}

__shared8::__shared8(realization_type realization_type_val) {
    OSSTRY {
	bit_mask = 0;
	realization_type_field = realization_type_val;
    } OSSCLEAN(__shared8)
}

__shared8 & __shared8::operator = (const __shared8 & that) {
    if (this == &that)
	return *this;
    this->~__shared8();
    bit_mask = that.bit_mask;
    realization_type_field = that.realization_type_field;
    concatenation_field = that.concatenation_field;
    return *this;
}

int __shared8::operator == (const __shared8 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (realization_type_field != that.realization_type_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (concatenation_field != that.concatenation_field)
	    return 0;
    }
    return 1;
}

int __shared8::operator != (const __shared8 & that) const {
    return !(operator ==(that));
}

__shared8::realization_type & __shared8::get_realization_type() {
    return realization_type_field;
}

__shared8::realization_type __shared8::get_realization_type() const {
    return realization_type_field;
}

void __shared8::set_realization_type(realization_type realization_type_val) {
    realization_type_field = realization_type_val;
}

__shared8::concatenation *__shared8::get_concatenation() {
    if (bit_mask & 0x80000000)
	return &concatenation_field;
    else
	return 0;
}

const __shared8::concatenation *__shared8::get_concatenation() const {
    if (bit_mask & 0x80000000)
	return &concatenation_field;
    else
	return 0;
}

void __shared8::set_concatenation(concatenation concatenation_val) {
    bit_mask |= 0x80000000;
    concatenation_field = concatenation_val;
}

int __shared8::concatenation_is_default() const {
    return !(bit_mask & 0x80000000);
}

void __shared8::set_default_concatenation() {
    bit_mask &= ~0x80000000;
}

/* Auxiliary data structures and functions for class __shared9 */

class __shared9_member {
public:
    __shared9_member *next;
    __shared9::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared9_member();
    __shared9_member(const __shared9::component & val);
};

void *__shared9_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared9_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared9_member::__shared9_member() {
}

__shared9_member::__shared9_member(const __shared9::component & val) {
    value = val;
}

static void *__shared9_copy(void *that) {
    return new __shared9_member(((__shared9_member *)that)->value);
}

static void __shared9_destroy(void *that) {
    delete (__shared9_member *)that;
}

static int __shared9_compare(void *val1, void *val2) {
    return (((__shared9_member *)val1)->value == ((__shared9_member *)val2)->value);
}

/* Constructors */

__shared9::__shared9() {
}

__shared9::__shared9(const __shared9 & that) {
    OSSTRY {
	do_copy(that, &__shared9_copy);
    } OSSCLEAN(__shared9)
}

/* Destructor */

__shared9::~__shared9() {
    do_destroy(&__shared9_destroy);
}

/* Operators: assignment, equality, inequality */

__shared9 & __shared9::operator = (const __shared9 & that) {
    do_destroy(&__shared9_destroy);
    do_copy(that, &__shared9_copy);
    return *this;
}

int __shared9::operator == (const __shared9 & that) const {
    return do_compare(that, &__shared9_compare);
}

int __shared9::operator != (const __shared9 & that) const {
    return !do_compare(that, &__shared9_compare);
}

/* Locate ("At" etc) methods */

__shared9::component *__shared9::at(OssIndex pos) {
    return &((__shared9_member *)pos)->value;
}

const __shared9::component *__shared9::at(OssIndex pos) const {
    return &((__shared9_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared9::prepend(const component & val) {
    __shared9_member *newrec = new __shared9_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared9::prepend(__shared9 *seq) {
    return do_prepend(seq);
}

OssIndex __shared9::insert_after(OssIndex pos, const component & val) {
    __shared9_member *newrec = new __shared9_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared9::insert_after(OssIndex pos, __shared9 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared9::remove_front() {
    __shared9_member *extr = (__shared9_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared9_destroy(extr);
    return 0;
}

int __shared9::remove_after(OssIndex pos) {
    __shared9_member *extr = (__shared9_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared9_destroy(extr);
    return 0;
}

/* Extract methods */

__shared9 *__shared9::extract_after(OssIndex begin, OssIndex end) {
    return (__shared9 *)do_extract_after(begin, end);
}

void *ActionInfo::operator new(size_t size) {
    return ossNewFunc(size);
}

void ActionInfo::operator delete(void *ptr) {
    asn1Free(ptr);
}

ActionInfo::ActionInfo() {
    memset(this, 0, sizeof(ActionInfo));
}

ActionInfo::ActionInfo(const ActionInfo & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	actionType_field = that.actionType_field;
	actionInfoArg_field = that.actionInfoArg_field;
    } OSSCLEAN(ActionInfo)
}

ActionInfo::ActionInfo(const actionType & actionType_val, const actionInfoArg & actionInfoArg_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	actionType_field = actionType_val;
	actionInfoArg_field = actionInfoArg_val;
    } OSSCLEAN(ActionInfo)
}

ActionInfo::ActionInfo(const actionType & actionType_val) {
    OSSTRY {
	bit_mask = 0;
	actionType_field = actionType_val;
    } OSSCLEAN(ActionInfo)
}

ActionInfo & ActionInfo::operator = (const ActionInfo & that) {
    if (this == &that)
	return *this;
    this->~ActionInfo();
    bit_mask = that.bit_mask;
    actionType_field = that.actionType_field;
    actionInfoArg_field = that.actionInfoArg_field;
    return *this;
}

int ActionInfo::operator == (const ActionInfo & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (actionType_field != that.actionType_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (actionInfoArg_field != that.actionInfoArg_field)
	    return 0;
    }
    return 1;
}

int ActionInfo::operator != (const ActionInfo & that) const {
    return !(operator ==(that));
}

ActionInfo::actionType & ActionInfo::get_actionType() {
    return actionType_field;
}

const ActionInfo::actionType & ActionInfo::get_actionType() const {
    return actionType_field;
}

void ActionInfo::set_actionType(const actionType & actionType_val) {
    actionType_field = actionType_val;
}

ActionInfo::actionInfoArg *ActionInfo::get_actionInfoArg() {
    if (bit_mask & 0x80000000)
	return &actionInfoArg_field;
    else
	return 0;
}

const ActionInfo::actionInfoArg *ActionInfo::get_actionInfoArg() const {
    if (bit_mask & 0x80000000)
	return &actionInfoArg_field;
    else
	return 0;
}

void ActionInfo::set_actionInfoArg(const actionInfoArg & actionInfoArg_val) {
    bit_mask |= 0x80000000;
    actionInfoArg_field = actionInfoArg_val;
}

int ActionInfo::actionInfoArg_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void ActionInfo::omit_actionInfoArg() {
    actionInfoArg_field.~AvaSet_Value();
    bit_mask &= ~0x80000000;
}

void *ActionArgument::operator new(size_t size) {
    return ossNewFunc(size);
}

void ActionArgument::operator delete(void *ptr) {
    asn1Free(ptr);
}

enum CMISSync ActionArgument::get_default_synchronization() {
    return ActionArgument::default_synchronization;
}

const Scope& ActionArgument::get_default_scope() {
    return ActionArgument::default_scope;
}

const CMISFilter& ActionArgument::get_default_filter() {
    return ActionArgument::default_filter;
}

ActionArgument::ActionArgument() {
    memset(this, 0, sizeof(ActionArgument));
}

ActionArgument::ActionArgument(const ActionArgument & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	baseManagedObjectClass_field = that.baseManagedObjectClass_field;
	baseManagedObjectInstance_field = that.baseManagedObjectInstance_field;
	accessControl_field = that.accessControl_field;
	synchronization_field = that.synchronization_field;
	if (bit_mask & 0x20000000)
	    scope_field = that.scope_field;
	if (bit_mask & 0x10000000)
	    filter_field = that.filter_field;
	actionInfo_field = that.actionInfo_field;
    } OSSCLEAN(ActionArgument)
}

ActionArgument::ActionArgument(const baseManagedObjectClass & baseManagedObjectClass_val, 
    const baseManagedObjectInstance & baseManagedObjectInstance_val, const accessControl & accessControl_val, 
    synchronization synchronization_val, const scope & scope_val, const filter & filter_val, 
    const actionInfo & actionInfo_val) {
    OSSTRY {
	bit_mask = 0xf0000000;
	baseManagedObjectClass_field = baseManagedObjectClass_val;
	baseManagedObjectInstance_field = baseManagedObjectInstance_val;
	accessControl_field = accessControl_val;
	synchronization_field = synchronization_val;
	scope_field = scope_val;
	filter_field = filter_val;
	actionInfo_field = actionInfo_val;
    } OSSCLEAN(ActionArgument)
}

ActionArgument::ActionArgument(const baseManagedObjectClass & baseManagedObjectClass_val, 
    const baseManagedObjectInstance & baseManagedObjectInstance_val, const actionInfo & actionInfo_val) {
    OSSTRY {
	bit_mask = 0;
	baseManagedObjectClass_field = baseManagedObjectClass_val;
	baseManagedObjectInstance_field = baseManagedObjectInstance_val;
	actionInfo_field = actionInfo_val;
    } OSSCLEAN(ActionArgument)
}

ActionArgument::~ActionArgument() {
    if (!(bit_mask & 0x20000000))
	memset(&scope_field, 0, sizeof(scope));
    if (!(bit_mask & 0x10000000))
	memset(&filter_field, 0, sizeof(filter));
}

ActionArgument & ActionArgument::operator = (const ActionArgument & that) {
    if (this == &that)
	return *this;
    this->~ActionArgument();
    bit_mask = that.bit_mask;
    baseManagedObjectClass_field = that.baseManagedObjectClass_field;
    baseManagedObjectInstance_field = that.baseManagedObjectInstance_field;
    accessControl_field = that.accessControl_field;
    synchronization_field = that.synchronization_field;
    if (bit_mask & 0x20000000)
	scope_field = that.scope_field;
    if (bit_mask & 0x10000000)
	filter_field = that.filter_field;
    actionInfo_field = that.actionInfo_field;
    return *this;
}

int ActionArgument::operator == (const ActionArgument & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (baseManagedObjectClass_field != that.baseManagedObjectClass_field)
	return 0;
    if (baseManagedObjectInstance_field != that.baseManagedObjectInstance_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (accessControl_field != that.accessControl_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (synchronization_field != that.synchronization_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (scope_field != that.scope_field)
	    return 0;
    }
    if (bit_mask & 0x10000000) {
	if (filter_field != that.filter_field)
	    return 0;
    }
    if (actionInfo_field != that.actionInfo_field)
	return 0;
    return 1;
}

int ActionArgument::operator != (const ActionArgument & that) const {
    return !(operator ==(that));
}

ActionArgument::baseManagedObjectClass & ActionArgument::get_baseManagedObjectClass() {
    return baseManagedObjectClass_field;
}

const ActionArgument::baseManagedObjectClass & ActionArgument::get_baseManagedObjectClass() const {
    return baseManagedObjectClass_field;
}

void ActionArgument::set_baseManagedObjectClass(const baseManagedObjectClass & baseManagedObjectClass_val) {
    baseManagedObjectClass_field = baseManagedObjectClass_val;
}

ActionArgument::baseManagedObjectInstance & ActionArgument::get_baseManagedObjectInstance() {
    return baseManagedObjectInstance_field;
}

const ActionArgument::baseManagedObjectInstance & ActionArgument::get_baseManagedObjectInstance() const {
    return baseManagedObjectInstance_field;
}

void ActionArgument::set_baseManagedObjectInstance(const baseManagedObjectInstance & baseManagedObjectInstance_val) {
    baseManagedObjectInstance_field = baseManagedObjectInstance_val;
}

ActionArgument::accessControl *ActionArgument::get_accessControl() {
    if (bit_mask & 0x80000000)
	return &accessControl_field;
    else
	return 0;
}

const ActionArgument::accessControl *ActionArgument::get_accessControl() const {
    if (bit_mask & 0x80000000)
	return &accessControl_field;
    else
	return 0;
}

void ActionArgument::set_accessControl(const accessControl & accessControl_val) {
    bit_mask |= 0x80000000;
    accessControl_field = accessControl_val;
}

int ActionArgument::accessControl_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void ActionArgument::omit_accessControl() {
    accessControl_field.~__shared2();
    bit_mask &= ~0x80000000;
}

ActionArgument::synchronization *ActionArgument::get_synchronization() {
    if (bit_mask & 0x40000000)
	return &synchronization_field;
    else
	return 0;
}

const ActionArgument::synchronization *ActionArgument::get_synchronization() const {
    if (bit_mask & 0x40000000)
	return &synchronization_field;
    else
	return 0;
}

void ActionArgument::set_synchronization(synchronization synchronization_val) {
    bit_mask |= 0x40000000;
    synchronization_field = synchronization_val;
}

int ActionArgument::synchronization_is_default() const {
    return !(bit_mask & 0x40000000);
}

void ActionArgument::set_default_synchronization() {
    bit_mask &= ~0x40000000;
}

ActionArgument::scope *ActionArgument::get_scope() {
    if (bit_mask & 0x20000000)
	return &scope_field;
    else
	return 0;
}

const ActionArgument::scope *ActionArgument::get_scope() const {
    if (bit_mask & 0x20000000)
	return &scope_field;
    else
	return 0;
}

void ActionArgument::set_scope(const scope & scope_val) {
    if (!(bit_mask & 0x20000000)) {
	memset(&scope_field, 0, sizeof(scope));
	bit_mask |= 0x20000000;
    }
    scope_field = scope_val;
}

int ActionArgument::scope_is_default() const {
    return !(bit_mask & 0x20000000);
}

void ActionArgument::set_default_scope() {
    if (bit_mask & 0x20000000) {
	scope_field.~Scope();
	bit_mask &= ~0x20000000;
    }
}

ActionArgument::filter *ActionArgument::get_filter() {
    if (bit_mask & 0x10000000)
	return &filter_field;
    else
	return 0;
}

const ActionArgument::filter *ActionArgument::get_filter() const {
    if (bit_mask & 0x10000000)
	return &filter_field;
    else
	return 0;
}

void ActionArgument::set_filter(const filter & filter_val) {
    if (!(bit_mask & 0x10000000)) {
	memset(&filter_field, 0, sizeof(filter));
	bit_mask |= 0x10000000;
    }
    filter_field = filter_val;
}

int ActionArgument::filter_is_default() const {
    return !(bit_mask & 0x10000000);
}

void ActionArgument::set_default_filter() {
    if (bit_mask & 0x10000000) {
	filter_field.~CMISFilter();
	bit_mask &= ~0x10000000;
    }
}

ActionArgument::actionInfo & ActionArgument::get_actionInfo() {
    return actionInfo_field;
}

const ActionArgument::actionInfo & ActionArgument::get_actionInfo() const {
    return actionInfo_field;
}

void ActionArgument::set_actionInfo(const actionInfo & actionInfo_val) {
    actionInfo_field = actionInfo_val;
}

void *__seq2::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq2::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq2::__seq2() {
    memset(this, 0, sizeof(__seq2));
}

__seq2::__seq2(const __seq2 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	managedObjectClass_field = that.managedObjectClass_field;
	actionType_field = that.actionType_field;
    } OSSCLEAN(__seq2)
}

__seq2::__seq2(const managedObjectClass & managedObjectClass_val, const actionType & actionType_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	managedObjectClass_field = managedObjectClass_val;
	actionType_field = actionType_val;
    } OSSCLEAN(__seq2)
}

__seq2::__seq2(const actionType & actionType_val) {
    OSSTRY {
	bit_mask = 0;
	actionType_field = actionType_val;
    } OSSCLEAN(__seq2)
}

__seq2 & __seq2::operator = (const __seq2 & that) {
    if (this == &that)
	return *this;
    this->~__seq2();
    bit_mask = that.bit_mask;
    managedObjectClass_field = that.managedObjectClass_field;
    actionType_field = that.actionType_field;
    return *this;
}

int __seq2::operator == (const __seq2 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (managedObjectClass_field != that.managedObjectClass_field)
	    return 0;
    }
    if (actionType_field != that.actionType_field)
	return 0;
    return 1;
}

int __seq2::operator != (const __seq2 & that) const {
    return !(operator ==(that));
}

__seq2::managedObjectClass *__seq2::get_managedObjectClass() {
    if (bit_mask & 0x80000000)
	return &managedObjectClass_field;
    else
	return 0;
}

const __seq2::managedObjectClass *__seq2::get_managedObjectClass() const {
    if (bit_mask & 0x80000000)
	return &managedObjectClass_field;
    else
	return 0;
}

void __seq2::set_managedObjectClass(const managedObjectClass & managedObjectClass_val) {
    bit_mask |= 0x80000000;
    managedObjectClass_field = managedObjectClass_val;
}

int __seq2::managedObjectClass_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void __seq2::omit_managedObjectClass() {
    managedObjectClass_field.~__shared3();
    bit_mask &= ~0x80000000;
}

__seq2::actionType & __seq2::get_actionType() {
    return actionType_field;
}

const __seq2::actionType & __seq2::get_actionType() const {
    return actionType_field;
}

void __seq2::set_actionType(const actionType & actionType_val) {
    actionType_field = actionType_val;
}

void *__seq3::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq3::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq3::__seq3() {
    memset(this, 0, sizeof(__seq3));
}

__seq3::__seq3(const __seq3 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	managedObjectClass_field = that.managedObjectClass_field;
	eventType_field = that.eventType_field;
    } OSSCLEAN(__seq3)
}

__seq3::__seq3(const managedObjectClass & managedObjectClass_val, const eventType & eventType_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	managedObjectClass_field = managedObjectClass_val;
	eventType_field = eventType_val;
    } OSSCLEAN(__seq3)
}

__seq3::__seq3(const eventType & eventType_val) {
    OSSTRY {
	bit_mask = 0;
	eventType_field = eventType_val;
    } OSSCLEAN(__seq3)
}

__seq3 & __seq3::operator = (const __seq3 & that) {
    if (this == &that)
	return *this;
    this->~__seq3();
    bit_mask = that.bit_mask;
    managedObjectClass_field = that.managedObjectClass_field;
    eventType_field = that.eventType_field;
    return *this;
}

int __seq3::operator == (const __seq3 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (managedObjectClass_field != that.managedObjectClass_field)
	    return 0;
    }
    if (eventType_field != that.eventType_field)
	return 0;
    return 1;
}

int __seq3::operator != (const __seq3 & that) const {
    return !(operator ==(that));
}

__seq3::managedObjectClass *__seq3::get_managedObjectClass() {
    if (bit_mask & 0x80000000)
	return &managedObjectClass_field;
    else
	return 0;
}

const __seq3::managedObjectClass *__seq3::get_managedObjectClass() const {
    if (bit_mask & 0x80000000)
	return &managedObjectClass_field;
    else
	return 0;
}

void __seq3::set_managedObjectClass(const managedObjectClass & managedObjectClass_val) {
    bit_mask |= 0x80000000;
    managedObjectClass_field = managedObjectClass_val;
}

int __seq3::managedObjectClass_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void __seq3::omit_managedObjectClass() {
    managedObjectClass_field.~__shared3();
    bit_mask &= ~0x80000000;
}

__seq3::eventType & __seq3::get_eventType() {
    return eventType_field;
}

const __seq3::eventType & __seq3::get_eventType() const {
    return eventType_field;
}

void __seq3::set_eventType(const eventType & eventType_val) {
    eventType_field = eventType_val;
}

NoSuchArgument::NoSuchArgument() {
    memset(this, 0, sizeof(NoSuchArgument));
}

NoSuchArgument::NoSuchArgument(const NoSuchArgument & that) {
    memset(this, 0, sizeof(NoSuchArgument));
    operator =(that);
}

NoSuchArgument::~NoSuchArgument() {
    cleanup();
}

NoSuchArgument & NoSuchArgument::operator = (const NoSuchArgument & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case actionId_chosen:
	    if (that.actionId_field)
		actionId_field = new actionId(*that.actionId_field);
	    break;
	case eventId_chosen:
	    if (that.eventId_field)
		eventId_field = new eventId(*that.eventId_field);
	    break;
    }
    return *this;
}

int NoSuchArgument::operator == (const NoSuchArgument & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case actionId_chosen:
	    if ((actionId_field) && (that.actionId_field))
		return (*actionId_field == *(that.actionId_field));
	    else if (!((!actionId_field) && (!that.actionId_field)))
		return 0;
	    break;
	case eventId_chosen:
	    if ((eventId_field) && (that.eventId_field))
		return (*eventId_field == *(that.eventId_field));
	    else if (!((!eventId_field) && (!that.eventId_field)))
		return 0;
	    break;
    }

    return 1;
}

int NoSuchArgument::operator != (const NoSuchArgument & that) const {
    return !(operator ==(that));
}

NoSuchArgument::actionId *NoSuchArgument::get_actionId() {
    if (_choice == actionId_chosen)
	return (actionId *)actionId_field;
    else
	return 0;
}

const NoSuchArgument::actionId *NoSuchArgument::get_actionId() const {
    if (_choice == actionId_chosen)
	return (const actionId *)actionId_field;
    else
	return 0;
}

void NoSuchArgument::set_actionId(const actionId & actionId_val) {
    cleanup();
    actionId_field = new actionId(actionId_val);
    _choice = actionId_chosen;
}

NoSuchArgument::eventId *NoSuchArgument::get_eventId() {
    if (_choice == eventId_chosen)
	return (eventId *)eventId_field;
    else
	return 0;
}

const NoSuchArgument::eventId *NoSuchArgument::get_eventId() const {
    if (_choice == eventId_chosen)
	return (const eventId *)eventId_field;
    else
	return 0;
}

void NoSuchArgument::set_eventId(const eventId & eventId_val) {
    cleanup();
    eventId_field = new eventId(eventId_val);
    _choice = eventId_chosen;
}

void NoSuchArgument::cleanup() {
    switch (_choice) {
	case actionId_chosen:
	    if (actionId_field)
		delete actionId_field;
	    break;
	case eventId_chosen:
	    if (eventId_field)
		delete eventId_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

void *__seq1::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq1::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq1::__seq1() {
    memset(this, 0, sizeof(__seq1));
}

__seq1::__seq1(const __seq1 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	eventType_field = that.eventType_field;
	eventInfo_field = that.eventInfo_field;
    } OSSCLEAN(__seq1)
}

__seq1::__seq1(const eventType & eventType_val, const eventInfo & eventInfo_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	eventType_field = eventType_val;
	eventInfo_field = eventInfo_val;
    } OSSCLEAN(__seq1)
}

__seq1::__seq1(const eventType & eventType_val) {
    OSSTRY {
	bit_mask = 0;
	eventType_field = eventType_val;
    } OSSCLEAN(__seq1)
}

__seq1 & __seq1::operator = (const __seq1 & that) {
    if (this == &that)
	return *this;
    this->~__seq1();
    bit_mask = that.bit_mask;
    eventType_field = that.eventType_field;
    eventInfo_field = that.eventInfo_field;
    return *this;
}

int __seq1::operator == (const __seq1 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (eventType_field != that.eventType_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (eventInfo_field != that.eventInfo_field)
	    return 0;
    }
    return 1;
}

int __seq1::operator != (const __seq1 & that) const {
    return !(operator ==(that));
}

__seq1::eventType & __seq1::get_eventType() {
    return eventType_field;
}

const __seq1::eventType & __seq1::get_eventType() const {
    return eventType_field;
}

void __seq1::set_eventType(const eventType & eventType_val) {
    eventType_field = eventType_val;
}

__seq1::eventInfo *__seq1::get_eventInfo() {
    if (bit_mask & 0x80000000)
	return &eventInfo_field;
    else
	return 0;
}

const __seq1::eventInfo *__seq1::get_eventInfo() const {
    if (bit_mask & 0x80000000)
	return &eventInfo_field;
    else
	return 0;
}

void __seq1::set_eventInfo(const eventInfo & eventInfo_val) {
    bit_mask |= 0x80000000;
    eventInfo_field = eventInfo_val;
}

int __seq1::eventInfo_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void __seq1::omit_eventInfo() {
    eventInfo_field.~AvaSet_Value();
    bit_mask &= ~0x80000000;
}

InvalidArgumentValue::InvalidArgumentValue() {
    memset(this, 0, sizeof(InvalidArgumentValue));
}

InvalidArgumentValue::InvalidArgumentValue(const InvalidArgumentValue & that) {
    memset(this, 0, sizeof(InvalidArgumentValue));
    operator =(that);
}

InvalidArgumentValue::~InvalidArgumentValue() {
    cleanup();
}

InvalidArgumentValue & InvalidArgumentValue::operator = (const InvalidArgumentValue & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case actionValue_chosen:
	    if (that.actionValue_field)
		actionValue_field = new actionValue(*that.actionValue_field);
	    break;
	case eventValue_chosen:
	    if (that.eventValue_field)
		eventValue_field = new eventValue(*that.eventValue_field);
	    break;
    }
    return *this;
}

int InvalidArgumentValue::operator == (const InvalidArgumentValue & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case actionValue_chosen:
	    if ((actionValue_field) && (that.actionValue_field))
		return (*actionValue_field == *(that.actionValue_field));
	    else if (!((!actionValue_field) && (!that.actionValue_field)))
		return 0;
	    break;
	case eventValue_chosen:
	    if ((eventValue_field) && (that.eventValue_field))
		return (*eventValue_field == *(that.eventValue_field));
	    else if (!((!eventValue_field) && (!that.eventValue_field)))
		return 0;
	    break;
    }

    return 1;
}

int InvalidArgumentValue::operator != (const InvalidArgumentValue & that) const {
    return !(operator ==(that));
}

InvalidArgumentValue::actionValue *InvalidArgumentValue::get_actionValue() {
    if (_choice == actionValue_chosen)
	return (actionValue *)actionValue_field;
    else
	return 0;
}

const InvalidArgumentValue::actionValue *InvalidArgumentValue::get_actionValue() const {
    if (_choice == actionValue_chosen)
	return (const actionValue *)actionValue_field;
    else
	return 0;
}

void InvalidArgumentValue::set_actionValue(const actionValue & actionValue_val) {
    cleanup();
    actionValue_field = new actionValue(actionValue_val);
    _choice = actionValue_chosen;
}

InvalidArgumentValue::eventValue *InvalidArgumentValue::get_eventValue() {
    if (_choice == eventValue_chosen)
	return (eventValue *)eventValue_field;
    else
	return 0;
}

const InvalidArgumentValue::eventValue *InvalidArgumentValue::get_eventValue() const {
    if (_choice == eventValue_chosen)
	return (const eventValue *)eventValue_field;
    else
	return 0;
}

void InvalidArgumentValue::set_eventValue(const eventValue & eventValue_val) {
    cleanup();
    eventValue_field = new eventValue(eventValue_val);
    _choice = eventValue_chosen;
}

void InvalidArgumentValue::cleanup() {
    switch (_choice) {
	case actionValue_chosen:
	    if (actionValue_field)
		delete actionValue_field;
	    break;
	case eventValue_chosen:
	    if (eventValue_field)
		delete eventValue_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

__choice2::__choice2() {
    memset(this, 0, sizeof(__choice2));
}

__choice2::__choice2(const __choice2 & that) {
    memset(this, 0, sizeof(__choice2));
    operator =(that);
}

__choice2::~__choice2() {
    cleanup();
}

__choice2 & __choice2::operator = (const __choice2 & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case actionType_chosen:
	    if (that.actionType_field)
		actionType_field = new actionType(*that.actionType_field);
	    break;
	case actionArgument_chosen:
	    if (that.actionArgument_field)
		actionArgument_field = new actionArgument(*that.actionArgument_field);
	    break;
	case argumentValue_chosen:
	    if (that.argumentValue_field)
		argumentValue_field = new argumentValue(*that.argumentValue_field);
	    break;
    }
    return *this;
}

int __choice2::operator == (const __choice2 & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case actionType_chosen:
	    if ((actionType_field) && (that.actionType_field))
		return (*actionType_field == *(that.actionType_field));
	    else if (!((!actionType_field) && (!that.actionType_field)))
		return 0;
	    break;
	case actionArgument_chosen:
	    if ((actionArgument_field) && (that.actionArgument_field))
		return (*actionArgument_field == *(that.actionArgument_field));
	    else if (!((!actionArgument_field) && (!that.actionArgument_field)))
		return 0;
	    break;
	case argumentValue_chosen:
	    if ((argumentValue_field) && (that.argumentValue_field))
		return (*argumentValue_field == *(that.argumentValue_field));
	    else if (!((!argumentValue_field) && (!that.argumentValue_field)))
		return 0;
	    break;
    }

    return 1;
}

int __choice2::operator != (const __choice2 & that) const {
    return !(operator ==(that));
}

__choice2::actionType *__choice2::get_actionType() {
    if (_choice == actionType_chosen)
	return (actionType *)actionType_field;
    else
	return 0;
}

const __choice2::actionType *__choice2::get_actionType() const {
    if (_choice == actionType_chosen)
	return (const actionType *)actionType_field;
    else
	return 0;
}

void __choice2::set_actionType(const actionType & actionType_val) {
    cleanup();
    actionType_field = new actionType(actionType_val);
    _choice = actionType_chosen;
}

__choice2::actionArgument *__choice2::get_actionArgument() {
    if (_choice == actionArgument_chosen)
	return (actionArgument *)actionArgument_field;
    else
	return 0;
}

const __choice2::actionArgument *__choice2::get_actionArgument() const {
    if (_choice == actionArgument_chosen)
	return (const actionArgument *)actionArgument_field;
    else
	return 0;
}

void __choice2::set_actionArgument(const actionArgument & actionArgument_val) {
    cleanup();
    actionArgument_field = new actionArgument(actionArgument_val);
    _choice = actionArgument_chosen;
}

__choice2::argumentValue *__choice2::get_argumentValue() {
    if (_choice == argumentValue_chosen)
	return (argumentValue *)argumentValue_field;
    else
	return 0;
}

const __choice2::argumentValue *__choice2::get_argumentValue() const {
    if (_choice == argumentValue_chosen)
	return (const argumentValue *)argumentValue_field;
    else
	return 0;
}

void __choice2::set_argumentValue(const argumentValue & argumentValue_val) {
    cleanup();
    argumentValue_field = new argumentValue(argumentValue_val);
    _choice = argumentValue_chosen;
}

void __choice2::cleanup() {
    switch (_choice) {
	case actionType_chosen:
	    if (actionType_field)
		delete actionType_field;
	    break;
	case actionArgument_chosen:
	    if (actionArgument_field)
		delete actionArgument_field;
	    break;
	case argumentValue_chosen:
	    if (argumentValue_field)
		delete argumentValue_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

void *ActionErrorInfo::operator new(size_t size) {
    return ossNewFunc(size);
}

void ActionErrorInfo::operator delete(void *ptr) {
    asn1Free(ptr);
}

ActionErrorInfo::ActionErrorInfo() {
    memset(this, 0, sizeof(ActionErrorInfo));
}

ActionErrorInfo::ActionErrorInfo(const ActionErrorInfo & that) {
    OSSTRY {
	errorStatus_field = that.errorStatus_field;
	errorInfo_field = that.errorInfo_field;
    } OSSCLEAN(ActionErrorInfo)
}

ActionErrorInfo::ActionErrorInfo(errorStatus errorStatus_val, const errorInfo & errorInfo_val) {
    OSSTRY {
	errorStatus_field = errorStatus_val;
	errorInfo_field = errorInfo_val;
    } OSSCLEAN(ActionErrorInfo)
}

ActionErrorInfo & ActionErrorInfo::operator = (const ActionErrorInfo & that) {
    if (this == &that)
	return *this;
    errorStatus_field = that.errorStatus_field;
    errorInfo_field = that.errorInfo_field;
    return *this;
}

int ActionErrorInfo::operator == (const ActionErrorInfo & that) const {
    if (errorStatus_field != that.errorStatus_field)
	return 0;
    if (errorInfo_field != that.errorInfo_field)
	return 0;
    return 1;
}

int ActionErrorInfo::operator != (const ActionErrorInfo & that) const {
    return !(operator ==(that));
}

ActionErrorInfo::errorStatus & ActionErrorInfo::get_errorStatus() {
    return errorStatus_field;
}

ActionErrorInfo::errorStatus ActionErrorInfo::get_errorStatus() const {
    return errorStatus_field;
}

void ActionErrorInfo::set_errorStatus(errorStatus errorStatus_val) {
    errorStatus_field = errorStatus_val;
}

ActionErrorInfo::errorInfo & ActionErrorInfo::get_errorInfo() {
    return errorInfo_field;
}

const ActionErrorInfo::errorInfo & ActionErrorInfo::get_errorInfo() const {
    return errorInfo_field;
}

void ActionErrorInfo::set_errorInfo(const errorInfo & errorInfo_val) {
    errorInfo_field = errorInfo_val;
}

void *ActionError::operator new(size_t size) {
    return ossNewFunc(size);
}

void ActionError::operator delete(void *ptr) {
    asn1Free(ptr);
}

ActionError::ActionError() {
    memset(this, 0, sizeof(ActionError));
}

ActionError::ActionError(const ActionError & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	managedObjectClass_field = that.managedObjectClass_field;
	managedObjectInstance_field = that.managedObjectInstance_field;
	currentTime_field = that.currentTime_field;
	actionErrorInfo_field = that.actionErrorInfo_field;
    } OSSCLEAN(ActionError)
}

ActionError::ActionError(const managedObjectClass & managedObjectClass_val, const managedObjectInstance & managedObjectInstance_val, 
    const currentTime & currentTime_val, const actionErrorInfo & actionErrorInfo_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	managedObjectClass_field = managedObjectClass_val;
	managedObjectInstance_field = managedObjectInstance_val;
	currentTime_field = currentTime_val;
	actionErrorInfo_field = actionErrorInfo_val;
    } OSSCLEAN(ActionError)
}

ActionError::ActionError(const actionErrorInfo & actionErrorInfo_val) {
    OSSTRY {
	bit_mask = 0;
	actionErrorInfo_field = actionErrorInfo_val;
    } OSSCLEAN(ActionError)
}

ActionError & ActionError::operator = (const ActionError & that) {
    if (this == &that)
	return *this;
    this->~ActionError();
    bit_mask = that.bit_mask;
    managedObjectClass_field = that.managedObjectClass_field;
    managedObjectInstance_field = that.managedObjectInstance_field;
    currentTime_field = that.currentTime_field;
    actionErrorInfo_field = that.actionErrorInfo_field;
    return *this;
}

int ActionError::operator == (const ActionError & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (managedObjectClass_field != that.managedObjectClass_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (managedObjectInstance_field != that.managedObjectInstance_field)
	    return 0;
    }
    if (currentTime_field != that.currentTime_field)
	return 0;
    if (actionErrorInfo_field != that.actionErrorInfo_field)
	return 0;
    return 1;
}

int ActionError::operator != (const ActionError & that) const {
    return !(operator ==(that));
}

ActionError::managedObjectClass *ActionError::get_managedObjectClass() {
    if (bit_mask & 0x80000000)
	return &managedObjectClass_field;
    else
	return 0;
}

const ActionError::managedObjectClass *ActionError::get_managedObjectClass() const {
    if (bit_mask & 0x80000000)
	return &managedObjectClass_field;
    else
	return 0;
}

void ActionError::set_managedObjectClass(const managedObjectClass & managedObjectClass_val) {
    bit_mask |= 0x80000000;
    managedObjectClass_field = managedObjectClass_val;
}

int ActionError::managedObjectClass_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void ActionError::omit_managedObjectClass() {
    managedObjectClass_field.~__shared3();
    bit_mask &= ~0x80000000;
}

ActionError::managedObjectInstance *ActionError::get_managedObjectInstance() {
    if (bit_mask & 0x40000000)
	return &managedObjectInstance_field;
    else
	return 0;
}

const ActionError::managedObjectInstance *ActionError::get_managedObjectInstance() const {
    if (bit_mask & 0x40000000)
	return &managedObjectInstance_field;
    else
	return 0;
}

void ActionError::set_managedObjectInstance(const managedObjectInstance & managedObjectInstance_val) {
    bit_mask |= 0x40000000;
    managedObjectInstance_field = managedObjectInstance_val;
}

int ActionError::managedObjectInstance_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void ActionError::omit_managedObjectInstance() {
    managedObjectInstance_field.~ObjectInstance();
    bit_mask &= ~0x40000000;
}

ActionError::currentTime *ActionError::get_currentTime() {
    if (*(char **)&currentTime_field)
	return &currentTime_field;
    else
	return 0;
}

const ActionError::currentTime *ActionError::get_currentTime() const {
    if (*(char **)&currentTime_field)
	return &currentTime_field;
    else
	return 0;
}

void ActionError::set_currentTime(const currentTime & currentTime_val) {
    currentTime_field = currentTime_val;
}

int ActionError::currentTime_is_present() const {
    return !!(*(char **)&currentTime_field);
}

void ActionError::omit_currentTime() {
    currentTime_field.~OssGeneralizedTime();
}

ActionError::actionErrorInfo & ActionError::get_actionErrorInfo() {
    return actionErrorInfo_field;
}

const ActionError::actionErrorInfo & ActionError::get_actionErrorInfo() const {
    return actionErrorInfo_field;
}

void ActionError::set_actionErrorInfo(const actionErrorInfo & actionErrorInfo_val) {
    actionErrorInfo_field = actionErrorInfo_val;
}

void *ActionReply::operator new(size_t size) {
    return ossNewFunc(size);
}

void ActionReply::operator delete(void *ptr) {
    asn1Free(ptr);
}

ActionReply::ActionReply() {
    memset(this, 0, sizeof(ActionReply));
}

ActionReply::ActionReply(const ActionReply & that) {
    OSSTRY {
	actionType_field = that.actionType_field;
	actionReplyInfo_field = that.actionReplyInfo_field;
    } OSSCLEAN(ActionReply)
}

ActionReply::ActionReply(const actionType & actionType_val, const actionReplyInfo & actionReplyInfo_val) {
    OSSTRY {
	actionType_field = actionType_val;
	actionReplyInfo_field = actionReplyInfo_val;
    } OSSCLEAN(ActionReply)
}

ActionReply & ActionReply::operator = (const ActionReply & that) {
    if (this == &that)
	return *this;
    actionType_field = that.actionType_field;
    actionReplyInfo_field = that.actionReplyInfo_field;
    return *this;
}

int ActionReply::operator == (const ActionReply & that) const {
    if (actionType_field != that.actionType_field)
	return 0;
    if (actionReplyInfo_field != that.actionReplyInfo_field)
	return 0;
    return 1;
}

int ActionReply::operator != (const ActionReply & that) const {
    return !(operator ==(that));
}

ActionReply::actionType & ActionReply::get_actionType() {
    return actionType_field;
}

const ActionReply::actionType & ActionReply::get_actionType() const {
    return actionType_field;
}

void ActionReply::set_actionType(const actionType & actionType_val) {
    actionType_field = actionType_val;
}

ActionReply::actionReplyInfo & ActionReply::get_actionReplyInfo() {
    return actionReplyInfo_field;
}

const ActionReply::actionReplyInfo & ActionReply::get_actionReplyInfo() const {
    return actionReplyInfo_field;
}

void ActionReply::set_actionReplyInfo(const actionReplyInfo & actionReplyInfo_val) {
    actionReplyInfo_field = actionReplyInfo_val;
}

void *ActionResult::operator new(size_t size) {
    return ossNewFunc(size);
}

void ActionResult::operator delete(void *ptr) {
    asn1Free(ptr);
}

ActionResult::ActionResult() {
    memset(this, 0, sizeof(ActionResult));
}

ActionResult::ActionResult(const ActionResult & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	managedObjectClass_field = that.managedObjectClass_field;
	managedObjectInstance_field = that.managedObjectInstance_field;
	currentTime_field = that.currentTime_field;
	actionReply_field = that.actionReply_field;
    } OSSCLEAN(ActionResult)
}

ActionResult::ActionResult(const managedObjectClass & managedObjectClass_val, const managedObjectInstance & managedObjectInstance_val, 
    const currentTime & currentTime_val, const actionReply & actionReply_val) {
    OSSTRY {
	bit_mask = 0xe0000000;
	managedObjectClass_field = managedObjectClass_val;
	managedObjectInstance_field = managedObjectInstance_val;
	currentTime_field = currentTime_val;
	actionReply_field = actionReply_val;
    } OSSCLEAN(ActionResult)
}

ActionResult & ActionResult::operator = (const ActionResult & that) {
    if (this == &that)
	return *this;
    this->~ActionResult();
    bit_mask = that.bit_mask;
    managedObjectClass_field = that.managedObjectClass_field;
    managedObjectInstance_field = that.managedObjectInstance_field;
    currentTime_field = that.currentTime_field;
    actionReply_field = that.actionReply_field;
    return *this;
}

int ActionResult::operator == (const ActionResult & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (managedObjectClass_field != that.managedObjectClass_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (managedObjectInstance_field != that.managedObjectInstance_field)
	    return 0;
    }
    if (currentTime_field != that.currentTime_field)
	return 0;
    if (bit_mask & 0x20000000) {
	if (actionReply_field != that.actionReply_field)
	    return 0;
    }
    return 1;
}

int ActionResult::operator != (const ActionResult & that) const {
    return !(operator ==(that));
}

ActionResult::managedObjectClass *ActionResult::get_managedObjectClass() {
    if (bit_mask & 0x80000000)
	return &managedObjectClass_field;
    else
	return 0;
}

const ActionResult::managedObjectClass *ActionResult::get_managedObjectClass() const {
    if (bit_mask & 0x80000000)
	return &managedObjectClass_field;
    else
	return 0;
}

void ActionResult::set_managedObjectClass(const managedObjectClass & managedObjectClass_val) {
    bit_mask |= 0x80000000;
    managedObjectClass_field = managedObjectClass_val;
}

int ActionResult::managedObjectClass_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void ActionResult::omit_managedObjectClass() {
    managedObjectClass_field.~__shared3();
    bit_mask &= ~0x80000000;
}

ActionResult::managedObjectInstance *ActionResult::get_managedObjectInstance() {
    if (bit_mask & 0x40000000)
	return &managedObjectInstance_field;
    else
	return 0;
}

const ActionResult::managedObjectInstance *ActionResult::get_managedObjectInstance() const {
    if (bit_mask & 0x40000000)
	return &managedObjectInstance_field;
    else
	return 0;
}

void ActionResult::set_managedObjectInstance(const managedObjectInstance & managedObjectInstance_val) {
    bit_mask |= 0x40000000;
    managedObjectInstance_field = managedObjectInstance_val;
}

int ActionResult::managedObjectInstance_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void ActionResult::omit_managedObjectInstance() {
    managedObjectInstance_field.~ObjectInstance();
    bit_mask &= ~0x40000000;
}

ActionResult::currentTime *ActionResult::get_currentTime() {
    if (*(char **)&currentTime_field)
	return &currentTime_field;
    else
	return 0;
}

const ActionResult::currentTime *ActionResult::get_currentTime() const {
    if (*(char **)&currentTime_field)
	return &currentTime_field;
    else
	return 0;
}

void ActionResult::set_currentTime(const currentTime & currentTime_val) {
    currentTime_field = currentTime_val;
}

int ActionResult::currentTime_is_present() const {
    return !!(*(char **)&currentTime_field);
}

void ActionResult::omit_currentTime() {
    currentTime_field.~OssGeneralizedTime();
}

ActionResult::actionReply *ActionResult::get_actionReply() {
    if (bit_mask & 0x20000000)
	return &actionReply_field;
    else
	return 0;
}

const ActionResult::actionReply *ActionResult::get_actionReply() const {
    if (bit_mask & 0x20000000)
	return &actionReply_field;
    else
	return 0;
}

void ActionResult::set_actionReply(const actionReply & actionReply_val) {
    bit_mask |= 0x20000000;
    actionReply_field = actionReply_val;
}

int ActionResult::actionReply_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void ActionResult::omit_actionReply() {
    actionReply_field.~ActionReply();
    bit_mask &= ~0x20000000;
}

void *AttributeError::operator new(size_t size) {
    return ossNewFunc(size);
}

void AttributeError::operator delete(void *ptr) {
    asn1Free(ptr);
}

AttributeError::AttributeError() {
    memset(this, 0, sizeof(AttributeError));
}

AttributeError::AttributeError(const AttributeError & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	errorStatus_field = that.errorStatus_field;
	modifyOperator_field = that.modifyOperator_field;
	attributeId_field = that.attributeId_field;
	attributeValue_field = that.attributeValue_field;
    } OSSCLEAN(AttributeError)
}

AttributeError::AttributeError(errorStatus errorStatus_val, modifyOperator modifyOperator_val, 
    const attributeId & attributeId_val, const attributeValue & attributeValue_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	errorStatus_field = errorStatus_val;
	modifyOperator_field = modifyOperator_val;
	attributeId_field = attributeId_val;
	attributeValue_field = attributeValue_val;
    } OSSCLEAN(AttributeError)
}

AttributeError::AttributeError(errorStatus errorStatus_val, const attributeId & attributeId_val) {
    OSSTRY {
	bit_mask = 0;
	errorStatus_field = errorStatus_val;
	attributeId_field = attributeId_val;
    } OSSCLEAN(AttributeError)
}

AttributeError & AttributeError::operator = (const AttributeError & that) {
    if (this == &that)
	return *this;
    this->~AttributeError();
    bit_mask = that.bit_mask;
    errorStatus_field = that.errorStatus_field;
    modifyOperator_field = that.modifyOperator_field;
    attributeId_field = that.attributeId_field;
    attributeValue_field = that.attributeValue_field;
    return *this;
}

int AttributeError::operator == (const AttributeError & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (errorStatus_field != that.errorStatus_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (modifyOperator_field != that.modifyOperator_field)
	    return 0;
    }
    if (attributeId_field != that.attributeId_field)
	return 0;
    if (bit_mask & 0x40000000) {
	if (attributeValue_field != that.attributeValue_field)
	    return 0;
    }
    return 1;
}

int AttributeError::operator != (const AttributeError & that) const {
    return !(operator ==(that));
}

AttributeError::errorStatus & AttributeError::get_errorStatus() {
    return errorStatus_field;
}

AttributeError::errorStatus AttributeError::get_errorStatus() const {
    return errorStatus_field;
}

void AttributeError::set_errorStatus(errorStatus errorStatus_val) {
    errorStatus_field = errorStatus_val;
}

AttributeError::modifyOperator *AttributeError::get_modifyOperator() {
    if (bit_mask & 0x80000000)
	return &modifyOperator_field;
    else
	return 0;
}

const AttributeError::modifyOperator *AttributeError::get_modifyOperator() const {
    if (bit_mask & 0x80000000)
	return &modifyOperator_field;
    else
	return 0;
}

void AttributeError::set_modifyOperator(modifyOperator modifyOperator_val) {
    bit_mask |= 0x80000000;
    modifyOperator_field = modifyOperator_val;
}

int AttributeError::modifyOperator_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void AttributeError::omit_modifyOperator() {
    bit_mask &= ~0x80000000;
}

AttributeError::attributeId & AttributeError::get_attributeId() {
    return attributeId_field;
}

const AttributeError::attributeId & AttributeError::get_attributeId() const {
    return attributeId_field;
}

void AttributeError::set_attributeId(const attributeId & attributeId_val) {
    attributeId_field = attributeId_val;
}

AttributeError::attributeValue *AttributeError::get_attributeValue() {
    if (bit_mask & 0x40000000)
	return &attributeValue_field;
    else
	return 0;
}

const AttributeError::attributeValue *AttributeError::get_attributeValue() const {
    if (bit_mask & 0x40000000)
	return &attributeValue_field;
    else
	return 0;
}

void AttributeError::set_attributeValue(const attributeValue & attributeValue_val) {
    bit_mask |= 0x40000000;
    attributeValue_field = attributeValue_val;
}

int AttributeError::attributeValue_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void AttributeError::omit_attributeValue() {
    attributeValue_field.~AvaSet_Value();
    bit_mask &= ~0x40000000;
}

void *AttributeIdError::operator new(size_t size) {
    return ossNewFunc(size);
}

void AttributeIdError::operator delete(void *ptr) {
    asn1Free(ptr);
}

AttributeIdError::AttributeIdError() {
    memset(this, 0, sizeof(AttributeIdError));
}

AttributeIdError::AttributeIdError(const AttributeIdError & that) {
    OSSTRY {
	errorStatus_field = that.errorStatus_field;
	attributeId_field = that.attributeId_field;
    } OSSCLEAN(AttributeIdError)
}

AttributeIdError::AttributeIdError(errorStatus errorStatus_val, const attributeId & attributeId_val) {
    OSSTRY {
	errorStatus_field = errorStatus_val;
	attributeId_field = attributeId_val;
    } OSSCLEAN(AttributeIdError)
}

AttributeIdError & AttributeIdError::operator = (const AttributeIdError & that) {
    if (this == &that)
	return *this;
    errorStatus_field = that.errorStatus_field;
    attributeId_field = that.attributeId_field;
    return *this;
}

int AttributeIdError::operator == (const AttributeIdError & that) const {
    if (errorStatus_field != that.errorStatus_field)
	return 0;
    if (attributeId_field != that.attributeId_field)
	return 0;
    return 1;
}

int AttributeIdError::operator != (const AttributeIdError & that) const {
    return !(operator ==(that));
}

AttributeIdError::errorStatus & AttributeIdError::get_errorStatus() {
    return errorStatus_field;
}

AttributeIdError::errorStatus AttributeIdError::get_errorStatus() const {
    return errorStatus_field;
}

void AttributeIdError::set_errorStatus(errorStatus errorStatus_val) {
    errorStatus_field = errorStatus_val;
}

AttributeIdError::attributeId & AttributeIdError::get_attributeId() {
    return attributeId_field;
}

const AttributeIdError::attributeId & AttributeIdError::get_attributeId() const {
    return attributeId_field;
}

void AttributeIdError::set_attributeId(const attributeId & attributeId_val) {
    attributeId_field = attributeId_val;
}

void *AttributeValueAssertion::operator new(size_t size) {
    return ossNewFunc(size);
}

void AttributeValueAssertion::operator delete(void *ptr) {
    asn1Free(ptr);
}

AttributeValueAssertion::AttributeValueAssertion() {
    memset(this, 0, sizeof(AttributeValueAssertion));
}

AttributeValueAssertion::AttributeValueAssertion(const AttributeValueAssertion & that) {
    OSSTRY {
	id_field = that.id_field;
	value_field = that.value_field;
    } OSSCLEAN(AttributeValueAssertion)
}

AttributeValueAssertion::AttributeValueAssertion(const id & id_val, const value & value_val) {
    OSSTRY {
	id_field = id_val;
	value_field = value_val;
    } OSSCLEAN(AttributeValueAssertion)
}

AttributeValueAssertion & AttributeValueAssertion::operator = (const AttributeValueAssertion & that) {
    if (this == &that)
	return *this;
    id_field = that.id_field;
    value_field = that.value_field;
    return *this;
}

int AttributeValueAssertion::operator == (const AttributeValueAssertion & that) const {
    if (id_field != that.id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int AttributeValueAssertion::operator != (const AttributeValueAssertion & that) const {
    return !(operator ==(that));
}

AttributeValueAssertion::id & AttributeValueAssertion::get_id() {
    return id_field;
}

const AttributeValueAssertion::id & AttributeValueAssertion::get_id() const {
    return id_field;
}

void AttributeValueAssertion::set_id(const id & id_val) {
    id_field = id_val;
}

AttributeValueAssertion::value & AttributeValueAssertion::get_value() {
    return value_field;
}

const AttributeValueAssertion::value & AttributeValueAssertion::get_value() const {
    return value_field;
}

void AttributeValueAssertion::set_value(const value & value_val) {
    value_field = value_val;
}

void *BaseManagedObjectId::operator new(size_t size) {
    return ossNewFunc(size);
}

void BaseManagedObjectId::operator delete(void *ptr) {
    asn1Free(ptr);
}

BaseManagedObjectId::BaseManagedObjectId() {
    memset(this, 0, sizeof(BaseManagedObjectId));
}

BaseManagedObjectId::BaseManagedObjectId(const BaseManagedObjectId & that) {
    OSSTRY {
	baseManagedObjectClass_field = that.baseManagedObjectClass_field;
	baseManagedObjectInstance_field = that.baseManagedObjectInstance_field;
    } OSSCLEAN(BaseManagedObjectId)
}

BaseManagedObjectId::BaseManagedObjectId(const baseManagedObjectClass & baseManagedObjectClass_val, 
    const baseManagedObjectInstance & baseManagedObjectInstance_val) {
    OSSTRY {
	baseManagedObjectClass_field = baseManagedObjectClass_val;
	baseManagedObjectInstance_field = baseManagedObjectInstance_val;
    } OSSCLEAN(BaseManagedObjectId)
}

BaseManagedObjectId & BaseManagedObjectId::operator = (const BaseManagedObjectId & that) {
    if (this == &that)
	return *this;
    baseManagedObjectClass_field = that.baseManagedObjectClass_field;
    baseManagedObjectInstance_field = that.baseManagedObjectInstance_field;
    return *this;
}

int BaseManagedObjectId::operator == (const BaseManagedObjectId & that) const {
    if (baseManagedObjectClass_field != that.baseManagedObjectClass_field)
	return 0;
    if (baseManagedObjectInstance_field != that.baseManagedObjectInstance_field)
	return 0;
    return 1;
}

int BaseManagedObjectId::operator != (const BaseManagedObjectId & that) const {
    return !(operator ==(that));
}

BaseManagedObjectId::baseManagedObjectClass & BaseManagedObjectId::get_baseManagedObjectClass() {
    return baseManagedObjectClass_field;
}

const BaseManagedObjectId::baseManagedObjectClass & BaseManagedObjectId::get_baseManagedObjectClass() const {
    return baseManagedObjectClass_field;
}

void BaseManagedObjectId::set_baseManagedObjectClass(const baseManagedObjectClass & baseManagedObjectClass_val) {
    baseManagedObjectClass_field = baseManagedObjectClass_val;
}

BaseManagedObjectId::baseManagedObjectInstance & BaseManagedObjectId::get_baseManagedObjectInstance() {
    return baseManagedObjectInstance_field;
}

const BaseManagedObjectId::baseManagedObjectInstance & BaseManagedObjectId::get_baseManagedObjectInstance() const {
    return baseManagedObjectInstance_field;
}

void BaseManagedObjectId::set_baseManagedObjectInstance(const baseManagedObjectInstance & baseManagedObjectInstance_val) {
    baseManagedObjectInstance_field = baseManagedObjectInstance_val;
}

void *ComplexityLimitation::operator new(size_t size) {
    return ossNewFunc(size);
}

void ComplexityLimitation::operator delete(void *ptr) {
    asn1Free(ptr);
}

ComplexityLimitation::ComplexityLimitation() {
    memset(this, 0, sizeof(ComplexityLimitation));
}

ComplexityLimitation::ComplexityLimitation(const ComplexityLimitation & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	scope_field = that.scope_field;
	filter_field = that.filter_field;
	sync_field = that.sync_field;
    } OSSCLEAN(ComplexityLimitation)
}

ComplexityLimitation::ComplexityLimitation(const scope & scope_val, const filter & filter_val, 
    sync sync_val) {
    OSSTRY {
	bit_mask = 0xe0000000;
	scope_field = scope_val;
	filter_field = filter_val;
	sync_field = sync_val;
    } OSSCLEAN(ComplexityLimitation)
}

ComplexityLimitation & ComplexityLimitation::operator = (const ComplexityLimitation & that) {
    if (this == &that)
	return *this;
    this->~ComplexityLimitation();
    bit_mask = that.bit_mask;
    scope_field = that.scope_field;
    filter_field = that.filter_field;
    sync_field = that.sync_field;
    return *this;
}

int ComplexityLimitation::operator == (const ComplexityLimitation & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (scope_field != that.scope_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (filter_field != that.filter_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (sync_field != that.sync_field)
	    return 0;
    }
    return 1;
}

int ComplexityLimitation::operator != (const ComplexityLimitation & that) const {
    return !(operator ==(that));
}

ComplexityLimitation::scope *ComplexityLimitation::get_scope() {
    if (bit_mask & 0x80000000)
	return &scope_field;
    else
	return 0;
}

const ComplexityLimitation::scope *ComplexityLimitation::get_scope() const {
    if (bit_mask & 0x80000000)
	return &scope_field;
    else
	return 0;
}

void ComplexityLimitation::set_scope(const scope & scope_val) {
    bit_mask |= 0x80000000;
    scope_field = scope_val;
}

int ComplexityLimitation::scope_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void ComplexityLimitation::omit_scope() {
    scope_field.~Scope();
    bit_mask &= ~0x80000000;
}

ComplexityLimitation::filter *ComplexityLimitation::get_filter() {
    if (bit_mask & 0x40000000)
	return &filter_field;
    else
	return 0;
}

const ComplexityLimitation::filter *ComplexityLimitation::get_filter() const {
    if (bit_mask & 0x40000000)
	return &filter_field;
    else
	return 0;
}

void ComplexityLimitation::set_filter(const filter & filter_val) {
    bit_mask |= 0x40000000;
    filter_field = filter_val;
}

int ComplexityLimitation::filter_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void ComplexityLimitation::omit_filter() {
    filter_field.~CMISFilter();
    bit_mask &= ~0x40000000;
}

ComplexityLimitation::sync *ComplexityLimitation::get_sync() {
    if (bit_mask & 0x20000000)
	return &sync_field;
    else
	return 0;
}

const ComplexityLimitation::sync *ComplexityLimitation::get_sync() const {
    if (bit_mask & 0x20000000)
	return &sync_field;
    else
	return 0;
}

void ComplexityLimitation::set_sync(sync sync_val) {
    bit_mask |= 0x20000000;
    sync_field = sync_val;
}

int ComplexityLimitation::sync_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void ComplexityLimitation::omit_sync() {
    bit_mask &= ~0x20000000;
}

__choice3::__choice3() {
    memset(this, 0, sizeof(__choice3));
}

__choice3::__choice3(const __choice3 & that) {
    memset(this, 0, sizeof(__choice3));
    operator =(that);
}

__choice3::~__choice3() {
    cleanup();
}

__choice3 & __choice3::operator = (const __choice3 & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case managedObjectInstance_chosen:
	    if (that.managedObjectInstance_field)
		managedObjectInstance_field = new managedObjectInstance(*that.managedObjectInstance_field);
	    break;
	case superiorObjectInstance_chosen:
	    if (that.superiorObjectInstance_field)
		superiorObjectInstance_field = new superiorObjectInstance(*that.superiorObjectInstance_field);
	    break;
    }
    return *this;
}

int __choice3::operator == (const __choice3 & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case managedObjectInstance_chosen:
	    if ((managedObjectInstance_field) && (that.managedObjectInstance_field))
		return (*managedObjectInstance_field == *(that.managedObjectInstance_field));
	    else if (!((!managedObjectInstance_field) && (!that.managedObjectInstance_field)))
		return 0;
	    break;
	case superiorObjectInstance_chosen:
	    if ((superiorObjectInstance_field) && (that.superiorObjectInstance_field))
		return (*superiorObjectInstance_field == *(that.superiorObjectInstance_field));
	    else if (!((!superiorObjectInstance_field) && (!that.superiorObjectInstance_field)))
		return 0;
	    break;
    }

    return 1;
}

int __choice3::operator != (const __choice3 & that) const {
    return !(operator ==(that));
}

__choice3::managedObjectInstance *__choice3::get_managedObjectInstance() {
    if (_choice == managedObjectInstance_chosen)
	return (managedObjectInstance *)managedObjectInstance_field;
    else
	return 0;
}

const __choice3::managedObjectInstance *__choice3::get_managedObjectInstance() const {
    if (_choice == managedObjectInstance_chosen)
	return (const managedObjectInstance *)managedObjectInstance_field;
    else
	return 0;
}

void __choice3::set_managedObjectInstance(const managedObjectInstance & managedObjectInstance_val) {
    cleanup();
    managedObjectInstance_field = new managedObjectInstance(managedObjectInstance_val);
    _choice = managedObjectInstance_chosen;
}

__choice3::superiorObjectInstance *__choice3::get_superiorObjectInstance() {
    if (_choice == superiorObjectInstance_chosen)
	return (superiorObjectInstance *)superiorObjectInstance_field;
    else
	return 0;
}

const __choice3::superiorObjectInstance *__choice3::get_superiorObjectInstance() const {
    if (_choice == superiorObjectInstance_chosen)
	return (const superiorObjectInstance *)superiorObjectInstance_field;
    else
	return 0;
}

void __choice3::set_superiorObjectInstance(const superiorObjectInstance & superiorObjectInstance_val) {
    cleanup();
    superiorObjectInstance_field = new superiorObjectInstance(superiorObjectInstance_val);
    _choice = superiorObjectInstance_chosen;
}

void __choice3::cleanup() {
    switch (_choice) {
	case managedObjectInstance_chosen:
	    if (managedObjectInstance_field)
		delete managedObjectInstance_field;
	    break;
	case superiorObjectInstance_chosen:
	    if (superiorObjectInstance_field)
		delete superiorObjectInstance_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

/* Auxiliary data structures and functions for class __shared10 */

class __shared10_member {
public:
    __shared10_member *next;
    __shared10::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared10_member();
    __shared10_member(const __shared10::component & val);
};

void *__shared10_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared10_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared10_member::__shared10_member() {
}

__shared10_member::__shared10_member(const __shared10::component & val) {
    value = val;
}

static void *__shared10_copy(void *that) {
    return new __shared10_member(((__shared10_member *)that)->value);
}

static void __shared10_destroy(void *that) {
    delete (__shared10_member *)that;
}

static int __shared10_compare(void *val1, void *val2) {
    return (((__shared10_member *)val1)->value == ((__shared10_member *)val2)->value);
}

/* Constructors */

__shared10::__shared10() {
}

__shared10::__shared10(const __shared10 & that) {
    OSSTRY {
	do_copy(that, &__shared10_copy);
    } OSSCLEAN(__shared10)
}

/* Destructor */

__shared10::~__shared10() {
    do_destroy(&__shared10_destroy);
}

/* Operators: assignment, equality, inequality */

__shared10 & __shared10::operator = (const __shared10 & that) {
    do_destroy(&__shared10_destroy);
    do_copy(that, &__shared10_copy);
    return *this;
}

int __shared10::operator == (const __shared10 & that) const {
    return do_compare(that, &__shared10_compare);
}

int __shared10::operator != (const __shared10 & that) const {
    return !do_compare(that, &__shared10_compare);
}

/* Locate ("At" etc) methods */

__shared10::component *__shared10::at(OssIndex pos) {
    return &((__shared10_member *)pos)->value;
}

const __shared10::component *__shared10::at(OssIndex pos) const {
    return &((__shared10_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared10::prepend(const component & val) {
    __shared10_member *newrec = new __shared10_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared10::prepend(__shared10 *seq) {
    return do_prepend(seq);
}

OssIndex __shared10::insert_after(OssIndex pos, const component & val) {
    __shared10_member *newrec = new __shared10_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared10::insert_after(OssIndex pos, __shared10 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared10::remove_front() {
    __shared10_member *extr = (__shared10_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared10_destroy(extr);
    return 0;
}

int __shared10::remove_after(OssIndex pos) {
    __shared10_member *extr = (__shared10_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared10_destroy(extr);
    return 0;
}

/* Extract methods */

__shared10 *__shared10::extract_after(OssIndex begin, OssIndex end) {
    return (__shared10 *)do_extract_after(begin, end);
}

void *CreateArgument::operator new(size_t size) {
    return ossNewFunc(size);
}

void CreateArgument::operator delete(void *ptr) {
    asn1Free(ptr);
}

CreateArgument::CreateArgument() {
    memset(this, 0, sizeof(CreateArgument));
}

CreateArgument::CreateArgument(const CreateArgument & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	managedObjectClass_field = that.managedObjectClass_field;
	managedOrSuperiorObjectInstance_field = that.managedOrSuperiorObjectInstance_field;
	accessControl_field = that.accessControl_field;
	referenceObjectInstance_field = that.referenceObjectInstance_field;
	attributeList_field = that.attributeList_field;
    } OSSCLEAN(CreateArgument)
}

CreateArgument::CreateArgument(const managedObjectClass & managedObjectClass_val, 
    const managedOrSuperiorObjectInstance & managedOrSuperiorObjectInstance_val, const accessControl & accessControl_val, 
    const referenceObjectInstance & referenceObjectInstance_val, const attributeList & attributeList_val) {
    OSSTRY {
	bit_mask = 0xf0000000;
	managedObjectClass_field = managedObjectClass_val;
	managedOrSuperiorObjectInstance_field = managedOrSuperiorObjectInstance_val;
	accessControl_field = accessControl_val;
	referenceObjectInstance_field = referenceObjectInstance_val;
	attributeList_field = attributeList_val;
    } OSSCLEAN(CreateArgument)
}

CreateArgument::CreateArgument(const managedObjectClass & managedObjectClass_val) {
    OSSTRY {
	bit_mask = 0;
	managedObjectClass_field = managedObjectClass_val;
    } OSSCLEAN(CreateArgument)
}

CreateArgument & CreateArgument::operator = (const CreateArgument & that) {
    if (this == &that)
	return *this;
    this->~CreateArgument();
    bit_mask = that.bit_mask;
    managedObjectClass_field = that.managedObjectClass_field;
    managedOrSuperiorObjectInstance_field = that.managedOrSuperiorObjectInstance_field;
    accessControl_field = that.accessControl_field;
    referenceObjectInstance_field = that.referenceObjectInstance_field;
    attributeList_field = that.attributeList_field;
    return *this;
}

int CreateArgument::operator == (const CreateArgument & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (managedObjectClass_field != that.managedObjectClass_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (managedOrSuperiorObjectInstance_field != that.managedOrSuperiorObjectInstance_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (accessControl_field != that.accessControl_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (referenceObjectInstance_field != that.referenceObjectInstance_field)
	    return 0;
    }
    if (bit_mask & 0x10000000) {
	if (attributeList_field != that.attributeList_field)
	    return 0;
    }
    return 1;
}

int CreateArgument::operator != (const CreateArgument & that) const {
    return !(operator ==(that));
}

CreateArgument::managedObjectClass & CreateArgument::get_managedObjectClass() {
    return managedObjectClass_field;
}

const CreateArgument::managedObjectClass & CreateArgument::get_managedObjectClass() const {
    return managedObjectClass_field;
}

void CreateArgument::set_managedObjectClass(const managedObjectClass & managedObjectClass_val) {
    managedObjectClass_field = managedObjectClass_val;
}

CreateArgument::managedOrSuperiorObjectInstance *CreateArgument::get_managedOrSuperiorObjectInstance() {
    if (bit_mask & 0x80000000)
	return &managedOrSuperiorObjectInstance_field;
    else
	return 0;
}

const CreateArgument::managedOrSuperiorObjectInstance *CreateArgument::get_managedOrSuperiorObjectInstance() const {
    if (bit_mask & 0x80000000)
	return &managedOrSuperiorObjectInstance_field;
    else
	return 0;
}

void CreateArgument::set_managedOrSuperiorObjectInstance(const managedOrSuperiorObjectInstance & managedOrSuperiorObjectInstance_val) {
    bit_mask |= 0x80000000;
    managedOrSuperiorObjectInstance_field = managedOrSuperiorObjectInstance_val;
}

int CreateArgument::managedOrSuperiorObjectInstance_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void CreateArgument::omit_managedOrSuperiorObjectInstance() {
    managedOrSuperiorObjectInstance_field.~__choice3();
    bit_mask &= ~0x80000000;
}

CreateArgument::accessControl *CreateArgument::get_accessControl() {
    if (bit_mask & 0x40000000)
	return &accessControl_field;
    else
	return 0;
}

const CreateArgument::accessControl *CreateArgument::get_accessControl() const {
    if (bit_mask & 0x40000000)
	return &accessControl_field;
    else
	return 0;
}

void CreateArgument::set_accessControl(const accessControl & accessControl_val) {
    bit_mask |= 0x40000000;
    accessControl_field = accessControl_val;
}

int CreateArgument::accessControl_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void CreateArgument::omit_accessControl() {
    accessControl_field.~__shared2();
    bit_mask &= ~0x40000000;
}

CreateArgument::referenceObjectInstance *CreateArgument::get_referenceObjectInstance() {
    if (bit_mask & 0x20000000)
	return &referenceObjectInstance_field;
    else
	return 0;
}

const CreateArgument::referenceObjectInstance *CreateArgument::get_referenceObjectInstance() const {
    if (bit_mask & 0x20000000)
	return &referenceObjectInstance_field;
    else
	return 0;
}

void CreateArgument::set_referenceObjectInstance(const referenceObjectInstance & referenceObjectInstance_val) {
    bit_mask |= 0x20000000;
    referenceObjectInstance_field = referenceObjectInstance_val;
}

int CreateArgument::referenceObjectInstance_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void CreateArgument::omit_referenceObjectInstance() {
    referenceObjectInstance_field.~ObjectInstance();
    bit_mask &= ~0x20000000;
}

CreateArgument::attributeList *CreateArgument::get_attributeList() {
    if (bit_mask & 0x10000000)
	return &attributeList_field;
    else
	return 0;
}

const CreateArgument::attributeList *CreateArgument::get_attributeList() const {
    if (bit_mask & 0x10000000)
	return &attributeList_field;
    else
	return 0;
}

void CreateArgument::set_attributeList(const attributeList & attributeList_val) {
    bit_mask |= 0x10000000;
    attributeList_field = attributeList_val;
}

int CreateArgument::attributeList_is_present() const {
    return !!(bit_mask & 0x10000000);
}

void CreateArgument::omit_attributeList() {
    attributeList_field.~__shared10();
    bit_mask &= ~0x10000000;
}

void *__shared11::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared11::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared11::__shared11() {
    memset(this, 0, sizeof(__shared11));
}

__shared11::__shared11(const __shared11 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	managedObjectClass_field = that.managedObjectClass_field;
	managedObjectInstance_field = that.managedObjectInstance_field;
	currentTime_field = that.currentTime_field;
	attributeList_field = that.attributeList_field;
    } OSSCLEAN(__shared11)
}

__shared11::__shared11(const managedObjectClass & managedObjectClass_val, const managedObjectInstance & managedObjectInstance_val, 
    const currentTime & currentTime_val, const attributeList & attributeList_val) {
    OSSTRY {
	bit_mask = 0xe0000000;
	managedObjectClass_field = managedObjectClass_val;
	managedObjectInstance_field = managedObjectInstance_val;
	currentTime_field = currentTime_val;
	attributeList_field = attributeList_val;
    } OSSCLEAN(__shared11)
}

__shared11 & __shared11::operator = (const __shared11 & that) {
    if (this == &that)
	return *this;
    this->~__shared11();
    bit_mask = that.bit_mask;
    managedObjectClass_field = that.managedObjectClass_field;
    managedObjectInstance_field = that.managedObjectInstance_field;
    currentTime_field = that.currentTime_field;
    attributeList_field = that.attributeList_field;
    return *this;
}

int __shared11::operator == (const __shared11 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (managedObjectClass_field != that.managedObjectClass_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (managedObjectInstance_field != that.managedObjectInstance_field)
	    return 0;
    }
    if (currentTime_field != that.currentTime_field)
	return 0;
    if (bit_mask & 0x20000000) {
	if (attributeList_field != that.attributeList_field)
	    return 0;
    }
    return 1;
}

int __shared11::operator != (const __shared11 & that) const {
    return !(operator ==(that));
}

__shared11::managedObjectClass *__shared11::get_managedObjectClass() {
    if (bit_mask & 0x80000000)
	return &managedObjectClass_field;
    else
	return 0;
}

const __shared11::managedObjectClass *__shared11::get_managedObjectClass() const {
    if (bit_mask & 0x80000000)
	return &managedObjectClass_field;
    else
	return 0;
}

void __shared11::set_managedObjectClass(const managedObjectClass & managedObjectClass_val) {
    bit_mask |= 0x80000000;
    managedObjectClass_field = managedObjectClass_val;
}

int __shared11::managedObjectClass_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void __shared11::omit_managedObjectClass() {
    managedObjectClass_field.~__shared3();
    bit_mask &= ~0x80000000;
}

__shared11::managedObjectInstance *__shared11::get_managedObjectInstance() {
    if (bit_mask & 0x40000000)
	return &managedObjectInstance_field;
    else
	return 0;
}

const __shared11::managedObjectInstance *__shared11::get_managedObjectInstance() const {
    if (bit_mask & 0x40000000)
	return &managedObjectInstance_field;
    else
	return 0;
}

void __shared11::set_managedObjectInstance(const managedObjectInstance & managedObjectInstance_val) {
    bit_mask |= 0x40000000;
    managedObjectInstance_field = managedObjectInstance_val;
}

int __shared11::managedObjectInstance_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void __shared11::omit_managedObjectInstance() {
    managedObjectInstance_field.~ObjectInstance();
    bit_mask &= ~0x40000000;
}

__shared11::currentTime *__shared11::get_currentTime() {
    if (*(char **)&currentTime_field)
	return &currentTime_field;
    else
	return 0;
}

const __shared11::currentTime *__shared11::get_currentTime() const {
    if (*(char **)&currentTime_field)
	return &currentTime_field;
    else
	return 0;
}

void __shared11::set_currentTime(const currentTime & currentTime_val) {
    currentTime_field = currentTime_val;
}

int __shared11::currentTime_is_present() const {
    return !!(*(char **)&currentTime_field);
}

void __shared11::omit_currentTime() {
    currentTime_field.~OssGeneralizedTime();
}

__shared11::attributeList *__shared11::get_attributeList() {
    if (bit_mask & 0x20000000)
	return &attributeList_field;
    else
	return 0;
}

const __shared11::attributeList *__shared11::get_attributeList() const {
    if (bit_mask & 0x20000000)
	return &attributeList_field;
    else
	return 0;
}

void __shared11::set_attributeList(const attributeList & attributeList_val) {
    bit_mask |= 0x20000000;
    attributeList_field = attributeList_val;
}

int __shared11::attributeList_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void __shared11::omit_attributeList() {
    attributeList_field.~__shared10();
    bit_mask &= ~0x20000000;
}

void *DeleteArgument::operator new(size_t size) {
    return ossNewFunc(size);
}

void DeleteArgument::operator delete(void *ptr) {
    asn1Free(ptr);
}

enum CMISSync DeleteArgument::get_default_synchronization() {
    return DeleteArgument::default_synchronization;
}

const Scope& DeleteArgument::get_default_scope() {
    return DeleteArgument::default_scope;
}

const CMISFilter& DeleteArgument::get_default_filter() {
    return DeleteArgument::default_filter;
}

DeleteArgument::DeleteArgument() {
    memset(this, 0, sizeof(DeleteArgument));
}

DeleteArgument::DeleteArgument(const DeleteArgument & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	baseManagedObjectClass_field = that.baseManagedObjectClass_field;
	baseManagedObjectInstance_field = that.baseManagedObjectInstance_field;
	accessControl_field = that.accessControl_field;
	synchronization_field = that.synchronization_field;
	if (bit_mask & 0x20000000)
	    scope_field = that.scope_field;
	if (bit_mask & 0x10000000)
	    filter_field = that.filter_field;
    } OSSCLEAN(DeleteArgument)
}

DeleteArgument::DeleteArgument(const baseManagedObjectClass & baseManagedObjectClass_val, 
    const baseManagedObjectInstance & baseManagedObjectInstance_val, const accessControl & accessControl_val, 
    synchronization synchronization_val, const scope & scope_val, const filter & filter_val) {
    OSSTRY {
	bit_mask = 0xf0000000;
	baseManagedObjectClass_field = baseManagedObjectClass_val;
	baseManagedObjectInstance_field = baseManagedObjectInstance_val;
	accessControl_field = accessControl_val;
	synchronization_field = synchronization_val;
	scope_field = scope_val;
	filter_field = filter_val;
    } OSSCLEAN(DeleteArgument)
}

DeleteArgument::DeleteArgument(const baseManagedObjectClass & baseManagedObjectClass_val, 
    const baseManagedObjectInstance & baseManagedObjectInstance_val) {
    OSSTRY {
	bit_mask = 0;
	baseManagedObjectClass_field = baseManagedObjectClass_val;
	baseManagedObjectInstance_field = baseManagedObjectInstance_val;
    } OSSCLEAN(DeleteArgument)
}

DeleteArgument::~DeleteArgument() {
    if (!(bit_mask & 0x20000000))
	memset(&scope_field, 0, sizeof(scope));
    if (!(bit_mask & 0x10000000))
	memset(&filter_field, 0, sizeof(filter));
}

DeleteArgument & DeleteArgument::operator = (const DeleteArgument & that) {
    if (this == &that)
	return *this;
    this->~DeleteArgument();
    bit_mask = that.bit_mask;
    baseManagedObjectClass_field = that.baseManagedObjectClass_field;
    baseManagedObjectInstance_field = that.baseManagedObjectInstance_field;
    accessControl_field = that.accessControl_field;
    synchronization_field = that.synchronization_field;
    if (bit_mask & 0x20000000)
	scope_field = that.scope_field;
    if (bit_mask & 0x10000000)
	filter_field = that.filter_field;
    return *this;
}

int DeleteArgument::operator == (const DeleteArgument & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (baseManagedObjectClass_field != that.baseManagedObjectClass_field)
	return 0;
    if (baseManagedObjectInstance_field != that.baseManagedObjectInstance_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (accessControl_field != that.accessControl_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (synchronization_field != that.synchronization_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (scope_field != that.scope_field)
	    return 0;
    }
    if (bit_mask & 0x10000000) {
	if (filter_field != that.filter_field)
	    return 0;
    }
    return 1;
}

int DeleteArgument::operator != (const DeleteArgument & that) const {
    return !(operator ==(that));
}

DeleteArgument::baseManagedObjectClass & DeleteArgument::get_baseManagedObjectClass() {
    return baseManagedObjectClass_field;
}

const DeleteArgument::baseManagedObjectClass & DeleteArgument::get_baseManagedObjectClass() const {
    return baseManagedObjectClass_field;
}

void DeleteArgument::set_baseManagedObjectClass(const baseManagedObjectClass & baseManagedObjectClass_val) {
    baseManagedObjectClass_field = baseManagedObjectClass_val;
}

DeleteArgument::baseManagedObjectInstance & DeleteArgument::get_baseManagedObjectInstance() {
    return baseManagedObjectInstance_field;
}

const DeleteArgument::baseManagedObjectInstance & DeleteArgument::get_baseManagedObjectInstance() const {
    return baseManagedObjectInstance_field;
}

void DeleteArgument::set_baseManagedObjectInstance(const baseManagedObjectInstance & baseManagedObjectInstance_val) {
    baseManagedObjectInstance_field = baseManagedObjectInstance_val;
}

DeleteArgument::accessControl *DeleteArgument::get_accessControl() {
    if (bit_mask & 0x80000000)
	return &accessControl_field;
    else
	return 0;
}

const DeleteArgument::accessControl *DeleteArgument::get_accessControl() const {
    if (bit_mask & 0x80000000)
	return &accessControl_field;
    else
	return 0;
}

void DeleteArgument::set_accessControl(const accessControl & accessControl_val) {
    bit_mask |= 0x80000000;
    accessControl_field = accessControl_val;
}

int DeleteArgument::accessControl_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void DeleteArgument::omit_accessControl() {
    accessControl_field.~__shared2();
    bit_mask &= ~0x80000000;
}

DeleteArgument::synchronization *DeleteArgument::get_synchronization() {
    if (bit_mask & 0x40000000)
	return &synchronization_field;
    else
	return 0;
}

const DeleteArgument::synchronization *DeleteArgument::get_synchronization() const {
    if (bit_mask & 0x40000000)
	return &synchronization_field;
    else
	return 0;
}

void DeleteArgument::set_synchronization(synchronization synchronization_val) {
    bit_mask |= 0x40000000;
    synchronization_field = synchronization_val;
}

int DeleteArgument::synchronization_is_default() const {
    return !(bit_mask & 0x40000000);
}

void DeleteArgument::set_default_synchronization() {
    bit_mask &= ~0x40000000;
}

DeleteArgument::scope *DeleteArgument::get_scope() {
    if (bit_mask & 0x20000000)
	return &scope_field;
    else
	return 0;
}

const DeleteArgument::scope *DeleteArgument::get_scope() const {
    if (bit_mask & 0x20000000)
	return &scope_field;
    else
	return 0;
}

void DeleteArgument::set_scope(const scope & scope_val) {
    if (!(bit_mask & 0x20000000)) {
	memset(&scope_field, 0, sizeof(scope));
	bit_mask |= 0x20000000;
    }
    scope_field = scope_val;
}

int DeleteArgument::scope_is_default() const {
    return !(bit_mask & 0x20000000);
}

void DeleteArgument::set_default_scope() {
    if (bit_mask & 0x20000000) {
	scope_field.~Scope();
	bit_mask &= ~0x20000000;
    }
}

DeleteArgument::filter *DeleteArgument::get_filter() {
    if (bit_mask & 0x10000000)
	return &filter_field;
    else
	return 0;
}

const DeleteArgument::filter *DeleteArgument::get_filter() const {
    if (bit_mask & 0x10000000)
	return &filter_field;
    else
	return 0;
}

void DeleteArgument::set_filter(const filter & filter_val) {
    if (!(bit_mask & 0x10000000)) {
	memset(&filter_field, 0, sizeof(filter));
	bit_mask |= 0x10000000;
    }
    filter_field = filter_val;
}

int DeleteArgument::filter_is_default() const {
    return !(bit_mask & 0x10000000);
}

void DeleteArgument::set_default_filter() {
    if (bit_mask & 0x10000000) {
	filter_field.~CMISFilter();
	bit_mask &= ~0x10000000;
    }
}

void *DeleteError::operator new(size_t size) {
    return ossNewFunc(size);
}

void DeleteError::operator delete(void *ptr) {
    asn1Free(ptr);
}

DeleteError::DeleteError() {
    memset(this, 0, sizeof(DeleteError));
}

DeleteError::DeleteError(const DeleteError & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	managedObjectClass_field = that.managedObjectClass_field;
	managedObjectInstance_field = that.managedObjectInstance_field;
	currentTime_field = that.currentTime_field;
	deleteErrorInfo_field = that.deleteErrorInfo_field;
    } OSSCLEAN(DeleteError)
}

DeleteError::DeleteError(const managedObjectClass & managedObjectClass_val, const managedObjectInstance & managedObjectInstance_val, 
    const currentTime & currentTime_val, deleteErrorInfo deleteErrorInfo_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	managedObjectClass_field = managedObjectClass_val;
	managedObjectInstance_field = managedObjectInstance_val;
	currentTime_field = currentTime_val;
	deleteErrorInfo_field = deleteErrorInfo_val;
    } OSSCLEAN(DeleteError)
}

DeleteError::DeleteError(deleteErrorInfo deleteErrorInfo_val) {
    OSSTRY {
	bit_mask = 0;
	deleteErrorInfo_field = deleteErrorInfo_val;
    } OSSCLEAN(DeleteError)
}

DeleteError & DeleteError::operator = (const DeleteError & that) {
    if (this == &that)
	return *this;
    this->~DeleteError();
    bit_mask = that.bit_mask;
    managedObjectClass_field = that.managedObjectClass_field;
    managedObjectInstance_field = that.managedObjectInstance_field;
    currentTime_field = that.currentTime_field;
    deleteErrorInfo_field = that.deleteErrorInfo_field;
    return *this;
}

int DeleteError::operator == (const DeleteError & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (managedObjectClass_field != that.managedObjectClass_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (managedObjectInstance_field != that.managedObjectInstance_field)
	    return 0;
    }
    if (currentTime_field != that.currentTime_field)
	return 0;
    if (deleteErrorInfo_field != that.deleteErrorInfo_field)
	return 0;
    return 1;
}

int DeleteError::operator != (const DeleteError & that) const {
    return !(operator ==(that));
}

DeleteError::managedObjectClass *DeleteError::get_managedObjectClass() {
    if (bit_mask & 0x80000000)
	return &managedObjectClass_field;
    else
	return 0;
}

const DeleteError::managedObjectClass *DeleteError::get_managedObjectClass() const {
    if (bit_mask & 0x80000000)
	return &managedObjectClass_field;
    else
	return 0;
}

void DeleteError::set_managedObjectClass(const managedObjectClass & managedObjectClass_val) {
    bit_mask |= 0x80000000;
    managedObjectClass_field = managedObjectClass_val;
}

int DeleteError::managedObjectClass_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void DeleteError::omit_managedObjectClass() {
    managedObjectClass_field.~__shared3();
    bit_mask &= ~0x80000000;
}

DeleteError::managedObjectInstance *DeleteError::get_managedObjectInstance() {
    if (bit_mask & 0x40000000)
	return &managedObjectInstance_field;
    else
	return 0;
}

const DeleteError::managedObjectInstance *DeleteError::get_managedObjectInstance() const {
    if (bit_mask & 0x40000000)
	return &managedObjectInstance_field;
    else
	return 0;
}

void DeleteError::set_managedObjectInstance(const managedObjectInstance & managedObjectInstance_val) {
    bit_mask |= 0x40000000;
    managedObjectInstance_field = managedObjectInstance_val;
}

int DeleteError::managedObjectInstance_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void DeleteError::omit_managedObjectInstance() {
    managedObjectInstance_field.~ObjectInstance();
    bit_mask &= ~0x40000000;
}

DeleteError::currentTime *DeleteError::get_currentTime() {
    if (*(char **)&currentTime_field)
	return &currentTime_field;
    else
	return 0;
}

const DeleteError::currentTime *DeleteError::get_currentTime() const {
    if (*(char **)&currentTime_field)
	return &currentTime_field;
    else
	return 0;
}

void DeleteError::set_currentTime(const currentTime & currentTime_val) {
    currentTime_field = currentTime_val;
}

int DeleteError::currentTime_is_present() const {
    return !!(*(char **)&currentTime_field);
}

void DeleteError::omit_currentTime() {
    currentTime_field.~OssGeneralizedTime();
}

DeleteError::deleteErrorInfo & DeleteError::get_deleteErrorInfo() {
    return deleteErrorInfo_field;
}

DeleteError::deleteErrorInfo DeleteError::get_deleteErrorInfo() const {
    return deleteErrorInfo_field;
}

void DeleteError::set_deleteErrorInfo(deleteErrorInfo deleteErrorInfo_val) {
    deleteErrorInfo_field = deleteErrorInfo_val;
}

void *DeleteResult::operator new(size_t size) {
    return ossNewFunc(size);
}

void DeleteResult::operator delete(void *ptr) {
    asn1Free(ptr);
}

DeleteResult::DeleteResult() {
    memset(this, 0, sizeof(DeleteResult));
}

DeleteResult::DeleteResult(const DeleteResult & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	managedObjectClass_field = that.managedObjectClass_field;
	managedObjectInstance_field = that.managedObjectInstance_field;
	currentTime_field = that.currentTime_field;
    } OSSCLEAN(DeleteResult)
}

DeleteResult::DeleteResult(const managedObjectClass & managedObjectClass_val, const managedObjectInstance & managedObjectInstance_val, 
    const currentTime & currentTime_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	managedObjectClass_field = managedObjectClass_val;
	managedObjectInstance_field = managedObjectInstance_val;
	currentTime_field = currentTime_val;
    } OSSCLEAN(DeleteResult)
}

DeleteResult & DeleteResult::operator = (const DeleteResult & that) {
    if (this == &that)
	return *this;
    this->~DeleteResult();
    bit_mask = that.bit_mask;
    managedObjectClass_field = that.managedObjectClass_field;
    managedObjectInstance_field = that.managedObjectInstance_field;
    currentTime_field = that.currentTime_field;
    return *this;
}

int DeleteResult::operator == (const DeleteResult & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (managedObjectClass_field != that.managedObjectClass_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (managedObjectInstance_field != that.managedObjectInstance_field)
	    return 0;
    }
    if (currentTime_field != that.currentTime_field)
	return 0;
    return 1;
}

int DeleteResult::operator != (const DeleteResult & that) const {
    return !(operator ==(that));
}

DeleteResult::managedObjectClass *DeleteResult::get_managedObjectClass() {
    if (bit_mask & 0x80000000)
	return &managedObjectClass_field;
    else
	return 0;
}

const DeleteResult::managedObjectClass *DeleteResult::get_managedObjectClass() const {
    if (bit_mask & 0x80000000)
	return &managedObjectClass_field;
    else
	return 0;
}

void DeleteResult::set_managedObjectClass(const managedObjectClass & managedObjectClass_val) {
    bit_mask |= 0x80000000;
    managedObjectClass_field = managedObjectClass_val;
}

int DeleteResult::managedObjectClass_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void DeleteResult::omit_managedObjectClass() {
    managedObjectClass_field.~__shared3();
    bit_mask &= ~0x80000000;
}

DeleteResult::managedObjectInstance *DeleteResult::get_managedObjectInstance() {
    if (bit_mask & 0x40000000)
	return &managedObjectInstance_field;
    else
	return 0;
}

const DeleteResult::managedObjectInstance *DeleteResult::get_managedObjectInstance() const {
    if (bit_mask & 0x40000000)
	return &managedObjectInstance_field;
    else
	return 0;
}

void DeleteResult::set_managedObjectInstance(const managedObjectInstance & managedObjectInstance_val) {
    bit_mask |= 0x40000000;
    managedObjectInstance_field = managedObjectInstance_val;
}

int DeleteResult::managedObjectInstance_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void DeleteResult::omit_managedObjectInstance() {
    managedObjectInstance_field.~ObjectInstance();
    bit_mask &= ~0x40000000;
}

DeleteResult::currentTime *DeleteResult::get_currentTime() {
    if (*(char **)&currentTime_field)
	return &currentTime_field;
    else
	return 0;
}

const DeleteResult::currentTime *DeleteResult::get_currentTime() const {
    if (*(char **)&currentTime_field)
	return &currentTime_field;
    else
	return 0;
}

void DeleteResult::set_currentTime(const currentTime & currentTime_val) {
    currentTime_field = currentTime_val;
}

int DeleteResult::currentTime_is_present() const {
    return !!(*(char **)&currentTime_field);
}

void DeleteResult::omit_currentTime() {
    currentTime_field.~OssGeneralizedTime();
}

void *EventReply::operator new(size_t size) {
    return ossNewFunc(size);
}

void EventReply::operator delete(void *ptr) {
    asn1Free(ptr);
}

EventReply::EventReply() {
    memset(this, 0, sizeof(EventReply));
}

EventReply::EventReply(const EventReply & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	eventType_field = that.eventType_field;
	eventReplyInfo_field = that.eventReplyInfo_field;
    } OSSCLEAN(EventReply)
}

EventReply::EventReply(const eventType & eventType_val, const eventReplyInfo & eventReplyInfo_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	eventType_field = eventType_val;
	eventReplyInfo_field = eventReplyInfo_val;
    } OSSCLEAN(EventReply)
}

EventReply::EventReply(const eventType & eventType_val) {
    OSSTRY {
	bit_mask = 0;
	eventType_field = eventType_val;
    } OSSCLEAN(EventReply)
}

EventReply & EventReply::operator = (const EventReply & that) {
    if (this == &that)
	return *this;
    this->~EventReply();
    bit_mask = that.bit_mask;
    eventType_field = that.eventType_field;
    eventReplyInfo_field = that.eventReplyInfo_field;
    return *this;
}

int EventReply::operator == (const EventReply & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (eventType_field != that.eventType_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (eventReplyInfo_field != that.eventReplyInfo_field)
	    return 0;
    }
    return 1;
}

int EventReply::operator != (const EventReply & that) const {
    return !(operator ==(that));
}

EventReply::eventType & EventReply::get_eventType() {
    return eventType_field;
}

const EventReply::eventType & EventReply::get_eventType() const {
    return eventType_field;
}

void EventReply::set_eventType(const eventType & eventType_val) {
    eventType_field = eventType_val;
}

EventReply::eventReplyInfo *EventReply::get_eventReplyInfo() {
    if (bit_mask & 0x80000000)
	return &eventReplyInfo_field;
    else
	return 0;
}

const EventReply::eventReplyInfo *EventReply::get_eventReplyInfo() const {
    if (bit_mask & 0x80000000)
	return &eventReplyInfo_field;
    else
	return 0;
}

void EventReply::set_eventReplyInfo(const eventReplyInfo & eventReplyInfo_val) {
    bit_mask |= 0x80000000;
    eventReplyInfo_field = eventReplyInfo_val;
}

int EventReply::eventReplyInfo_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void EventReply::omit_eventReplyInfo() {
    eventReplyInfo_field.~AvaSet_Value();
    bit_mask &= ~0x80000000;
}

void *EventReportArgument::operator new(size_t size) {
    return ossNewFunc(size);
}

void EventReportArgument::operator delete(void *ptr) {
    asn1Free(ptr);
}

EventReportArgument::EventReportArgument() {
    memset(this, 0, sizeof(EventReportArgument));
}

EventReportArgument::EventReportArgument(const EventReportArgument & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	managedObjectClass_field = that.managedObjectClass_field;
	managedObjectInstance_field = that.managedObjectInstance_field;
	eventTime_field = that.eventTime_field;
	eventType_field = that.eventType_field;
	eventInfo_field = that.eventInfo_field;
    } OSSCLEAN(EventReportArgument)
}

EventReportArgument::EventReportArgument(const managedObjectClass & managedObjectClass_val, 
    const managedObjectInstance & managedObjectInstance_val, const eventTime & eventTime_val, 
    const eventType & eventType_val, const eventInfo & eventInfo_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	managedObjectClass_field = managedObjectClass_val;
	managedObjectInstance_field = managedObjectInstance_val;
	eventTime_field = eventTime_val;
	eventType_field = eventType_val;
	eventInfo_field = eventInfo_val;
    } OSSCLEAN(EventReportArgument)
}

EventReportArgument::EventReportArgument(const managedObjectClass & managedObjectClass_val, 
    const managedObjectInstance & managedObjectInstance_val, const eventType & eventType_val) {
    OSSTRY {
	bit_mask = 0;
	managedObjectClass_field = managedObjectClass_val;
	managedObjectInstance_field = managedObjectInstance_val;
	eventType_field = eventType_val;
    } OSSCLEAN(EventReportArgument)
}

EventReportArgument & EventReportArgument::operator = (const EventReportArgument & that) {
    if (this == &that)
	return *this;
    this->~EventReportArgument();
    bit_mask = that.bit_mask;
    managedObjectClass_field = that.managedObjectClass_field;
    managedObjectInstance_field = that.managedObjectInstance_field;
    eventTime_field = that.eventTime_field;
    eventType_field = that.eventType_field;
    eventInfo_field = that.eventInfo_field;
    return *this;
}

int EventReportArgument::operator == (const EventReportArgument & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (managedObjectClass_field != that.managedObjectClass_field)
	return 0;
    if (managedObjectInstance_field != that.managedObjectInstance_field)
	return 0;
    if (eventTime_field != that.eventTime_field)
	return 0;
    if (eventType_field != that.eventType_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (eventInfo_field != that.eventInfo_field)
	    return 0;
    }
    return 1;
}

int EventReportArgument::operator != (const EventReportArgument & that) const {
    return !(operator ==(that));
}

EventReportArgument::managedObjectClass & EventReportArgument::get_managedObjectClass() {
    return managedObjectClass_field;
}

const EventReportArgument::managedObjectClass & EventReportArgument::get_managedObjectClass() const {
    return managedObjectClass_field;
}

void EventReportArgument::set_managedObjectClass(const managedObjectClass & managedObjectClass_val) {
    managedObjectClass_field = managedObjectClass_val;
}

EventReportArgument::managedObjectInstance & EventReportArgument::get_managedObjectInstance() {
    return managedObjectInstance_field;
}

const EventReportArgument::managedObjectInstance & EventReportArgument::get_managedObjectInstance() const {
    return managedObjectInstance_field;
}

void EventReportArgument::set_managedObjectInstance(const managedObjectInstance & managedObjectInstance_val) {
    managedObjectInstance_field = managedObjectInstance_val;
}

EventReportArgument::eventTime *EventReportArgument::get_eventTime() {
    if (*(char **)&eventTime_field)
	return &eventTime_field;
    else
	return 0;
}

const EventReportArgument::eventTime *EventReportArgument::get_eventTime() const {
    if (*(char **)&eventTime_field)
	return &eventTime_field;
    else
	return 0;
}

void EventReportArgument::set_eventTime(const eventTime & eventTime_val) {
    eventTime_field = eventTime_val;
}

int EventReportArgument::eventTime_is_present() const {
    return !!(*(char **)&eventTime_field);
}

void EventReportArgument::omit_eventTime() {
    eventTime_field.~OssGeneralizedTime();
}

EventReportArgument::eventType & EventReportArgument::get_eventType() {
    return eventType_field;
}

const EventReportArgument::eventType & EventReportArgument::get_eventType() const {
    return eventType_field;
}

void EventReportArgument::set_eventType(const eventType & eventType_val) {
    eventType_field = eventType_val;
}

EventReportArgument::eventInfo *EventReportArgument::get_eventInfo() {
    if (bit_mask & 0x80000000)
	return &eventInfo_field;
    else
	return 0;
}

const EventReportArgument::eventInfo *EventReportArgument::get_eventInfo() const {
    if (bit_mask & 0x80000000)
	return &eventInfo_field;
    else
	return 0;
}

void EventReportArgument::set_eventInfo(const eventInfo & eventInfo_val) {
    bit_mask |= 0x80000000;
    eventInfo_field = eventInfo_val;
}

int EventReportArgument::eventInfo_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void EventReportArgument::omit_eventInfo() {
    eventInfo_field.~AvaSet_Value();
    bit_mask &= ~0x80000000;
}

void *EventReportResult::operator new(size_t size) {
    return ossNewFunc(size);
}

void EventReportResult::operator delete(void *ptr) {
    asn1Free(ptr);
}

EventReportResult::EventReportResult() {
    memset(this, 0, sizeof(EventReportResult));
}

EventReportResult::EventReportResult(const EventReportResult & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	managedObjectClass_field = that.managedObjectClass_field;
	managedObjectInstance_field = that.managedObjectInstance_field;
	currentTime_field = that.currentTime_field;
	eventReply_field = that.eventReply_field;
    } OSSCLEAN(EventReportResult)
}

EventReportResult::EventReportResult(const managedObjectClass & managedObjectClass_val, 
    const managedObjectInstance & managedObjectInstance_val, const currentTime & currentTime_val, 
    const eventReply & eventReply_val) {
    OSSTRY {
	bit_mask = 0xe0000000;
	managedObjectClass_field = managedObjectClass_val;
	managedObjectInstance_field = managedObjectInstance_val;
	currentTime_field = currentTime_val;
	eventReply_field = eventReply_val;
    } OSSCLEAN(EventReportResult)
}

EventReportResult & EventReportResult::operator = (const EventReportResult & that) {
    if (this == &that)
	return *this;
    this->~EventReportResult();
    bit_mask = that.bit_mask;
    managedObjectClass_field = that.managedObjectClass_field;
    managedObjectInstance_field = that.managedObjectInstance_field;
    currentTime_field = that.currentTime_field;
    eventReply_field = that.eventReply_field;
    return *this;
}

int EventReportResult::operator == (const EventReportResult & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (managedObjectClass_field != that.managedObjectClass_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (managedObjectInstance_field != that.managedObjectInstance_field)
	    return 0;
    }
    if (currentTime_field != that.currentTime_field)
	return 0;
    if (bit_mask & 0x20000000) {
	if (eventReply_field != that.eventReply_field)
	    return 0;
    }
    return 1;
}

int EventReportResult::operator != (const EventReportResult & that) const {
    return !(operator ==(that));
}

EventReportResult::managedObjectClass *EventReportResult::get_managedObjectClass() {
    if (bit_mask & 0x80000000)
	return &managedObjectClass_field;
    else
	return 0;
}

const EventReportResult::managedObjectClass *EventReportResult::get_managedObjectClass() const {
    if (bit_mask & 0x80000000)
	return &managedObjectClass_field;
    else
	return 0;
}

void EventReportResult::set_managedObjectClass(const managedObjectClass & managedObjectClass_val) {
    bit_mask |= 0x80000000;
    managedObjectClass_field = managedObjectClass_val;
}

int EventReportResult::managedObjectClass_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void EventReportResult::omit_managedObjectClass() {
    managedObjectClass_field.~__shared3();
    bit_mask &= ~0x80000000;
}

EventReportResult::managedObjectInstance *EventReportResult::get_managedObjectInstance() {
    if (bit_mask & 0x40000000)
	return &managedObjectInstance_field;
    else
	return 0;
}

const EventReportResult::managedObjectInstance *EventReportResult::get_managedObjectInstance() const {
    if (bit_mask & 0x40000000)
	return &managedObjectInstance_field;
    else
	return 0;
}

void EventReportResult::set_managedObjectInstance(const managedObjectInstance & managedObjectInstance_val) {
    bit_mask |= 0x40000000;
    managedObjectInstance_field = managedObjectInstance_val;
}

int EventReportResult::managedObjectInstance_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void EventReportResult::omit_managedObjectInstance() {
    managedObjectInstance_field.~ObjectInstance();
    bit_mask &= ~0x40000000;
}

EventReportResult::currentTime *EventReportResult::get_currentTime() {
    if (*(char **)&currentTime_field)
	return &currentTime_field;
    else
	return 0;
}

const EventReportResult::currentTime *EventReportResult::get_currentTime() const {
    if (*(char **)&currentTime_field)
	return &currentTime_field;
    else
	return 0;
}

void EventReportResult::set_currentTime(const currentTime & currentTime_val) {
    currentTime_field = currentTime_val;
}

int EventReportResult::currentTime_is_present() const {
    return !!(*(char **)&currentTime_field);
}

void EventReportResult::omit_currentTime() {
    currentTime_field.~OssGeneralizedTime();
}

EventReportResult::eventReply *EventReportResult::get_eventReply() {
    if (bit_mask & 0x20000000)
	return &eventReply_field;
    else
	return 0;
}

const EventReportResult::eventReply *EventReportResult::get_eventReply() const {
    if (bit_mask & 0x20000000)
	return &eventReply_field;
    else
	return 0;
}

void EventReportResult::set_eventReply(const eventReply & eventReply_val) {
    bit_mask |= 0x20000000;
    eventReply_field = eventReply_val;
}

int EventReportResult::eventReply_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void EventReportResult::omit_eventReply() {
    eventReply_field.~EventReply();
    bit_mask &= ~0x20000000;
}

__choice4::__choice4() {
    memset(this, 0, sizeof(__choice4));
}

__choice4::__choice4(const __choice4 & that) {
    memset(this, 0, sizeof(__choice4));
    operator =(that);
}

__choice4::~__choice4() {
    cleanup();
}

__choice4 & __choice4::operator = (const __choice4 & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case initialString_chosen:
	    if (that.initialString_field)
		initialString_field = new initialString(*that.initialString_field);
	    break;
	case anyString_chosen:
	    if (that.anyString_field)
		anyString_field = new anyString(*that.anyString_field);
	    break;
	case finalString_chosen:
	    if (that.finalString_field)
		finalString_field = new finalString(*that.finalString_field);
	    break;
    }
    return *this;
}

int __choice4::operator == (const __choice4 & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case initialString_chosen:
	    if ((initialString_field) && (that.initialString_field))
		return (*initialString_field == *(that.initialString_field));
	    else if (!((!initialString_field) && (!that.initialString_field)))
		return 0;
	    break;
	case anyString_chosen:
	    if ((anyString_field) && (that.anyString_field))
		return (*anyString_field == *(that.anyString_field));
	    else if (!((!anyString_field) && (!that.anyString_field)))
		return 0;
	    break;
	case finalString_chosen:
	    if ((finalString_field) && (that.finalString_field))
		return (*finalString_field == *(that.finalString_field));
	    else if (!((!finalString_field) && (!that.finalString_field)))
		return 0;
	    break;
    }

    return 1;
}

int __choice4::operator != (const __choice4 & that) const {
    return !(operator ==(that));
}

__choice4::initialString *__choice4::get_initialString() {
    if (_choice == initialString_chosen)
	return (initialString *)initialString_field;
    else
	return 0;
}

const __choice4::initialString *__choice4::get_initialString() const {
    if (_choice == initialString_chosen)
	return (const initialString *)initialString_field;
    else
	return 0;
}

void __choice4::set_initialString(const initialString & initialString_val) {
    cleanup();
    initialString_field = new initialString(initialString_val);
    _choice = initialString_chosen;
}

__choice4::anyString *__choice4::get_anyString() {
    if (_choice == anyString_chosen)
	return (anyString *)anyString_field;
    else
	return 0;
}

const __choice4::anyString *__choice4::get_anyString() const {
    if (_choice == anyString_chosen)
	return (const anyString *)anyString_field;
    else
	return 0;
}

void __choice4::set_anyString(const anyString & anyString_val) {
    cleanup();
    anyString_field = new anyString(anyString_val);
    _choice = anyString_chosen;
}

__choice4::finalString *__choice4::get_finalString() {
    if (_choice == finalString_chosen)
	return (finalString *)finalString_field;
    else
	return 0;
}

const __choice4::finalString *__choice4::get_finalString() const {
    if (_choice == finalString_chosen)
	return (const finalString *)finalString_field;
    else
	return 0;
}

void __choice4::set_finalString(const finalString & finalString_val) {
    cleanup();
    finalString_field = new finalString(finalString_val);
    _choice = finalString_chosen;
}

void __choice4::cleanup() {
    switch (_choice) {
	case initialString_chosen:
	    if (initialString_field)
		delete initialString_field;
	    break;
	case anyString_chosen:
	    if (anyString_field)
		delete anyString_field;
	    break;
	case finalString_chosen:
	    if (finalString_field)
		delete finalString_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

void *GetArgument::operator new(size_t size) {
    return ossNewFunc(size);
}

void GetArgument::operator delete(void *ptr) {
    asn1Free(ptr);
}

enum CMISSync GetArgument::get_default_synchronization() {
    return GetArgument::default_synchronization;
}

const Scope& GetArgument::get_default_scope() {
    return GetArgument::default_scope;
}

const CMISFilter& GetArgument::get_default_filter() {
    return GetArgument::default_filter;
}

GetArgument::GetArgument() {
    memset(this, 0, sizeof(GetArgument));
}

GetArgument::GetArgument(const GetArgument & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	baseManagedObjectClass_field = that.baseManagedObjectClass_field;
	baseManagedObjectInstance_field = that.baseManagedObjectInstance_field;
	accessControl_field = that.accessControl_field;
	synchronization_field = that.synchronization_field;
	if (bit_mask & 0x20000000)
	    scope_field = that.scope_field;
	if (bit_mask & 0x10000000)
	    filter_field = that.filter_field;
	attributeIdList_field = that.attributeIdList_field;
    } OSSCLEAN(GetArgument)
}

GetArgument::GetArgument(const baseManagedObjectClass & baseManagedObjectClass_val, 
    const baseManagedObjectInstance & baseManagedObjectInstance_val, const accessControl & accessControl_val, 
    synchronization synchronization_val, const scope & scope_val, const filter & filter_val, 
    const attributeIdList & attributeIdList_val) {
    OSSTRY {
	bit_mask = 0xf8000000;
	baseManagedObjectClass_field = baseManagedObjectClass_val;
	baseManagedObjectInstance_field = baseManagedObjectInstance_val;
	accessControl_field = accessControl_val;
	synchronization_field = synchronization_val;
	scope_field = scope_val;
	filter_field = filter_val;
	attributeIdList_field = attributeIdList_val;
    } OSSCLEAN(GetArgument)
}

GetArgument::GetArgument(const baseManagedObjectClass & baseManagedObjectClass_val, 
    const baseManagedObjectInstance & baseManagedObjectInstance_val) {
    OSSTRY {
	bit_mask = 0;
	baseManagedObjectClass_field = baseManagedObjectClass_val;
	baseManagedObjectInstance_field = baseManagedObjectInstance_val;
    } OSSCLEAN(GetArgument)
}

GetArgument::~GetArgument() {
    if (!(bit_mask & 0x20000000))
	memset(&scope_field, 0, sizeof(scope));
    if (!(bit_mask & 0x10000000))
	memset(&filter_field, 0, sizeof(filter));
}

GetArgument & GetArgument::operator = (const GetArgument & that) {
    if (this == &that)
	return *this;
    this->~GetArgument();
    bit_mask = that.bit_mask;
    baseManagedObjectClass_field = that.baseManagedObjectClass_field;
    baseManagedObjectInstance_field = that.baseManagedObjectInstance_field;
    accessControl_field = that.accessControl_field;
    synchronization_field = that.synchronization_field;
    if (bit_mask & 0x20000000)
	scope_field = that.scope_field;
    if (bit_mask & 0x10000000)
	filter_field = that.filter_field;
    attributeIdList_field = that.attributeIdList_field;
    return *this;
}

int GetArgument::operator == (const GetArgument & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (baseManagedObjectClass_field != that.baseManagedObjectClass_field)
	return 0;
    if (baseManagedObjectInstance_field != that.baseManagedObjectInstance_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (accessControl_field != that.accessControl_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (synchronization_field != that.synchronization_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (scope_field != that.scope_field)
	    return 0;
    }
    if (bit_mask & 0x10000000) {
	if (filter_field != that.filter_field)
	    return 0;
    }
    if (bit_mask & 0x8000000) {
	if (attributeIdList_field != that.attributeIdList_field)
	    return 0;
    }
    return 1;
}

int GetArgument::operator != (const GetArgument & that) const {
    return !(operator ==(that));
}

GetArgument::baseManagedObjectClass & GetArgument::get_baseManagedObjectClass() {
    return baseManagedObjectClass_field;
}

const GetArgument::baseManagedObjectClass & GetArgument::get_baseManagedObjectClass() const {
    return baseManagedObjectClass_field;
}

void GetArgument::set_baseManagedObjectClass(const baseManagedObjectClass & baseManagedObjectClass_val) {
    baseManagedObjectClass_field = baseManagedObjectClass_val;
}

GetArgument::baseManagedObjectInstance & GetArgument::get_baseManagedObjectInstance() {
    return baseManagedObjectInstance_field;
}

const GetArgument::baseManagedObjectInstance & GetArgument::get_baseManagedObjectInstance() const {
    return baseManagedObjectInstance_field;
}

void GetArgument::set_baseManagedObjectInstance(const baseManagedObjectInstance & baseManagedObjectInstance_val) {
    baseManagedObjectInstance_field = baseManagedObjectInstance_val;
}

GetArgument::accessControl *GetArgument::get_accessControl() {
    if (bit_mask & 0x80000000)
	return &accessControl_field;
    else
	return 0;
}

const GetArgument::accessControl *GetArgument::get_accessControl() const {
    if (bit_mask & 0x80000000)
	return &accessControl_field;
    else
	return 0;
}

void GetArgument::set_accessControl(const accessControl & accessControl_val) {
    bit_mask |= 0x80000000;
    accessControl_field = accessControl_val;
}

int GetArgument::accessControl_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void GetArgument::omit_accessControl() {
    accessControl_field.~__shared2();
    bit_mask &= ~0x80000000;
}

GetArgument::synchronization *GetArgument::get_synchronization() {
    if (bit_mask & 0x40000000)
	return &synchronization_field;
    else
	return 0;
}

const GetArgument::synchronization *GetArgument::get_synchronization() const {
    if (bit_mask & 0x40000000)
	return &synchronization_field;
    else
	return 0;
}

void GetArgument::set_synchronization(synchronization synchronization_val) {
    bit_mask |= 0x40000000;
    synchronization_field = synchronization_val;
}

int GetArgument::synchronization_is_default() const {
    return !(bit_mask & 0x40000000);
}

void GetArgument::set_default_synchronization() {
    bit_mask &= ~0x40000000;
}

GetArgument::scope *GetArgument::get_scope() {
    if (bit_mask & 0x20000000)
	return &scope_field;
    else
	return 0;
}

const GetArgument::scope *GetArgument::get_scope() const {
    if (bit_mask & 0x20000000)
	return &scope_field;
    else
	return 0;
}

void GetArgument::set_scope(const scope & scope_val) {
    if (!(bit_mask & 0x20000000)) {
	memset(&scope_field, 0, sizeof(scope));
	bit_mask |= 0x20000000;
    }
    scope_field = scope_val;
}

int GetArgument::scope_is_default() const {
    return !(bit_mask & 0x20000000);
}

void GetArgument::set_default_scope() {
    if (bit_mask & 0x20000000) {
	scope_field.~Scope();
	bit_mask &= ~0x20000000;
    }
}

GetArgument::filter *GetArgument::get_filter() {
    if (bit_mask & 0x10000000)
	return &filter_field;
    else
	return 0;
}

const GetArgument::filter *GetArgument::get_filter() const {
    if (bit_mask & 0x10000000)
	return &filter_field;
    else
	return 0;
}

void GetArgument::set_filter(const filter & filter_val) {
    if (!(bit_mask & 0x10000000)) {
	memset(&filter_field, 0, sizeof(filter));
	bit_mask |= 0x10000000;
    }
    filter_field = filter_val;
}

int GetArgument::filter_is_default() const {
    return !(bit_mask & 0x10000000);
}

void GetArgument::set_default_filter() {
    if (bit_mask & 0x10000000) {
	filter_field.~CMISFilter();
	bit_mask &= ~0x10000000;
    }
}

GetArgument::attributeIdList *GetArgument::get_attributeIdList() {
    if (bit_mask & 0x8000000)
	return &attributeIdList_field;
    else
	return 0;
}

const GetArgument::attributeIdList *GetArgument::get_attributeIdList() const {
    if (bit_mask & 0x8000000)
	return &attributeIdList_field;
    else
	return 0;
}

void GetArgument::set_attributeIdList(const attributeIdList & attributeIdList_val) {
    bit_mask |= 0x8000000;
    attributeIdList_field = attributeIdList_val;
}

int GetArgument::attributeIdList_is_present() const {
    return !!(bit_mask & 0x8000000);
}

void GetArgument::omit_attributeIdList() {
    attributeIdList_field.~__shared9();
    bit_mask &= ~0x8000000;
}

GetInfoStatus::GetInfoStatus() {
    memset(this, 0, sizeof(GetInfoStatus));
}

GetInfoStatus::GetInfoStatus(const GetInfoStatus & that) {
    memset(this, 0, sizeof(GetInfoStatus));
    operator =(that);
}

GetInfoStatus::~GetInfoStatus() {
    cleanup();
}

GetInfoStatus & GetInfoStatus::operator = (const GetInfoStatus & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case attributeIdError_chosen:
	    if (that.attributeIdError_field)
		attributeIdError_field = new attributeIdError(*that.attributeIdError_field);
	    break;
	case attribute_chosen:
	    if (that.attribute_field)
		attribute_field = new attribute(*that.attribute_field);
	    break;
    }
    return *this;
}

int GetInfoStatus::operator == (const GetInfoStatus & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case attributeIdError_chosen:
	    if ((attributeIdError_field) && (that.attributeIdError_field))
		return (*attributeIdError_field == *(that.attributeIdError_field));
	    else if (!((!attributeIdError_field) && (!that.attributeIdError_field)))
		return 0;
	    break;
	case attribute_chosen:
	    if ((attribute_field) && (that.attribute_field))
		return (*attribute_field == *(that.attribute_field));
	    else if (!((!attribute_field) && (!that.attribute_field)))
		return 0;
	    break;
    }

    return 1;
}

int GetInfoStatus::operator != (const GetInfoStatus & that) const {
    return !(operator ==(that));
}

GetInfoStatus::attributeIdError *GetInfoStatus::get_attributeIdError() {
    if (_choice == attributeIdError_chosen)
	return (attributeIdError *)attributeIdError_field;
    else
	return 0;
}

const GetInfoStatus::attributeIdError *GetInfoStatus::get_attributeIdError() const {
    if (_choice == attributeIdError_chosen)
	return (const attributeIdError *)attributeIdError_field;
    else
	return 0;
}

void GetInfoStatus::set_attributeIdError(const attributeIdError & attributeIdError_val) {
    cleanup();
    attributeIdError_field = new attributeIdError(attributeIdError_val);
    _choice = attributeIdError_chosen;
}

GetInfoStatus::attribute *GetInfoStatus::get_attribute() {
    if (_choice == attribute_chosen)
	return (attribute *)attribute_field;
    else
	return 0;
}

const GetInfoStatus::attribute *GetInfoStatus::get_attribute() const {
    if (_choice == attribute_chosen)
	return (const attribute *)attribute_field;
    else
	return 0;
}

void GetInfoStatus::set_attribute(const attribute & attribute_val) {
    cleanup();
    attribute_field = new attribute(attribute_val);
    _choice = attribute_chosen;
}

void GetInfoStatus::cleanup() {
    switch (_choice) {
	case attributeIdError_chosen:
	    if (attributeIdError_field)
		delete attributeIdError_field;
	    break;
	case attribute_chosen:
	    if (attribute_field)
		delete attribute_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

/* Auxiliary data structures and functions for class __setof6 */

class __setof6_member {
public:
    __setof6_member *next;
    __setof6::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __setof6_member();
    __setof6_member(const __setof6::component & val);
};

void *__setof6_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __setof6_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__setof6_member::__setof6_member() {
}

__setof6_member::__setof6_member(const __setof6::component & val) {
    value = val;
}

static void *__setof6_copy(void *that) {
    return new __setof6_member(((__setof6_member *)that)->value);
}

static void __setof6_destroy(void *that) {
    delete (__setof6_member *)that;
}

static int __setof6_compare(void *val1, void *val2) {
    return (((__setof6_member *)val1)->value == ((__setof6_member *)val2)->value);
}

/* Constructors */

__setof6::__setof6() {
}

__setof6::__setof6(const __setof6 & that) {
    OSSTRY {
	do_copy(that, &__setof6_copy);
    } OSSCLEAN(__setof6)
}

/* Destructor */

__setof6::~__setof6() {
    do_destroy(&__setof6_destroy);
}

/* Operators: assignment, equality, inequality */

__setof6 & __setof6::operator = (const __setof6 & that) {
    do_destroy(&__setof6_destroy);
    do_copy(that, &__setof6_copy);
    return *this;
}

int __setof6::operator == (const __setof6 & that) const {
    return do_compare(that, &__setof6_compare);
}

int __setof6::operator != (const __setof6 & that) const {
    return !do_compare(that, &__setof6_compare);
}

/* Locate ("At" etc) methods */

__setof6::component *__setof6::at(OssIndex pos) {
    return &((__setof6_member *)pos)->value;
}

const __setof6::component *__setof6::at(OssIndex pos) const {
    return &((__setof6_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __setof6::prepend(const component & val) {
    __setof6_member *newrec = new __setof6_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __setof6::prepend(__setof6 *seq) {
    return do_prepend(seq);
}

OssIndex __setof6::insert_after(OssIndex pos, const component & val) {
    __setof6_member *newrec = new __setof6_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __setof6::insert_after(OssIndex pos, __setof6 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __setof6::remove_front() {
    __setof6_member *extr = (__setof6_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __setof6_destroy(extr);
    return 0;
}

int __setof6::remove_after(OssIndex pos) {
    __setof6_member *extr = (__setof6_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __setof6_destroy(extr);
    return 0;
}

/* Extract methods */

__setof6 *__setof6::extract_after(OssIndex begin, OssIndex end) {
    return (__setof6 *)do_extract_after(begin, end);
}

void *GetListError::operator new(size_t size) {
    return ossNewFunc(size);
}

void GetListError::operator delete(void *ptr) {
    asn1Free(ptr);
}

GetListError::GetListError() {
    memset(this, 0, sizeof(GetListError));
}

GetListError::GetListError(const GetListError & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	managedObjectClass_field = that.managedObjectClass_field;
	managedObjectInstance_field = that.managedObjectInstance_field;
	currentTime_field = that.currentTime_field;
	getInfoList_field = that.getInfoList_field;
    } OSSCLEAN(GetListError)
}

GetListError::GetListError(const managedObjectClass & managedObjectClass_val, const managedObjectInstance & managedObjectInstance_val, 
    const currentTime & currentTime_val, const getInfoList & getInfoList_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	managedObjectClass_field = managedObjectClass_val;
	managedObjectInstance_field = managedObjectInstance_val;
	currentTime_field = currentTime_val;
	getInfoList_field = getInfoList_val;
    } OSSCLEAN(GetListError)
}

GetListError::GetListError(const getInfoList & getInfoList_val) {
    OSSTRY {
	bit_mask = 0;
	getInfoList_field = getInfoList_val;
    } OSSCLEAN(GetListError)
}

GetListError & GetListError::operator = (const GetListError & that) {
    if (this == &that)
	return *this;
    this->~GetListError();
    bit_mask = that.bit_mask;
    managedObjectClass_field = that.managedObjectClass_field;
    managedObjectInstance_field = that.managedObjectInstance_field;
    currentTime_field = that.currentTime_field;
    getInfoList_field = that.getInfoList_field;
    return *this;
}

int GetListError::operator == (const GetListError & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (managedObjectClass_field != that.managedObjectClass_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (managedObjectInstance_field != that.managedObjectInstance_field)
	    return 0;
    }
    if (currentTime_field != that.currentTime_field)
	return 0;
    if (getInfoList_field != that.getInfoList_field)
	return 0;
    return 1;
}

int GetListError::operator != (const GetListError & that) const {
    return !(operator ==(that));
}

GetListError::managedObjectClass *GetListError::get_managedObjectClass() {
    if (bit_mask & 0x80000000)
	return &managedObjectClass_field;
    else
	return 0;
}

const GetListError::managedObjectClass *GetListError::get_managedObjectClass() const {
    if (bit_mask & 0x80000000)
	return &managedObjectClass_field;
    else
	return 0;
}

void GetListError::set_managedObjectClass(const managedObjectClass & managedObjectClass_val) {
    bit_mask |= 0x80000000;
    managedObjectClass_field = managedObjectClass_val;
}

int GetListError::managedObjectClass_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void GetListError::omit_managedObjectClass() {
    managedObjectClass_field.~__shared3();
    bit_mask &= ~0x80000000;
}

GetListError::managedObjectInstance *GetListError::get_managedObjectInstance() {
    if (bit_mask & 0x40000000)
	return &managedObjectInstance_field;
    else
	return 0;
}

const GetListError::managedObjectInstance *GetListError::get_managedObjectInstance() const {
    if (bit_mask & 0x40000000)
	return &managedObjectInstance_field;
    else
	return 0;
}

void GetListError::set_managedObjectInstance(const managedObjectInstance & managedObjectInstance_val) {
    bit_mask |= 0x40000000;
    managedObjectInstance_field = managedObjectInstance_val;
}

int GetListError::managedObjectInstance_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void GetListError::omit_managedObjectInstance() {
    managedObjectInstance_field.~ObjectInstance();
    bit_mask &= ~0x40000000;
}

GetListError::currentTime *GetListError::get_currentTime() {
    if (*(char **)&currentTime_field)
	return &currentTime_field;
    else
	return 0;
}

const GetListError::currentTime *GetListError::get_currentTime() const {
    if (*(char **)&currentTime_field)
	return &currentTime_field;
    else
	return 0;
}

void GetListError::set_currentTime(const currentTime & currentTime_val) {
    currentTime_field = currentTime_val;
}

int GetListError::currentTime_is_present() const {
    return !!(*(char **)&currentTime_field);
}

void GetListError::omit_currentTime() {
    currentTime_field.~OssGeneralizedTime();
}

GetListError::getInfoList & GetListError::get_getInfoList() {
    return getInfoList_field;
}

const GetListError::getInfoList & GetListError::get_getInfoList() const {
    return getInfoList_field;
}

void GetListError::set_getInfoList(const getInfoList & getInfoList_val) {
    getInfoList_field = getInfoList_val;
}

__shared12::__shared12() {
    memset(this, 0, sizeof(__shared12));
}

__shared12::__shared12(const __shared12 & that) {
    memset(this, 0, sizeof(__shared12));
    operator =(that);
}

__shared12 & __shared12::operator = (const __shared12 & that) {
    if (this == &that)
	return *this;
    _choice = that._choice;
    switch (_choice) {
	case present_chosen:
	    *(present *)&present_field = *(present *)&that.present_field;
	    break;
	case absent_chosen:
	    *(absent *)&absent_field = *(absent *)&that.absent_field;
	    break;
    }
    return *this;
}

int __shared12::operator == (const __shared12 & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case present_chosen:
	    return *(present *)&present_field == *(present *)&that.present_field;
	case absent_chosen:
	    return *(absent *)&absent_field == *(absent *)&that.absent_field;
    }

    return 1;
}

int __shared12::operator != (const __shared12 & that) const {
    return !(operator ==(that));
}

__shared12::present *__shared12::get_present() {
    if (_choice == present_chosen)
	return (present *)&present_field;
    else
	return 0;
}

const __shared12::present *__shared12::get_present() const {
    if (_choice == present_chosen)
	return (const present *)&present_field;
    else
	return 0;
}

void __shared12::set_present(present present_val) {
    *(present *)&present_field = present_val;
    _choice = present_chosen;
}

__shared12::absent *__shared12::get_absent() {
    if (_choice == absent_chosen)
	return (absent *)&absent_field;
    else
	return 0;
}

const __shared12::absent *__shared12::get_absent() const {
    if (_choice == absent_chosen)
	return (const absent *)&absent_field;
    else
	return 0;
}

void __shared12::set_absent(absent absent_val) {
    *(absent *)&absent_field = absent_val;
    _choice = absent_chosen;
}

/* Auxiliary data structures and functions for class __setof9 */

class __setof9_member {
public:
    __setof9_member *next;
    __setof9::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __setof9_member();
    __setof9_member(const __setof9::component & val);
};

void *__setof9_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __setof9_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__setof9_member::__setof9_member() {
}

__setof9_member::__setof9_member(const __setof9::component & val) {
    value = val;
}

static void *__setof9_copy(void *that) {
    return new __setof9_member(((__setof9_member *)that)->value);
}

static void __setof9_destroy(void *that) {
    delete (__setof9_member *)that;
}

static int __setof9_compare(void *val1, void *val2) {
    return (((__setof9_member *)val1)->value == ((__setof9_member *)val2)->value);
}

/* Constructors */

__setof9::__setof9() {
}

__setof9::__setof9(const __setof9 & that) {
    OSSTRY {
	do_copy(that, &__setof9_copy);
    } OSSCLEAN(__setof9)
}

/* Destructor */

__setof9::~__setof9() {
    do_destroy(&__setof9_destroy);
}

/* Operators: assignment, equality, inequality */

__setof9 & __setof9::operator = (const __setof9 & that) {
    do_destroy(&__setof9_destroy);
    do_copy(that, &__setof9_copy);
    return *this;
}

int __setof9::operator == (const __setof9 & that) const {
    return do_compare(that, &__setof9_compare);
}

int __setof9::operator != (const __setof9 & that) const {
    return !do_compare(that, &__setof9_compare);
}

/* Locate ("At" etc) methods */

__setof9::component *__setof9::at(OssIndex pos) {
    return &((__setof9_member *)pos)->value;
}

const __setof9::component *__setof9::at(OssIndex pos) const {
    return &((__setof9_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __setof9::prepend(const component & val) {
    __setof9_member *newrec = new __setof9_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __setof9::prepend(__setof9 *seq) {
    return do_prepend(seq);
}

OssIndex __setof9::insert_after(OssIndex pos, const component & val) {
    __setof9_member *newrec = new __setof9_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __setof9::insert_after(OssIndex pos, __setof9 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __setof9::remove_front() {
    __setof9_member *extr = (__setof9_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __setof9_destroy(extr);
    return 0;
}

int __setof9::remove_after(OssIndex pos) {
    __setof9_member *extr = (__setof9_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __setof9_destroy(extr);
    return 0;
}

/* Extract methods */

__setof9 *__setof9::extract_after(OssIndex begin, OssIndex end) {
    return (__setof9 *)do_extract_after(begin, end);
}

void *SetListError::operator new(size_t size) {
    return ossNewFunc(size);
}

void SetListError::operator delete(void *ptr) {
    asn1Free(ptr);
}

SetListError::SetListError() {
    memset(this, 0, sizeof(SetListError));
}

SetListError::SetListError(const SetListError & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	managedObjectClass_field = that.managedObjectClass_field;
	managedObjectInstance_field = that.managedObjectInstance_field;
	currentTime_field = that.currentTime_field;
	setInfoList_field = that.setInfoList_field;
    } OSSCLEAN(SetListError)
}

SetListError::SetListError(const managedObjectClass & managedObjectClass_val, const managedObjectInstance & managedObjectInstance_val, 
    const currentTime & currentTime_val, const setInfoList & setInfoList_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	managedObjectClass_field = managedObjectClass_val;
	managedObjectInstance_field = managedObjectInstance_val;
	currentTime_field = currentTime_val;
	setInfoList_field = setInfoList_val;
    } OSSCLEAN(SetListError)
}

SetListError::SetListError(const setInfoList & setInfoList_val) {
    OSSTRY {
	bit_mask = 0;
	setInfoList_field = setInfoList_val;
    } OSSCLEAN(SetListError)
}

SetListError & SetListError::operator = (const SetListError & that) {
    if (this == &that)
	return *this;
    this->~SetListError();
    bit_mask = that.bit_mask;
    managedObjectClass_field = that.managedObjectClass_field;
    managedObjectInstance_field = that.managedObjectInstance_field;
    currentTime_field = that.currentTime_field;
    setInfoList_field = that.setInfoList_field;
    return *this;
}

int SetListError::operator == (const SetListError & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (managedObjectClass_field != that.managedObjectClass_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (managedObjectInstance_field != that.managedObjectInstance_field)
	    return 0;
    }
    if (currentTime_field != that.currentTime_field)
	return 0;
    if (setInfoList_field != that.setInfoList_field)
	return 0;
    return 1;
}

int SetListError::operator != (const SetListError & that) const {
    return !(operator ==(that));
}

SetListError::managedObjectClass *SetListError::get_managedObjectClass() {
    if (bit_mask & 0x80000000)
	return &managedObjectClass_field;
    else
	return 0;
}

const SetListError::managedObjectClass *SetListError::get_managedObjectClass() const {
    if (bit_mask & 0x80000000)
	return &managedObjectClass_field;
    else
	return 0;
}

void SetListError::set_managedObjectClass(const managedObjectClass & managedObjectClass_val) {
    bit_mask |= 0x80000000;
    managedObjectClass_field = managedObjectClass_val;
}

int SetListError::managedObjectClass_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void SetListError::omit_managedObjectClass() {
    managedObjectClass_field.~__shared3();
    bit_mask &= ~0x80000000;
}

SetListError::managedObjectInstance *SetListError::get_managedObjectInstance() {
    if (bit_mask & 0x40000000)
	return &managedObjectInstance_field;
    else
	return 0;
}

const SetListError::managedObjectInstance *SetListError::get_managedObjectInstance() const {
    if (bit_mask & 0x40000000)
	return &managedObjectInstance_field;
    else
	return 0;
}

void SetListError::set_managedObjectInstance(const managedObjectInstance & managedObjectInstance_val) {
    bit_mask |= 0x40000000;
    managedObjectInstance_field = managedObjectInstance_val;
}

int SetListError::managedObjectInstance_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void SetListError::omit_managedObjectInstance() {
    managedObjectInstance_field.~ObjectInstance();
    bit_mask &= ~0x40000000;
}

SetListError::currentTime *SetListError::get_currentTime() {
    if (*(char **)&currentTime_field)
	return &currentTime_field;
    else
	return 0;
}

const SetListError::currentTime *SetListError::get_currentTime() const {
    if (*(char **)&currentTime_field)
	return &currentTime_field;
    else
	return 0;
}

void SetListError::set_currentTime(const currentTime & currentTime_val) {
    currentTime_field = currentTime_val;
}

int SetListError::currentTime_is_present() const {
    return !!(*(char **)&currentTime_field);
}

void SetListError::omit_currentTime() {
    currentTime_field.~OssGeneralizedTime();
}

SetListError::setInfoList & SetListError::get_setInfoList() {
    return setInfoList_field;
}

const SetListError::setInfoList & SetListError::get_setInfoList() const {
    return setInfoList_field;
}

void SetListError::set_setInfoList(const setInfoList & setInfoList_val) {
    setInfoList_field = setInfoList_val;
}

void *SpecificErrorInfo::operator new(size_t size) {
    return ossNewFunc(size);
}

void SpecificErrorInfo::operator delete(void *ptr) {
    asn1Free(ptr);
}

SpecificErrorInfo::SpecificErrorInfo() {
    memset(this, 0, sizeof(SpecificErrorInfo));
}

SpecificErrorInfo::SpecificErrorInfo(const SpecificErrorInfo & that) {
    OSSTRY {
	errorId_field = that.errorId_field;
	errorInfo_field = that.errorInfo_field;
    } OSSCLEAN(SpecificErrorInfo)
}

SpecificErrorInfo::SpecificErrorInfo(const errorId & errorId_val, const errorInfo & errorInfo_val) {
    OSSTRY {
	errorId_field = errorId_val;
	errorInfo_field = errorInfo_val;
    } OSSCLEAN(SpecificErrorInfo)
}

SpecificErrorInfo & SpecificErrorInfo::operator = (const SpecificErrorInfo & that) {
    if (this == &that)
	return *this;
    errorId_field = that.errorId_field;
    errorInfo_field = that.errorInfo_field;
    return *this;
}

int SpecificErrorInfo::operator == (const SpecificErrorInfo & that) const {
    if (errorId_field != that.errorId_field)
	return 0;
    if (errorInfo_field != that.errorInfo_field)
	return 0;
    return 1;
}

int SpecificErrorInfo::operator != (const SpecificErrorInfo & that) const {
    return !(operator ==(that));
}

SpecificErrorInfo::errorId & SpecificErrorInfo::get_errorId() {
    return errorId_field;
}

const SpecificErrorInfo::errorId & SpecificErrorInfo::get_errorId() const {
    return errorId_field;
}

void SpecificErrorInfo::set_errorId(const errorId & errorId_val) {
    errorId_field = errorId_val;
}

SpecificErrorInfo::errorInfo & SpecificErrorInfo::get_errorInfo() {
    return errorInfo_field;
}

const SpecificErrorInfo::errorInfo & SpecificErrorInfo::get_errorInfo() const {
    return errorInfo_field;
}

void SpecificErrorInfo::set_errorInfo(const errorInfo & errorInfo_val) {
    errorInfo_field = errorInfo_val;
}

void *ProcessingFailure::operator new(size_t size) {
    return ossNewFunc(size);
}

void ProcessingFailure::operator delete(void *ptr) {
    asn1Free(ptr);
}

ProcessingFailure::ProcessingFailure() {
    memset(this, 0, sizeof(ProcessingFailure));
}

ProcessingFailure::ProcessingFailure(const ProcessingFailure & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	managedObjectClass_field = that.managedObjectClass_field;
	managedObjectInstance_field = that.managedObjectInstance_field;
	specificErrorInfo_field = that.specificErrorInfo_field;
    } OSSCLEAN(ProcessingFailure)
}

ProcessingFailure::ProcessingFailure(const managedObjectClass & managedObjectClass_val, 
    const managedObjectInstance & managedObjectInstance_val, const specificErrorInfo & specificErrorInfo_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	managedObjectClass_field = managedObjectClass_val;
	managedObjectInstance_field = managedObjectInstance_val;
	specificErrorInfo_field = specificErrorInfo_val;
    } OSSCLEAN(ProcessingFailure)
}

ProcessingFailure::ProcessingFailure(const managedObjectClass & managedObjectClass_val, 
    const specificErrorInfo & specificErrorInfo_val) {
    OSSTRY {
	bit_mask = 0;
	managedObjectClass_field = managedObjectClass_val;
	specificErrorInfo_field = specificErrorInfo_val;
    } OSSCLEAN(ProcessingFailure)
}

ProcessingFailure & ProcessingFailure::operator = (const ProcessingFailure & that) {
    if (this == &that)
	return *this;
    this->~ProcessingFailure();
    bit_mask = that.bit_mask;
    managedObjectClass_field = that.managedObjectClass_field;
    managedObjectInstance_field = that.managedObjectInstance_field;
    specificErrorInfo_field = that.specificErrorInfo_field;
    return *this;
}

int ProcessingFailure::operator == (const ProcessingFailure & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (managedObjectClass_field != that.managedObjectClass_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (managedObjectInstance_field != that.managedObjectInstance_field)
	    return 0;
    }
    if (specificErrorInfo_field != that.specificErrorInfo_field)
	return 0;
    return 1;
}

int ProcessingFailure::operator != (const ProcessingFailure & that) const {
    return !(operator ==(that));
}

ProcessingFailure::managedObjectClass & ProcessingFailure::get_managedObjectClass() {
    return managedObjectClass_field;
}

const ProcessingFailure::managedObjectClass & ProcessingFailure::get_managedObjectClass() const {
    return managedObjectClass_field;
}

void ProcessingFailure::set_managedObjectClass(const managedObjectClass & managedObjectClass_val) {
    managedObjectClass_field = managedObjectClass_val;
}

ProcessingFailure::managedObjectInstance *ProcessingFailure::get_managedObjectInstance() {
    if (bit_mask & 0x80000000)
	return &managedObjectInstance_field;
    else
	return 0;
}

const ProcessingFailure::managedObjectInstance *ProcessingFailure::get_managedObjectInstance() const {
    if (bit_mask & 0x80000000)
	return &managedObjectInstance_field;
    else
	return 0;
}

void ProcessingFailure::set_managedObjectInstance(const managedObjectInstance & managedObjectInstance_val) {
    bit_mask |= 0x80000000;
    managedObjectInstance_field = managedObjectInstance_val;
}

int ProcessingFailure::managedObjectInstance_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void ProcessingFailure::omit_managedObjectInstance() {
    managedObjectInstance_field.~ObjectInstance();
    bit_mask &= ~0x80000000;
}

ProcessingFailure::specificErrorInfo & ProcessingFailure::get_specificErrorInfo() {
    return specificErrorInfo_field;
}

const ProcessingFailure::specificErrorInfo & ProcessingFailure::get_specificErrorInfo() const {
    return specificErrorInfo_field;
}

void ProcessingFailure::set_specificErrorInfo(const specificErrorInfo & specificErrorInfo_val) {
    specificErrorInfo_field = specificErrorInfo_val;
}

LinkedReplyArgument::LinkedReplyArgument() {
    memset(this, 0, sizeof(LinkedReplyArgument));
}

LinkedReplyArgument::LinkedReplyArgument(const LinkedReplyArgument & that) {
    memset(this, 0, sizeof(LinkedReplyArgument));
    operator =(that);
}

LinkedReplyArgument::~LinkedReplyArgument() {
    cleanup();
}

LinkedReplyArgument & LinkedReplyArgument::operator = (const LinkedReplyArgument & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case getResult_chosen:
	    if (that.getResult_field)
		getResult_field = new getResult(*that.getResult_field);
	    break;
	case getListError_chosen:
	    if (that.getListError_field)
		getListError_field = new getListError(*that.getListError_field);
	    break;
	case setResult_chosen:
	    if (that.setResult_field)
		setResult_field = new setResult(*that.setResult_field);
	    break;
	case setListError_chosen:
	    if (that.setListError_field)
		setListError_field = new setListError(*that.setListError_field);
	    break;
	case actionResult_chosen:
	    if (that.actionResult_field)
		actionResult_field = new actionResult(*that.actionResult_field);
	    break;
	case processingFailure_chosen:
	    if (that.processingFailure_field)
		processingFailure_field = new processingFailure(*that.processingFailure_field);
	    break;
	case deleteResult_chosen:
	    if (that.deleteResult_field)
		deleteResult_field = new deleteResult(*that.deleteResult_field);
	    break;
	case actionError_chosen:
	    if (that.actionError_field)
		actionError_field = new actionError(*that.actionError_field);
	    break;
	case deleteError_chosen:
	    if (that.deleteError_field)
		deleteError_field = new deleteError(*that.deleteError_field);
	    break;
    }
    return *this;
}

int LinkedReplyArgument::operator == (const LinkedReplyArgument & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case getResult_chosen:
	    if ((getResult_field) && (that.getResult_field))
		return (*getResult_field == *(that.getResult_field));
	    else if (!((!getResult_field) && (!that.getResult_field)))
		return 0;
	    break;
	case getListError_chosen:
	    if ((getListError_field) && (that.getListError_field))
		return (*getListError_field == *(that.getListError_field));
	    else if (!((!getListError_field) && (!that.getListError_field)))
		return 0;
	    break;
	case setResult_chosen:
	    if ((setResult_field) && (that.setResult_field))
		return (*setResult_field == *(that.setResult_field));
	    else if (!((!setResult_field) && (!that.setResult_field)))
		return 0;
	    break;
	case setListError_chosen:
	    if ((setListError_field) && (that.setListError_field))
		return (*setListError_field == *(that.setListError_field));
	    else if (!((!setListError_field) && (!that.setListError_field)))
		return 0;
	    break;
	case actionResult_chosen:
	    if ((actionResult_field) && (that.actionResult_field))
		return (*actionResult_field == *(that.actionResult_field));
	    else if (!((!actionResult_field) && (!that.actionResult_field)))
		return 0;
	    break;
	case processingFailure_chosen:
	    if ((processingFailure_field) && (that.processingFailure_field))
		return (*processingFailure_field == *(that.processingFailure_field));
	    else if (!((!processingFailure_field) && (!that.processingFailure_field)))
		return 0;
	    break;
	case deleteResult_chosen:
	    if ((deleteResult_field) && (that.deleteResult_field))
		return (*deleteResult_field == *(that.deleteResult_field));
	    else if (!((!deleteResult_field) && (!that.deleteResult_field)))
		return 0;
	    break;
	case actionError_chosen:
	    if ((actionError_field) && (that.actionError_field))
		return (*actionError_field == *(that.actionError_field));
	    else if (!((!actionError_field) && (!that.actionError_field)))
		return 0;
	    break;
	case deleteError_chosen:
	    if ((deleteError_field) && (that.deleteError_field))
		return (*deleteError_field == *(that.deleteError_field));
	    else if (!((!deleteError_field) && (!that.deleteError_field)))
		return 0;
	    break;
    }

    return 1;
}

int LinkedReplyArgument::operator != (const LinkedReplyArgument & that) const {
    return !(operator ==(that));
}

LinkedReplyArgument::getResult *LinkedReplyArgument::get_getResult() {
    if (_choice == getResult_chosen)
	return (getResult *)getResult_field;
    else
	return 0;
}

const LinkedReplyArgument::getResult *LinkedReplyArgument::get_getResult() const {
    if (_choice == getResult_chosen)
	return (const getResult *)getResult_field;
    else
	return 0;
}

void LinkedReplyArgument::set_getResult(const getResult & getResult_val) {
    cleanup();
    getResult_field = new getResult(getResult_val);
    _choice = getResult_chosen;
}

LinkedReplyArgument::getListError *LinkedReplyArgument::get_getListError() {
    if (_choice == getListError_chosen)
	return (getListError *)getListError_field;
    else
	return 0;
}

const LinkedReplyArgument::getListError *LinkedReplyArgument::get_getListError() const {
    if (_choice == getListError_chosen)
	return (const getListError *)getListError_field;
    else
	return 0;
}

void LinkedReplyArgument::set_getListError(const getListError & getListError_val) {
    cleanup();
    getListError_field = new getListError(getListError_val);
    _choice = getListError_chosen;
}

LinkedReplyArgument::setResult *LinkedReplyArgument::get_setResult() {
    if (_choice == setResult_chosen)
	return (setResult *)setResult_field;
    else
	return 0;
}

const LinkedReplyArgument::setResult *LinkedReplyArgument::get_setResult() const {
    if (_choice == setResult_chosen)
	return (const setResult *)setResult_field;
    else
	return 0;
}

void LinkedReplyArgument::set_setResult(const setResult & setResult_val) {
    cleanup();
    setResult_field = new setResult(setResult_val);
    _choice = setResult_chosen;
}

LinkedReplyArgument::setListError *LinkedReplyArgument::get_setListError() {
    if (_choice == setListError_chosen)
	return (setListError *)setListError_field;
    else
	return 0;
}

const LinkedReplyArgument::setListError *LinkedReplyArgument::get_setListError() const {
    if (_choice == setListError_chosen)
	return (const setListError *)setListError_field;
    else
	return 0;
}

void LinkedReplyArgument::set_setListError(const setListError & setListError_val) {
    cleanup();
    setListError_field = new setListError(setListError_val);
    _choice = setListError_chosen;
}

LinkedReplyArgument::actionResult *LinkedReplyArgument::get_actionResult() {
    if (_choice == actionResult_chosen)
	return (actionResult *)actionResult_field;
    else
	return 0;
}

const LinkedReplyArgument::actionResult *LinkedReplyArgument::get_actionResult() const {
    if (_choice == actionResult_chosen)
	return (const actionResult *)actionResult_field;
    else
	return 0;
}

void LinkedReplyArgument::set_actionResult(const actionResult & actionResult_val) {
    cleanup();
    actionResult_field = new actionResult(actionResult_val);
    _choice = actionResult_chosen;
}

LinkedReplyArgument::processingFailure *LinkedReplyArgument::get_processingFailure() {
    if (_choice == processingFailure_chosen)
	return (processingFailure *)processingFailure_field;
    else
	return 0;
}

const LinkedReplyArgument::processingFailure *LinkedReplyArgument::get_processingFailure() const {
    if (_choice == processingFailure_chosen)
	return (const processingFailure *)processingFailure_field;
    else
	return 0;
}

void LinkedReplyArgument::set_processingFailure(const processingFailure & processingFailure_val) {
    cleanup();
    processingFailure_field = new processingFailure(processingFailure_val);
    _choice = processingFailure_chosen;
}

LinkedReplyArgument::deleteResult *LinkedReplyArgument::get_deleteResult() {
    if (_choice == deleteResult_chosen)
	return (deleteResult *)deleteResult_field;
    else
	return 0;
}

const LinkedReplyArgument::deleteResult *LinkedReplyArgument::get_deleteResult() const {
    if (_choice == deleteResult_chosen)
	return (const deleteResult *)deleteResult_field;
    else
	return 0;
}

void LinkedReplyArgument::set_deleteResult(const deleteResult & deleteResult_val) {
    cleanup();
    deleteResult_field = new deleteResult(deleteResult_val);
    _choice = deleteResult_chosen;
}

LinkedReplyArgument::actionError *LinkedReplyArgument::get_actionError() {
    if (_choice == actionError_chosen)
	return (actionError *)actionError_field;
    else
	return 0;
}

const LinkedReplyArgument::actionError *LinkedReplyArgument::get_actionError() const {
    if (_choice == actionError_chosen)
	return (const actionError *)actionError_field;
    else
	return 0;
}

void LinkedReplyArgument::set_actionError(const actionError & actionError_val) {
    cleanup();
    actionError_field = new actionError(actionError_val);
    _choice = actionError_chosen;
}

LinkedReplyArgument::deleteError *LinkedReplyArgument::get_deleteError() {
    if (_choice == deleteError_chosen)
	return (deleteError *)deleteError_field;
    else
	return 0;
}

const LinkedReplyArgument::deleteError *LinkedReplyArgument::get_deleteError() const {
    if (_choice == deleteError_chosen)
	return (const deleteError *)deleteError_field;
    else
	return 0;
}

void LinkedReplyArgument::set_deleteError(const deleteError & deleteError_val) {
    cleanup();
    deleteError_field = new deleteError(deleteError_val);
    _choice = deleteError_chosen;
}

void LinkedReplyArgument::cleanup() {
    switch (_choice) {
	case getResult_chosen:
	    if (getResult_field)
		delete getResult_field;
	    break;
	case getListError_chosen:
	    if (getListError_field)
		delete getListError_field;
	    break;
	case setResult_chosen:
	    if (setResult_field)
		delete setResult_field;
	    break;
	case setListError_chosen:
	    if (setListError_field)
		delete setListError_field;
	    break;
	case actionResult_chosen:
	    if (actionResult_field)
		delete actionResult_field;
	    break;
	case processingFailure_chosen:
	    if (processingFailure_field)
		delete processingFailure_field;
	    break;
	case deleteResult_chosen:
	    if (deleteResult_field)
		delete deleteResult_field;
	    break;
	case actionError_chosen:
	    if (actionError_field)
		delete actionError_field;
	    break;
	case deleteError_chosen:
	    if (deleteError_field)
		delete deleteError_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

void *NoSuchAction::operator new(size_t size) {
    return ossNewFunc(size);
}

void NoSuchAction::operator delete(void *ptr) {
    asn1Free(ptr);
}

NoSuchAction::NoSuchAction() {
    memset(this, 0, sizeof(NoSuchAction));
}

NoSuchAction::NoSuchAction(const NoSuchAction & that) {
    OSSTRY {
	managedObjectClass_field = that.managedObjectClass_field;
	actionType_field = that.actionType_field;
    } OSSCLEAN(NoSuchAction)
}

NoSuchAction::NoSuchAction(const managedObjectClass & managedObjectClass_val, const actionType & actionType_val) {
    OSSTRY {
	managedObjectClass_field = managedObjectClass_val;
	actionType_field = actionType_val;
    } OSSCLEAN(NoSuchAction)
}

NoSuchAction & NoSuchAction::operator = (const NoSuchAction & that) {
    if (this == &that)
	return *this;
    managedObjectClass_field = that.managedObjectClass_field;
    actionType_field = that.actionType_field;
    return *this;
}

int NoSuchAction::operator == (const NoSuchAction & that) const {
    if (managedObjectClass_field != that.managedObjectClass_field)
	return 0;
    if (actionType_field != that.actionType_field)
	return 0;
    return 1;
}

int NoSuchAction::operator != (const NoSuchAction & that) const {
    return !(operator ==(that));
}

NoSuchAction::managedObjectClass & NoSuchAction::get_managedObjectClass() {
    return managedObjectClass_field;
}

const NoSuchAction::managedObjectClass & NoSuchAction::get_managedObjectClass() const {
    return managedObjectClass_field;
}

void NoSuchAction::set_managedObjectClass(const managedObjectClass & managedObjectClass_val) {
    managedObjectClass_field = managedObjectClass_val;
}

NoSuchAction::actionType & NoSuchAction::get_actionType() {
    return actionType_field;
}

const NoSuchAction::actionType & NoSuchAction::get_actionType() const {
    return actionType_field;
}

void NoSuchAction::set_actionType(const actionType & actionType_val) {
    actionType_field = actionType_val;
}

void *NoSuchEventType::operator new(size_t size) {
    return ossNewFunc(size);
}

void NoSuchEventType::operator delete(void *ptr) {
    asn1Free(ptr);
}

NoSuchEventType::NoSuchEventType() {
    memset(this, 0, sizeof(NoSuchEventType));
}

NoSuchEventType::NoSuchEventType(const NoSuchEventType & that) {
    OSSTRY {
	managedObjectClass_field = that.managedObjectClass_field;
	eventType_field = that.eventType_field;
    } OSSCLEAN(NoSuchEventType)
}

NoSuchEventType::NoSuchEventType(const managedObjectClass & managedObjectClass_val, 
    const eventType & eventType_val) {
    OSSTRY {
	managedObjectClass_field = managedObjectClass_val;
	eventType_field = eventType_val;
    } OSSCLEAN(NoSuchEventType)
}

NoSuchEventType & NoSuchEventType::operator = (const NoSuchEventType & that) {
    if (this == &that)
	return *this;
    managedObjectClass_field = that.managedObjectClass_field;
    eventType_field = that.eventType_field;
    return *this;
}

int NoSuchEventType::operator == (const NoSuchEventType & that) const {
    if (managedObjectClass_field != that.managedObjectClass_field)
	return 0;
    if (eventType_field != that.eventType_field)
	return 0;
    return 1;
}

int NoSuchEventType::operator != (const NoSuchEventType & that) const {
    return !(operator ==(that));
}

NoSuchEventType::managedObjectClass & NoSuchEventType::get_managedObjectClass() {
    return managedObjectClass_field;
}

const NoSuchEventType::managedObjectClass & NoSuchEventType::get_managedObjectClass() const {
    return managedObjectClass_field;
}

void NoSuchEventType::set_managedObjectClass(const managedObjectClass & managedObjectClass_val) {
    managedObjectClass_field = managedObjectClass_val;
}

NoSuchEventType::eventType & NoSuchEventType::get_eventType() {
    return eventType_field;
}

const NoSuchEventType::eventType & NoSuchEventType::get_eventType() const {
    return eventType_field;
}

void NoSuchEventType::set_eventType(const eventType & eventType_val) {
    eventType_field = eventType_val;
}

/* Auxiliary data structures and functions for class RelativeDistinguishedName */

class RelativeDistinguishedName_member {
public:
    RelativeDistinguishedName_member *next;
    RelativeDistinguishedName::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    RelativeDistinguishedName_member();
    RelativeDistinguishedName_member(const RelativeDistinguishedName::component & val);
};

void *RelativeDistinguishedName_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void RelativeDistinguishedName_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

RelativeDistinguishedName_member::RelativeDistinguishedName_member() {
}

RelativeDistinguishedName_member::RelativeDistinguishedName_member(const RelativeDistinguishedName::component & val) {
    value = val;
}

static void *RelativeDistinguishedName_copy(void *that) {
    return new RelativeDistinguishedName_member(((RelativeDistinguishedName_member *)that)->value);
}

static void RelativeDistinguishedName_destroy(void *that) {
    delete (RelativeDistinguishedName_member *)that;
}

static int RelativeDistinguishedName_compare(void *val1, void *val2) {
    return (((RelativeDistinguishedName_member *)val1)->value == ((RelativeDistinguishedName_member *)val2)->value);
}

/* Constructors */

RelativeDistinguishedName::RelativeDistinguishedName() {
}

RelativeDistinguishedName::RelativeDistinguishedName(const RelativeDistinguishedName & that) {
    OSSTRY {
	do_copy(that, &RelativeDistinguishedName_copy);
    } OSSCLEAN(RelativeDistinguishedName)
}

/* Destructor */

RelativeDistinguishedName::~RelativeDistinguishedName() {
    do_destroy(&RelativeDistinguishedName_destroy);
}

/* Operators: assignment, equality, inequality */

RelativeDistinguishedName & RelativeDistinguishedName::operator = (const RelativeDistinguishedName & that) {
    do_destroy(&RelativeDistinguishedName_destroy);
    do_copy(that, &RelativeDistinguishedName_copy);
    return *this;
}

int RelativeDistinguishedName::operator == (const RelativeDistinguishedName & that) const {
    return do_compare(that, &RelativeDistinguishedName_compare);
}

int RelativeDistinguishedName::operator != (const RelativeDistinguishedName & that) const {
    return !do_compare(that, &RelativeDistinguishedName_compare);
}

/* Locate ("At" etc) methods */

RelativeDistinguishedName::component *RelativeDistinguishedName::at(OssIndex pos) {
    return &((RelativeDistinguishedName_member *)pos)->value;
}

const RelativeDistinguishedName::component *RelativeDistinguishedName::at(OssIndex pos) const {
    return &((RelativeDistinguishedName_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex RelativeDistinguishedName::prepend(const component & val) {
    RelativeDistinguishedName_member *newrec = new RelativeDistinguishedName_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex RelativeDistinguishedName::prepend(RelativeDistinguishedName *seq) {
    return do_prepend(seq);
}

OssIndex RelativeDistinguishedName::insert_after(OssIndex pos, const component & val) {
    RelativeDistinguishedName_member *newrec = new RelativeDistinguishedName_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex RelativeDistinguishedName::insert_after(OssIndex pos, RelativeDistinguishedName *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int RelativeDistinguishedName::remove_front() {
    RelativeDistinguishedName_member *extr = (RelativeDistinguishedName_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    RelativeDistinguishedName_destroy(extr);
    return 0;
}

int RelativeDistinguishedName::remove_after(OssIndex pos) {
    RelativeDistinguishedName_member *extr = (RelativeDistinguishedName_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    RelativeDistinguishedName_destroy(extr);
    return 0;
}

/* Extract methods */

RelativeDistinguishedName *RelativeDistinguishedName::extract_after(OssIndex begin, OssIndex end) {
    return (RelativeDistinguishedName *)do_extract_after(begin, end);
}

/* Auxiliary data structures and functions for class __setof8 */

class __setof8_member {
public:
    __setof8_member *next;
    __setof8::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __setof8_member();
    __setof8_member(const __setof8::component & val);
};

void *__setof8_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __setof8_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__setof8_member::__setof8_member() {
}

__setof8_member::__setof8_member(const __setof8::component & val) {
    value = val;
}

static void *__setof8_copy(void *that) {
    return new __setof8_member(((__setof8_member *)that)->value);
}

static void __setof8_destroy(void *that) {
    delete (__setof8_member *)that;
}

static int __setof8_compare(void *val1, void *val2) {
    return (((__setof8_member *)val1)->value == ((__setof8_member *)val2)->value);
}

/* Constructors */

__setof8::__setof8() {
}

__setof8::__setof8(const __setof8 & that) {
    OSSTRY {
	do_copy(that, &__setof8_copy);
    } OSSCLEAN(__setof8)
}

/* Destructor */

__setof8::~__setof8() {
    do_destroy(&__setof8_destroy);
}

/* Operators: assignment, equality, inequality */

__setof8 & __setof8::operator = (const __setof8 & that) {
    do_destroy(&__setof8_destroy);
    do_copy(that, &__setof8_copy);
    return *this;
}

int __setof8::operator == (const __setof8 & that) const {
    return do_compare(that, &__setof8_compare);
}

int __setof8::operator != (const __setof8 & that) const {
    return !do_compare(that, &__setof8_compare);
}

/* Locate ("At" etc) methods */

__setof8::component *__setof8::at(OssIndex pos) {
    return &((__setof8_member *)pos)->value;
}

const __setof8::component *__setof8::at(OssIndex pos) const {
    return &((__setof8_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __setof8::prepend(const component & val) {
    __setof8_member *newrec = new __setof8_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __setof8::prepend(__setof8 *seq) {
    return do_prepend(seq);
}

OssIndex __setof8::insert_after(OssIndex pos, const component & val) {
    __setof8_member *newrec = new __setof8_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __setof8::insert_after(OssIndex pos, __setof8 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __setof8::remove_front() {
    __setof8_member *extr = (__setof8_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __setof8_destroy(extr);
    return 0;
}

int __setof8::remove_after(OssIndex pos) {
    __setof8_member *extr = (__setof8_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __setof8_destroy(extr);
    return 0;
}

/* Extract methods */

__setof8 *__setof8::extract_after(OssIndex begin, OssIndex end) {
    return (__setof8 *)do_extract_after(begin, end);
}

void *SetArgument::operator new(size_t size) {
    return ossNewFunc(size);
}

void SetArgument::operator delete(void *ptr) {
    asn1Free(ptr);
}

enum CMISSync SetArgument::get_default_synchronization() {
    return SetArgument::default_synchronization;
}

const Scope& SetArgument::get_default_scope() {
    return SetArgument::default_scope;
}

const CMISFilter& SetArgument::get_default_filter() {
    return SetArgument::default_filter;
}

SetArgument::SetArgument() {
    memset(this, 0, sizeof(SetArgument));
}

SetArgument::SetArgument(const SetArgument & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	baseManagedObjectClass_field = that.baseManagedObjectClass_field;
	baseManagedObjectInstance_field = that.baseManagedObjectInstance_field;
	accessControl_field = that.accessControl_field;
	synchronization_field = that.synchronization_field;
	if (bit_mask & 0x20000000)
	    scope_field = that.scope_field;
	if (bit_mask & 0x10000000)
	    filter_field = that.filter_field;
	modificationList_field = that.modificationList_field;
    } OSSCLEAN(SetArgument)
}

SetArgument::SetArgument(const baseManagedObjectClass & baseManagedObjectClass_val, 
    const baseManagedObjectInstance & baseManagedObjectInstance_val, const accessControl & accessControl_val, 
    synchronization synchronization_val, const scope & scope_val, const filter & filter_val, 
    const modificationList & modificationList_val) {
    OSSTRY {
	bit_mask = 0xf0000000;
	baseManagedObjectClass_field = baseManagedObjectClass_val;
	baseManagedObjectInstance_field = baseManagedObjectInstance_val;
	accessControl_field = accessControl_val;
	synchronization_field = synchronization_val;
	scope_field = scope_val;
	filter_field = filter_val;
	modificationList_field = modificationList_val;
    } OSSCLEAN(SetArgument)
}

SetArgument::SetArgument(const baseManagedObjectClass & baseManagedObjectClass_val, 
    const baseManagedObjectInstance & baseManagedObjectInstance_val, const modificationList & modificationList_val) {
    OSSTRY {
	bit_mask = 0;
	baseManagedObjectClass_field = baseManagedObjectClass_val;
	baseManagedObjectInstance_field = baseManagedObjectInstance_val;
	modificationList_field = modificationList_val;
    } OSSCLEAN(SetArgument)
}

SetArgument::~SetArgument() {
    if (!(bit_mask & 0x20000000))
	memset(&scope_field, 0, sizeof(scope));
    if (!(bit_mask & 0x10000000))
	memset(&filter_field, 0, sizeof(filter));
}

SetArgument & SetArgument::operator = (const SetArgument & that) {
    if (this == &that)
	return *this;
    this->~SetArgument();
    bit_mask = that.bit_mask;
    baseManagedObjectClass_field = that.baseManagedObjectClass_field;
    baseManagedObjectInstance_field = that.baseManagedObjectInstance_field;
    accessControl_field = that.accessControl_field;
    synchronization_field = that.synchronization_field;
    if (bit_mask & 0x20000000)
	scope_field = that.scope_field;
    if (bit_mask & 0x10000000)
	filter_field = that.filter_field;
    modificationList_field = that.modificationList_field;
    return *this;
}

int SetArgument::operator == (const SetArgument & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (baseManagedObjectClass_field != that.baseManagedObjectClass_field)
	return 0;
    if (baseManagedObjectInstance_field != that.baseManagedObjectInstance_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (accessControl_field != that.accessControl_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (synchronization_field != that.synchronization_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (scope_field != that.scope_field)
	    return 0;
    }
    if (bit_mask & 0x10000000) {
	if (filter_field != that.filter_field)
	    return 0;
    }
    if (modificationList_field != that.modificationList_field)
	return 0;
    return 1;
}

int SetArgument::operator != (const SetArgument & that) const {
    return !(operator ==(that));
}

SetArgument::baseManagedObjectClass & SetArgument::get_baseManagedObjectClass() {
    return baseManagedObjectClass_field;
}

const SetArgument::baseManagedObjectClass & SetArgument::get_baseManagedObjectClass() const {
    return baseManagedObjectClass_field;
}

void SetArgument::set_baseManagedObjectClass(const baseManagedObjectClass & baseManagedObjectClass_val) {
    baseManagedObjectClass_field = baseManagedObjectClass_val;
}

SetArgument::baseManagedObjectInstance & SetArgument::get_baseManagedObjectInstance() {
    return baseManagedObjectInstance_field;
}

const SetArgument::baseManagedObjectInstance & SetArgument::get_baseManagedObjectInstance() const {
    return baseManagedObjectInstance_field;
}

void SetArgument::set_baseManagedObjectInstance(const baseManagedObjectInstance & baseManagedObjectInstance_val) {
    baseManagedObjectInstance_field = baseManagedObjectInstance_val;
}

SetArgument::accessControl *SetArgument::get_accessControl() {
    if (bit_mask & 0x80000000)
	return &accessControl_field;
    else
	return 0;
}

const SetArgument::accessControl *SetArgument::get_accessControl() const {
    if (bit_mask & 0x80000000)
	return &accessControl_field;
    else
	return 0;
}

void SetArgument::set_accessControl(const accessControl & accessControl_val) {
    bit_mask |= 0x80000000;
    accessControl_field = accessControl_val;
}

int SetArgument::accessControl_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void SetArgument::omit_accessControl() {
    accessControl_field.~__shared2();
    bit_mask &= ~0x80000000;
}

SetArgument::synchronization *SetArgument::get_synchronization() {
    if (bit_mask & 0x40000000)
	return &synchronization_field;
    else
	return 0;
}

const SetArgument::synchronization *SetArgument::get_synchronization() const {
    if (bit_mask & 0x40000000)
	return &synchronization_field;
    else
	return 0;
}

void SetArgument::set_synchronization(synchronization synchronization_val) {
    bit_mask |= 0x40000000;
    synchronization_field = synchronization_val;
}

int SetArgument::synchronization_is_default() const {
    return !(bit_mask & 0x40000000);
}

void SetArgument::set_default_synchronization() {
    bit_mask &= ~0x40000000;
}

SetArgument::scope *SetArgument::get_scope() {
    if (bit_mask & 0x20000000)
	return &scope_field;
    else
	return 0;
}

const SetArgument::scope *SetArgument::get_scope() const {
    if (bit_mask & 0x20000000)
	return &scope_field;
    else
	return 0;
}

void SetArgument::set_scope(const scope & scope_val) {
    if (!(bit_mask & 0x20000000)) {
	memset(&scope_field, 0, sizeof(scope));
	bit_mask |= 0x20000000;
    }
    scope_field = scope_val;
}

int SetArgument::scope_is_default() const {
    return !(bit_mask & 0x20000000);
}

void SetArgument::set_default_scope() {
    if (bit_mask & 0x20000000) {
	scope_field.~Scope();
	bit_mask &= ~0x20000000;
    }
}

SetArgument::filter *SetArgument::get_filter() {
    if (bit_mask & 0x10000000)
	return &filter_field;
    else
	return 0;
}

const SetArgument::filter *SetArgument::get_filter() const {
    if (bit_mask & 0x10000000)
	return &filter_field;
    else
	return 0;
}

void SetArgument::set_filter(const filter & filter_val) {
    if (!(bit_mask & 0x10000000)) {
	memset(&filter_field, 0, sizeof(filter));
	bit_mask |= 0x10000000;
    }
    filter_field = filter_val;
}

int SetArgument::filter_is_default() const {
    return !(bit_mask & 0x10000000);
}

void SetArgument::set_default_filter() {
    if (bit_mask & 0x10000000) {
	filter_field.~CMISFilter();
	bit_mask &= ~0x10000000;
    }
}

SetArgument::modificationList & SetArgument::get_modificationList() {
    return modificationList_field;
}

const SetArgument::modificationList & SetArgument::get_modificationList() const {
    return modificationList_field;
}

void SetArgument::set_modificationList(const modificationList & modificationList_val) {
    modificationList_field = modificationList_val;
}

void *__seq4::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq4::operator delete(void *ptr) {
    asn1Free(ptr);
}

OSS_INT32 __seq4::get_default_modifyOperator() {
    return __seq4::default_modifyOperator;
}

__seq4::__seq4() {
    memset(this, 0, sizeof(__seq4));
}

__seq4::__seq4(const __seq4 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	modifyOperator_field = that.modifyOperator_field;
	attributeId_field = that.attributeId_field;
	attributeValue_field = that.attributeValue_field;
    } OSSCLEAN(__seq4)
}

__seq4::__seq4(modifyOperator modifyOperator_val, const attributeId & attributeId_val, 
    const attributeValue & attributeValue_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	modifyOperator_field = modifyOperator_val;
	attributeId_field = attributeId_val;
	attributeValue_field = attributeValue_val;
    } OSSCLEAN(__seq4)
}

__seq4::__seq4(const attributeId & attributeId_val) {
    OSSTRY {
	bit_mask = 0;
	attributeId_field = attributeId_val;
    } OSSCLEAN(__seq4)
}

__seq4 & __seq4::operator = (const __seq4 & that) {
    if (this == &that)
	return *this;
    this->~__seq4();
    bit_mask = that.bit_mask;
    modifyOperator_field = that.modifyOperator_field;
    attributeId_field = that.attributeId_field;
    attributeValue_field = that.attributeValue_field;
    return *this;
}

int __seq4::operator == (const __seq4 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (modifyOperator_field != that.modifyOperator_field)
	    return 0;
    }
    if (attributeId_field != that.attributeId_field)
	return 0;
    if (bit_mask & 0x40000000) {
	if (attributeValue_field != that.attributeValue_field)
	    return 0;
    }
    return 1;
}

int __seq4::operator != (const __seq4 & that) const {
    return !(operator ==(that));
}

__seq4::modifyOperator *__seq4::get_modifyOperator() {
    if (bit_mask & 0x80000000)
	return &modifyOperator_field;
    else
	return 0;
}

const __seq4::modifyOperator *__seq4::get_modifyOperator() const {
    if (bit_mask & 0x80000000)
	return &modifyOperator_field;
    else
	return 0;
}

void __seq4::set_modifyOperator(modifyOperator modifyOperator_val) {
    bit_mask |= 0x80000000;
    modifyOperator_field = modifyOperator_val;
}

int __seq4::modifyOperator_is_default() const {
    return !(bit_mask & 0x80000000);
}

void __seq4::set_default_modifyOperator() {
    bit_mask &= ~0x80000000;
}

__seq4::attributeId & __seq4::get_attributeId() {
    return attributeId_field;
}

const __seq4::attributeId & __seq4::get_attributeId() const {
    return attributeId_field;
}

void __seq4::set_attributeId(const attributeId & attributeId_val) {
    attributeId_field = attributeId_val;
}

__seq4::attributeValue *__seq4::get_attributeValue() {
    if (bit_mask & 0x40000000)
	return &attributeValue_field;
    else
	return 0;
}

const __seq4::attributeValue *__seq4::get_attributeValue() const {
    if (bit_mask & 0x40000000)
	return &attributeValue_field;
    else
	return 0;
}

void __seq4::set_attributeValue(const attributeValue & attributeValue_val) {
    bit_mask |= 0x40000000;
    attributeValue_field = attributeValue_val;
}

int __seq4::attributeValue_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void __seq4::omit_attributeValue() {
    attributeValue_field.~AvaSet_Value();
    bit_mask &= ~0x40000000;
}

SetInfoStatus::SetInfoStatus() {
    memset(this, 0, sizeof(SetInfoStatus));
}

SetInfoStatus::SetInfoStatus(const SetInfoStatus & that) {
    memset(this, 0, sizeof(SetInfoStatus));
    operator =(that);
}

SetInfoStatus::~SetInfoStatus() {
    cleanup();
}

SetInfoStatus & SetInfoStatus::operator = (const SetInfoStatus & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case attributeError_chosen:
	    if (that.attributeError_field)
		attributeError_field = new attributeError(*that.attributeError_field);
	    break;
	case attribute_chosen:
	    if (that.attribute_field)
		attribute_field = new attribute(*that.attribute_field);
	    break;
    }
    return *this;
}

int SetInfoStatus::operator == (const SetInfoStatus & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case attributeError_chosen:
	    if ((attributeError_field) && (that.attributeError_field))
		return (*attributeError_field == *(that.attributeError_field));
	    else if (!((!attributeError_field) && (!that.attributeError_field)))
		return 0;
	    break;
	case attribute_chosen:
	    if ((attribute_field) && (that.attribute_field))
		return (*attribute_field == *(that.attribute_field));
	    else if (!((!attribute_field) && (!that.attribute_field)))
		return 0;
	    break;
    }

    return 1;
}

int SetInfoStatus::operator != (const SetInfoStatus & that) const {
    return !(operator ==(that));
}

SetInfoStatus::attributeError *SetInfoStatus::get_attributeError() {
    if (_choice == attributeError_chosen)
	return (attributeError *)attributeError_field;
    else
	return 0;
}

const SetInfoStatus::attributeError *SetInfoStatus::get_attributeError() const {
    if (_choice == attributeError_chosen)
	return (const attributeError *)attributeError_field;
    else
	return 0;
}

void SetInfoStatus::set_attributeError(const attributeError & attributeError_val) {
    cleanup();
    attributeError_field = new attributeError(attributeError_val);
    _choice = attributeError_chosen;
}

SetInfoStatus::attribute *SetInfoStatus::get_attribute() {
    if (_choice == attribute_chosen)
	return (attribute *)attribute_field;
    else
	return 0;
}

const SetInfoStatus::attribute *SetInfoStatus::get_attribute() const {
    if (_choice == attribute_chosen)
	return (const attribute *)attribute_field;
    else
	return 0;
}

void SetInfoStatus::set_attribute(const attribute & attribute_val) {
    cleanup();
    attribute_field = new attribute(attribute_val);
    _choice = attribute_chosen;
}

void SetInfoStatus::cleanup() {
    switch (_choice) {
	case attributeError_chosen:
	    if (attributeError_field)
		delete attributeError_field;
	    break;
	case attribute_chosen:
	    if (attribute_field)
		delete attribute_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

Code::Code() {
    memset(this, 0, sizeof(Code));
}

Code::Code(const Code & that) {
    memset(this, 0, sizeof(Code));
    operator =(that);
}

Code::~Code() {
    cleanup();
}

Code & Code::operator = (const Code & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case local_chosen:
	    *(local *)&local_field = *(local *)&that.local_field;
	    break;
	case global_chosen:
	    *(global *)&global_field = *(global *)&that.global_field;
	    break;
    }
    return *this;
}

int Code::operator == (const Code & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case local_chosen:
	    return *(local *)&local_field == *(local *)&that.local_field;
	case global_chosen:
	    return *(global *)&global_field == *(global *)&that.global_field;
    }

    return 1;
}

int Code::operator != (const Code & that) const {
    return !(operator ==(that));
}

Code::local *Code::get_local() {
    if (_choice == local_chosen)
	return (local *)&local_field;
    else
	return 0;
}

const Code::local *Code::get_local() const {
    if (_choice == local_chosen)
	return (const local *)&local_field;
    else
	return 0;
}

void Code::set_local(local local_val) {
    cleanup();
    *(local *)&local_field = local_val;
    _choice = local_chosen;
}

Code::global *Code::get_global() {
    if (_choice == global_chosen)
	return (global *)&global_field;
    else
	return 0;
}

const Code::global *Code::get_global() const {
    if (_choice == global_chosen)
	return (const global *)&global_field;
    else
	return 0;
}

void Code::set_global(const global & global_val) {
    cleanup();
    *(global *)&global_field = global_val;
    _choice = global_chosen;
}

void Code::cleanup() {
    switch (_choice) {
	case local_chosen:
	    break;
	case global_chosen:
	    ((global *)&global_field)->~OssEncOID();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

CMIP_Operations_ArgumentType::CMIP_Operations_ArgumentType()
{
}

CMIP_Operations_ArgumentType::CMIP_Operations_ArgumentType(const CMIP_Operations_ArgumentType & that)
{
    operator =(that);
}

CMIP_Operations_ArgumentType::~CMIP_Operations_ArgumentType()
{
    cleanup_decoded();
}

CMIP_Operations_ArgumentType & CMIP_Operations_ArgumentType::operator = (const CMIP_Operations_ArgumentType & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = SMASE_A_ASSOCIATE_Information_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int CMIP_Operations_ArgumentType::operator == (const CMIP_Operations_ArgumentType & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return SMASE_A_ASSOCIATE_Information_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int CMIP_Operations_ArgumentType::operator != (const CMIP_Operations_ArgumentType & that) const
{
    return !(operator ==(that));
}

int CMIP_Operations_ArgumentType::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;
    result = check_type(index);
    if (result)
	return oss_call_error_cond(OSS_TYPE_MISMATCH);

    result = SMASE_A_ASSOCIATE_Information_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int CMIP_Operations_ArgumentType::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
    if (check_type(index))
	return oss_call_error_cond(OSS_TYPE_MISMATCH);
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int CMIP_Operations_ArgumentType::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int CMIP_Operations_ArgumentType::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int CMIP_Operations_ArgumentType::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

ActionArgument *CMIP_Operations_ArgumentType::get_ActionArgument()
{
    if (pdunum == 1)
	return (ActionArgument *)decoded;
    else
	return NULL;
}

const ActionArgument *CMIP_Operations_ArgumentType::get_ActionArgument() const
{
    if (pdunum == 1)
	return (const ActionArgument *)decoded;
    else
	return NULL;
}

void CMIP_Operations_ArgumentType::set_ActionArgument(const ActionArgument & data)
{
    void *copy;

    copy = new ActionArgument(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 1;
	decoded = copy;
    }
}

ActionArgument *CMIP_Operations_ArgumentType::release_ActionArgument()
{
    pdunum = 0;
    decoded = NULL;
    return get_ActionArgument();
}

void CMIP_Operations_ArgumentType::set_ActionArgument(ActionArgument *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 1;
    decoded = data;
}

__shared12 *CMIP_Operations_ArgumentType::get_InvokeIDType()
{
    if (pdunum == 19)
	return (__shared12 *)decoded;
    else
	return NULL;
}

const __shared12 *CMIP_Operations_ArgumentType::get_InvokeIDType() const
{
    if (pdunum == 19)
	return (const __shared12 *)decoded;
    else
	return NULL;
}

void CMIP_Operations_ArgumentType::set_InvokeIDType(const __shared12 & data)
{
    void *copy;

    copy = new InvokeIDType(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 19;
	decoded = copy;
    }
}

__shared12 *CMIP_Operations_ArgumentType::release_InvokeIDType()
{
    pdunum = 0;
    decoded = NULL;
    return get_InvokeIDType();
}

void CMIP_Operations_ArgumentType::set_InvokeIDType(__shared12 *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 19;
    decoded = data;
}

CreateArgument *CMIP_Operations_ArgumentType::get_CreateArgument()
{
    if (pdunum == 9)
	return (CreateArgument *)decoded;
    else
	return NULL;
}

const CreateArgument *CMIP_Operations_ArgumentType::get_CreateArgument() const
{
    if (pdunum == 9)
	return (const CreateArgument *)decoded;
    else
	return NULL;
}

void CMIP_Operations_ArgumentType::set_CreateArgument(const CreateArgument & data)
{
    void *copy;

    copy = new CreateArgument(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 9;
	decoded = copy;
    }
}

CreateArgument *CMIP_Operations_ArgumentType::release_CreateArgument()
{
    pdunum = 0;
    decoded = NULL;
    return get_CreateArgument();
}

void CMIP_Operations_ArgumentType::set_CreateArgument(CreateArgument *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 9;
    decoded = data;
}

DeleteArgument *CMIP_Operations_ArgumentType::get_DeleteArgument()
{
    if (pdunum == 11)
	return (DeleteArgument *)decoded;
    else
	return NULL;
}

const DeleteArgument *CMIP_Operations_ArgumentType::get_DeleteArgument() const
{
    if (pdunum == 11)
	return (const DeleteArgument *)decoded;
    else
	return NULL;
}

void CMIP_Operations_ArgumentType::set_DeleteArgument(const DeleteArgument & data)
{
    void *copy;

    copy = new DeleteArgument(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 11;
	decoded = copy;
    }
}

DeleteArgument *CMIP_Operations_ArgumentType::release_DeleteArgument()
{
    pdunum = 0;
    decoded = NULL;
    return get_DeleteArgument();
}

void CMIP_Operations_ArgumentType::set_DeleteArgument(DeleteArgument *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 11;
    decoded = data;
}

EventReportArgument *CMIP_Operations_ArgumentType::get_EventReportArgument()
{
    if (pdunum == 13)
	return (EventReportArgument *)decoded;
    else
	return NULL;
}

const EventReportArgument *CMIP_Operations_ArgumentType::get_EventReportArgument() const
{
    if (pdunum == 13)
	return (const EventReportArgument *)decoded;
    else
	return NULL;
}

void CMIP_Operations_ArgumentType::set_EventReportArgument(const EventReportArgument & data)
{
    void *copy;

    copy = new EventReportArgument(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 13;
	decoded = copy;
    }
}

EventReportArgument *CMIP_Operations_ArgumentType::release_EventReportArgument()
{
    pdunum = 0;
    decoded = NULL;
    return get_EventReportArgument();
}

void CMIP_Operations_ArgumentType::set_EventReportArgument(EventReportArgument *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 13;
    decoded = data;
}

GetArgument *CMIP_Operations_ArgumentType::get_GetArgument()
{
    if (pdunum == 15)
	return (GetArgument *)decoded;
    else
	return NULL;
}

const GetArgument *CMIP_Operations_ArgumentType::get_GetArgument() const
{
    if (pdunum == 15)
	return (const GetArgument *)decoded;
    else
	return NULL;
}

void CMIP_Operations_ArgumentType::set_GetArgument(const GetArgument & data)
{
    void *copy;

    copy = new GetArgument(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 15;
	decoded = copy;
    }
}

GetArgument *CMIP_Operations_ArgumentType::release_GetArgument()
{
    pdunum = 0;
    decoded = NULL;
    return get_GetArgument();
}

void CMIP_Operations_ArgumentType::set_GetArgument(GetArgument *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 15;
    decoded = data;
}

LinkedReplyArgument *CMIP_Operations_ArgumentType::get_LinkedReplyArgument()
{
    if (pdunum == 20)
	return (LinkedReplyArgument *)decoded;
    else
	return NULL;
}

const LinkedReplyArgument *CMIP_Operations_ArgumentType::get_LinkedReplyArgument() const
{
    if (pdunum == 20)
	return (const LinkedReplyArgument *)decoded;
    else
	return NULL;
}

void CMIP_Operations_ArgumentType::set_LinkedReplyArgument(const LinkedReplyArgument & data)
{
    void *copy;

    copy = new LinkedReplyArgument(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 20;
	decoded = copy;
    }
}

LinkedReplyArgument *CMIP_Operations_ArgumentType::release_LinkedReplyArgument()
{
    pdunum = 0;
    decoded = NULL;
    return get_LinkedReplyArgument();
}

void CMIP_Operations_ArgumentType::set_LinkedReplyArgument(LinkedReplyArgument *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 20;
    decoded = data;
}

SetArgument *CMIP_Operations_ArgumentType::get_SetArgument()
{
    if (pdunum == 28)
	return (SetArgument *)decoded;
    else
	return NULL;
}

const SetArgument *CMIP_Operations_ArgumentType::get_SetArgument() const
{
    if (pdunum == 28)
	return (const SetArgument *)decoded;
    else
	return NULL;
}

void CMIP_Operations_ArgumentType::set_SetArgument(const SetArgument & data)
{
    void *copy;

    copy = new SetArgument(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 28;
	decoded = copy;
    }
}

SetArgument *CMIP_Operations_ArgumentType::release_SetArgument()
{
    pdunum = 0;
    decoded = NULL;
    return get_SetArgument();
}

void CMIP_Operations_ArgumentType::set_SetArgument(SetArgument *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 28;
    decoded = data;
}

void CMIP_Operations_ArgumentType::cleanup_decoded()
{
    if (pdunum && decoded) {
	SMASE_A_ASSOCIATE_Information_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

int CMIP_Operations_ArgumentType::check_type(int index)
{
    return (index != 1) && (index != 19) && (index != 9) && (index != 11) &&
	    (index != 13) && (index != 15) && (index != 20) && (index != 28);
}

CMIP_Confirmed_Operations_ResultType::CMIP_Confirmed_Operations_ResultType()
{
}

CMIP_Confirmed_Operations_ResultType::CMIP_Confirmed_Operations_ResultType(const CMIP_Confirmed_Operations_ResultType & that)
{
    operator =(that);
}

CMIP_Confirmed_Operations_ResultType::~CMIP_Confirmed_Operations_ResultType()
{
    cleanup_decoded();
}

CMIP_Confirmed_Operations_ResultType & CMIP_Confirmed_Operations_ResultType::operator = (const CMIP_Confirmed_Operations_ResultType & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = SMASE_A_ASSOCIATE_Information_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int CMIP_Confirmed_Operations_ResultType::operator == (const CMIP_Confirmed_Operations_ResultType & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return SMASE_A_ASSOCIATE_Information_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int CMIP_Confirmed_Operations_ResultType::operator != (const CMIP_Confirmed_Operations_ResultType & that) const
{
    return !(operator ==(that));
}

int CMIP_Confirmed_Operations_ResultType::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = SMASE_A_ASSOCIATE_Information_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int CMIP_Confirmed_Operations_ResultType::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int CMIP_Confirmed_Operations_ResultType::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int CMIP_Confirmed_Operations_ResultType::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int CMIP_Confirmed_Operations_ResultType::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

ActionResult *CMIP_Confirmed_Operations_ResultType::get_ActionResult()
{
    if (pdunum == 2)
	return (ActionResult *)decoded;
    else
	return NULL;
}

const ActionResult *CMIP_Confirmed_Operations_ResultType::get_ActionResult() const
{
    if (pdunum == 2)
	return (const ActionResult *)decoded;
    else
	return NULL;
}

void CMIP_Confirmed_Operations_ResultType::set_ActionResult(const ActionResult & data)
{
    void *copy;

    copy = new ActionResult(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 2;
	decoded = copy;
    }
}

ActionResult *CMIP_Confirmed_Operations_ResultType::release_ActionResult()
{
    pdunum = 0;
    decoded = NULL;
    return get_ActionResult();
}

void CMIP_Confirmed_Operations_ResultType::set_ActionResult(ActionResult *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 2;
    decoded = data;
}

__shared11 *CMIP_Confirmed_Operations_ResultType::get_CreateResult()
{
    if (pdunum == 10)
	return (__shared11 *)decoded;
    else
	return NULL;
}

const __shared11 *CMIP_Confirmed_Operations_ResultType::get_CreateResult() const
{
    if (pdunum == 10)
	return (const __shared11 *)decoded;
    else
	return NULL;
}

void CMIP_Confirmed_Operations_ResultType::set_CreateResult(const __shared11 & data)
{
    void *copy;

    copy = new CreateResult(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 10;
	decoded = copy;
    }
}

__shared11 *CMIP_Confirmed_Operations_ResultType::release_CreateResult()
{
    pdunum = 0;
    decoded = NULL;
    return get_CreateResult();
}

void CMIP_Confirmed_Operations_ResultType::set_CreateResult(__shared11 *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 10;
    decoded = data;
}

DeleteResult *CMIP_Confirmed_Operations_ResultType::get_DeleteResult()
{
    if (pdunum == 12)
	return (DeleteResult *)decoded;
    else
	return NULL;
}

const DeleteResult *CMIP_Confirmed_Operations_ResultType::get_DeleteResult() const
{
    if (pdunum == 12)
	return (const DeleteResult *)decoded;
    else
	return NULL;
}

void CMIP_Confirmed_Operations_ResultType::set_DeleteResult(const DeleteResult & data)
{
    void *copy;

    copy = new DeleteResult(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 12;
	decoded = copy;
    }
}

DeleteResult *CMIP_Confirmed_Operations_ResultType::release_DeleteResult()
{
    pdunum = 0;
    decoded = NULL;
    return get_DeleteResult();
}

void CMIP_Confirmed_Operations_ResultType::set_DeleteResult(DeleteResult *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 12;
    decoded = data;
}

EventReportResult *CMIP_Confirmed_Operations_ResultType::get_EventReportResult()
{
    if (pdunum == 14)
	return (EventReportResult *)decoded;
    else
	return NULL;
}

const EventReportResult *CMIP_Confirmed_Operations_ResultType::get_EventReportResult() const
{
    if (pdunum == 14)
	return (const EventReportResult *)decoded;
    else
	return NULL;
}

void CMIP_Confirmed_Operations_ResultType::set_EventReportResult(const EventReportResult & data)
{
    void *copy;

    copy = new EventReportResult(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 14;
	decoded = copy;
    }
}

EventReportResult *CMIP_Confirmed_Operations_ResultType::release_EventReportResult()
{
    pdunum = 0;
    decoded = NULL;
    return get_EventReportResult();
}

void CMIP_Confirmed_Operations_ResultType::set_EventReportResult(EventReportResult *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 14;
    decoded = data;
}

__shared11 *CMIP_Confirmed_Operations_ResultType::get_GetResult()
{
    if (pdunum == 17)
	return (__shared11 *)decoded;
    else
	return NULL;
}

const __shared11 *CMIP_Confirmed_Operations_ResultType::get_GetResult() const
{
    if (pdunum == 17)
	return (const __shared11 *)decoded;
    else
	return NULL;
}

void CMIP_Confirmed_Operations_ResultType::set_GetResult(const __shared11 & data)
{
    void *copy;

    copy = new GetResult(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 17;
	decoded = copy;
    }
}

__shared11 *CMIP_Confirmed_Operations_ResultType::release_GetResult()
{
    pdunum = 0;
    decoded = NULL;
    return get_GetResult();
}

void CMIP_Confirmed_Operations_ResultType::set_GetResult(__shared11 *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 17;
    decoded = data;
}

__shared11 *CMIP_Confirmed_Operations_ResultType::get_SetResult()
{
    if (pdunum == 30)
	return (__shared11 *)decoded;
    else
	return NULL;
}

const __shared11 *CMIP_Confirmed_Operations_ResultType::get_SetResult() const
{
    if (pdunum == 30)
	return (const __shared11 *)decoded;
    else
	return NULL;
}

void CMIP_Confirmed_Operations_ResultType::set_SetResult(const __shared11 & data)
{
    void *copy;

    copy = new SetResult(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 30;
	decoded = copy;
    }
}

__shared11 *CMIP_Confirmed_Operations_ResultType::release_SetResult()
{
    pdunum = 0;
    decoded = NULL;
    return get_SetResult();
}

void CMIP_Confirmed_Operations_ResultType::set_SetResult(__shared11 *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 30;
    decoded = data;
}

void CMIP_Confirmed_Operations_ResultType::cleanup_decoded()
{
    if (pdunum && decoded) {
	SMASE_A_ASSOCIATE_Information_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

ROSEapdus_ParameterType_Table_ParameterType::ROSEapdus_ParameterType_Table_ParameterType()
{
}

ROSEapdus_ParameterType_Table_ParameterType::ROSEapdus_ParameterType_Table_ParameterType(const ROSEapdus_ParameterType_Table_ParameterType & that)
{
    operator =(that);
}

ROSEapdus_ParameterType_Table_ParameterType::~ROSEapdus_ParameterType_Table_ParameterType()
{
    cleanup_decoded();
}

ROSEapdus_ParameterType_Table_ParameterType & ROSEapdus_ParameterType_Table_ParameterType::operator = (const ROSEapdus_ParameterType_Table_ParameterType & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = SMASE_A_ASSOCIATE_Information_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int ROSEapdus_ParameterType_Table_ParameterType::operator == (const ROSEapdus_ParameterType_Table_ParameterType & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return SMASE_A_ASSOCIATE_Information_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int ROSEapdus_ParameterType_Table_ParameterType::operator != (const ROSEapdus_ParameterType_Table_ParameterType & that) const
{
    return !(operator ==(that));
}

int ROSEapdus_ParameterType_Table_ParameterType::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = SMASE_A_ASSOCIATE_Information_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int ROSEapdus_ParameterType_Table_ParameterType::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int ROSEapdus_ParameterType_Table_ParameterType::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int ROSEapdus_ParameterType_Table_ParameterType::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int ROSEapdus_ParameterType_Table_ParameterType::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

BaseManagedObjectId *ROSEapdus_ParameterType_Table_ParameterType::get_BaseManagedObjectId()
{
    if (pdunum == 5)
	return (BaseManagedObjectId *)decoded;
    else
	return NULL;
}

const BaseManagedObjectId *ROSEapdus_ParameterType_Table_ParameterType::get_BaseManagedObjectId() const
{
    if (pdunum == 5)
	return (const BaseManagedObjectId *)decoded;
    else
	return NULL;
}

void ROSEapdus_ParameterType_Table_ParameterType::set_BaseManagedObjectId(const BaseManagedObjectId & data)
{
    void *copy;

    copy = new BaseManagedObjectId(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 5;
	decoded = copy;
    }
}

BaseManagedObjectId *ROSEapdus_ParameterType_Table_ParameterType::release_BaseManagedObjectId()
{
    pdunum = 0;
    decoded = NULL;
    return get_BaseManagedObjectId();
}

void ROSEapdus_ParameterType_Table_ParameterType::set_BaseManagedObjectId(BaseManagedObjectId *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 5;
    decoded = data;
}

ComplexityLimitation *ROSEapdus_ParameterType_Table_ParameterType::get_ComplexityLimitation()
{
    if (pdunum == 8)
	return (ComplexityLimitation *)decoded;
    else
	return NULL;
}

const ComplexityLimitation *ROSEapdus_ParameterType_Table_ParameterType::get_ComplexityLimitation() const
{
    if (pdunum == 8)
	return (const ComplexityLimitation *)decoded;
    else
	return NULL;
}

void ROSEapdus_ParameterType_Table_ParameterType::set_ComplexityLimitation(const ComplexityLimitation & data)
{
    void *copy;

    copy = new ComplexityLimitation(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 8;
	decoded = copy;
    }
}

ComplexityLimitation *ROSEapdus_ParameterType_Table_ParameterType::release_ComplexityLimitation()
{
    pdunum = 0;
    decoded = NULL;
    return get_ComplexityLimitation();
}

void ROSEapdus_ParameterType_Table_ParameterType::set_ComplexityLimitation(ComplexityLimitation *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 8;
    decoded = data;
}

Scope *ROSEapdus_ParameterType_Table_ParameterType::get_Scope()
{
    if (pdunum == 27)
	return (Scope *)decoded;
    else
	return NULL;
}

const Scope *ROSEapdus_ParameterType_Table_ParameterType::get_Scope() const
{
    if (pdunum == 27)
	return (const Scope *)decoded;
    else
	return NULL;
}

void ROSEapdus_ParameterType_Table_ParameterType::set_Scope(const Scope & data)
{
    void *copy;

    copy = new Scope(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 27;
	decoded = copy;
    }
}

Scope *ROSEapdus_ParameterType_Table_ParameterType::release_Scope()
{
    pdunum = 0;
    decoded = NULL;
    return get_Scope();
}

void ROSEapdus_ParameterType_Table_ParameterType::set_Scope(Scope *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 27;
    decoded = data;
}

InvalidArgumentValue *ROSEapdus_ParameterType_Table_ParameterType::get_InvalidArgumentValue()
{
    if (pdunum == 18)
	return (InvalidArgumentValue *)decoded;
    else
	return NULL;
}

const InvalidArgumentValue *ROSEapdus_ParameterType_Table_ParameterType::get_InvalidArgumentValue() const
{
    if (pdunum == 18)
	return (const InvalidArgumentValue *)decoded;
    else
	return NULL;
}

void ROSEapdus_ParameterType_Table_ParameterType::set_InvalidArgumentValue(const InvalidArgumentValue & data)
{
    void *copy;

    copy = new InvalidArgumentValue(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 18;
	decoded = copy;
    }
}

InvalidArgumentValue *ROSEapdus_ParameterType_Table_ParameterType::release_InvalidArgumentValue()
{
    pdunum = 0;
    decoded = NULL;
    return get_InvalidArgumentValue();
}

void ROSEapdus_ParameterType_Table_ParameterType::set_InvalidArgumentValue(InvalidArgumentValue *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 18;
    decoded = data;
}

CMISFilter *ROSEapdus_ParameterType_Table_ParameterType::get_CMISFilter()
{
    if (pdunum == 6)
	return (CMISFilter *)decoded;
    else
	return NULL;
}

const CMISFilter *ROSEapdus_ParameterType_Table_ParameterType::get_CMISFilter() const
{
    if (pdunum == 6)
	return (const CMISFilter *)decoded;
    else
	return NULL;
}

void ROSEapdus_ParameterType_Table_ParameterType::set_CMISFilter(const CMISFilter & data)
{
    void *copy;

    copy = new CMISFilter(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 6;
	decoded = copy;
    }
}

CMISFilter *ROSEapdus_ParameterType_Table_ParameterType::release_CMISFilter()
{
    pdunum = 0;
    decoded = NULL;
    return get_CMISFilter();
}

void ROSEapdus_ParameterType_Table_ParameterType::set_CMISFilter(CMISFilter *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 6;
    decoded = data;
}

NoSuchAction *ROSEapdus_ParameterType_Table_ParameterType::get_NoSuchAction()
{
    if (pdunum == 21)
	return (NoSuchAction *)decoded;
    else
	return NULL;
}

const NoSuchAction *ROSEapdus_ParameterType_Table_ParameterType::get_NoSuchAction() const
{
    if (pdunum == 21)
	return (const NoSuchAction *)decoded;
    else
	return NULL;
}

void ROSEapdus_ParameterType_Table_ParameterType::set_NoSuchAction(const NoSuchAction & data)
{
    void *copy;

    copy = new NoSuchAction(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 21;
	decoded = copy;
    }
}

NoSuchAction *ROSEapdus_ParameterType_Table_ParameterType::release_NoSuchAction()
{
    pdunum = 0;
    decoded = NULL;
    return get_NoSuchAction();
}

void ROSEapdus_ParameterType_Table_ParameterType::set_NoSuchAction(NoSuchAction *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 21;
    decoded = data;
}

NoSuchArgument *ROSEapdus_ParameterType_Table_ParameterType::get_NoSuchArgument()
{
    if (pdunum == 22)
	return (NoSuchArgument *)decoded;
    else
	return NULL;
}

const NoSuchArgument *ROSEapdus_ParameterType_Table_ParameterType::get_NoSuchArgument() const
{
    if (pdunum == 22)
	return (const NoSuchArgument *)decoded;
    else
	return NULL;
}

void ROSEapdus_ParameterType_Table_ParameterType::set_NoSuchArgument(const NoSuchArgument & data)
{
    void *copy;

    copy = new NoSuchArgument(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 22;
	decoded = copy;
    }
}

NoSuchArgument *ROSEapdus_ParameterType_Table_ParameterType::release_NoSuchArgument()
{
    pdunum = 0;
    decoded = NULL;
    return get_NoSuchArgument();
}

void ROSEapdus_ParameterType_Table_ParameterType::set_NoSuchArgument(NoSuchArgument *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 22;
    decoded = data;
}

__shared3 *ROSEapdus_ParameterType_Table_ParameterType::get_ObjectClass()
{
    if (pdunum == 24)
	return (__shared3 *)decoded;
    else
	return NULL;
}

const __shared3 *ROSEapdus_ParameterType_Table_ParameterType::get_ObjectClass() const
{
    if (pdunum == 24)
	return (const __shared3 *)decoded;
    else
	return NULL;
}

void ROSEapdus_ParameterType_Table_ParameterType::set_ObjectClass(const __shared3 & data)
{
    void *copy;

    copy = new ObjectClass(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 24;
	decoded = copy;
    }
}

__shared3 *ROSEapdus_ParameterType_Table_ParameterType::release_ObjectClass()
{
    pdunum = 0;
    decoded = NULL;
    return get_ObjectClass();
}

void ROSEapdus_ParameterType_Table_ParameterType::set_ObjectClass(__shared3 *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 24;
    decoded = data;
}

ObjectInstance *ROSEapdus_ParameterType_Table_ParameterType::get_ObjectInstance()
{
    if (pdunum == 25)
	return (ObjectInstance *)decoded;
    else
	return NULL;
}

const ObjectInstance *ROSEapdus_ParameterType_Table_ParameterType::get_ObjectInstance() const
{
    if (pdunum == 25)
	return (const ObjectInstance *)decoded;
    else
	return NULL;
}

void ROSEapdus_ParameterType_Table_ParameterType::set_ObjectInstance(const ObjectInstance & data)
{
    void *copy;

    copy = new ObjectInstance(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 25;
	decoded = copy;
    }
}

ObjectInstance *ROSEapdus_ParameterType_Table_ParameterType::release_ObjectInstance()
{
    pdunum = 0;
    decoded = NULL;
    return get_ObjectInstance();
}

void ROSEapdus_ParameterType_Table_ParameterType::set_ObjectInstance(ObjectInstance *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 25;
    decoded = data;
}

ProcessingFailure *ROSEapdus_ParameterType_Table_ParameterType::get_ProcessingFailure()
{
    if (pdunum == 26)
	return (ProcessingFailure *)decoded;
    else
	return NULL;
}

const ProcessingFailure *ROSEapdus_ParameterType_Table_ParameterType::get_ProcessingFailure() const
{
    if (pdunum == 26)
	return (const ProcessingFailure *)decoded;
    else
	return NULL;
}

void ROSEapdus_ParameterType_Table_ParameterType::set_ProcessingFailure(const ProcessingFailure & data)
{
    void *copy;

    copy = new ProcessingFailure(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 26;
	decoded = copy;
    }
}

ProcessingFailure *ROSEapdus_ParameterType_Table_ParameterType::release_ProcessingFailure()
{
    pdunum = 0;
    decoded = NULL;
    return get_ProcessingFailure();
}

void ROSEapdus_ParameterType_Table_ParameterType::set_ProcessingFailure(ProcessingFailure *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 26;
    decoded = data;
}

CMISSync *ROSEapdus_ParameterType_Table_ParameterType::get_CMISSync()
{
    if (pdunum == 7)
	return (CMISSync *)decoded;
    else
	return NULL;
}

const CMISSync *ROSEapdus_ParameterType_Table_ParameterType::get_CMISSync() const
{
    if (pdunum == 7)
	return (const CMISSync *)decoded;
    else
	return NULL;
}

void ROSEapdus_ParameterType_Table_ParameterType::set_CMISSync(const CMISSync & data)
{
    void *copy;

    copy = osscppMalloc(sizeof(CMISSync));
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	*(CMISSync *)copy = data;
	pdunum = 7;
	decoded = copy;
    }
}

CMISSync *ROSEapdus_ParameterType_Table_ParameterType::release_CMISSync()
{
    pdunum = 0;
    decoded = NULL;
    return get_CMISSync();
}

void ROSEapdus_ParameterType_Table_ParameterType::set_CMISSync(CMISSync *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 7;
    decoded = data;
}

__shared12 *ROSEapdus_ParameterType_Table_ParameterType::get_InvokeIDType()
{
    if (pdunum == 19)
	return (__shared12 *)decoded;
    else
	return NULL;
}

const __shared12 *ROSEapdus_ParameterType_Table_ParameterType::get_InvokeIDType() const
{
    if (pdunum == 19)
	return (const __shared12 *)decoded;
    else
	return NULL;
}

void ROSEapdus_ParameterType_Table_ParameterType::set_InvokeIDType(const __shared12 & data)
{
    void *copy;

    copy = new InvokeIDType(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 19;
	decoded = copy;
    }
}

__shared12 *ROSEapdus_ParameterType_Table_ParameterType::release_InvokeIDType()
{
    pdunum = 0;
    decoded = NULL;
    return get_InvokeIDType();
}

void ROSEapdus_ParameterType_Table_ParameterType::set_InvokeIDType(__shared12 *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 19;
    decoded = data;
}

Attribute *ROSEapdus_ParameterType_Table_ParameterType::get_Attribute()
{
    if (pdunum == 3)
	return (Attribute *)decoded;
    else
	return NULL;
}

const Attribute *ROSEapdus_ParameterType_Table_ParameterType::get_Attribute() const
{
    if (pdunum == 3)
	return (const Attribute *)decoded;
    else
	return NULL;
}

void ROSEapdus_ParameterType_Table_ParameterType::set_Attribute(const Attribute & data)
{
    void *copy;

    copy = new Attribute(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 3;
	decoded = copy;
    }
}

Attribute *ROSEapdus_ParameterType_Table_ParameterType::release_Attribute()
{
    pdunum = 0;
    decoded = NULL;
    return get_Attribute();
}

void ROSEapdus_ParameterType_Table_ParameterType::set_Attribute(Attribute *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 3;
    decoded = data;
}

__shared9 *ROSEapdus_ParameterType_Table_ParameterType::get_MissingAttributeValue_PARAMETER()
{
    if (pdunum == 65)
	return (__shared9 *)decoded;
    else
	return NULL;
}

const __shared9 *ROSEapdus_ParameterType_Table_ParameterType::get_MissingAttributeValue_PARAMETER() const
{
    if (pdunum == 65)
	return (const __shared9 *)decoded;
    else
	return NULL;
}

void ROSEapdus_ParameterType_Table_ParameterType::set_MissingAttributeValue_PARAMETER(const __shared9 & data)
{
    void *copy;

    copy = new MissingAttributeValue_PARAMETER(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 65;
	decoded = copy;
    }
}

__shared9 *ROSEapdus_ParameterType_Table_ParameterType::release_MissingAttributeValue_PARAMETER()
{
    pdunum = 0;
    decoded = NULL;
    return get_MissingAttributeValue_PARAMETER();
}

void ROSEapdus_ParameterType_Table_ParameterType::set_MissingAttributeValue_PARAMETER(__shared9 *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 65;
    decoded = data;
}

__shared3 *ROSEapdus_ParameterType_Table_ParameterType::get_AttributeId()
{
    if (pdunum == 4)
	return (__shared3 *)decoded;
    else
	return NULL;
}

const __shared3 *ROSEapdus_ParameterType_Table_ParameterType::get_AttributeId() const
{
    if (pdunum == 4)
	return (const __shared3 *)decoded;
    else
	return NULL;
}

void ROSEapdus_ParameterType_Table_ParameterType::set_AttributeId(const __shared3 & data)
{
    void *copy;

    copy = new AttributeId(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 4;
	decoded = copy;
    }
}

__shared3 *ROSEapdus_ParameterType_Table_ParameterType::release_AttributeId()
{
    pdunum = 0;
    decoded = NULL;
    return get_AttributeId();
}

void ROSEapdus_ParameterType_Table_ParameterType::set_AttributeId(__shared3 *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 4;
    decoded = data;
}

NoSuchEventType *ROSEapdus_ParameterType_Table_ParameterType::get_NoSuchEventType()
{
    if (pdunum == 23)
	return (NoSuchEventType *)decoded;
    else
	return NULL;
}

const NoSuchEventType *ROSEapdus_ParameterType_Table_ParameterType::get_NoSuchEventType() const
{
    if (pdunum == 23)
	return (const NoSuchEventType *)decoded;
    else
	return NULL;
}

void ROSEapdus_ParameterType_Table_ParameterType::set_NoSuchEventType(const NoSuchEventType & data)
{
    void *copy;

    copy = new NoSuchEventType(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 23;
	decoded = copy;
    }
}

NoSuchEventType *ROSEapdus_ParameterType_Table_ParameterType::release_NoSuchEventType()
{
    pdunum = 0;
    decoded = NULL;
    return get_NoSuchEventType();
}

void ROSEapdus_ParameterType_Table_ParameterType::set_NoSuchEventType(NoSuchEventType *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 23;
    decoded = data;
}

GetListError *ROSEapdus_ParameterType_Table_ParameterType::get_GetListError()
{
    if (pdunum == 16)
	return (GetListError *)decoded;
    else
	return NULL;
}

const GetListError *ROSEapdus_ParameterType_Table_ParameterType::get_GetListError() const
{
    if (pdunum == 16)
	return (const GetListError *)decoded;
    else
	return NULL;
}

void ROSEapdus_ParameterType_Table_ParameterType::set_GetListError(const GetListError & data)
{
    void *copy;

    copy = new GetListError(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 16;
	decoded = copy;
    }
}

GetListError *ROSEapdus_ParameterType_Table_ParameterType::release_GetListError()
{
    pdunum = 0;
    decoded = NULL;
    return get_GetListError();
}

void ROSEapdus_ParameterType_Table_ParameterType::set_GetListError(GetListError *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 16;
    decoded = data;
}

SetListError *ROSEapdus_ParameterType_Table_ParameterType::get_SetListError()
{
    if (pdunum == 29)
	return (SetListError *)decoded;
    else
	return NULL;
}

const SetListError *ROSEapdus_ParameterType_Table_ParameterType::get_SetListError() const
{
    if (pdunum == 29)
	return (const SetListError *)decoded;
    else
	return NULL;
}

void ROSEapdus_ParameterType_Table_ParameterType::set_SetListError(const SetListError & data)
{
    void *copy;

    copy = new SetListError(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 29;
	decoded = copy;
    }
}

SetListError *ROSEapdus_ParameterType_Table_ParameterType::release_SetListError()
{
    pdunum = 0;
    decoded = NULL;
    return get_SetListError();
}

void ROSEapdus_ParameterType_Table_ParameterType::set_SetListError(SetListError *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 29;
    decoded = data;
}

void ROSEapdus_ParameterType_Table_ParameterType::cleanup_decoded()
{
    if (pdunum && decoded) {
	SMASE_A_ASSOCIATE_Information_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *__seq6::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq6::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq6::__seq6() {
    memset(this, 0, sizeof(__seq6));
}

__seq6::__seq6(const __seq6 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	invokeId_field = that.invokeId_field;
	linkedId_field = that.linkedId_field;
	opcode_field = that.opcode_field;
	argument_field = that.argument_field;
    } OSSCLEAN(__seq6)
}

__seq6::__seq6(const invokeId & invokeId_val, const linkedId & linkedId_val, const opcode & opcode_val, 
    const argument & argument_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	invokeId_field = invokeId_val;
	linkedId_field = linkedId_val;
	opcode_field = opcode_val;
	argument_field = argument_val;
    } OSSCLEAN(__seq6)
}

__seq6::__seq6(const invokeId & invokeId_val, const opcode & opcode_val) {
    OSSTRY {
	bit_mask = 0;
	invokeId_field = invokeId_val;
	opcode_field = opcode_val;
    } OSSCLEAN(__seq6)
}

__seq6 & __seq6::operator = (const __seq6 & that) {
    if (this == &that)
	return *this;
    this->~__seq6();
    bit_mask = that.bit_mask;
    invokeId_field = that.invokeId_field;
    linkedId_field = that.linkedId_field;
    opcode_field = that.opcode_field;
    argument_field = that.argument_field;
    return *this;
}

int __seq6::operator == (const __seq6 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (invokeId_field != that.invokeId_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (linkedId_field != that.linkedId_field)
	    return 0;
    }
    if (opcode_field != that.opcode_field)
	return 0;
    if (bit_mask & 0x40000000) {
	if (argument_field != that.argument_field)
	    return 0;
    }
    return 1;
}

int __seq6::operator != (const __seq6 & that) const {
    return !(operator ==(that));
}

__seq6::invokeId & __seq6::get_invokeId() {
    return invokeId_field;
}

const __seq6::invokeId & __seq6::get_invokeId() const {
    return invokeId_field;
}

void __seq6::set_invokeId(const invokeId & invokeId_val) {
    invokeId_field = invokeId_val;
}

__seq6::linkedId *__seq6::get_linkedId() {
    if (bit_mask & 0x80000000)
	return &linkedId_field;
    else
	return 0;
}

const __seq6::linkedId *__seq6::get_linkedId() const {
    if (bit_mask & 0x80000000)
	return &linkedId_field;
    else
	return 0;
}

void __seq6::set_linkedId(const linkedId & linkedId_val) {
    bit_mask |= 0x80000000;
    linkedId_field = linkedId_val;
}

int __seq6::linkedId_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void __seq6::omit_linkedId() {
    linkedId_field.~__shared12();
    bit_mask &= ~0x80000000;
}

__seq6::opcode & __seq6::get_opcode() {
    return opcode_field;
}

const __seq6::opcode & __seq6::get_opcode() const {
    return opcode_field;
}

void __seq6::set_opcode(const opcode & opcode_val) {
    opcode_field = opcode_val;
}

__seq6::argument *__seq6::get_argument() {
    if (bit_mask & 0x40000000)
	return &argument_field;
    else
	return 0;
}

const __seq6::argument *__seq6::get_argument() const {
    if (bit_mask & 0x40000000)
	return &argument_field;
    else
	return 0;
}

void __seq6::set_argument(const argument & argument_val) {
    bit_mask |= 0x40000000;
    argument_field = argument_val;
}

int __seq6::argument_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void __seq6::omit_argument() {
    argument_field.~CMIP_Operations_ArgumentType();
    bit_mask &= ~0x40000000;
}

void *__seq5::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq5::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq5::__seq5() {
    memset(this, 0, sizeof(__seq5));
}

__seq5::__seq5(const __seq5 & that) {
    OSSTRY {
	opcode_field = that.opcode_field;
	result_field = that.result_field;
    } OSSCLEAN(__seq5)
}

__seq5::__seq5(const opcode & opcode_val, const result & result_val) {
    OSSTRY {
	opcode_field = opcode_val;
	result_field = result_val;
    } OSSCLEAN(__seq5)
}

__seq5 & __seq5::operator = (const __seq5 & that) {
    if (this == &that)
	return *this;
    opcode_field = that.opcode_field;
    result_field = that.result_field;
    return *this;
}

int __seq5::operator == (const __seq5 & that) const {
    if (opcode_field != that.opcode_field)
	return 0;
    if (result_field != that.result_field)
	return 0;
    return 1;
}

int __seq5::operator != (const __seq5 & that) const {
    return !(operator ==(that));
}

__seq5::opcode & __seq5::get_opcode() {
    return opcode_field;
}

const __seq5::opcode & __seq5::get_opcode() const {
    return opcode_field;
}

void __seq5::set_opcode(const opcode & opcode_val) {
    opcode_field = opcode_val;
}

__seq5::result & __seq5::get_result() {
    return result_field;
}

const __seq5::result & __seq5::get_result() const {
    return result_field;
}

void __seq5::set_result(const result & result_val) {
    result_field = result_val;
}

void *__seq7::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq7::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq7::__seq7() {
    memset(this, 0, sizeof(__seq7));
}

__seq7::__seq7(const __seq7 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	invokeId_field = that.invokeId_field;
	result_field = that.result_field;
    } OSSCLEAN(__seq7)
}

__seq7::__seq7(const invokeId & invokeId_val, const result & result_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	invokeId_field = invokeId_val;
	result_field = result_val;
    } OSSCLEAN(__seq7)
}

__seq7::__seq7(const invokeId & invokeId_val) {
    OSSTRY {
	bit_mask = 0;
	invokeId_field = invokeId_val;
    } OSSCLEAN(__seq7)
}

__seq7 & __seq7::operator = (const __seq7 & that) {
    if (this == &that)
	return *this;
    this->~__seq7();
    bit_mask = that.bit_mask;
    invokeId_field = that.invokeId_field;
    result_field = that.result_field;
    return *this;
}

int __seq7::operator == (const __seq7 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (invokeId_field != that.invokeId_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (result_field != that.result_field)
	    return 0;
    }
    return 1;
}

int __seq7::operator != (const __seq7 & that) const {
    return !(operator ==(that));
}

__seq7::invokeId & __seq7::get_invokeId() {
    return invokeId_field;
}

const __seq7::invokeId & __seq7::get_invokeId() const {
    return invokeId_field;
}

void __seq7::set_invokeId(const invokeId & invokeId_val) {
    invokeId_field = invokeId_val;
}

__seq7::result *__seq7::get_result() {
    if (bit_mask & 0x80000000)
	return &result_field;
    else
	return 0;
}

const __seq7::result *__seq7::get_result() const {
    if (bit_mask & 0x80000000)
	return &result_field;
    else
	return 0;
}

void __seq7::set_result(const result & result_val) {
    bit_mask |= 0x80000000;
    result_field = result_val;
}

int __seq7::result_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void __seq7::omit_result() {
    result_field.~__seq5();
    bit_mask &= ~0x80000000;
}

void *__seq8::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq8::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq8::__seq8() {
    memset(this, 0, sizeof(__seq8));
}

__seq8::__seq8(const __seq8 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	invokeId_field = that.invokeId_field;
	errcode_field = that.errcode_field;
	parameter_field = that.parameter_field;
    } OSSCLEAN(__seq8)
}

__seq8::__seq8(const invokeId & invokeId_val, const errcode & errcode_val, const parameter & parameter_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	invokeId_field = invokeId_val;
	errcode_field = errcode_val;
	parameter_field = parameter_val;
    } OSSCLEAN(__seq8)
}

__seq8::__seq8(const invokeId & invokeId_val, const errcode & errcode_val) {
    OSSTRY {
	bit_mask = 0;
	invokeId_field = invokeId_val;
	errcode_field = errcode_val;
    } OSSCLEAN(__seq8)
}

__seq8 & __seq8::operator = (const __seq8 & that) {
    if (this == &that)
	return *this;
    this->~__seq8();
    bit_mask = that.bit_mask;
    invokeId_field = that.invokeId_field;
    errcode_field = that.errcode_field;
    parameter_field = that.parameter_field;
    return *this;
}

int __seq8::operator == (const __seq8 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (invokeId_field != that.invokeId_field)
	return 0;
    if (errcode_field != that.errcode_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (parameter_field != that.parameter_field)
	    return 0;
    }
    return 1;
}

int __seq8::operator != (const __seq8 & that) const {
    return !(operator ==(that));
}

__seq8::invokeId & __seq8::get_invokeId() {
    return invokeId_field;
}

const __seq8::invokeId & __seq8::get_invokeId() const {
    return invokeId_field;
}

void __seq8::set_invokeId(const invokeId & invokeId_val) {
    invokeId_field = invokeId_val;
}

__seq8::errcode & __seq8::get_errcode() {
    return errcode_field;
}

const __seq8::errcode & __seq8::get_errcode() const {
    return errcode_field;
}

void __seq8::set_errcode(const errcode & errcode_val) {
    errcode_field = errcode_val;
}

__seq8::parameter *__seq8::get_parameter() {
    if (bit_mask & 0x80000000)
	return &parameter_field;
    else
	return 0;
}

const __seq8::parameter *__seq8::get_parameter() const {
    if (bit_mask & 0x80000000)
	return &parameter_field;
    else
	return 0;
}

void __seq8::set_parameter(const parameter & parameter_val) {
    bit_mask |= 0x80000000;
    parameter_field = parameter_val;
}

int __seq8::parameter_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void __seq8::omit_parameter() {
    parameter_field.~ROSEapdus_ParameterType_Table_ParameterType();
    bit_mask &= ~0x80000000;
}

__choice6::__choice6() {
    memset(this, 0, sizeof(__choice6));
}

__choice6::__choice6(const __choice6 & that) {
    memset(this, 0, sizeof(__choice6));
    operator =(that);
}

__choice6 & __choice6::operator = (const __choice6 & that) {
    if (this == &that)
	return *this;
    _choice = that._choice;
    switch (_choice) {
	case general_chosen:
	    *(general *)&general_field = *(general *)&that.general_field;
	    break;
	case invoke_chosen:
	    *(invoke *)&invoke_field = *(invoke *)&that.invoke_field;
	    break;
	case returnResult_chosen:
	    *(returnResult *)&returnResult_field = *(returnResult *)&that.returnResult_field;
	    break;
	case returnError_chosen:
	    *(returnError *)&returnError_field = *(returnError *)&that.returnError_field;
	    break;
    }
    return *this;
}

int __choice6::operator == (const __choice6 & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case general_chosen:
	    return *(general *)&general_field == *(general *)&that.general_field;
	case invoke_chosen:
	    return *(invoke *)&invoke_field == *(invoke *)&that.invoke_field;
	case returnResult_chosen:
	    return *(returnResult *)&returnResult_field == *(returnResult *)&that.returnResult_field;
	case returnError_chosen:
	    return *(returnError *)&returnError_field == *(returnError *)&that.returnError_field;
    }

    return 1;
}

int __choice6::operator != (const __choice6 & that) const {
    return !(operator ==(that));
}

__choice6::general *__choice6::get_general() {
    if (_choice == general_chosen)
	return (general *)&general_field;
    else
	return 0;
}

const __choice6::general *__choice6::get_general() const {
    if (_choice == general_chosen)
	return (const general *)&general_field;
    else
	return 0;
}

void __choice6::set_general(general general_val) {
    *(general *)&general_field = general_val;
    _choice = general_chosen;
}

__choice6::invoke *__choice6::get_invoke() {
    if (_choice == invoke_chosen)
	return (invoke *)&invoke_field;
    else
	return 0;
}

const __choice6::invoke *__choice6::get_invoke() const {
    if (_choice == invoke_chosen)
	return (const invoke *)&invoke_field;
    else
	return 0;
}

void __choice6::set_invoke(invoke invoke_val) {
    *(invoke *)&invoke_field = invoke_val;
    _choice = invoke_chosen;
}

__choice6::returnResult *__choice6::get_returnResult() {
    if (_choice == returnResult_chosen)
	return (returnResult *)&returnResult_field;
    else
	return 0;
}

const __choice6::returnResult *__choice6::get_returnResult() const {
    if (_choice == returnResult_chosen)
	return (const returnResult *)&returnResult_field;
    else
	return 0;
}

void __choice6::set_returnResult(returnResult returnResult_val) {
    *(returnResult *)&returnResult_field = returnResult_val;
    _choice = returnResult_chosen;
}

__choice6::returnError *__choice6::get_returnError() {
    if (_choice == returnError_chosen)
	return (returnError *)&returnError_field;
    else
	return 0;
}

const __choice6::returnError *__choice6::get_returnError() const {
    if (_choice == returnError_chosen)
	return (const returnError *)&returnError_field;
    else
	return 0;
}

void __choice6::set_returnError(returnError returnError_val) {
    *(returnError *)&returnError_field = returnError_val;
    _choice = returnError_chosen;
}

void *__shared13::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared13::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared13::__shared13() {
    memset(this, 0, sizeof(__shared13));
}

__shared13::__shared13(const __shared13 & that) {
    OSSTRY {
	invokeId_field = that.invokeId_field;
	problem_field = that.problem_field;
    } OSSCLEAN(__shared13)
}

__shared13::__shared13(const invokeId & invokeId_val, const problem & problem_val) {
    OSSTRY {
	invokeId_field = invokeId_val;
	problem_field = problem_val;
    } OSSCLEAN(__shared13)
}

__shared13 & __shared13::operator = (const __shared13 & that) {
    if (this == &that)
	return *this;
    invokeId_field = that.invokeId_field;
    problem_field = that.problem_field;
    return *this;
}

int __shared13::operator == (const __shared13 & that) const {
    if (invokeId_field != that.invokeId_field)
	return 0;
    if (problem_field != that.problem_field)
	return 0;
    return 1;
}

int __shared13::operator != (const __shared13 & that) const {
    return !(operator ==(that));
}

__shared13::invokeId & __shared13::get_invokeId() {
    return invokeId_field;
}

const __shared13::invokeId & __shared13::get_invokeId() const {
    return invokeId_field;
}

void __shared13::set_invokeId(const invokeId & invokeId_val) {
    invokeId_field = invokeId_val;
}

__shared13::problem & __shared13::get_problem() {
    return problem_field;
}

const __shared13::problem & __shared13::get_problem() const {
    return problem_field;
}

void __shared13::set_problem(const problem & problem_val) {
    problem_field = problem_val;
}

ROSEapdus::ROSEapdus() {
    memset(this, 0, sizeof(ROSEapdus));
}

ROSEapdus::ROSEapdus(const ROSEapdus & that) {
    memset(this, 0, sizeof(ROSEapdus));
    operator =(that);
}

ROSEapdus::~ROSEapdus() {
    cleanup();
}

ROSEapdus & ROSEapdus::operator = (const ROSEapdus & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case invoke_chosen:
	    if (that.invoke_field)
		invoke_field = new invoke(*that.invoke_field);
	    break;
	case returnResult_chosen:
	    if (that.returnResult_field)
		returnResult_field = new returnResult(*that.returnResult_field);
	    break;
	case returnError_chosen:
	    if (that.returnError_field)
		returnError_field = new returnError(*that.returnError_field);
	    break;
	case reject_chosen:
	    if (that.reject_field)
		reject_field = new reject(*that.reject_field);
	    break;
    }
    return *this;
}

int ROSEapdus::operator == (const ROSEapdus & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case invoke_chosen:
	    if ((invoke_field) && (that.invoke_field))
		return (*invoke_field == *(that.invoke_field));
	    else if (!((!invoke_field) && (!that.invoke_field)))
		return 0;
	    break;
	case returnResult_chosen:
	    if ((returnResult_field) && (that.returnResult_field))
		return (*returnResult_field == *(that.returnResult_field));
	    else if (!((!returnResult_field) && (!that.returnResult_field)))
		return 0;
	    break;
	case returnError_chosen:
	    if ((returnError_field) && (that.returnError_field))
		return (*returnError_field == *(that.returnError_field));
	    else if (!((!returnError_field) && (!that.returnError_field)))
		return 0;
	    break;
	case reject_chosen:
	    if ((reject_field) && (that.reject_field))
		return (*reject_field == *(that.reject_field));
	    else if (!((!reject_field) && (!that.reject_field)))
		return 0;
	    break;
    }

    return 1;
}

int ROSEapdus::operator != (const ROSEapdus & that) const {
    return !(operator ==(that));
}

ROSEapdus::invoke *ROSEapdus::get_invoke() {
    if (_choice == invoke_chosen)
	return (invoke *)invoke_field;
    else
	return 0;
}

const ROSEapdus::invoke *ROSEapdus::get_invoke() const {
    if (_choice == invoke_chosen)
	return (const invoke *)invoke_field;
    else
	return 0;
}

void ROSEapdus::set_invoke(const invoke & invoke_val) {
    cleanup();
    invoke_field = new invoke(invoke_val);
    _choice = invoke_chosen;
}

ROSEapdus::returnResult *ROSEapdus::get_returnResult() {
    if (_choice == returnResult_chosen)
	return (returnResult *)returnResult_field;
    else
	return 0;
}

const ROSEapdus::returnResult *ROSEapdus::get_returnResult() const {
    if (_choice == returnResult_chosen)
	return (const returnResult *)returnResult_field;
    else
	return 0;
}

void ROSEapdus::set_returnResult(const returnResult & returnResult_val) {
    cleanup();
    returnResult_field = new returnResult(returnResult_val);
    _choice = returnResult_chosen;
}

ROSEapdus::returnError *ROSEapdus::get_returnError() {
    if (_choice == returnError_chosen)
	return (returnError *)returnError_field;
    else
	return 0;
}

const ROSEapdus::returnError *ROSEapdus::get_returnError() const {
    if (_choice == returnError_chosen)
	return (const returnError *)returnError_field;
    else
	return 0;
}

void ROSEapdus::set_returnError(const returnError & returnError_val) {
    cleanup();
    returnError_field = new returnError(returnError_val);
    _choice = returnError_chosen;
}

ROSEapdus::reject *ROSEapdus::get_reject() {
    if (_choice == reject_chosen)
	return (reject *)reject_field;
    else
	return 0;
}

const ROSEapdus::reject *ROSEapdus::get_reject() const {
    if (_choice == reject_chosen)
	return (const reject *)reject_field;
    else
	return 0;
}

void ROSEapdus::set_reject(const reject & reject_val) {
    cleanup();
    reject_field = new reject(reject_val);
    _choice = reject_chosen;
}

void ROSEapdus::cleanup() {
    switch (_choice) {
	case invoke_chosen:
	    if (invoke_field)
		delete invoke_field;
	    break;
	case returnResult_chosen:
	    if (returnResult_field)
		delete returnResult_field;
	    break;
	case returnError_chosen:
	    if (returnError_field)
		delete returnError_field;
	    break;
	case reject_chosen:
	    if (reject_field)
		delete reject_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

void *CMIPAbortInfo::operator new(size_t size) {
    return ossNewFunc(size);
}

void CMIPAbortInfo::operator delete(void *ptr) {
    asn1Free(ptr);
}

CMIPAbortInfo::CMIPAbortInfo() {
    memset(this, 0, sizeof(CMIPAbortInfo));
}

CMIPAbortInfo::CMIPAbortInfo(const CMIPAbortInfo & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	abortSource_field = that.abortSource_field;
	userInfo_field = that.userInfo_field;
    } OSSCLEAN(CMIPAbortInfo)
}

CMIPAbortInfo::CMIPAbortInfo(abortSource abortSource_val, const userInfo & userInfo_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	abortSource_field = abortSource_val;
	userInfo_field = userInfo_val;
    } OSSCLEAN(CMIPAbortInfo)
}

CMIPAbortInfo::CMIPAbortInfo(abortSource abortSource_val) {
    OSSTRY {
	bit_mask = 0;
	abortSource_field = abortSource_val;
    } OSSCLEAN(CMIPAbortInfo)
}

CMIPAbortInfo & CMIPAbortInfo::operator = (const CMIPAbortInfo & that) {
    if (this == &that)
	return *this;
    this->~CMIPAbortInfo();
    bit_mask = that.bit_mask;
    abortSource_field = that.abortSource_field;
    userInfo_field = that.userInfo_field;
    return *this;
}

int CMIPAbortInfo::operator == (const CMIPAbortInfo & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (abortSource_field != that.abortSource_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (userInfo_field != that.userInfo_field)
	    return 0;
    }
    return 1;
}

int CMIPAbortInfo::operator != (const CMIPAbortInfo & that) const {
    return !(operator ==(that));
}

CMIPAbortInfo::abortSource & CMIPAbortInfo::get_abortSource() {
    return abortSource_field;
}

CMIPAbortInfo::abortSource CMIPAbortInfo::get_abortSource() const {
    return abortSource_field;
}

void CMIPAbortInfo::set_abortSource(abortSource abortSource_val) {
    abortSource_field = abortSource_val;
}

CMIPAbortInfo::userInfo *CMIPAbortInfo::get_userInfo() {
    if (bit_mask & 0x80000000)
	return &userInfo_field;
    else
	return 0;
}

const CMIPAbortInfo::userInfo *CMIPAbortInfo::get_userInfo() const {
    if (bit_mask & 0x80000000)
	return &userInfo_field;
    else
	return 0;
}

void CMIPAbortInfo::set_userInfo(const userInfo & userInfo_val) {
    bit_mask |= 0x80000000;
    userInfo_field = userInfo_val;
}

int CMIPAbortInfo::userInfo_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void CMIPAbortInfo::omit_userInfo() {
    userInfo_field.~__shared2();
    bit_mask &= ~0x80000000;
}

void *CMIPUserInfo::operator new(size_t size) {
    return ossNewFunc(size);
}

void CMIPUserInfo::operator delete(void *ptr) {
    asn1Free(ptr);
}

const OssBitString& CMIPUserInfo::get_default_protocolVersion() {
    return CMIPUserInfo::default_protocolVersion;
}

const OssBitString& CMIPUserInfo::get_default_functionalUnits() {
    return CMIPUserInfo::default_functionalUnits;
}

CMIPUserInfo::CMIPUserInfo() {
    memset(this, 0, sizeof(CMIPUserInfo));
}

CMIPUserInfo::CMIPUserInfo(const CMIPUserInfo & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	if (bit_mask & 0x80000000)
	    protocolVersion_field = that.protocolVersion_field;
	if (bit_mask & 0x40000000)
	    functionalUnits_field = that.functionalUnits_field;
	accessControl_field = that.accessControl_field;
	userInfo_field = that.userInfo_field;
    } OSSCLEAN(CMIPUserInfo)
}

CMIPUserInfo::CMIPUserInfo(const protocolVersion & protocolVersion_val, const functionalUnits & functionalUnits_val, 
    const accessControl & accessControl_val, const userInfo & userInfo_val) {
    OSSTRY {
	bit_mask = 0xf0000000;
	protocolVersion_field = protocolVersion_val;
	functionalUnits_field = functionalUnits_val;
	accessControl_field = accessControl_val;
	userInfo_field = userInfo_val;
    } OSSCLEAN(CMIPUserInfo)
}

CMIPUserInfo::~CMIPUserInfo() {
    if (!(bit_mask & 0x80000000))
	memset(&protocolVersion_field, 0, sizeof(protocolVersion));
    if (!(bit_mask & 0x40000000))
	memset(&functionalUnits_field, 0, sizeof(functionalUnits));
}

CMIPUserInfo & CMIPUserInfo::operator = (const CMIPUserInfo & that) {
    if (this == &that)
	return *this;
    this->~CMIPUserInfo();
    bit_mask = that.bit_mask;
    if (bit_mask & 0x80000000)
	protocolVersion_field = that.protocolVersion_field;
    if (bit_mask & 0x40000000)
	functionalUnits_field = that.functionalUnits_field;
    accessControl_field = that.accessControl_field;
    userInfo_field = that.userInfo_field;
    return *this;
}

int CMIPUserInfo::operator == (const CMIPUserInfo & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (protocolVersion_field != that.protocolVersion_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (functionalUnits_field != that.functionalUnits_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (accessControl_field != that.accessControl_field)
	    return 0;
    }
    if (bit_mask & 0x10000000) {
	if (userInfo_field != that.userInfo_field)
	    return 0;
    }
    return 1;
}

int CMIPUserInfo::operator != (const CMIPUserInfo & that) const {
    return !(operator ==(that));
}

CMIPUserInfo::protocolVersion *CMIPUserInfo::get_protocolVersion() {
    if (bit_mask & 0x80000000)
	return &protocolVersion_field;
    else
	return 0;
}

const CMIPUserInfo::protocolVersion *CMIPUserInfo::get_protocolVersion() const {
    if (bit_mask & 0x80000000)
	return &protocolVersion_field;
    else
	return 0;
}

void CMIPUserInfo::set_protocolVersion(const protocolVersion & protocolVersion_val) {
    if (!(bit_mask & 0x80000000)) {
	memset(&protocolVersion_field, 0, sizeof(protocolVersion));
	bit_mask |= 0x80000000;
    }
    protocolVersion_field = protocolVersion_val;
}

int CMIPUserInfo::protocolVersion_is_default() const {
    return !(bit_mask & 0x80000000);
}

void CMIPUserInfo::set_default_protocolVersion() {
    if (bit_mask & 0x80000000) {
	protocolVersion_field.~OssBitString();
	bit_mask &= ~0x80000000;
    }
}

CMIPUserInfo::functionalUnits *CMIPUserInfo::get_functionalUnits() {
    if (bit_mask & 0x40000000)
	return &functionalUnits_field;
    else
	return 0;
}

const CMIPUserInfo::functionalUnits *CMIPUserInfo::get_functionalUnits() const {
    if (bit_mask & 0x40000000)
	return &functionalUnits_field;
    else
	return 0;
}

void CMIPUserInfo::set_functionalUnits(const functionalUnits & functionalUnits_val) {
    if (!(bit_mask & 0x40000000)) {
	memset(&functionalUnits_field, 0, sizeof(functionalUnits));
	bit_mask |= 0x40000000;
    }
    functionalUnits_field = functionalUnits_val;
}

int CMIPUserInfo::functionalUnits_is_default() const {
    return !(bit_mask & 0x40000000);
}

void CMIPUserInfo::set_default_functionalUnits() {
    if (bit_mask & 0x40000000) {
	functionalUnits_field.~OssBitString();
	bit_mask &= ~0x40000000;
    }
}

CMIPUserInfo::accessControl *CMIPUserInfo::get_accessControl() {
    if (bit_mask & 0x20000000)
	return &accessControl_field;
    else
	return 0;
}

const CMIPUserInfo::accessControl *CMIPUserInfo::get_accessControl() const {
    if (bit_mask & 0x20000000)
	return &accessControl_field;
    else
	return 0;
}

void CMIPUserInfo::set_accessControl(const accessControl & accessControl_val) {
    bit_mask |= 0x20000000;
    accessControl_field = accessControl_val;
}

int CMIPUserInfo::accessControl_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void CMIPUserInfo::omit_accessControl() {
    accessControl_field.~__shared2();
    bit_mask &= ~0x20000000;
}

CMIPUserInfo::userInfo *CMIPUserInfo::get_userInfo() {
    if (bit_mask & 0x10000000)
	return &userInfo_field;
    else
	return 0;
}

const CMIPUserInfo::userInfo *CMIPUserInfo::get_userInfo() const {
    if (bit_mask & 0x10000000)
	return &userInfo_field;
    else
	return 0;
}

void CMIPUserInfo::set_userInfo(const userInfo & userInfo_val) {
    bit_mask |= 0x10000000;
    userInfo_field = userInfo_val;
}

int CMIPUserInfo::userInfo_is_present() const {
    return !!(bit_mask & 0x10000000);
}

void CMIPUserInfo::omit_userInfo() {
    userInfo_field.~__shared2();
    bit_mask &= ~0x10000000;
}

/* Auxiliary data structures and functions for class __shared14 */

class __shared14_member {
public:
    __shared14_member *next;
    __shared14::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
};

void *__shared14_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared14_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

static void *__shared14_copy(void *that) {
    __shared14_member *result = new __shared14_member;
    if (result)
	result->value = ((__shared14_member *)that)->value;
    return result;
}

static void __shared14_destroy(void *that) {
    delete (__shared14_member *)that;
}

static int __shared14_compare(void *val1, void *val2) {
    return (((__shared14_member *)val1)->value == ((__shared14_member *)val2)->value);
}

/* Constructors */

__shared14::__shared14() {
}

__shared14::__shared14(const __shared14 & that) {
    OSSTRY {
	do_copy(that, &__shared14_copy);
    } OSSCLEAN(__shared14)
}

/* Destructor */

__shared14::~__shared14() {
    do_destroy(&__shared14_destroy);
}

/* Operators: assignment, equality, inequality */

__shared14 & __shared14::operator = (const __shared14 & that) {
    do_destroy(&__shared14_destroy);
    do_copy(that, &__shared14_copy);
    return *this;
}

int __shared14::operator == (const __shared14 & that) const {
    return do_compare(that, &__shared14_compare);
}

int __shared14::operator != (const __shared14 & that) const {
    return !do_compare(that, &__shared14_compare);
}

/* Locate ("At" etc) methods */

__shared14::component *__shared14::at(OssIndex pos) {
    return &((__shared14_member *)pos)->value;
}

const __shared14::component *__shared14::at(OssIndex pos) const {
    return &((__shared14_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared14::prepend(component val) {
    __shared14_member *newrec = new __shared14_member();
    if (!newrec)
	return OSS_NOINDEX;
    newrec->value = val;
    return do_prepend(newrec);
}

OssIndex __shared14::prepend(__shared14 *seq) {
    return do_prepend(seq);
}

OssIndex __shared14::insert_after(OssIndex pos, component val) {
    __shared14_member *newrec = new __shared14_member();
    if (!newrec)
	return OSS_NOINDEX;
    newrec->value = val;
    return do_insert_after(pos, newrec);
}

OssIndex __shared14::insert_after(OssIndex pos, __shared14 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared14::remove_front() {
    __shared14_member *extr = (__shared14_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared14_destroy(extr);
    return 0;
}

int __shared14::remove_after(OssIndex pos) {
    __shared14_member *extr = (__shared14_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared14_destroy(extr);
    return 0;
}

/* Extract methods */

__shared14 *__shared14::extract_after(OssIndex begin, OssIndex end) {
    return (__shared14 *)do_extract_after(begin, end);
}

void *FunctionalUnitPackage::operator new(size_t size) {
    return ossNewFunc(size);
}

void FunctionalUnitPackage::operator delete(void *ptr) {
    asn1Free(ptr);
}

const OssBitString& FunctionalUnitPackage::get_default_managerRoleFunctionalUnit() {
    return FunctionalUnitPackage::default_managerRoleFunctionalUnit;
}

const OssBitString& FunctionalUnitPackage::get_default_agentRoleFunctionalUnit() {
    return FunctionalUnitPackage::default_agentRoleFunctionalUnit;
}

FunctionalUnitPackage::FunctionalUnitPackage() {
    memset(this, 0, sizeof(FunctionalUnitPackage));
}

FunctionalUnitPackage::FunctionalUnitPackage(const FunctionalUnitPackage & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	functionalUnitPackageId_field = that.functionalUnitPackageId_field;
	if (bit_mask & 0x80000000)
	    managerRoleFunctionalUnit_field = that.managerRoleFunctionalUnit_field;
	if (bit_mask & 0x40000000)
	    agentRoleFunctionalUnit_field = that.agentRoleFunctionalUnit_field;
    } OSSCLEAN(FunctionalUnitPackage)
}

FunctionalUnitPackage::FunctionalUnitPackage(const functionalUnitPackageId & functionalUnitPackageId_val, 
    const managerRoleFunctionalUnit & managerRoleFunctionalUnit_val, const agentRoleFunctionalUnit & agentRoleFunctionalUnit_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	functionalUnitPackageId_field = functionalUnitPackageId_val;
	managerRoleFunctionalUnit_field = managerRoleFunctionalUnit_val;
	agentRoleFunctionalUnit_field = agentRoleFunctionalUnit_val;
    } OSSCLEAN(FunctionalUnitPackage)
}

FunctionalUnitPackage::FunctionalUnitPackage(const functionalUnitPackageId & functionalUnitPackageId_val) {
    OSSTRY {
	bit_mask = 0;
	functionalUnitPackageId_field = functionalUnitPackageId_val;
    } OSSCLEAN(FunctionalUnitPackage)
}

FunctionalUnitPackage::~FunctionalUnitPackage() {
    if (!(bit_mask & 0x80000000))
	memset(&managerRoleFunctionalUnit_field, 0, sizeof(managerRoleFunctionalUnit));
    if (!(bit_mask & 0x40000000))
	memset(&agentRoleFunctionalUnit_field, 0, sizeof(agentRoleFunctionalUnit));
}

FunctionalUnitPackage & FunctionalUnitPackage::operator = (const FunctionalUnitPackage & that) {
    if (this == &that)
	return *this;
    this->~FunctionalUnitPackage();
    bit_mask = that.bit_mask;
    functionalUnitPackageId_field = that.functionalUnitPackageId_field;
    if (bit_mask & 0x80000000)
	managerRoleFunctionalUnit_field = that.managerRoleFunctionalUnit_field;
    if (bit_mask & 0x40000000)
	agentRoleFunctionalUnit_field = that.agentRoleFunctionalUnit_field;
    return *this;
}

int FunctionalUnitPackage::operator == (const FunctionalUnitPackage & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (functionalUnitPackageId_field != that.functionalUnitPackageId_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (managerRoleFunctionalUnit_field != that.managerRoleFunctionalUnit_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (agentRoleFunctionalUnit_field != that.agentRoleFunctionalUnit_field)
	    return 0;
    }
    return 1;
}

int FunctionalUnitPackage::operator != (const FunctionalUnitPackage & that) const {
    return !(operator ==(that));
}

FunctionalUnitPackage::functionalUnitPackageId & FunctionalUnitPackage::get_functionalUnitPackageId() {
    return functionalUnitPackageId_field;
}

const FunctionalUnitPackage::functionalUnitPackageId & FunctionalUnitPackage::get_functionalUnitPackageId() const {
    return functionalUnitPackageId_field;
}

void FunctionalUnitPackage::set_functionalUnitPackageId(const functionalUnitPackageId & functionalUnitPackageId_val) {
    functionalUnitPackageId_field = functionalUnitPackageId_val;
}

FunctionalUnitPackage::managerRoleFunctionalUnit *FunctionalUnitPackage::get_managerRoleFunctionalUnit() {
    if (bit_mask & 0x80000000)
	return &managerRoleFunctionalUnit_field;
    else
	return 0;
}

const FunctionalUnitPackage::managerRoleFunctionalUnit *FunctionalUnitPackage::get_managerRoleFunctionalUnit() const {
    if (bit_mask & 0x80000000)
	return &managerRoleFunctionalUnit_field;
    else
	return 0;
}

void FunctionalUnitPackage::set_managerRoleFunctionalUnit(const managerRoleFunctionalUnit & managerRoleFunctionalUnit_val) {
    if (!(bit_mask & 0x80000000)) {
	memset(&managerRoleFunctionalUnit_field, 0, sizeof(managerRoleFunctionalUnit));
	bit_mask |= 0x80000000;
    }
    managerRoleFunctionalUnit_field = managerRoleFunctionalUnit_val;
}

int FunctionalUnitPackage::managerRoleFunctionalUnit_is_default() const {
    return !(bit_mask & 0x80000000);
}

void FunctionalUnitPackage::set_default_managerRoleFunctionalUnit() {
    if (bit_mask & 0x80000000) {
	managerRoleFunctionalUnit_field.~OssBitString();
	bit_mask &= ~0x80000000;
    }
}

FunctionalUnitPackage::agentRoleFunctionalUnit *FunctionalUnitPackage::get_agentRoleFunctionalUnit() {
    if (bit_mask & 0x40000000)
	return &agentRoleFunctionalUnit_field;
    else
	return 0;
}

const FunctionalUnitPackage::agentRoleFunctionalUnit *FunctionalUnitPackage::get_agentRoleFunctionalUnit() const {
    if (bit_mask & 0x40000000)
	return &agentRoleFunctionalUnit_field;
    else
	return 0;
}

void FunctionalUnitPackage::set_agentRoleFunctionalUnit(const agentRoleFunctionalUnit & agentRoleFunctionalUnit_val) {
    if (!(bit_mask & 0x40000000)) {
	memset(&agentRoleFunctionalUnit_field, 0, sizeof(agentRoleFunctionalUnit));
	bit_mask |= 0x40000000;
    }
    agentRoleFunctionalUnit_field = agentRoleFunctionalUnit_val;
}

int FunctionalUnitPackage::agentRoleFunctionalUnit_is_default() const {
    return !(bit_mask & 0x40000000);
}

void FunctionalUnitPackage::set_default_agentRoleFunctionalUnit() {
    if (bit_mask & 0x40000000) {
	agentRoleFunctionalUnit_field.~OssBitString();
	bit_mask &= ~0x40000000;
    }
}

/* Auxiliary data structures and functions for class __shared15 */

class __shared15_member {
public:
    __shared15_member *next;
    __shared15::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared15_member();
    __shared15_member(const __shared15::component & val);
};

void *__shared15_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared15_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared15_member::__shared15_member() {
}

__shared15_member::__shared15_member(const __shared15::component & val) {
    value = val;
}

static void *__shared15_copy(void *that) {
    return new __shared15_member(((__shared15_member *)that)->value);
}

static void __shared15_destroy(void *that) {
    delete (__shared15_member *)that;
}

static int __shared15_compare(void *val1, void *val2) {
    return (((__shared15_member *)val1)->value == ((__shared15_member *)val2)->value);
}

/* Constructors */

__shared15::__shared15() {
}

__shared15::__shared15(const __shared15 & that) {
    OSSTRY {
	do_copy(that, &__shared15_copy);
    } OSSCLEAN(__shared15)
}

/* Destructor */

__shared15::~__shared15() {
    do_destroy(&__shared15_destroy);
}

/* Operators: assignment, equality, inequality */

__shared15 & __shared15::operator = (const __shared15 & that) {
    do_destroy(&__shared15_destroy);
    do_copy(that, &__shared15_copy);
    return *this;
}

int __shared15::operator == (const __shared15 & that) const {
    return do_compare(that, &__shared15_compare);
}

int __shared15::operator != (const __shared15 & that) const {
    return !do_compare(that, &__shared15_compare);
}

/* Locate ("At" etc) methods */

__shared15::component *__shared15::at(OssIndex pos) {
    return &((__shared15_member *)pos)->value;
}

const __shared15::component *__shared15::at(OssIndex pos) const {
    return &((__shared15_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared15::prepend(const component & val) {
    __shared15_member *newrec = new __shared15_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared15::prepend(__shared15 *seq) {
    return do_prepend(seq);
}

OssIndex __shared15::insert_after(OssIndex pos, const component & val) {
    __shared15_member *newrec = new __shared15_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared15::insert_after(OssIndex pos, __shared15 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared15::remove_front() {
    __shared15_member *extr = (__shared15_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared15_destroy(extr);
    return 0;
}

int __shared15::remove_after(OssIndex pos) {
    __shared15_member *extr = (__shared15_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared15_destroy(extr);
    return 0;
}

/* Extract methods */

__shared15 *__shared15::extract_after(OssIndex begin, OssIndex end) {
    return (__shared15 *)do_extract_after(begin, end);
}

SmUserInfoSent::SmUserInfoSent() {
    memset(this, 0, sizeof(SmUserInfoSent));
}

SmUserInfoSent::SmUserInfoSent(const SmUserInfoSent & that) {
    memset(this, 0, sizeof(SmUserInfoSent));
    operator =(that);
}

SmUserInfoSent::~SmUserInfoSent() {
    cleanup();
}

SmUserInfoSent & SmUserInfoSent::operator = (const SmUserInfoSent & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case nothingSent_chosen:
	    *(nothingSent *)&nothingSent_field = *(nothingSent *)&that.nothingSent_field;
	    break;
	case informationSent_chosen:
	    *(informationSent *)&informationSent_field = *(informationSent *)&that.informationSent_field;
	    break;
    }
    return *this;
}

int SmUserInfoSent::operator == (const SmUserInfoSent & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case nothingSent_chosen:
	    return *(nothingSent *)&nothingSent_field == *(nothingSent *)&that.nothingSent_field;
	case informationSent_chosen:
	    return *(informationSent *)&informationSent_field == *(informationSent *)&that.informationSent_field;
    }

    return 1;
}

int SmUserInfoSent::operator != (const SmUserInfoSent & that) const {
    return !(operator ==(that));
}

SmUserInfoSent::nothingSent *SmUserInfoSent::get_nothingSent() {
    if (_choice == nothingSent_chosen)
	return (nothingSent *)&nothingSent_field;
    else
	return 0;
}

const SmUserInfoSent::nothingSent *SmUserInfoSent::get_nothingSent() const {
    if (_choice == nothingSent_chosen)
	return (const nothingSent *)&nothingSent_field;
    else
	return 0;
}

void SmUserInfoSent::set_nothingSent(nothingSent nothingSent_val) {
    cleanup();
    *(nothingSent *)&nothingSent_field = nothingSent_val;
    _choice = nothingSent_chosen;
}

SmUserInfoSent::informationSent *SmUserInfoSent::get_informationSent() {
    if (_choice == informationSent_chosen)
	return (informationSent *)&informationSent_field;
    else
	return 0;
}

const SmUserInfoSent::informationSent *SmUserInfoSent::get_informationSent() const {
    if (_choice == informationSent_chosen)
	return (const informationSent *)&informationSent_field;
    else
	return 0;
}

void SmUserInfoSent::set_informationSent(const informationSent & informationSent_val) {
    cleanup();
    *(informationSent *)&informationSent_field = informationSent_val;
    _choice = informationSent_chosen;
}

void SmUserInfoSent::cleanup() {
    switch (_choice) {
	case nothingSent_chosen:
	    break;
	case informationSent_chosen:
	    ((informationSent *)&informationSent_field)->~OssString();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

SmUserInfoReceived::SmUserInfoReceived() {
    memset(this, 0, sizeof(SmUserInfoReceived));
}

SmUserInfoReceived::SmUserInfoReceived(const SmUserInfoReceived & that) {
    memset(this, 0, sizeof(SmUserInfoReceived));
    operator =(that);
}

SmUserInfoReceived::~SmUserInfoReceived() {
    cleanup();
}

SmUserInfoReceived & SmUserInfoReceived::operator = (const SmUserInfoReceived & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case nothingReceived_chosen:
	    *(nothingReceived *)&nothingReceived_field = *(nothingReceived *)&that.nothingReceived_field;
	    break;
	case informationReceived_chosen:
	    *(informationReceived *)&informationReceived_field = *(informationReceived *)&that.informationReceived_field;
	    break;
    }
    return *this;
}

int SmUserInfoReceived::operator == (const SmUserInfoReceived & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case nothingReceived_chosen:
	    return *(nothingReceived *)&nothingReceived_field == *(nothingReceived *)&that.nothingReceived_field;
	case informationReceived_chosen:
	    return *(informationReceived *)&informationReceived_field == *(informationReceived *)&that.informationReceived_field;
    }

    return 1;
}

int SmUserInfoReceived::operator != (const SmUserInfoReceived & that) const {
    return !(operator ==(that));
}

SmUserInfoReceived::nothingReceived *SmUserInfoReceived::get_nothingReceived() {
    if (_choice == nothingReceived_chosen)
	return (nothingReceived *)&nothingReceived_field;
    else
	return 0;
}

const SmUserInfoReceived::nothingReceived *SmUserInfoReceived::get_nothingReceived() const {
    if (_choice == nothingReceived_chosen)
	return (const nothingReceived *)&nothingReceived_field;
    else
	return 0;
}

void SmUserInfoReceived::set_nothingReceived(nothingReceived nothingReceived_val) {
    cleanup();
    *(nothingReceived *)&nothingReceived_field = nothingReceived_val;
    _choice = nothingReceived_chosen;
}

SmUserInfoReceived::informationReceived *SmUserInfoReceived::get_informationReceived() {
    if (_choice == informationReceived_chosen)
	return (informationReceived *)&informationReceived_field;
    else
	return 0;
}

const SmUserInfoReceived::informationReceived *SmUserInfoReceived::get_informationReceived() const {
    if (_choice == informationReceived_chosen)
	return (const informationReceived *)&informationReceived_field;
    else
	return 0;
}

void SmUserInfoReceived::set_informationReceived(const informationReceived & informationReceived_val) {
    cleanup();
    *(informationReceived *)&informationReceived_field = informationReceived_val;
    _choice = informationReceived_chosen;
}

void SmUserInfoReceived::cleanup() {
    switch (_choice) {
	case nothingReceived_chosen:
	    break;
	case informationReceived_chosen:
	    ((informationReceived *)&informationReceived_field)->~OssString();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

void *RTABapdu::operator new(size_t size) {
    return ossNewFunc(size);
}

void RTABapdu::operator delete(void *ptr) {
    asn1Free(ptr);
}

RTABapdu::RTABapdu() {
    memset(this, 0, sizeof(RTABapdu));
}

RTABapdu::RTABapdu(const RTABapdu & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	abortReason_field = that.abortReason_field;
	reflectedParameter_field = that.reflectedParameter_field;
	userdataAB_field = that.userdataAB_field;
    } OSSCLEAN(RTABapdu)
}

RTABapdu::RTABapdu(abortReason abortReason_val, const reflectedParameter & reflectedParameter_val, 
    const userdataAB & userdataAB_val) {
    OSSTRY {
	bit_mask = 0xe0000000;
	abortReason_field = abortReason_val;
	reflectedParameter_field = reflectedParameter_val;
	userdataAB_field = userdataAB_val;
    } OSSCLEAN(RTABapdu)
}

RTABapdu & RTABapdu::operator = (const RTABapdu & that) {
    if (this == &that)
	return *this;
    this->~RTABapdu();
    bit_mask = that.bit_mask;
    abortReason_field = that.abortReason_field;
    reflectedParameter_field = that.reflectedParameter_field;
    userdataAB_field = that.userdataAB_field;
    return *this;
}

int RTABapdu::operator == (const RTABapdu & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (abortReason_field != that.abortReason_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (reflectedParameter_field != that.reflectedParameter_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (userdataAB_field != that.userdataAB_field)
	    return 0;
    }
    return 1;
}

int RTABapdu::operator != (const RTABapdu & that) const {
    return !(operator ==(that));
}

RTABapdu::abortReason *RTABapdu::get_abortReason() {
    if (bit_mask & 0x80000000)
	return &abortReason_field;
    else
	return 0;
}

const RTABapdu::abortReason *RTABapdu::get_abortReason() const {
    if (bit_mask & 0x80000000)
	return &abortReason_field;
    else
	return 0;
}

void RTABapdu::set_abortReason(abortReason abortReason_val) {
    bit_mask |= 0x80000000;
    abortReason_field = abortReason_val;
}

int RTABapdu::abortReason_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void RTABapdu::omit_abortReason() {
    bit_mask &= ~0x80000000;
}

RTABapdu::reflectedParameter *RTABapdu::get_reflectedParameter() {
    if (bit_mask & 0x40000000)
	return &reflectedParameter_field;
    else
	return 0;
}

const RTABapdu::reflectedParameter *RTABapdu::get_reflectedParameter() const {
    if (bit_mask & 0x40000000)
	return &reflectedParameter_field;
    else
	return 0;
}

void RTABapdu::set_reflectedParameter(const reflectedParameter & reflectedParameter_val) {
    bit_mask |= 0x40000000;
    reflectedParameter_field = reflectedParameter_val;
}

int RTABapdu::reflectedParameter_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void RTABapdu::omit_reflectedParameter() {
    reflectedParameter_field.~OssBitString();
    bit_mask &= ~0x40000000;
}

RTABapdu::userdataAB *RTABapdu::get_userdataAB() {
    if (bit_mask & 0x20000000)
	return &userdataAB_field;
    else
	return 0;
}

const RTABapdu::userdataAB *RTABapdu::get_userdataAB() const {
    if (bit_mask & 0x20000000)
	return &userdataAB_field;
    else
	return 0;
}

void RTABapdu::set_userdataAB(const userdataAB & userdataAB_val) {
    bit_mask |= 0x20000000;
    userdataAB_field = userdataAB_val;
}

int RTABapdu::userdataAB_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void RTABapdu::omit_userdataAB() {
    userdataAB_field.~OssOpen();
    bit_mask &= ~0x20000000;
}

void *SMASEUserData::operator new(size_t size) {
    return ossNewFunc(size);
}

void SMASEUserData::operator delete(void *ptr) {
    asn1Free(ptr);
}

SMASEUserData::SMASEUserData() {
    memset(this, 0, sizeof(SMASEUserData));
}

SMASEUserData::SMASEUserData(const SMASEUserData & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	smfuPackages_field = that.smfuPackages_field;
	reason_field = that.reason_field;
	systemsManagementUserInformation_field = that.systemsManagementUserInformation_field;
    } OSSCLEAN(SMASEUserData)
}

SMASEUserData::SMASEUserData(const smfuPackages & smfuPackages_val, reason reason_val, 
    const systemsManagementUserInformation & systemsManagementUserInformation_val) {
    OSSTRY {
	bit_mask = 0xe0000000;
	smfuPackages_field = smfuPackages_val;
	reason_field = reason_val;
	systemsManagementUserInformation_field = systemsManagementUserInformation_val;
    } OSSCLEAN(SMASEUserData)
}

SMASEUserData & SMASEUserData::operator = (const SMASEUserData & that) {
    if (this == &that)
	return *this;
    this->~SMASEUserData();
    bit_mask = that.bit_mask;
    smfuPackages_field = that.smfuPackages_field;
    reason_field = that.reason_field;
    systemsManagementUserInformation_field = that.systemsManagementUserInformation_field;
    return *this;
}

int SMASEUserData::operator == (const SMASEUserData & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (smfuPackages_field != that.smfuPackages_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (reason_field != that.reason_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (systemsManagementUserInformation_field != that.systemsManagementUserInformation_field)
	    return 0;
    }
    return 1;
}

int SMASEUserData::operator != (const SMASEUserData & that) const {
    return !(operator ==(that));
}

SMASEUserData::smfuPackages *SMASEUserData::get_smfuPackages() {
    if (bit_mask & 0x80000000)
	return &smfuPackages_field;
    else
	return 0;
}

const SMASEUserData::smfuPackages *SMASEUserData::get_smfuPackages() const {
    if (bit_mask & 0x80000000)
	return &smfuPackages_field;
    else
	return 0;
}

void SMASEUserData::set_smfuPackages(const smfuPackages & smfuPackages_val) {
    bit_mask |= 0x80000000;
    smfuPackages_field = smfuPackages_val;
}

int SMASEUserData::smfuPackages_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void SMASEUserData::omit_smfuPackages() {
    smfuPackages_field.~__shared15();
    bit_mask &= ~0x80000000;
}

SMASEUserData::reason *SMASEUserData::get_reason() {
    if (bit_mask & 0x40000000)
	return &reason_field;
    else
	return 0;
}

const SMASEUserData::reason *SMASEUserData::get_reason() const {
    if (bit_mask & 0x40000000)
	return &reason_field;
    else
	return 0;
}

void SMASEUserData::set_reason(reason reason_val) {
    bit_mask |= 0x40000000;
    reason_field = reason_val;
}

int SMASEUserData::reason_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void SMASEUserData::omit_reason() {
    bit_mask &= ~0x40000000;
}

SMASEUserData::systemsManagementUserInformation *SMASEUserData::get_systemsManagementUserInformation() {
    if (bit_mask & 0x20000000)
	return &systemsManagementUserInformation_field;
    else
	return 0;
}

const SMASEUserData::systemsManagementUserInformation *SMASEUserData::get_systemsManagementUserInformation() const {
    if (bit_mask & 0x20000000)
	return &systemsManagementUserInformation_field;
    else
	return 0;
}

void SMASEUserData::set_systemsManagementUserInformation(const systemsManagementUserInformation & systemsManagementUserInformation_val) {
    bit_mask |= 0x20000000;
    systemsManagementUserInformation_field = systemsManagementUserInformation_val;
}

int SMASEUserData::systemsManagementUserInformation_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void SMASEUserData::omit_systemsManagementUserInformation() {
    systemsManagementUserInformation_field.~OssString();
    bit_mask &= ~0x20000000;
}

/* Universal PDU class */

SMASE_A_ASSOCIATE_Information_PDU::SMASE_A_ASSOCIATE_Information_PDU() {
}

void SMASE_A_ASSOCIATE_Information_PDU::set_ActionArgument(ActionArgument & d) {
    index = 1;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ActionArgument *SMASE_A_ASSOCIATE_Information_PDU::get_ActionArgument() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 1 && !constant)
#else
    if (index == 1)
#endif
	return (ActionArgument *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_ActionResult(ActionResult & d) {
    index = 2;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ActionResult *SMASE_A_ASSOCIATE_Information_PDU::get_ActionResult() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 2 && !constant)
#else
    if (index == 2)
#endif
	return (ActionResult *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_Attribute(Attribute & d) {
    index = 3;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Attribute *SMASE_A_ASSOCIATE_Information_PDU::get_Attribute() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 3 && !constant)
#else
    if (index == 3)
#endif
	return (Attribute *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_AttributeId(AttributeId & d) {
    index = 4;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AttributeId *SMASE_A_ASSOCIATE_Information_PDU::get_AttributeId() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 4 && !constant)
#else
    if (index == 4)
#endif
	return (AttributeId *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_BaseManagedObjectId(BaseManagedObjectId & d) {
    index = 5;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

BaseManagedObjectId *SMASE_A_ASSOCIATE_Information_PDU::get_BaseManagedObjectId() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 5 && !constant)
#else
    if (index == 5)
#endif
	return (BaseManagedObjectId *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_CMISFilter(CMISFilter & d) {
    index = 6;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CMISFilter *SMASE_A_ASSOCIATE_Information_PDU::get_CMISFilter() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 6 && !constant)
#else
    if (index == 6)
#endif
	return (CMISFilter *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_CMISSync(CMISSync & d) {
    index = 7;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CMISSync *SMASE_A_ASSOCIATE_Information_PDU::get_CMISSync() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 7 && !constant)
#else
    if (index == 7)
#endif
	return (CMISSync *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_ComplexityLimitation(ComplexityLimitation & d) {
    index = 8;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ComplexityLimitation *SMASE_A_ASSOCIATE_Information_PDU::get_ComplexityLimitation() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 8 && !constant)
#else
    if (index == 8)
#endif
	return (ComplexityLimitation *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_CreateArgument(CreateArgument & d) {
    index = 9;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CreateArgument *SMASE_A_ASSOCIATE_Information_PDU::get_CreateArgument() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 9 && !constant)
#else
    if (index == 9)
#endif
	return (CreateArgument *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_CreateResult(CreateResult & d) {
    index = 10;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CreateResult *SMASE_A_ASSOCIATE_Information_PDU::get_CreateResult() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 10 && !constant)
#else
    if (index == 10)
#endif
	return (CreateResult *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_DeleteArgument(DeleteArgument & d) {
    index = 11;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

DeleteArgument *SMASE_A_ASSOCIATE_Information_PDU::get_DeleteArgument() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 11 && !constant)
#else
    if (index == 11)
#endif
	return (DeleteArgument *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_DeleteResult(DeleteResult & d) {
    index = 12;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

DeleteResult *SMASE_A_ASSOCIATE_Information_PDU::get_DeleteResult() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 12 && !constant)
#else
    if (index == 12)
#endif
	return (DeleteResult *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_EventReportArgument(EventReportArgument & d) {
    index = 13;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EventReportArgument *SMASE_A_ASSOCIATE_Information_PDU::get_EventReportArgument() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 13 && !constant)
#else
    if (index == 13)
#endif
	return (EventReportArgument *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_EventReportResult(EventReportResult & d) {
    index = 14;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EventReportResult *SMASE_A_ASSOCIATE_Information_PDU::get_EventReportResult() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 14 && !constant)
#else
    if (index == 14)
#endif
	return (EventReportResult *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_GetArgument(GetArgument & d) {
    index = 15;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

GetArgument *SMASE_A_ASSOCIATE_Information_PDU::get_GetArgument() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 15 && !constant)
#else
    if (index == 15)
#endif
	return (GetArgument *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_GetListError(GetListError & d) {
    index = 16;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

GetListError *SMASE_A_ASSOCIATE_Information_PDU::get_GetListError() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 16 && !constant)
#else
    if (index == 16)
#endif
	return (GetListError *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_GetResult(GetResult & d) {
    index = 17;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

GetResult *SMASE_A_ASSOCIATE_Information_PDU::get_GetResult() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 17 && !constant)
#else
    if (index == 17)
#endif
	return (GetResult *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_InvalidArgumentValue(InvalidArgumentValue & d) {
    index = 18;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

InvalidArgumentValue *SMASE_A_ASSOCIATE_Information_PDU::get_InvalidArgumentValue() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 18 && !constant)
#else
    if (index == 18)
#endif
	return (InvalidArgumentValue *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_InvokeIDType(InvokeIDType & d) {
    index = 19;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

InvokeIDType *SMASE_A_ASSOCIATE_Information_PDU::get_InvokeIDType() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 19 && !constant)
#else
    if (index == 19)
#endif
	return (InvokeIDType *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_LinkedReplyArgument(LinkedReplyArgument & d) {
    index = 20;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

LinkedReplyArgument *SMASE_A_ASSOCIATE_Information_PDU::get_LinkedReplyArgument() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 20 && !constant)
#else
    if (index == 20)
#endif
	return (LinkedReplyArgument *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_NoSuchAction(NoSuchAction & d) {
    index = 21;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoSuchAction *SMASE_A_ASSOCIATE_Information_PDU::get_NoSuchAction() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 21 && !constant)
#else
    if (index == 21)
#endif
	return (NoSuchAction *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_NoSuchArgument(NoSuchArgument & d) {
    index = 22;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoSuchArgument *SMASE_A_ASSOCIATE_Information_PDU::get_NoSuchArgument() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 22 && !constant)
#else
    if (index == 22)
#endif
	return (NoSuchArgument *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_NoSuchEventType(NoSuchEventType & d) {
    index = 23;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoSuchEventType *SMASE_A_ASSOCIATE_Information_PDU::get_NoSuchEventType() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 23 && !constant)
#else
    if (index == 23)
#endif
	return (NoSuchEventType *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_ObjectClass(ObjectClass & d) {
    index = 24;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ObjectClass *SMASE_A_ASSOCIATE_Information_PDU::get_ObjectClass() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 24 && !constant)
#else
    if (index == 24)
#endif
	return (ObjectClass *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_ObjectInstance(ObjectInstance & d) {
    index = 25;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ObjectInstance *SMASE_A_ASSOCIATE_Information_PDU::get_ObjectInstance() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 25 && !constant)
#else
    if (index == 25)
#endif
	return (ObjectInstance *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_ProcessingFailure(ProcessingFailure & d) {
    index = 26;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ProcessingFailure *SMASE_A_ASSOCIATE_Information_PDU::get_ProcessingFailure() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 26 && !constant)
#else
    if (index == 26)
#endif
	return (ProcessingFailure *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_Scope(Scope & d) {
    index = 27;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Scope *SMASE_A_ASSOCIATE_Information_PDU::get_Scope() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 27 && !constant)
#else
    if (index == 27)
#endif
	return (Scope *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_SetArgument(SetArgument & d) {
    index = 28;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SetArgument *SMASE_A_ASSOCIATE_Information_PDU::get_SetArgument() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 28 && !constant)
#else
    if (index == 28)
#endif
	return (SetArgument *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_SetListError(SetListError & d) {
    index = 29;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SetListError *SMASE_A_ASSOCIATE_Information_PDU::get_SetListError() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 29 && !constant)
#else
    if (index == 29)
#endif
	return (SetListError *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_SetResult(SetResult & d) {
    index = 30;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SetResult *SMASE_A_ASSOCIATE_Information_PDU::get_SetResult() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 30 && !constant)
#else
    if (index == 30)
#endif
	return (SetResult *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_ROSEapdus(ROSEapdus & d) {
    index = 31;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ROSEapdus *SMASE_A_ASSOCIATE_Information_PDU::get_ROSEapdus() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 31 && !constant)
#else
    if (index == 31)
#endif
	return (ROSEapdus *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_CMIPAbortInfo(CMIPAbortInfo & d) {
    index = 32;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CMIPAbortInfo *SMASE_A_ASSOCIATE_Information_PDU::get_CMIPAbortInfo() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 32 && !constant)
#else
    if (index == 32)
#endif
	return (CMIPAbortInfo *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_CMIPUserInfo(CMIPUserInfo & d) {
    index = 33;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CMIPUserInfo *SMASE_A_ASSOCIATE_Information_PDU::get_CMIPUserInfo() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 33 && !constant)
#else
    if (index == 33)
#endif
	return (CMIPUserInfo *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_CmipPduReceivingSupport(CmipPduReceivingSupport & d) {
    index = 34;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CmipPduReceivingSupport *SMASE_A_ASSOCIATE_Information_PDU::get_CmipPduReceivingSupport() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 34 && !constant)
#else
    if (index == 34)
#endif
	return (CmipPduReceivingSupport *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_CmipPduSendingSupport(CmipPduSendingSupport & d) {
    index = 35;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CmipPduSendingSupport *SMASE_A_ASSOCIATE_Information_PDU::get_CmipPduSendingSupport() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 35 && !constant)
#else
    if (index == 35)
#endif
	return (CmipPduSendingSupport *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_CmiseFunctionalUnitsSelected(CmiseFunctionalUnitsSelected & d) {
    index = 36;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CmiseFunctionalUnitsSelected *SMASE_A_ASSOCIATE_Information_PDU::get_CmiseFunctionalUnitsSelected() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 36 && !constant)
#else
    if (index == 36)
#endif
	return (CmiseFunctionalUnitsSelected *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_CmiseFunctionalUnitsSupported(CmiseFunctionalUnitsSupported & d) {
    index = 37;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CmiseFunctionalUnitsSupported *SMASE_A_ASSOCIATE_Information_PDU::get_CmiseFunctionalUnitsSupported() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 37 && !constant)
#else
    if (index == 37)
#endif
	return (CmiseFunctionalUnitsSupported *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_InvokeldsOutstanding(InvokeldsOutstanding & d) {
    index = 38;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

InvokeldsOutstanding *SMASE_A_ASSOCIATE_Information_PDU::get_InvokeldsOutstanding() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 38 && !constant)
#else
    if (index == 38)
#endif
	return (InvokeldsOutstanding *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_InvokeIdsPerforming(InvokeIdsPerforming & d) {
    index = 39;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

InvokeIdsPerforming *SMASE_A_ASSOCIATE_Information_PDU::get_InvokeIdsPerforming() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 39 && !constant)
#else
    if (index == 39)
#endif
	return (InvokeIdsPerforming *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_MaxEncodedCmipPduReceiveSize(MaxEncodedCmipPduReceiveSize & d) {
    index = 40;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

MaxEncodedCmipPduReceiveSize *SMASE_A_ASSOCIATE_Information_PDU::get_MaxEncodedCmipPduReceiveSize() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 40 && !constant)
#else
    if (index == 40)
#endif
	return (MaxEncodedCmipPduReceiveSize *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_ProtocolVersionSupported(ProtocolVersionSupported & d) {
    index = 41;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ProtocolVersionSupported *SMASE_A_ASSOCIATE_Information_PDU::get_ProtocolVersionSupported() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 41 && !constant)
#else
    if (index == 41)
#endif
	return (ProtocolVersionSupported *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_SmaseFunctionalUnits(SmaseFunctionalUnits & d) {
    index = 42;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SmaseFunctionalUnits *SMASE_A_ASSOCIATE_Information_PDU::get_SmaseFunctionalUnits() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 42 && !constant)
#else
    if (index == 42)
#endif
	return (SmaseFunctionalUnits *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_SmUserInfoSent(SmUserInfoSent & d) {
    index = 43;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SmUserInfoSent *SMASE_A_ASSOCIATE_Information_PDU::get_SmUserInfoSent() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 43 && !constant)
#else
    if (index == 43)
#endif
	return (SmUserInfoSent *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_SmUserInfoReceived(SmUserInfoReceived & d) {
    index = 44;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SmUserInfoReceived *SMASE_A_ASSOCIATE_Information_PDU::get_SmUserInfoReceived() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 44 && !constant)
#else
    if (index == 44)
#endif
	return (SmUserInfoReceived *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_ROSEInvokeIds(ROSEInvokeIds & d) {
    index = 45;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ROSEInvokeIds *SMASE_A_ASSOCIATE_Information_PDU::get_ROSEInvokeIds() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 45 && !constant)
#else
    if (index == 45)
#endif
	return (ROSEInvokeIds *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_NoInvokeId(NoInvokeId & d) {
    index = 46;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoInvokeId *SMASE_A_ASSOCIATE_Information_PDU::get_NoInvokeId() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 46 && !constant)
#else
    if (index == 46)
#endif
	return (NoInvokeId *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_SMASEUserData(SMASEUserData & d) {
    index = 47;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SMASEUserData *SMASE_A_ASSOCIATE_Information_PDU::get_SMASEUserData() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 47 && !constant)
#else
    if (index == 47)
#endif
	return (SMASEUserData *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_AccessDenied_PRIORITY(AccessDenied_PRIORITY & d) {
    index = 48;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AccessDenied_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_AccessDenied_PRIORITY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 48 && !constant)
#else
    if (index == 48)
#endif
	return (AccessDenied_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_ClassInstanceConflict_PRIORITY(ClassInstanceConflict_PRIORITY & d) {
    index = 49;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ClassInstanceConflict_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_ClassInstanceConflict_PRIORITY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 49 && !constant)
#else
    if (index == 49)
#endif
	return (ClassInstanceConflict_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_ComplexityLimitation_PRIORITY(ComplexityLimitation_PRIORITY & d) {
    index = 50;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ComplexityLimitation_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_ComplexityLimitation_PRIORITY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 50 && !constant)
#else
    if (index == 50)
#endif
	return (ComplexityLimitation_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_InvalidScope_PRIORITY(InvalidScope_PRIORITY & d) {
    index = 51;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

InvalidScope_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_InvalidScope_PRIORITY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 51 && !constant)
#else
    if (index == 51)
#endif
	return (InvalidScope_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_InvalidArgumentValue_PRIORITY(InvalidArgumentValue_PRIORITY & d) {
    index = 52;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

InvalidArgumentValue_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_InvalidArgumentValue_PRIORITY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 52 && !constant)
#else
    if (index == 52)
#endif
	return (InvalidArgumentValue_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_InvalidFilter_PRIORITY(InvalidFilter_PRIORITY & d) {
    index = 53;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

InvalidFilter_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_InvalidFilter_PRIORITY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 53 && !constant)
#else
    if (index == 53)
#endif
	return (InvalidFilter_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_NoSuchAction_PRIORITY(NoSuchAction_PRIORITY & d) {
    index = 54;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoSuchAction_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_NoSuchAction_PRIORITY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 54 && !constant)
#else
    if (index == 54)
#endif
	return (NoSuchAction_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_NoSuchArgument_PRIORITY(NoSuchArgument_PRIORITY & d) {
    index = 55;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoSuchArgument_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_NoSuchArgument_PRIORITY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 55 && !constant)
#else
    if (index == 55)
#endif
	return (NoSuchArgument_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_NoSuchObjectClass_PRIORITY(NoSuchObjectClass_PRIORITY & d) {
    index = 56;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoSuchObjectClass_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_NoSuchObjectClass_PRIORITY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 56 && !constant)
#else
    if (index == 56)
#endif
	return (NoSuchObjectClass_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_NoSuchObjectInstance_PRIORITY(NoSuchObjectInstance_PRIORITY & d) {
    index = 57;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoSuchObjectInstance_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_NoSuchObjectInstance_PRIORITY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 57 && !constant)
#else
    if (index == 57)
#endif
	return (NoSuchObjectInstance_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_ProcessingFailure_PRIORITY(ProcessingFailure_PRIORITY & d) {
    index = 58;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ProcessingFailure_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_ProcessingFailure_PRIORITY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 58 && !constant)
#else
    if (index == 58)
#endif
	return (ProcessingFailure_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_SyncNotSupported_PRIORITY(SyncNotSupported_PRIORITY & d) {
    index = 59;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SyncNotSupported_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_SyncNotSupported_PRIORITY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 59 && !constant)
#else
    if (index == 59)
#endif
	return (SyncNotSupported_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_MistypedOperation_PRIORITY(MistypedOperation_PRIORITY & d) {
    index = 60;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

MistypedOperation_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_MistypedOperation_PRIORITY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 60 && !constant)
#else
    if (index == 60)
#endif
	return (MistypedOperation_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_NoSuchInvokeId_PRIORITY(NoSuchInvokeId_PRIORITY & d) {
    index = 61;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoSuchInvokeId_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_NoSuchInvokeId_PRIORITY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 61 && !constant)
#else
    if (index == 61)
#endif
	return (NoSuchInvokeId_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_DuplicateManagedObjectInstance_PRIORITY(DuplicateManagedObjectInstance_PRIORITY & d) {
    index = 62;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

DuplicateManagedObjectInstance_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_DuplicateManagedObjectInstance_PRIORITY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 62 && !constant)
#else
    if (index == 62)
#endif
	return (DuplicateManagedObjectInstance_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_InvalidAttributeValue_PRIORITY(InvalidAttributeValue_PRIORITY & d) {
    index = 63;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

InvalidAttributeValue_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_InvalidAttributeValue_PRIORITY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 63 && !constant)
#else
    if (index == 63)
#endif
	return (InvalidAttributeValue_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_InvalidObjectInstance_PRIORITY(InvalidObjectInstance_PRIORITY & d) {
    index = 64;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

InvalidObjectInstance_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_InvalidObjectInstance_PRIORITY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 64 && !constant)
#else
    if (index == 64)
#endif
	return (InvalidObjectInstance_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_MissingAttributeValue_PARAMETER(MissingAttributeValue_PARAMETER & d) {
    index = 65;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

MissingAttributeValue_PARAMETER *SMASE_A_ASSOCIATE_Information_PDU::get_MissingAttributeValue_PARAMETER() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 65 && !constant)
#else
    if (index == 65)
#endif
	return (MissingAttributeValue_PARAMETER *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_MissingAttributeValue_PRIORITY(MissingAttributeValue_PRIORITY & d) {
    index = 66;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

MissingAttributeValue_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_MissingAttributeValue_PRIORITY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 66 && !constant)
#else
    if (index == 66)
#endif
	return (MissingAttributeValue_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_NoSuchAttribute_PRIORITY(NoSuchAttribute_PRIORITY & d) {
    index = 67;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoSuchAttribute_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_NoSuchAttribute_PRIORITY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 67 && !constant)
#else
    if (index == 67)
#endif
	return (NoSuchAttribute_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_NoSuchReferenceObject_PRIORITY(NoSuchReferenceObject_PRIORITY & d) {
    index = 68;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoSuchReferenceObject_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_NoSuchReferenceObject_PRIORITY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 68 && !constant)
#else
    if (index == 68)
#endif
	return (NoSuchReferenceObject_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_NoSuchEventType_PRIORITY(NoSuchEventType_PRIORITY & d) {
    index = 69;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoSuchEventType_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_NoSuchEventType_PRIORITY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 69 && !constant)
#else
    if (index == 69)
#endif
	return (NoSuchEventType_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_GetListError_PRIORITY(GetListError_PRIORITY & d) {
    index = 70;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

GetListError_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_GetListError_PRIORITY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 70 && !constant)
#else
    if (index == 70)
#endif
	return (GetListError_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_OperationCancelled_PRIORITY(OperationCancelled_PRIORITY & d) {
    index = 71;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

OperationCancelled_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_OperationCancelled_PRIORITY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 71 && !constant)
#else
    if (index == 71)
#endif
	return (OperationCancelled_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_SetListError_PRIORITY(SetListError_PRIORITY & d) {
    index = 72;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SetListError_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_SetListError_PRIORITY() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 72 && !constant)
#else
    if (index == 72)
#endif
	return (SetListError_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_Acse_RealizationParameter(Acse_RealizationParameter & d) {
    index = 73;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Acse_RealizationParameter *SMASE_A_ASSOCIATE_Information_PDU::get_Acse_RealizationParameter() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 73 && !constant)
#else
    if (index == 73)
#endif
	return (Acse_RealizationParameter *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_Acse_with_concatenation_RealizationParameter(Acse_with_concatenation_RealizationParameter & d) {
    index = 74;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Acse_with_concatenation_RealizationParameter *SMASE_A_ASSOCIATE_Information_PDU::get_Acse_with_concatenation_RealizationParameter() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 74 && !constant)
#else
    if (index == 74)
#endif
	return (Acse_with_concatenation_RealizationParameter *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_Association_by_RTSE_RealizationParameter(Association_by_RTSE_RealizationParameter & d) {
    index = 75;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Association_by_RTSE_RealizationParameter *SMASE_A_ASSOCIATE_Information_PDU::get_Association_by_RTSE_RealizationParameter() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 75 && !constant)
#else
    if (index == 75)
#endif
	return (Association_by_RTSE_RealizationParameter *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_PData_RealizationParameter(PData_RealizationParameter & d) {
    index = 76;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PData_RealizationParameter *SMASE_A_ASSOCIATE_Information_PDU::get_PData_RealizationParameter() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 76 && !constant)
#else
    if (index == 76)
#endif
	return (PData_RealizationParameter *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_PData_with_concatenation_RealizationParameter(PData_with_concatenation_RealizationParameter & d) {
    index = 77;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PData_with_concatenation_RealizationParameter *SMASE_A_ASSOCIATE_Information_PDU::get_PData_with_concatenation_RealizationParameter() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 77 && !constant)
#else
    if (index == 77)
#endif
	return (PData_with_concatenation_RealizationParameter *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_Transfer_by_RTSE_RealizationParameter(Transfer_by_RTSE_RealizationParameter & d) {
    index = 78;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Transfer_by_RTSE_RealizationParameter *SMASE_A_ASSOCIATE_Information_PDU::get_Transfer_by_RTSE_RealizationParameter() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 78 && !constant)
#else
    if (index == 78)
#endif
	return (Transfer_by_RTSE_RealizationParameter *)data;
    else
	return 0;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
void SMASE_A_ASSOCIATE_Information_PDU::set_const_ActionArgument(const ActionArgument & d) {
    index = 1;
    data = (void *)&d;
    constant = 1;
}

const ActionArgument *SMASE_A_ASSOCIATE_Information_PDU::get_const_ActionArgument() const {
    if (index == 1)
	return (const ActionArgument *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_ActionResult(const ActionResult & d) {
    index = 2;
    data = (void *)&d;
    constant = 1;
}

const ActionResult *SMASE_A_ASSOCIATE_Information_PDU::get_const_ActionResult() const {
    if (index == 2)
	return (const ActionResult *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_Attribute(const Attribute & d) {
    index = 3;
    data = (void *)&d;
    constant = 1;
}

const Attribute *SMASE_A_ASSOCIATE_Information_PDU::get_const_Attribute() const {
    if (index == 3)
	return (const Attribute *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_AttributeId(const AttributeId & d) {
    index = 4;
    data = (void *)&d;
    constant = 1;
}

const AttributeId *SMASE_A_ASSOCIATE_Information_PDU::get_const_AttributeId() const {
    if (index == 4)
	return (const AttributeId *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_BaseManagedObjectId(const BaseManagedObjectId & d) {
    index = 5;
    data = (void *)&d;
    constant = 1;
}

const BaseManagedObjectId *SMASE_A_ASSOCIATE_Information_PDU::get_const_BaseManagedObjectId() const {
    if (index == 5)
	return (const BaseManagedObjectId *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_CMISFilter(const CMISFilter & d) {
    index = 6;
    data = (void *)&d;
    constant = 1;
}

const CMISFilter *SMASE_A_ASSOCIATE_Information_PDU::get_const_CMISFilter() const {
    if (index == 6)
	return (const CMISFilter *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_CMISSync(const CMISSync & d) {
    index = 7;
    data = (void *)&d;
    constant = 1;
}

const CMISSync *SMASE_A_ASSOCIATE_Information_PDU::get_const_CMISSync() const {
    if (index == 7)
	return (const CMISSync *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_ComplexityLimitation(const ComplexityLimitation & d) {
    index = 8;
    data = (void *)&d;
    constant = 1;
}

const ComplexityLimitation *SMASE_A_ASSOCIATE_Information_PDU::get_const_ComplexityLimitation() const {
    if (index == 8)
	return (const ComplexityLimitation *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_CreateArgument(const CreateArgument & d) {
    index = 9;
    data = (void *)&d;
    constant = 1;
}

const CreateArgument *SMASE_A_ASSOCIATE_Information_PDU::get_const_CreateArgument() const {
    if (index == 9)
	return (const CreateArgument *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_CreateResult(const CreateResult & d) {
    index = 10;
    data = (void *)&d;
    constant = 1;
}

const CreateResult *SMASE_A_ASSOCIATE_Information_PDU::get_const_CreateResult() const {
    if (index == 10)
	return (const CreateResult *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_DeleteArgument(const DeleteArgument & d) {
    index = 11;
    data = (void *)&d;
    constant = 1;
}

const DeleteArgument *SMASE_A_ASSOCIATE_Information_PDU::get_const_DeleteArgument() const {
    if (index == 11)
	return (const DeleteArgument *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_DeleteResult(const DeleteResult & d) {
    index = 12;
    data = (void *)&d;
    constant = 1;
}

const DeleteResult *SMASE_A_ASSOCIATE_Information_PDU::get_const_DeleteResult() const {
    if (index == 12)
	return (const DeleteResult *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_EventReportArgument(const EventReportArgument & d) {
    index = 13;
    data = (void *)&d;
    constant = 1;
}

const EventReportArgument *SMASE_A_ASSOCIATE_Information_PDU::get_const_EventReportArgument() const {
    if (index == 13)
	return (const EventReportArgument *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_EventReportResult(const EventReportResult & d) {
    index = 14;
    data = (void *)&d;
    constant = 1;
}

const EventReportResult *SMASE_A_ASSOCIATE_Information_PDU::get_const_EventReportResult() const {
    if (index == 14)
	return (const EventReportResult *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_GetArgument(const GetArgument & d) {
    index = 15;
    data = (void *)&d;
    constant = 1;
}

const GetArgument *SMASE_A_ASSOCIATE_Information_PDU::get_const_GetArgument() const {
    if (index == 15)
	return (const GetArgument *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_GetListError(const GetListError & d) {
    index = 16;
    data = (void *)&d;
    constant = 1;
}

const GetListError *SMASE_A_ASSOCIATE_Information_PDU::get_const_GetListError() const {
    if (index == 16)
	return (const GetListError *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_GetResult(const GetResult & d) {
    index = 17;
    data = (void *)&d;
    constant = 1;
}

const GetResult *SMASE_A_ASSOCIATE_Information_PDU::get_const_GetResult() const {
    if (index == 17)
	return (const GetResult *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_InvalidArgumentValue(const InvalidArgumentValue & d) {
    index = 18;
    data = (void *)&d;
    constant = 1;
}

const InvalidArgumentValue *SMASE_A_ASSOCIATE_Information_PDU::get_const_InvalidArgumentValue() const {
    if (index == 18)
	return (const InvalidArgumentValue *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_InvokeIDType(const InvokeIDType & d) {
    index = 19;
    data = (void *)&d;
    constant = 1;
}

const InvokeIDType *SMASE_A_ASSOCIATE_Information_PDU::get_const_InvokeIDType() const {
    if (index == 19)
	return (const InvokeIDType *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_LinkedReplyArgument(const LinkedReplyArgument & d) {
    index = 20;
    data = (void *)&d;
    constant = 1;
}

const LinkedReplyArgument *SMASE_A_ASSOCIATE_Information_PDU::get_const_LinkedReplyArgument() const {
    if (index == 20)
	return (const LinkedReplyArgument *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_NoSuchAction(const NoSuchAction & d) {
    index = 21;
    data = (void *)&d;
    constant = 1;
}

const NoSuchAction *SMASE_A_ASSOCIATE_Information_PDU::get_const_NoSuchAction() const {
    if (index == 21)
	return (const NoSuchAction *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_NoSuchArgument(const NoSuchArgument & d) {
    index = 22;
    data = (void *)&d;
    constant = 1;
}

const NoSuchArgument *SMASE_A_ASSOCIATE_Information_PDU::get_const_NoSuchArgument() const {
    if (index == 22)
	return (const NoSuchArgument *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_NoSuchEventType(const NoSuchEventType & d) {
    index = 23;
    data = (void *)&d;
    constant = 1;
}

const NoSuchEventType *SMASE_A_ASSOCIATE_Information_PDU::get_const_NoSuchEventType() const {
    if (index == 23)
	return (const NoSuchEventType *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_ObjectClass(const ObjectClass & d) {
    index = 24;
    data = (void *)&d;
    constant = 1;
}

const ObjectClass *SMASE_A_ASSOCIATE_Information_PDU::get_const_ObjectClass() const {
    if (index == 24)
	return (const ObjectClass *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_ObjectInstance(const ObjectInstance & d) {
    index = 25;
    data = (void *)&d;
    constant = 1;
}

const ObjectInstance *SMASE_A_ASSOCIATE_Information_PDU::get_const_ObjectInstance() const {
    if (index == 25)
	return (const ObjectInstance *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_ProcessingFailure(const ProcessingFailure & d) {
    index = 26;
    data = (void *)&d;
    constant = 1;
}

const ProcessingFailure *SMASE_A_ASSOCIATE_Information_PDU::get_const_ProcessingFailure() const {
    if (index == 26)
	return (const ProcessingFailure *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_Scope(const Scope & d) {
    index = 27;
    data = (void *)&d;
    constant = 1;
}

const Scope *SMASE_A_ASSOCIATE_Information_PDU::get_const_Scope() const {
    if (index == 27)
	return (const Scope *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_SetArgument(const SetArgument & d) {
    index = 28;
    data = (void *)&d;
    constant = 1;
}

const SetArgument *SMASE_A_ASSOCIATE_Information_PDU::get_const_SetArgument() const {
    if (index == 28)
	return (const SetArgument *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_SetListError(const SetListError & d) {
    index = 29;
    data = (void *)&d;
    constant = 1;
}

const SetListError *SMASE_A_ASSOCIATE_Information_PDU::get_const_SetListError() const {
    if (index == 29)
	return (const SetListError *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_SetResult(const SetResult & d) {
    index = 30;
    data = (void *)&d;
    constant = 1;
}

const SetResult *SMASE_A_ASSOCIATE_Information_PDU::get_const_SetResult() const {
    if (index == 30)
	return (const SetResult *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_ROSEapdus(const ROSEapdus & d) {
    index = 31;
    data = (void *)&d;
    constant = 1;
}

const ROSEapdus *SMASE_A_ASSOCIATE_Information_PDU::get_const_ROSEapdus() const {
    if (index == 31)
	return (const ROSEapdus *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_CMIPAbortInfo(const CMIPAbortInfo & d) {
    index = 32;
    data = (void *)&d;
    constant = 1;
}

const CMIPAbortInfo *SMASE_A_ASSOCIATE_Information_PDU::get_const_CMIPAbortInfo() const {
    if (index == 32)
	return (const CMIPAbortInfo *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_CMIPUserInfo(const CMIPUserInfo & d) {
    index = 33;
    data = (void *)&d;
    constant = 1;
}

const CMIPUserInfo *SMASE_A_ASSOCIATE_Information_PDU::get_const_CMIPUserInfo() const {
    if (index == 33)
	return (const CMIPUserInfo *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_CmipPduReceivingSupport(const CmipPduReceivingSupport & d) {
    index = 34;
    data = (void *)&d;
    constant = 1;
}

const CmipPduReceivingSupport *SMASE_A_ASSOCIATE_Information_PDU::get_const_CmipPduReceivingSupport() const {
    if (index == 34)
	return (const CmipPduReceivingSupport *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_CmipPduSendingSupport(const CmipPduSendingSupport & d) {
    index = 35;
    data = (void *)&d;
    constant = 1;
}

const CmipPduSendingSupport *SMASE_A_ASSOCIATE_Information_PDU::get_const_CmipPduSendingSupport() const {
    if (index == 35)
	return (const CmipPduSendingSupport *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_CmiseFunctionalUnitsSelected(const CmiseFunctionalUnitsSelected & d) {
    index = 36;
    data = (void *)&d;
    constant = 1;
}

const CmiseFunctionalUnitsSelected *SMASE_A_ASSOCIATE_Information_PDU::get_const_CmiseFunctionalUnitsSelected() const {
    if (index == 36)
	return (const CmiseFunctionalUnitsSelected *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_CmiseFunctionalUnitsSupported(const CmiseFunctionalUnitsSupported & d) {
    index = 37;
    data = (void *)&d;
    constant = 1;
}

const CmiseFunctionalUnitsSupported *SMASE_A_ASSOCIATE_Information_PDU::get_const_CmiseFunctionalUnitsSupported() const {
    if (index == 37)
	return (const CmiseFunctionalUnitsSupported *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_InvokeldsOutstanding(const InvokeldsOutstanding & d) {
    index = 38;
    data = (void *)&d;
    constant = 1;
}

const InvokeldsOutstanding *SMASE_A_ASSOCIATE_Information_PDU::get_const_InvokeldsOutstanding() const {
    if (index == 38)
	return (const InvokeldsOutstanding *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_InvokeIdsPerforming(const InvokeIdsPerforming & d) {
    index = 39;
    data = (void *)&d;
    constant = 1;
}

const InvokeIdsPerforming *SMASE_A_ASSOCIATE_Information_PDU::get_const_InvokeIdsPerforming() const {
    if (index == 39)
	return (const InvokeIdsPerforming *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_MaxEncodedCmipPduReceiveSize(const MaxEncodedCmipPduReceiveSize & d) {
    index = 40;
    data = (void *)&d;
    constant = 1;
}

const MaxEncodedCmipPduReceiveSize *SMASE_A_ASSOCIATE_Information_PDU::get_const_MaxEncodedCmipPduReceiveSize() const {
    if (index == 40)
	return (const MaxEncodedCmipPduReceiveSize *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_ProtocolVersionSupported(const ProtocolVersionSupported & d) {
    index = 41;
    data = (void *)&d;
    constant = 1;
}

const ProtocolVersionSupported *SMASE_A_ASSOCIATE_Information_PDU::get_const_ProtocolVersionSupported() const {
    if (index == 41)
	return (const ProtocolVersionSupported *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_SmaseFunctionalUnits(const SmaseFunctionalUnits & d) {
    index = 42;
    data = (void *)&d;
    constant = 1;
}

const SmaseFunctionalUnits *SMASE_A_ASSOCIATE_Information_PDU::get_const_SmaseFunctionalUnits() const {
    if (index == 42)
	return (const SmaseFunctionalUnits *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_SmUserInfoSent(const SmUserInfoSent & d) {
    index = 43;
    data = (void *)&d;
    constant = 1;
}

const SmUserInfoSent *SMASE_A_ASSOCIATE_Information_PDU::get_const_SmUserInfoSent() const {
    if (index == 43)
	return (const SmUserInfoSent *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_SmUserInfoReceived(const SmUserInfoReceived & d) {
    index = 44;
    data = (void *)&d;
    constant = 1;
}

const SmUserInfoReceived *SMASE_A_ASSOCIATE_Information_PDU::get_const_SmUserInfoReceived() const {
    if (index == 44)
	return (const SmUserInfoReceived *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_ROSEInvokeIds(const ROSEInvokeIds & d) {
    index = 45;
    data = (void *)&d;
    constant = 1;
}

const ROSEInvokeIds *SMASE_A_ASSOCIATE_Information_PDU::get_const_ROSEInvokeIds() const {
    if (index == 45)
	return (const ROSEInvokeIds *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_NoInvokeId(const NoInvokeId & d) {
    index = 46;
    data = (void *)&d;
    constant = 1;
}

const NoInvokeId *SMASE_A_ASSOCIATE_Information_PDU::get_const_NoInvokeId() const {
    if (index == 46)
	return (const NoInvokeId *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_SMASEUserData(const SMASEUserData & d) {
    index = 47;
    data = (void *)&d;
    constant = 1;
}

const SMASEUserData *SMASE_A_ASSOCIATE_Information_PDU::get_const_SMASEUserData() const {
    if (index == 47)
	return (const SMASEUserData *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_AccessDenied_PRIORITY(const AccessDenied_PRIORITY & d) {
    index = 48;
    data = (void *)&d;
    constant = 1;
}

const AccessDenied_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_const_AccessDenied_PRIORITY() const {
    if (index == 48)
	return (const AccessDenied_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_ClassInstanceConflict_PRIORITY(const ClassInstanceConflict_PRIORITY & d) {
    index = 49;
    data = (void *)&d;
    constant = 1;
}

const ClassInstanceConflict_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_const_ClassInstanceConflict_PRIORITY() const {
    if (index == 49)
	return (const ClassInstanceConflict_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_ComplexityLimitation_PRIORITY(const ComplexityLimitation_PRIORITY & d) {
    index = 50;
    data = (void *)&d;
    constant = 1;
}

const ComplexityLimitation_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_const_ComplexityLimitation_PRIORITY() const {
    if (index == 50)
	return (const ComplexityLimitation_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_InvalidScope_PRIORITY(const InvalidScope_PRIORITY & d) {
    index = 51;
    data = (void *)&d;
    constant = 1;
}

const InvalidScope_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_const_InvalidScope_PRIORITY() const {
    if (index == 51)
	return (const InvalidScope_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_InvalidArgumentValue_PRIORITY(const InvalidArgumentValue_PRIORITY & d) {
    index = 52;
    data = (void *)&d;
    constant = 1;
}

const InvalidArgumentValue_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_const_InvalidArgumentValue_PRIORITY() const {
    if (index == 52)
	return (const InvalidArgumentValue_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_InvalidFilter_PRIORITY(const InvalidFilter_PRIORITY & d) {
    index = 53;
    data = (void *)&d;
    constant = 1;
}

const InvalidFilter_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_const_InvalidFilter_PRIORITY() const {
    if (index == 53)
	return (const InvalidFilter_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_NoSuchAction_PRIORITY(const NoSuchAction_PRIORITY & d) {
    index = 54;
    data = (void *)&d;
    constant = 1;
}

const NoSuchAction_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_const_NoSuchAction_PRIORITY() const {
    if (index == 54)
	return (const NoSuchAction_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_NoSuchArgument_PRIORITY(const NoSuchArgument_PRIORITY & d) {
    index = 55;
    data = (void *)&d;
    constant = 1;
}

const NoSuchArgument_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_const_NoSuchArgument_PRIORITY() const {
    if (index == 55)
	return (const NoSuchArgument_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_NoSuchObjectClass_PRIORITY(const NoSuchObjectClass_PRIORITY & d) {
    index = 56;
    data = (void *)&d;
    constant = 1;
}

const NoSuchObjectClass_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_const_NoSuchObjectClass_PRIORITY() const {
    if (index == 56)
	return (const NoSuchObjectClass_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_NoSuchObjectInstance_PRIORITY(const NoSuchObjectInstance_PRIORITY & d) {
    index = 57;
    data = (void *)&d;
    constant = 1;
}

const NoSuchObjectInstance_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_const_NoSuchObjectInstance_PRIORITY() const {
    if (index == 57)
	return (const NoSuchObjectInstance_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_ProcessingFailure_PRIORITY(const ProcessingFailure_PRIORITY & d) {
    index = 58;
    data = (void *)&d;
    constant = 1;
}

const ProcessingFailure_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_const_ProcessingFailure_PRIORITY() const {
    if (index == 58)
	return (const ProcessingFailure_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_SyncNotSupported_PRIORITY(const SyncNotSupported_PRIORITY & d) {
    index = 59;
    data = (void *)&d;
    constant = 1;
}

const SyncNotSupported_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_const_SyncNotSupported_PRIORITY() const {
    if (index == 59)
	return (const SyncNotSupported_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_MistypedOperation_PRIORITY(const MistypedOperation_PRIORITY & d) {
    index = 60;
    data = (void *)&d;
    constant = 1;
}

const MistypedOperation_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_const_MistypedOperation_PRIORITY() const {
    if (index == 60)
	return (const MistypedOperation_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_NoSuchInvokeId_PRIORITY(const NoSuchInvokeId_PRIORITY & d) {
    index = 61;
    data = (void *)&d;
    constant = 1;
}

const NoSuchInvokeId_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_const_NoSuchInvokeId_PRIORITY() const {
    if (index == 61)
	return (const NoSuchInvokeId_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_DuplicateManagedObjectInstance_PRIORITY(const DuplicateManagedObjectInstance_PRIORITY & d) {
    index = 62;
    data = (void *)&d;
    constant = 1;
}

const DuplicateManagedObjectInstance_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_const_DuplicateManagedObjectInstance_PRIORITY() const {
    if (index == 62)
	return (const DuplicateManagedObjectInstance_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_InvalidAttributeValue_PRIORITY(const InvalidAttributeValue_PRIORITY & d) {
    index = 63;
    data = (void *)&d;
    constant = 1;
}

const InvalidAttributeValue_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_const_InvalidAttributeValue_PRIORITY() const {
    if (index == 63)
	return (const InvalidAttributeValue_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_InvalidObjectInstance_PRIORITY(const InvalidObjectInstance_PRIORITY & d) {
    index = 64;
    data = (void *)&d;
    constant = 1;
}

const InvalidObjectInstance_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_const_InvalidObjectInstance_PRIORITY() const {
    if (index == 64)
	return (const InvalidObjectInstance_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_MissingAttributeValue_PARAMETER(const MissingAttributeValue_PARAMETER & d) {
    index = 65;
    data = (void *)&d;
    constant = 1;
}

const MissingAttributeValue_PARAMETER *SMASE_A_ASSOCIATE_Information_PDU::get_const_MissingAttributeValue_PARAMETER() const {
    if (index == 65)
	return (const MissingAttributeValue_PARAMETER *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_MissingAttributeValue_PRIORITY(const MissingAttributeValue_PRIORITY & d) {
    index = 66;
    data = (void *)&d;
    constant = 1;
}

const MissingAttributeValue_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_const_MissingAttributeValue_PRIORITY() const {
    if (index == 66)
	return (const MissingAttributeValue_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_NoSuchAttribute_PRIORITY(const NoSuchAttribute_PRIORITY & d) {
    index = 67;
    data = (void *)&d;
    constant = 1;
}

const NoSuchAttribute_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_const_NoSuchAttribute_PRIORITY() const {
    if (index == 67)
	return (const NoSuchAttribute_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_NoSuchReferenceObject_PRIORITY(const NoSuchReferenceObject_PRIORITY & d) {
    index = 68;
    data = (void *)&d;
    constant = 1;
}

const NoSuchReferenceObject_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_const_NoSuchReferenceObject_PRIORITY() const {
    if (index == 68)
	return (const NoSuchReferenceObject_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_NoSuchEventType_PRIORITY(const NoSuchEventType_PRIORITY & d) {
    index = 69;
    data = (void *)&d;
    constant = 1;
}

const NoSuchEventType_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_const_NoSuchEventType_PRIORITY() const {
    if (index == 69)
	return (const NoSuchEventType_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_GetListError_PRIORITY(const GetListError_PRIORITY & d) {
    index = 70;
    data = (void *)&d;
    constant = 1;
}

const GetListError_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_const_GetListError_PRIORITY() const {
    if (index == 70)
	return (const GetListError_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_OperationCancelled_PRIORITY(const OperationCancelled_PRIORITY & d) {
    index = 71;
    data = (void *)&d;
    constant = 1;
}

const OperationCancelled_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_const_OperationCancelled_PRIORITY() const {
    if (index == 71)
	return (const OperationCancelled_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_SetListError_PRIORITY(const SetListError_PRIORITY & d) {
    index = 72;
    data = (void *)&d;
    constant = 1;
}

const SetListError_PRIORITY *SMASE_A_ASSOCIATE_Information_PDU::get_const_SetListError_PRIORITY() const {
    if (index == 72)
	return (const SetListError_PRIORITY *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_Acse_RealizationParameter(const Acse_RealizationParameter & d) {
    index = 73;
    data = (void *)&d;
    constant = 1;
}

const Acse_RealizationParameter *SMASE_A_ASSOCIATE_Information_PDU::get_const_Acse_RealizationParameter() const {
    if (index == 73)
	return (const Acse_RealizationParameter *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_Acse_with_concatenation_RealizationParameter(const Acse_with_concatenation_RealizationParameter & d) {
    index = 74;
    data = (void *)&d;
    constant = 1;
}

const Acse_with_concatenation_RealizationParameter *SMASE_A_ASSOCIATE_Information_PDU::get_const_Acse_with_concatenation_RealizationParameter() const {
    if (index == 74)
	return (const Acse_with_concatenation_RealizationParameter *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_Association_by_RTSE_RealizationParameter(const Association_by_RTSE_RealizationParameter & d) {
    index = 75;
    data = (void *)&d;
    constant = 1;
}

const Association_by_RTSE_RealizationParameter *SMASE_A_ASSOCIATE_Information_PDU::get_const_Association_by_RTSE_RealizationParameter() const {
    if (index == 75)
	return (const Association_by_RTSE_RealizationParameter *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_PData_RealizationParameter(const PData_RealizationParameter & d) {
    index = 76;
    data = (void *)&d;
    constant = 1;
}

const PData_RealizationParameter *SMASE_A_ASSOCIATE_Information_PDU::get_const_PData_RealizationParameter() const {
    if (index == 76)
	return (const PData_RealizationParameter *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_PData_with_concatenation_RealizationParameter(const PData_with_concatenation_RealizationParameter & d) {
    index = 77;
    data = (void *)&d;
    constant = 1;
}

const PData_with_concatenation_RealizationParameter *SMASE_A_ASSOCIATE_Information_PDU::get_const_PData_with_concatenation_RealizationParameter() const {
    if (index == 77)
	return (const PData_with_concatenation_RealizationParameter *)data;
    else
	return 0;
}

void SMASE_A_ASSOCIATE_Information_PDU::set_const_Transfer_by_RTSE_RealizationParameter(const Transfer_by_RTSE_RealizationParameter & d) {
    index = 78;
    data = (void *)&d;
    constant = 1;
}

const Transfer_by_RTSE_RealizationParameter *SMASE_A_ASSOCIATE_Information_PDU::get_const_Transfer_by_RTSE_RealizationParameter() const {
    if (index == 78)
	return (const Transfer_by_RTSE_RealizationParameter *)data;
    else
	return 0;
}

#endif
/* Specific PDU classes */

ActionArgument_PDU::ActionArgument_PDU() {
}

void ActionArgument_PDU::set_data(ActionArgument & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ActionArgument *ActionArgument_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ActionArgument *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ActionArgument_PDU::set_const_data(const ActionArgument & d) {
    data = (void *)&d;
    constant = 1;
}

const ActionArgument *ActionArgument_PDU::get_const_data() const {
    return (const ActionArgument *)data;
}

#endif

OssTypeIndex ActionArgument_PDU::get_index() const {
    return 1;
}

ActionResult_PDU::ActionResult_PDU() {
}

void ActionResult_PDU::set_data(ActionResult & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ActionResult *ActionResult_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ActionResult *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ActionResult_PDU::set_const_data(const ActionResult & d) {
    data = (void *)&d;
    constant = 1;
}

const ActionResult *ActionResult_PDU::get_const_data() const {
    return (const ActionResult *)data;
}

#endif

OssTypeIndex ActionResult_PDU::get_index() const {
    return 2;
}

Attribute_PDU::Attribute_PDU() {
}

void Attribute_PDU::set_data(Attribute & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Attribute *Attribute_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Attribute *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Attribute_PDU::set_const_data(const Attribute & d) {
    data = (void *)&d;
    constant = 1;
}

const Attribute *Attribute_PDU::get_const_data() const {
    return (const Attribute *)data;
}

#endif

OssTypeIndex Attribute_PDU::get_index() const {
    return 3;
}

AttributeId_PDU::AttributeId_PDU() {
}

void AttributeId_PDU::set_data(AttributeId & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AttributeId *AttributeId_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (AttributeId *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void AttributeId_PDU::set_const_data(const AttributeId & d) {
    data = (void *)&d;
    constant = 1;
}

const AttributeId *AttributeId_PDU::get_const_data() const {
    return (const AttributeId *)data;
}

#endif

OssTypeIndex AttributeId_PDU::get_index() const {
    return 4;
}

BaseManagedObjectId_PDU::BaseManagedObjectId_PDU() {
}

void BaseManagedObjectId_PDU::set_data(BaseManagedObjectId & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

BaseManagedObjectId *BaseManagedObjectId_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (BaseManagedObjectId *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void BaseManagedObjectId_PDU::set_const_data(const BaseManagedObjectId & d) {
    data = (void *)&d;
    constant = 1;
}

const BaseManagedObjectId *BaseManagedObjectId_PDU::get_const_data() const {
    return (const BaseManagedObjectId *)data;
}

#endif

OssTypeIndex BaseManagedObjectId_PDU::get_index() const {
    return 5;
}

CMISFilter_PDU::CMISFilter_PDU() {
}

void CMISFilter_PDU::set_data(CMISFilter & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CMISFilter *CMISFilter_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (CMISFilter *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void CMISFilter_PDU::set_const_data(const CMISFilter & d) {
    data = (void *)&d;
    constant = 1;
}

const CMISFilter *CMISFilter_PDU::get_const_data() const {
    return (const CMISFilter *)data;
}

#endif

OssTypeIndex CMISFilter_PDU::get_index() const {
    return 6;
}

CMISSync_PDU::CMISSync_PDU() {
}

void CMISSync_PDU::set_data(CMISSync & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CMISSync *CMISSync_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (CMISSync *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void CMISSync_PDU::set_const_data(const CMISSync & d) {
    data = (void *)&d;
    constant = 1;
}

const CMISSync *CMISSync_PDU::get_const_data() const {
    return (const CMISSync *)data;
}

#endif

OssTypeIndex CMISSync_PDU::get_index() const {
    return 7;
}

ComplexityLimitation_PDU::ComplexityLimitation_PDU() {
}

void ComplexityLimitation_PDU::set_data(ComplexityLimitation & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ComplexityLimitation *ComplexityLimitation_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ComplexityLimitation *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ComplexityLimitation_PDU::set_const_data(const ComplexityLimitation & d) {
    data = (void *)&d;
    constant = 1;
}

const ComplexityLimitation *ComplexityLimitation_PDU::get_const_data() const {
    return (const ComplexityLimitation *)data;
}

#endif

OssTypeIndex ComplexityLimitation_PDU::get_index() const {
    return 8;
}

CreateArgument_PDU::CreateArgument_PDU() {
}

void CreateArgument_PDU::set_data(CreateArgument & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CreateArgument *CreateArgument_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (CreateArgument *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void CreateArgument_PDU::set_const_data(const CreateArgument & d) {
    data = (void *)&d;
    constant = 1;
}

const CreateArgument *CreateArgument_PDU::get_const_data() const {
    return (const CreateArgument *)data;
}

#endif

OssTypeIndex CreateArgument_PDU::get_index() const {
    return 9;
}

CreateResult_PDU::CreateResult_PDU() {
}

void CreateResult_PDU::set_data(CreateResult & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CreateResult *CreateResult_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (CreateResult *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void CreateResult_PDU::set_const_data(const CreateResult & d) {
    data = (void *)&d;
    constant = 1;
}

const CreateResult *CreateResult_PDU::get_const_data() const {
    return (const CreateResult *)data;
}

#endif

OssTypeIndex CreateResult_PDU::get_index() const {
    return 10;
}

DeleteArgument_PDU::DeleteArgument_PDU() {
}

void DeleteArgument_PDU::set_data(DeleteArgument & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

DeleteArgument *DeleteArgument_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (DeleteArgument *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void DeleteArgument_PDU::set_const_data(const DeleteArgument & d) {
    data = (void *)&d;
    constant = 1;
}

const DeleteArgument *DeleteArgument_PDU::get_const_data() const {
    return (const DeleteArgument *)data;
}

#endif

OssTypeIndex DeleteArgument_PDU::get_index() const {
    return 11;
}

DeleteResult_PDU::DeleteResult_PDU() {
}

void DeleteResult_PDU::set_data(DeleteResult & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

DeleteResult *DeleteResult_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (DeleteResult *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void DeleteResult_PDU::set_const_data(const DeleteResult & d) {
    data = (void *)&d;
    constant = 1;
}

const DeleteResult *DeleteResult_PDU::get_const_data() const {
    return (const DeleteResult *)data;
}

#endif

OssTypeIndex DeleteResult_PDU::get_index() const {
    return 12;
}

EventReportArgument_PDU::EventReportArgument_PDU() {
}

void EventReportArgument_PDU::set_data(EventReportArgument & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EventReportArgument *EventReportArgument_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (EventReportArgument *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void EventReportArgument_PDU::set_const_data(const EventReportArgument & d) {
    data = (void *)&d;
    constant = 1;
}

const EventReportArgument *EventReportArgument_PDU::get_const_data() const {
    return (const EventReportArgument *)data;
}

#endif

OssTypeIndex EventReportArgument_PDU::get_index() const {
    return 13;
}

EventReportResult_PDU::EventReportResult_PDU() {
}

void EventReportResult_PDU::set_data(EventReportResult & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EventReportResult *EventReportResult_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (EventReportResult *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void EventReportResult_PDU::set_const_data(const EventReportResult & d) {
    data = (void *)&d;
    constant = 1;
}

const EventReportResult *EventReportResult_PDU::get_const_data() const {
    return (const EventReportResult *)data;
}

#endif

OssTypeIndex EventReportResult_PDU::get_index() const {
    return 14;
}

GetArgument_PDU::GetArgument_PDU() {
}

void GetArgument_PDU::set_data(GetArgument & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

GetArgument *GetArgument_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (GetArgument *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void GetArgument_PDU::set_const_data(const GetArgument & d) {
    data = (void *)&d;
    constant = 1;
}

const GetArgument *GetArgument_PDU::get_const_data() const {
    return (const GetArgument *)data;
}

#endif

OssTypeIndex GetArgument_PDU::get_index() const {
    return 15;
}

GetListError_PDU::GetListError_PDU() {
}

void GetListError_PDU::set_data(GetListError & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

GetListError *GetListError_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (GetListError *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void GetListError_PDU::set_const_data(const GetListError & d) {
    data = (void *)&d;
    constant = 1;
}

const GetListError *GetListError_PDU::get_const_data() const {
    return (const GetListError *)data;
}

#endif

OssTypeIndex GetListError_PDU::get_index() const {
    return 16;
}

GetResult_PDU::GetResult_PDU() {
}

void GetResult_PDU::set_data(GetResult & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

GetResult *GetResult_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (GetResult *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void GetResult_PDU::set_const_data(const GetResult & d) {
    data = (void *)&d;
    constant = 1;
}

const GetResult *GetResult_PDU::get_const_data() const {
    return (const GetResult *)data;
}

#endif

OssTypeIndex GetResult_PDU::get_index() const {
    return 17;
}

InvalidArgumentValue_PDU::InvalidArgumentValue_PDU() {
}

void InvalidArgumentValue_PDU::set_data(InvalidArgumentValue & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

InvalidArgumentValue *InvalidArgumentValue_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (InvalidArgumentValue *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void InvalidArgumentValue_PDU::set_const_data(const InvalidArgumentValue & d) {
    data = (void *)&d;
    constant = 1;
}

const InvalidArgumentValue *InvalidArgumentValue_PDU::get_const_data() const {
    return (const InvalidArgumentValue *)data;
}

#endif

OssTypeIndex InvalidArgumentValue_PDU::get_index() const {
    return 18;
}

InvokeIDType_PDU::InvokeIDType_PDU() {
}

void InvokeIDType_PDU::set_data(InvokeIDType & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

InvokeIDType *InvokeIDType_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (InvokeIDType *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void InvokeIDType_PDU::set_const_data(const InvokeIDType & d) {
    data = (void *)&d;
    constant = 1;
}

const InvokeIDType *InvokeIDType_PDU::get_const_data() const {
    return (const InvokeIDType *)data;
}

#endif

OssTypeIndex InvokeIDType_PDU::get_index() const {
    return 19;
}

LinkedReplyArgument_PDU::LinkedReplyArgument_PDU() {
}

void LinkedReplyArgument_PDU::set_data(LinkedReplyArgument & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

LinkedReplyArgument *LinkedReplyArgument_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (LinkedReplyArgument *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void LinkedReplyArgument_PDU::set_const_data(const LinkedReplyArgument & d) {
    data = (void *)&d;
    constant = 1;
}

const LinkedReplyArgument *LinkedReplyArgument_PDU::get_const_data() const {
    return (const LinkedReplyArgument *)data;
}

#endif

OssTypeIndex LinkedReplyArgument_PDU::get_index() const {
    return 20;
}

NoSuchAction_PDU::NoSuchAction_PDU() {
}

void NoSuchAction_PDU::set_data(NoSuchAction & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoSuchAction *NoSuchAction_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (NoSuchAction *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void NoSuchAction_PDU::set_const_data(const NoSuchAction & d) {
    data = (void *)&d;
    constant = 1;
}

const NoSuchAction *NoSuchAction_PDU::get_const_data() const {
    return (const NoSuchAction *)data;
}

#endif

OssTypeIndex NoSuchAction_PDU::get_index() const {
    return 21;
}

NoSuchArgument_PDU::NoSuchArgument_PDU() {
}

void NoSuchArgument_PDU::set_data(NoSuchArgument & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoSuchArgument *NoSuchArgument_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (NoSuchArgument *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void NoSuchArgument_PDU::set_const_data(const NoSuchArgument & d) {
    data = (void *)&d;
    constant = 1;
}

const NoSuchArgument *NoSuchArgument_PDU::get_const_data() const {
    return (const NoSuchArgument *)data;
}

#endif

OssTypeIndex NoSuchArgument_PDU::get_index() const {
    return 22;
}

NoSuchEventType_PDU::NoSuchEventType_PDU() {
}

void NoSuchEventType_PDU::set_data(NoSuchEventType & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoSuchEventType *NoSuchEventType_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (NoSuchEventType *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void NoSuchEventType_PDU::set_const_data(const NoSuchEventType & d) {
    data = (void *)&d;
    constant = 1;
}

const NoSuchEventType *NoSuchEventType_PDU::get_const_data() const {
    return (const NoSuchEventType *)data;
}

#endif

OssTypeIndex NoSuchEventType_PDU::get_index() const {
    return 23;
}

ObjectClass_PDU::ObjectClass_PDU() {
}

void ObjectClass_PDU::set_data(ObjectClass & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ObjectClass *ObjectClass_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ObjectClass *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ObjectClass_PDU::set_const_data(const ObjectClass & d) {
    data = (void *)&d;
    constant = 1;
}

const ObjectClass *ObjectClass_PDU::get_const_data() const {
    return (const ObjectClass *)data;
}

#endif

OssTypeIndex ObjectClass_PDU::get_index() const {
    return 24;
}

ObjectInstance_PDU::ObjectInstance_PDU() {
}

void ObjectInstance_PDU::set_data(ObjectInstance & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ObjectInstance *ObjectInstance_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ObjectInstance *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ObjectInstance_PDU::set_const_data(const ObjectInstance & d) {
    data = (void *)&d;
    constant = 1;
}

const ObjectInstance *ObjectInstance_PDU::get_const_data() const {
    return (const ObjectInstance *)data;
}

#endif

OssTypeIndex ObjectInstance_PDU::get_index() const {
    return 25;
}

ProcessingFailure_PDU::ProcessingFailure_PDU() {
}

void ProcessingFailure_PDU::set_data(ProcessingFailure & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ProcessingFailure *ProcessingFailure_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ProcessingFailure *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ProcessingFailure_PDU::set_const_data(const ProcessingFailure & d) {
    data = (void *)&d;
    constant = 1;
}

const ProcessingFailure *ProcessingFailure_PDU::get_const_data() const {
    return (const ProcessingFailure *)data;
}

#endif

OssTypeIndex ProcessingFailure_PDU::get_index() const {
    return 26;
}

Scope_PDU::Scope_PDU() {
}

void Scope_PDU::set_data(Scope & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Scope *Scope_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Scope *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Scope_PDU::set_const_data(const Scope & d) {
    data = (void *)&d;
    constant = 1;
}

const Scope *Scope_PDU::get_const_data() const {
    return (const Scope *)data;
}

#endif

OssTypeIndex Scope_PDU::get_index() const {
    return 27;
}

SetArgument_PDU::SetArgument_PDU() {
}

void SetArgument_PDU::set_data(SetArgument & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SetArgument *SetArgument_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (SetArgument *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void SetArgument_PDU::set_const_data(const SetArgument & d) {
    data = (void *)&d;
    constant = 1;
}

const SetArgument *SetArgument_PDU::get_const_data() const {
    return (const SetArgument *)data;
}

#endif

OssTypeIndex SetArgument_PDU::get_index() const {
    return 28;
}

SetListError_PDU::SetListError_PDU() {
}

void SetListError_PDU::set_data(SetListError & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SetListError *SetListError_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (SetListError *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void SetListError_PDU::set_const_data(const SetListError & d) {
    data = (void *)&d;
    constant = 1;
}

const SetListError *SetListError_PDU::get_const_data() const {
    return (const SetListError *)data;
}

#endif

OssTypeIndex SetListError_PDU::get_index() const {
    return 29;
}

SetResult_PDU::SetResult_PDU() {
}

void SetResult_PDU::set_data(SetResult & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SetResult *SetResult_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (SetResult *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void SetResult_PDU::set_const_data(const SetResult & d) {
    data = (void *)&d;
    constant = 1;
}

const SetResult *SetResult_PDU::get_const_data() const {
    return (const SetResult *)data;
}

#endif

OssTypeIndex SetResult_PDU::get_index() const {
    return 30;
}

ROSEapdus_PDU::ROSEapdus_PDU() {
}

void ROSEapdus_PDU::set_data(ROSEapdus & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ROSEapdus *ROSEapdus_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ROSEapdus *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ROSEapdus_PDU::set_const_data(const ROSEapdus & d) {
    data = (void *)&d;
    constant = 1;
}

const ROSEapdus *ROSEapdus_PDU::get_const_data() const {
    return (const ROSEapdus *)data;
}

#endif

OssTypeIndex ROSEapdus_PDU::get_index() const {
    return 31;
}

CMIPAbortInfo_PDU::CMIPAbortInfo_PDU() {
}

void CMIPAbortInfo_PDU::set_data(CMIPAbortInfo & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CMIPAbortInfo *CMIPAbortInfo_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (CMIPAbortInfo *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void CMIPAbortInfo_PDU::set_const_data(const CMIPAbortInfo & d) {
    data = (void *)&d;
    constant = 1;
}

const CMIPAbortInfo *CMIPAbortInfo_PDU::get_const_data() const {
    return (const CMIPAbortInfo *)data;
}

#endif

OssTypeIndex CMIPAbortInfo_PDU::get_index() const {
    return 32;
}

CMIPUserInfo_PDU::CMIPUserInfo_PDU() {
}

void CMIPUserInfo_PDU::set_data(CMIPUserInfo & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CMIPUserInfo *CMIPUserInfo_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (CMIPUserInfo *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void CMIPUserInfo_PDU::set_const_data(const CMIPUserInfo & d) {
    data = (void *)&d;
    constant = 1;
}

const CMIPUserInfo *CMIPUserInfo_PDU::get_const_data() const {
    return (const CMIPUserInfo *)data;
}

#endif

OssTypeIndex CMIPUserInfo_PDU::get_index() const {
    return 33;
}

CmipPduReceivingSupport_PDU::CmipPduReceivingSupport_PDU() {
}

void CmipPduReceivingSupport_PDU::set_data(CmipPduReceivingSupport & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CmipPduReceivingSupport *CmipPduReceivingSupport_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (CmipPduReceivingSupport *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void CmipPduReceivingSupport_PDU::set_const_data(const CmipPduReceivingSupport & d) {
    data = (void *)&d;
    constant = 1;
}

const CmipPduReceivingSupport *CmipPduReceivingSupport_PDU::get_const_data() const {
    return (const CmipPduReceivingSupport *)data;
}

#endif

OssTypeIndex CmipPduReceivingSupport_PDU::get_index() const {
    return 34;
}

CmipPduSendingSupport_PDU::CmipPduSendingSupport_PDU() {
}

void CmipPduSendingSupport_PDU::set_data(CmipPduSendingSupport & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CmipPduSendingSupport *CmipPduSendingSupport_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (CmipPduSendingSupport *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void CmipPduSendingSupport_PDU::set_const_data(const CmipPduSendingSupport & d) {
    data = (void *)&d;
    constant = 1;
}

const CmipPduSendingSupport *CmipPduSendingSupport_PDU::get_const_data() const {
    return (const CmipPduSendingSupport *)data;
}

#endif

OssTypeIndex CmipPduSendingSupport_PDU::get_index() const {
    return 35;
}

CmiseFunctionalUnitsSelected_PDU::CmiseFunctionalUnitsSelected_PDU() {
}

void CmiseFunctionalUnitsSelected_PDU::set_data(CmiseFunctionalUnitsSelected & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CmiseFunctionalUnitsSelected *CmiseFunctionalUnitsSelected_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (CmiseFunctionalUnitsSelected *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void CmiseFunctionalUnitsSelected_PDU::set_const_data(const CmiseFunctionalUnitsSelected & d) {
    data = (void *)&d;
    constant = 1;
}

const CmiseFunctionalUnitsSelected *CmiseFunctionalUnitsSelected_PDU::get_const_data() const {
    return (const CmiseFunctionalUnitsSelected *)data;
}

#endif

OssTypeIndex CmiseFunctionalUnitsSelected_PDU::get_index() const {
    return 36;
}

CmiseFunctionalUnitsSupported_PDU::CmiseFunctionalUnitsSupported_PDU() {
}

void CmiseFunctionalUnitsSupported_PDU::set_data(CmiseFunctionalUnitsSupported & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CmiseFunctionalUnitsSupported *CmiseFunctionalUnitsSupported_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (CmiseFunctionalUnitsSupported *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void CmiseFunctionalUnitsSupported_PDU::set_const_data(const CmiseFunctionalUnitsSupported & d) {
    data = (void *)&d;
    constant = 1;
}

const CmiseFunctionalUnitsSupported *CmiseFunctionalUnitsSupported_PDU::get_const_data() const {
    return (const CmiseFunctionalUnitsSupported *)data;
}

#endif

OssTypeIndex CmiseFunctionalUnitsSupported_PDU::get_index() const {
    return 37;
}

InvokeldsOutstanding_PDU::InvokeldsOutstanding_PDU() {
}

void InvokeldsOutstanding_PDU::set_data(InvokeldsOutstanding & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

InvokeldsOutstanding *InvokeldsOutstanding_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (InvokeldsOutstanding *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void InvokeldsOutstanding_PDU::set_const_data(const InvokeldsOutstanding & d) {
    data = (void *)&d;
    constant = 1;
}

const InvokeldsOutstanding *InvokeldsOutstanding_PDU::get_const_data() const {
    return (const InvokeldsOutstanding *)data;
}

#endif

OssTypeIndex InvokeldsOutstanding_PDU::get_index() const {
    return 38;
}

InvokeIdsPerforming_PDU::InvokeIdsPerforming_PDU() {
}

void InvokeIdsPerforming_PDU::set_data(InvokeIdsPerforming & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

InvokeIdsPerforming *InvokeIdsPerforming_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (InvokeIdsPerforming *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void InvokeIdsPerforming_PDU::set_const_data(const InvokeIdsPerforming & d) {
    data = (void *)&d;
    constant = 1;
}

const InvokeIdsPerforming *InvokeIdsPerforming_PDU::get_const_data() const {
    return (const InvokeIdsPerforming *)data;
}

#endif

OssTypeIndex InvokeIdsPerforming_PDU::get_index() const {
    return 39;
}

MaxEncodedCmipPduReceiveSize_PDU::MaxEncodedCmipPduReceiveSize_PDU() {
}

void MaxEncodedCmipPduReceiveSize_PDU::set_data(MaxEncodedCmipPduReceiveSize & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

MaxEncodedCmipPduReceiveSize *MaxEncodedCmipPduReceiveSize_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (MaxEncodedCmipPduReceiveSize *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void MaxEncodedCmipPduReceiveSize_PDU::set_const_data(const MaxEncodedCmipPduReceiveSize & d) {
    data = (void *)&d;
    constant = 1;
}

const MaxEncodedCmipPduReceiveSize *MaxEncodedCmipPduReceiveSize_PDU::get_const_data() const {
    return (const MaxEncodedCmipPduReceiveSize *)data;
}

#endif

OssTypeIndex MaxEncodedCmipPduReceiveSize_PDU::get_index() const {
    return 40;
}

ProtocolVersionSupported_PDU::ProtocolVersionSupported_PDU() {
}

void ProtocolVersionSupported_PDU::set_data(ProtocolVersionSupported & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ProtocolVersionSupported *ProtocolVersionSupported_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ProtocolVersionSupported *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ProtocolVersionSupported_PDU::set_const_data(const ProtocolVersionSupported & d) {
    data = (void *)&d;
    constant = 1;
}

const ProtocolVersionSupported *ProtocolVersionSupported_PDU::get_const_data() const {
    return (const ProtocolVersionSupported *)data;
}

#endif

OssTypeIndex ProtocolVersionSupported_PDU::get_index() const {
    return 41;
}

SmaseFunctionalUnits_PDU::SmaseFunctionalUnits_PDU() {
}

void SmaseFunctionalUnits_PDU::set_data(SmaseFunctionalUnits & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SmaseFunctionalUnits *SmaseFunctionalUnits_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (SmaseFunctionalUnits *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void SmaseFunctionalUnits_PDU::set_const_data(const SmaseFunctionalUnits & d) {
    data = (void *)&d;
    constant = 1;
}

const SmaseFunctionalUnits *SmaseFunctionalUnits_PDU::get_const_data() const {
    return (const SmaseFunctionalUnits *)data;
}

#endif

OssTypeIndex SmaseFunctionalUnits_PDU::get_index() const {
    return 42;
}

SmUserInfoSent_PDU::SmUserInfoSent_PDU() {
}

void SmUserInfoSent_PDU::set_data(SmUserInfoSent & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SmUserInfoSent *SmUserInfoSent_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (SmUserInfoSent *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void SmUserInfoSent_PDU::set_const_data(const SmUserInfoSent & d) {
    data = (void *)&d;
    constant = 1;
}

const SmUserInfoSent *SmUserInfoSent_PDU::get_const_data() const {
    return (const SmUserInfoSent *)data;
}

#endif

OssTypeIndex SmUserInfoSent_PDU::get_index() const {
    return 43;
}

SmUserInfoReceived_PDU::SmUserInfoReceived_PDU() {
}

void SmUserInfoReceived_PDU::set_data(SmUserInfoReceived & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SmUserInfoReceived *SmUserInfoReceived_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (SmUserInfoReceived *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void SmUserInfoReceived_PDU::set_const_data(const SmUserInfoReceived & d) {
    data = (void *)&d;
    constant = 1;
}

const SmUserInfoReceived *SmUserInfoReceived_PDU::get_const_data() const {
    return (const SmUserInfoReceived *)data;
}

#endif

OssTypeIndex SmUserInfoReceived_PDU::get_index() const {
    return 44;
}

ROSEInvokeIds_PDU::ROSEInvokeIds_PDU() {
}

void ROSEInvokeIds_PDU::set_data(ROSEInvokeIds & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ROSEInvokeIds *ROSEInvokeIds_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ROSEInvokeIds *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ROSEInvokeIds_PDU::set_const_data(const ROSEInvokeIds & d) {
    data = (void *)&d;
    constant = 1;
}

const ROSEInvokeIds *ROSEInvokeIds_PDU::get_const_data() const {
    return (const ROSEInvokeIds *)data;
}

#endif

OssTypeIndex ROSEInvokeIds_PDU::get_index() const {
    return 45;
}

NoInvokeId_PDU::NoInvokeId_PDU() {
}

void NoInvokeId_PDU::set_data(NoInvokeId & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoInvokeId *NoInvokeId_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (NoInvokeId *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void NoInvokeId_PDU::set_const_data(const NoInvokeId & d) {
    data = (void *)&d;
    constant = 1;
}

const NoInvokeId *NoInvokeId_PDU::get_const_data() const {
    return (const NoInvokeId *)data;
}

#endif

OssTypeIndex NoInvokeId_PDU::get_index() const {
    return 46;
}

SMASEUserData_PDU::SMASEUserData_PDU() {
}

void SMASEUserData_PDU::set_data(SMASEUserData & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SMASEUserData *SMASEUserData_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (SMASEUserData *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void SMASEUserData_PDU::set_const_data(const SMASEUserData & d) {
    data = (void *)&d;
    constant = 1;
}

const SMASEUserData *SMASEUserData_PDU::get_const_data() const {
    return (const SMASEUserData *)data;
}

#endif

OssTypeIndex SMASEUserData_PDU::get_index() const {
    return 47;
}

AccessDenied_PRIORITY_PDU::AccessDenied_PRIORITY_PDU() {
}

void AccessDenied_PRIORITY_PDU::set_data(AccessDenied_PRIORITY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AccessDenied_PRIORITY *AccessDenied_PRIORITY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (AccessDenied_PRIORITY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void AccessDenied_PRIORITY_PDU::set_const_data(const AccessDenied_PRIORITY & d) {
    data = (void *)&d;
    constant = 1;
}

const AccessDenied_PRIORITY *AccessDenied_PRIORITY_PDU::get_const_data() const {
    return (const AccessDenied_PRIORITY *)data;
}

#endif

OssTypeIndex AccessDenied_PRIORITY_PDU::get_index() const {
    return 48;
}

ClassInstanceConflict_PRIORITY_PDU::ClassInstanceConflict_PRIORITY_PDU() {
}

void ClassInstanceConflict_PRIORITY_PDU::set_data(ClassInstanceConflict_PRIORITY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ClassInstanceConflict_PRIORITY *ClassInstanceConflict_PRIORITY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ClassInstanceConflict_PRIORITY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ClassInstanceConflict_PRIORITY_PDU::set_const_data(const ClassInstanceConflict_PRIORITY & d) {
    data = (void *)&d;
    constant = 1;
}

const ClassInstanceConflict_PRIORITY *ClassInstanceConflict_PRIORITY_PDU::get_const_data() const {
    return (const ClassInstanceConflict_PRIORITY *)data;
}

#endif

OssTypeIndex ClassInstanceConflict_PRIORITY_PDU::get_index() const {
    return 49;
}

ComplexityLimitation_PRIORITY_PDU::ComplexityLimitation_PRIORITY_PDU() {
}

void ComplexityLimitation_PRIORITY_PDU::set_data(ComplexityLimitation_PRIORITY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ComplexityLimitation_PRIORITY *ComplexityLimitation_PRIORITY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ComplexityLimitation_PRIORITY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ComplexityLimitation_PRIORITY_PDU::set_const_data(const ComplexityLimitation_PRIORITY & d) {
    data = (void *)&d;
    constant = 1;
}

const ComplexityLimitation_PRIORITY *ComplexityLimitation_PRIORITY_PDU::get_const_data() const {
    return (const ComplexityLimitation_PRIORITY *)data;
}

#endif

OssTypeIndex ComplexityLimitation_PRIORITY_PDU::get_index() const {
    return 50;
}

InvalidScope_PRIORITY_PDU::InvalidScope_PRIORITY_PDU() {
}

void InvalidScope_PRIORITY_PDU::set_data(InvalidScope_PRIORITY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

InvalidScope_PRIORITY *InvalidScope_PRIORITY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (InvalidScope_PRIORITY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void InvalidScope_PRIORITY_PDU::set_const_data(const InvalidScope_PRIORITY & d) {
    data = (void *)&d;
    constant = 1;
}

const InvalidScope_PRIORITY *InvalidScope_PRIORITY_PDU::get_const_data() const {
    return (const InvalidScope_PRIORITY *)data;
}

#endif

OssTypeIndex InvalidScope_PRIORITY_PDU::get_index() const {
    return 51;
}

InvalidArgumentValue_PRIORITY_PDU::InvalidArgumentValue_PRIORITY_PDU() {
}

void InvalidArgumentValue_PRIORITY_PDU::set_data(InvalidArgumentValue_PRIORITY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

InvalidArgumentValue_PRIORITY *InvalidArgumentValue_PRIORITY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (InvalidArgumentValue_PRIORITY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void InvalidArgumentValue_PRIORITY_PDU::set_const_data(const InvalidArgumentValue_PRIORITY & d) {
    data = (void *)&d;
    constant = 1;
}

const InvalidArgumentValue_PRIORITY *InvalidArgumentValue_PRIORITY_PDU::get_const_data() const {
    return (const InvalidArgumentValue_PRIORITY *)data;
}

#endif

OssTypeIndex InvalidArgumentValue_PRIORITY_PDU::get_index() const {
    return 52;
}

InvalidFilter_PRIORITY_PDU::InvalidFilter_PRIORITY_PDU() {
}

void InvalidFilter_PRIORITY_PDU::set_data(InvalidFilter_PRIORITY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

InvalidFilter_PRIORITY *InvalidFilter_PRIORITY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (InvalidFilter_PRIORITY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void InvalidFilter_PRIORITY_PDU::set_const_data(const InvalidFilter_PRIORITY & d) {
    data = (void *)&d;
    constant = 1;
}

const InvalidFilter_PRIORITY *InvalidFilter_PRIORITY_PDU::get_const_data() const {
    return (const InvalidFilter_PRIORITY *)data;
}

#endif

OssTypeIndex InvalidFilter_PRIORITY_PDU::get_index() const {
    return 53;
}

NoSuchAction_PRIORITY_PDU::NoSuchAction_PRIORITY_PDU() {
}

void NoSuchAction_PRIORITY_PDU::set_data(NoSuchAction_PRIORITY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoSuchAction_PRIORITY *NoSuchAction_PRIORITY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (NoSuchAction_PRIORITY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void NoSuchAction_PRIORITY_PDU::set_const_data(const NoSuchAction_PRIORITY & d) {
    data = (void *)&d;
    constant = 1;
}

const NoSuchAction_PRIORITY *NoSuchAction_PRIORITY_PDU::get_const_data() const {
    return (const NoSuchAction_PRIORITY *)data;
}

#endif

OssTypeIndex NoSuchAction_PRIORITY_PDU::get_index() const {
    return 54;
}

NoSuchArgument_PRIORITY_PDU::NoSuchArgument_PRIORITY_PDU() {
}

void NoSuchArgument_PRIORITY_PDU::set_data(NoSuchArgument_PRIORITY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoSuchArgument_PRIORITY *NoSuchArgument_PRIORITY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (NoSuchArgument_PRIORITY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void NoSuchArgument_PRIORITY_PDU::set_const_data(const NoSuchArgument_PRIORITY & d) {
    data = (void *)&d;
    constant = 1;
}

const NoSuchArgument_PRIORITY *NoSuchArgument_PRIORITY_PDU::get_const_data() const {
    return (const NoSuchArgument_PRIORITY *)data;
}

#endif

OssTypeIndex NoSuchArgument_PRIORITY_PDU::get_index() const {
    return 55;
}

NoSuchObjectClass_PRIORITY_PDU::NoSuchObjectClass_PRIORITY_PDU() {
}

void NoSuchObjectClass_PRIORITY_PDU::set_data(NoSuchObjectClass_PRIORITY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoSuchObjectClass_PRIORITY *NoSuchObjectClass_PRIORITY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (NoSuchObjectClass_PRIORITY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void NoSuchObjectClass_PRIORITY_PDU::set_const_data(const NoSuchObjectClass_PRIORITY & d) {
    data = (void *)&d;
    constant = 1;
}

const NoSuchObjectClass_PRIORITY *NoSuchObjectClass_PRIORITY_PDU::get_const_data() const {
    return (const NoSuchObjectClass_PRIORITY *)data;
}

#endif

OssTypeIndex NoSuchObjectClass_PRIORITY_PDU::get_index() const {
    return 56;
}

NoSuchObjectInstance_PRIORITY_PDU::NoSuchObjectInstance_PRIORITY_PDU() {
}

void NoSuchObjectInstance_PRIORITY_PDU::set_data(NoSuchObjectInstance_PRIORITY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoSuchObjectInstance_PRIORITY *NoSuchObjectInstance_PRIORITY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (NoSuchObjectInstance_PRIORITY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void NoSuchObjectInstance_PRIORITY_PDU::set_const_data(const NoSuchObjectInstance_PRIORITY & d) {
    data = (void *)&d;
    constant = 1;
}

const NoSuchObjectInstance_PRIORITY *NoSuchObjectInstance_PRIORITY_PDU::get_const_data() const {
    return (const NoSuchObjectInstance_PRIORITY *)data;
}

#endif

OssTypeIndex NoSuchObjectInstance_PRIORITY_PDU::get_index() const {
    return 57;
}

ProcessingFailure_PRIORITY_PDU::ProcessingFailure_PRIORITY_PDU() {
}

void ProcessingFailure_PRIORITY_PDU::set_data(ProcessingFailure_PRIORITY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ProcessingFailure_PRIORITY *ProcessingFailure_PRIORITY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ProcessingFailure_PRIORITY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ProcessingFailure_PRIORITY_PDU::set_const_data(const ProcessingFailure_PRIORITY & d) {
    data = (void *)&d;
    constant = 1;
}

const ProcessingFailure_PRIORITY *ProcessingFailure_PRIORITY_PDU::get_const_data() const {
    return (const ProcessingFailure_PRIORITY *)data;
}

#endif

OssTypeIndex ProcessingFailure_PRIORITY_PDU::get_index() const {
    return 58;
}

SyncNotSupported_PRIORITY_PDU::SyncNotSupported_PRIORITY_PDU() {
}

void SyncNotSupported_PRIORITY_PDU::set_data(SyncNotSupported_PRIORITY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SyncNotSupported_PRIORITY *SyncNotSupported_PRIORITY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (SyncNotSupported_PRIORITY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void SyncNotSupported_PRIORITY_PDU::set_const_data(const SyncNotSupported_PRIORITY & d) {
    data = (void *)&d;
    constant = 1;
}

const SyncNotSupported_PRIORITY *SyncNotSupported_PRIORITY_PDU::get_const_data() const {
    return (const SyncNotSupported_PRIORITY *)data;
}

#endif

OssTypeIndex SyncNotSupported_PRIORITY_PDU::get_index() const {
    return 59;
}

MistypedOperation_PRIORITY_PDU::MistypedOperation_PRIORITY_PDU() {
}

void MistypedOperation_PRIORITY_PDU::set_data(MistypedOperation_PRIORITY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

MistypedOperation_PRIORITY *MistypedOperation_PRIORITY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (MistypedOperation_PRIORITY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void MistypedOperation_PRIORITY_PDU::set_const_data(const MistypedOperation_PRIORITY & d) {
    data = (void *)&d;
    constant = 1;
}

const MistypedOperation_PRIORITY *MistypedOperation_PRIORITY_PDU::get_const_data() const {
    return (const MistypedOperation_PRIORITY *)data;
}

#endif

OssTypeIndex MistypedOperation_PRIORITY_PDU::get_index() const {
    return 60;
}

NoSuchInvokeId_PRIORITY_PDU::NoSuchInvokeId_PRIORITY_PDU() {
}

void NoSuchInvokeId_PRIORITY_PDU::set_data(NoSuchInvokeId_PRIORITY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoSuchInvokeId_PRIORITY *NoSuchInvokeId_PRIORITY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (NoSuchInvokeId_PRIORITY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void NoSuchInvokeId_PRIORITY_PDU::set_const_data(const NoSuchInvokeId_PRIORITY & d) {
    data = (void *)&d;
    constant = 1;
}

const NoSuchInvokeId_PRIORITY *NoSuchInvokeId_PRIORITY_PDU::get_const_data() const {
    return (const NoSuchInvokeId_PRIORITY *)data;
}

#endif

OssTypeIndex NoSuchInvokeId_PRIORITY_PDU::get_index() const {
    return 61;
}

DuplicateManagedObjectInstance_PRIORITY_PDU::DuplicateManagedObjectInstance_PRIORITY_PDU() {
}

void DuplicateManagedObjectInstance_PRIORITY_PDU::set_data(DuplicateManagedObjectInstance_PRIORITY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

DuplicateManagedObjectInstance_PRIORITY *DuplicateManagedObjectInstance_PRIORITY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (DuplicateManagedObjectInstance_PRIORITY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void DuplicateManagedObjectInstance_PRIORITY_PDU::set_const_data(const DuplicateManagedObjectInstance_PRIORITY & d) {
    data = (void *)&d;
    constant = 1;
}

const DuplicateManagedObjectInstance_PRIORITY *DuplicateManagedObjectInstance_PRIORITY_PDU::get_const_data() const {
    return (const DuplicateManagedObjectInstance_PRIORITY *)data;
}

#endif

OssTypeIndex DuplicateManagedObjectInstance_PRIORITY_PDU::get_index() const {
    return 62;
}

InvalidAttributeValue_PRIORITY_PDU::InvalidAttributeValue_PRIORITY_PDU() {
}

void InvalidAttributeValue_PRIORITY_PDU::set_data(InvalidAttributeValue_PRIORITY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

InvalidAttributeValue_PRIORITY *InvalidAttributeValue_PRIORITY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (InvalidAttributeValue_PRIORITY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void InvalidAttributeValue_PRIORITY_PDU::set_const_data(const InvalidAttributeValue_PRIORITY & d) {
    data = (void *)&d;
    constant = 1;
}

const InvalidAttributeValue_PRIORITY *InvalidAttributeValue_PRIORITY_PDU::get_const_data() const {
    return (const InvalidAttributeValue_PRIORITY *)data;
}

#endif

OssTypeIndex InvalidAttributeValue_PRIORITY_PDU::get_index() const {
    return 63;
}

InvalidObjectInstance_PRIORITY_PDU::InvalidObjectInstance_PRIORITY_PDU() {
}

void InvalidObjectInstance_PRIORITY_PDU::set_data(InvalidObjectInstance_PRIORITY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

InvalidObjectInstance_PRIORITY *InvalidObjectInstance_PRIORITY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (InvalidObjectInstance_PRIORITY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void InvalidObjectInstance_PRIORITY_PDU::set_const_data(const InvalidObjectInstance_PRIORITY & d) {
    data = (void *)&d;
    constant = 1;
}

const InvalidObjectInstance_PRIORITY *InvalidObjectInstance_PRIORITY_PDU::get_const_data() const {
    return (const InvalidObjectInstance_PRIORITY *)data;
}

#endif

OssTypeIndex InvalidObjectInstance_PRIORITY_PDU::get_index() const {
    return 64;
}

MissingAttributeValue_PARAMETER_PDU::MissingAttributeValue_PARAMETER_PDU() {
}

void MissingAttributeValue_PARAMETER_PDU::set_data(MissingAttributeValue_PARAMETER & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

MissingAttributeValue_PARAMETER *MissingAttributeValue_PARAMETER_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (MissingAttributeValue_PARAMETER *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void MissingAttributeValue_PARAMETER_PDU::set_const_data(const MissingAttributeValue_PARAMETER & d) {
    data = (void *)&d;
    constant = 1;
}

const MissingAttributeValue_PARAMETER *MissingAttributeValue_PARAMETER_PDU::get_const_data() const {
    return (const MissingAttributeValue_PARAMETER *)data;
}

#endif

OssTypeIndex MissingAttributeValue_PARAMETER_PDU::get_index() const {
    return 65;
}

MissingAttributeValue_PRIORITY_PDU::MissingAttributeValue_PRIORITY_PDU() {
}

void MissingAttributeValue_PRIORITY_PDU::set_data(MissingAttributeValue_PRIORITY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

MissingAttributeValue_PRIORITY *MissingAttributeValue_PRIORITY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (MissingAttributeValue_PRIORITY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void MissingAttributeValue_PRIORITY_PDU::set_const_data(const MissingAttributeValue_PRIORITY & d) {
    data = (void *)&d;
    constant = 1;
}

const MissingAttributeValue_PRIORITY *MissingAttributeValue_PRIORITY_PDU::get_const_data() const {
    return (const MissingAttributeValue_PRIORITY *)data;
}

#endif

OssTypeIndex MissingAttributeValue_PRIORITY_PDU::get_index() const {
    return 66;
}

NoSuchAttribute_PRIORITY_PDU::NoSuchAttribute_PRIORITY_PDU() {
}

void NoSuchAttribute_PRIORITY_PDU::set_data(NoSuchAttribute_PRIORITY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoSuchAttribute_PRIORITY *NoSuchAttribute_PRIORITY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (NoSuchAttribute_PRIORITY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void NoSuchAttribute_PRIORITY_PDU::set_const_data(const NoSuchAttribute_PRIORITY & d) {
    data = (void *)&d;
    constant = 1;
}

const NoSuchAttribute_PRIORITY *NoSuchAttribute_PRIORITY_PDU::get_const_data() const {
    return (const NoSuchAttribute_PRIORITY *)data;
}

#endif

OssTypeIndex NoSuchAttribute_PRIORITY_PDU::get_index() const {
    return 67;
}

NoSuchReferenceObject_PRIORITY_PDU::NoSuchReferenceObject_PRIORITY_PDU() {
}

void NoSuchReferenceObject_PRIORITY_PDU::set_data(NoSuchReferenceObject_PRIORITY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoSuchReferenceObject_PRIORITY *NoSuchReferenceObject_PRIORITY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (NoSuchReferenceObject_PRIORITY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void NoSuchReferenceObject_PRIORITY_PDU::set_const_data(const NoSuchReferenceObject_PRIORITY & d) {
    data = (void *)&d;
    constant = 1;
}

const NoSuchReferenceObject_PRIORITY *NoSuchReferenceObject_PRIORITY_PDU::get_const_data() const {
    return (const NoSuchReferenceObject_PRIORITY *)data;
}

#endif

OssTypeIndex NoSuchReferenceObject_PRIORITY_PDU::get_index() const {
    return 68;
}

NoSuchEventType_PRIORITY_PDU::NoSuchEventType_PRIORITY_PDU() {
}

void NoSuchEventType_PRIORITY_PDU::set_data(NoSuchEventType_PRIORITY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoSuchEventType_PRIORITY *NoSuchEventType_PRIORITY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (NoSuchEventType_PRIORITY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void NoSuchEventType_PRIORITY_PDU::set_const_data(const NoSuchEventType_PRIORITY & d) {
    data = (void *)&d;
    constant = 1;
}

const NoSuchEventType_PRIORITY *NoSuchEventType_PRIORITY_PDU::get_const_data() const {
    return (const NoSuchEventType_PRIORITY *)data;
}

#endif

OssTypeIndex NoSuchEventType_PRIORITY_PDU::get_index() const {
    return 69;
}

GetListError_PRIORITY_PDU::GetListError_PRIORITY_PDU() {
}

void GetListError_PRIORITY_PDU::set_data(GetListError_PRIORITY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

GetListError_PRIORITY *GetListError_PRIORITY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (GetListError_PRIORITY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void GetListError_PRIORITY_PDU::set_const_data(const GetListError_PRIORITY & d) {
    data = (void *)&d;
    constant = 1;
}

const GetListError_PRIORITY *GetListError_PRIORITY_PDU::get_const_data() const {
    return (const GetListError_PRIORITY *)data;
}

#endif

OssTypeIndex GetListError_PRIORITY_PDU::get_index() const {
    return 70;
}

OperationCancelled_PRIORITY_PDU::OperationCancelled_PRIORITY_PDU() {
}

void OperationCancelled_PRIORITY_PDU::set_data(OperationCancelled_PRIORITY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

OperationCancelled_PRIORITY *OperationCancelled_PRIORITY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (OperationCancelled_PRIORITY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void OperationCancelled_PRIORITY_PDU::set_const_data(const OperationCancelled_PRIORITY & d) {
    data = (void *)&d;
    constant = 1;
}

const OperationCancelled_PRIORITY *OperationCancelled_PRIORITY_PDU::get_const_data() const {
    return (const OperationCancelled_PRIORITY *)data;
}

#endif

OssTypeIndex OperationCancelled_PRIORITY_PDU::get_index() const {
    return 71;
}

SetListError_PRIORITY_PDU::SetListError_PRIORITY_PDU() {
}

void SetListError_PRIORITY_PDU::set_data(SetListError_PRIORITY & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SetListError_PRIORITY *SetListError_PRIORITY_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (SetListError_PRIORITY *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void SetListError_PRIORITY_PDU::set_const_data(const SetListError_PRIORITY & d) {
    data = (void *)&d;
    constant = 1;
}

const SetListError_PRIORITY *SetListError_PRIORITY_PDU::get_const_data() const {
    return (const SetListError_PRIORITY *)data;
}

#endif

OssTypeIndex SetListError_PRIORITY_PDU::get_index() const {
    return 72;
}

Acse_RealizationParameter_PDU::Acse_RealizationParameter_PDU() {
}

void Acse_RealizationParameter_PDU::set_data(Acse_RealizationParameter & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Acse_RealizationParameter *Acse_RealizationParameter_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Acse_RealizationParameter *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Acse_RealizationParameter_PDU::set_const_data(const Acse_RealizationParameter & d) {
    data = (void *)&d;
    constant = 1;
}

const Acse_RealizationParameter *Acse_RealizationParameter_PDU::get_const_data() const {
    return (const Acse_RealizationParameter *)data;
}

#endif

OssTypeIndex Acse_RealizationParameter_PDU::get_index() const {
    return 73;
}

Acse_with_concatenation_RealizationParameter_PDU::Acse_with_concatenation_RealizationParameter_PDU() {
}

void Acse_with_concatenation_RealizationParameter_PDU::set_data(Acse_with_concatenation_RealizationParameter & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Acse_with_concatenation_RealizationParameter *Acse_with_concatenation_RealizationParameter_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Acse_with_concatenation_RealizationParameter *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Acse_with_concatenation_RealizationParameter_PDU::set_const_data(const Acse_with_concatenation_RealizationParameter & d) {
    data = (void *)&d;
    constant = 1;
}

const Acse_with_concatenation_RealizationParameter *Acse_with_concatenation_RealizationParameter_PDU::get_const_data() const {
    return (const Acse_with_concatenation_RealizationParameter *)data;
}

#endif

OssTypeIndex Acse_with_concatenation_RealizationParameter_PDU::get_index() const {
    return 74;
}

Association_by_RTSE_RealizationParameter_PDU::Association_by_RTSE_RealizationParameter_PDU() {
}

void Association_by_RTSE_RealizationParameter_PDU::set_data(Association_by_RTSE_RealizationParameter & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Association_by_RTSE_RealizationParameter *Association_by_RTSE_RealizationParameter_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Association_by_RTSE_RealizationParameter *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Association_by_RTSE_RealizationParameter_PDU::set_const_data(const Association_by_RTSE_RealizationParameter & d) {
    data = (void *)&d;
    constant = 1;
}

const Association_by_RTSE_RealizationParameter *Association_by_RTSE_RealizationParameter_PDU::get_const_data() const {
    return (const Association_by_RTSE_RealizationParameter *)data;
}

#endif

OssTypeIndex Association_by_RTSE_RealizationParameter_PDU::get_index() const {
    return 75;
}

PData_RealizationParameter_PDU::PData_RealizationParameter_PDU() {
}

void PData_RealizationParameter_PDU::set_data(PData_RealizationParameter & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PData_RealizationParameter *PData_RealizationParameter_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PData_RealizationParameter *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PData_RealizationParameter_PDU::set_const_data(const PData_RealizationParameter & d) {
    data = (void *)&d;
    constant = 1;
}

const PData_RealizationParameter *PData_RealizationParameter_PDU::get_const_data() const {
    return (const PData_RealizationParameter *)data;
}

#endif

OssTypeIndex PData_RealizationParameter_PDU::get_index() const {
    return 76;
}

PData_with_concatenation_RealizationParameter_PDU::PData_with_concatenation_RealizationParameter_PDU() {
}

void PData_with_concatenation_RealizationParameter_PDU::set_data(PData_with_concatenation_RealizationParameter & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PData_with_concatenation_RealizationParameter *PData_with_concatenation_RealizationParameter_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PData_with_concatenation_RealizationParameter *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PData_with_concatenation_RealizationParameter_PDU::set_const_data(const PData_with_concatenation_RealizationParameter & d) {
    data = (void *)&d;
    constant = 1;
}

const PData_with_concatenation_RealizationParameter *PData_with_concatenation_RealizationParameter_PDU::get_const_data() const {
    return (const PData_with_concatenation_RealizationParameter *)data;
}

#endif

OssTypeIndex PData_with_concatenation_RealizationParameter_PDU::get_index() const {
    return 77;
}

Transfer_by_RTSE_RealizationParameter_PDU::Transfer_by_RTSE_RealizationParameter_PDU() {
}

void Transfer_by_RTSE_RealizationParameter_PDU::set_data(Transfer_by_RTSE_RealizationParameter & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Transfer_by_RTSE_RealizationParameter *Transfer_by_RTSE_RealizationParameter_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Transfer_by_RTSE_RealizationParameter *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Transfer_by_RTSE_RealizationParameter_PDU::set_const_data(const Transfer_by_RTSE_RealizationParameter & d) {
    data = (void *)&d;
    constant = 1;
}

const Transfer_by_RTSE_RealizationParameter *Transfer_by_RTSE_RealizationParameter_PDU::get_const_data() const {
    return (const Transfer_by_RTSE_RealizationParameter *)data;
}

#endif

OssTypeIndex Transfer_by_RTSE_RealizationParameter_PDU::get_index() const {
    return 78;
}

/* Control object class */

SMASE_A_ASSOCIATE_Information_Control::SMASE_A_ASSOCIATE_Information_Control() : OssControl(&SMASE_A_ASSOCIATE_Information_Table, SMASE_A_ASSOCIATE_Information_TableType::internal) {
}

SMASE_A_ASSOCIATE_Information_Control::SMASE_A_ASSOCIATE_Information_Control(const SMASE_A_ASSOCIATE_Information_Control & that) : OssControl(that) {
}


/* ASN.1 data initialization */
static unsigned char _v1[] = { 0x59, 0x03, 0x09, 0x03 };
static OSSC::COssEncOID _v0 = {
    4,
    _v1
};

const OssEncOID& crsMObjectClass = (const OssEncOID&)_v0;

static unsigned char _v3[] = { 0x59, 0x03, 0x09, 0x04 };
static OSSC::COssEncOID _v2 = {
    4,
    _v3
};

const OssEncOID& crsMPackage = (const OssEncOID&)_v2;

static unsigned char _v5[] = { 0x59, 0x03, 0x09, 0x06 };
static OSSC::COssEncOID _v4 = {
    4,
    _v5
};

const OssEncOID& crsMNameBinding = (const OssEncOID&)_v4;

static unsigned char _v7[] = { 0x59, 0x03, 0x09, 0x07 };
static OSSC::COssEncOID _v6 = {
    4,
    _v7
};

const OssEncOID& crsAttribute = (const OssEncOID&)_v6;


struct _InvokeId {
    OSS_UINT32 choice;
    union {
	OSS_INT32  present;
	char  absent;
    } u;
};
static _InvokeId _v8 = {
    2, {0}
};

const __shared12& noInvokeId = (const __shared12&)_v8;


struct _Code {
    OSS_UINT32 choice;
    union {
	OSS_INT32  local;
	OSSC::COssEncOID  global;
    } u;
};

struct _ERROR {
    OSS_UINT32 bit_mask;
    unsigned short ParameterType;
    ossBoolean parameterTypeOptional;
    unsigned short ErrorPriority;
    _Code errorCode;
};
struct _OPERATION;

struct _OPERATION {
    OSS_UINT32 bit_mask;
    unsigned short ArgumentType;
    ossBoolean argumentTypeOptional;
    ossBoolean returnResult;
    unsigned short ResultType;
    ossBoolean resultTypeOptional;
    struct ObjectSetEntry *Errors;
    struct ObjectSetEntry *Linked;
    ossBoolean synchronous;
    ossBoolean alwaysReturns;
    unsigned short InvokePriority;
    unsigned short ResultPriority;
    _Code operationCode;
};
const enum CMISSync ActionArgument::default_synchronization = bestEffort;


struct _Scope {
    OSS_UINT32 choice;
    union {
	OSS_INT32  namedNumbers;
	OSS_INT32  individualLevels;
	OSS_INT32  baseToNthLevel;
    } u;
};
static _Scope _v30 = {
    1, {0}
};

const Scope& ActionArgument::default_scope = (const Scope&)_v30;


struct _ActionTypeId {
    OSS_UINT32 choice;
    union {
	OSSC::COssEncOID  globalForm;
	OSS_INT32  localForm;
    } u;
};

struct _Attribute {
    _ActionTypeId  id;
    OSSC::COssConstrainedOpenType  value;
};

struct _choice4 {
    OSS_UINT32 choice;
    union {
	_Attribute * initialString;
	_Attribute * anyString;
	_Attribute * finalString;
    } u;
};

struct _seqof1 {
    struct _seqof1 * next;
    _choice4  value;
};

struct _FilterItem {
    OSS_UINT32 choice;
    union {
	_Attribute * equality;
	_seqof1 * substrings;
	_Attribute * greaterOrEqual;
	_Attribute * lessOrEqual;
	_ActionTypeId * present;
	_Attribute * subsetOf;
	_Attribute * supersetOf;
	_Attribute * nonNullSetIntersection;
    } u;
};
struct _setof1;
struct _CMISFilter;

struct _CMISFilter {
    OSS_UINT32 choice;
    union {
	_FilterItem * item;
	_setof1 * CMISFilter_and;
	_setof1 * CMISFilter_or;
	_CMISFilter * CMISFilter_not;
    } u;
};

struct _setof1 {
    struct _setof1 * next;
    _CMISFilter  value;
};
static _CMISFilter _v31 = {
    2, {NULL}
};

const CMISFilter& ActionArgument::default_filter = (const CMISFilter&)_v31;

const enum CMISSync DeleteArgument::default_synchronization = bestEffort;

static _Scope _v32 = {
    1, {0}
};

const Scope& DeleteArgument::default_scope = (const Scope&)_v32;

static _CMISFilter _v33 = {
    2, {NULL}
};

const CMISFilter& DeleteArgument::default_filter = (const CMISFilter&)_v33;

const enum CMISSync GetArgument::default_synchronization = bestEffort;

static _Scope _v34 = {
    1, {0}
};

const Scope& GetArgument::default_scope = (const Scope&)_v34;

static _CMISFilter _v35 = {
    2, {NULL}
};

const CMISFilter& GetArgument::default_filter = (const CMISFilter&)_v35;

const OSS_INT32 __seq4::default_modifyOperator = 0;

const enum CMISSync SetArgument::default_synchronization = bestEffort;

static _Scope _v36 = {
    1, {0}
};

const Scope& SetArgument::default_scope = (const Scope&)_v36;

static _CMISFilter _v37 = {
    2, {NULL}
};

const CMISFilter& SetArgument::default_filter = (const CMISFilter&)_v37;

static unsigned char _v39[] = {
    0x80
};
static OSSC::COssBitString _v38 = {
    1,
    _v39
};

const OssBitString& CMIPUserInfo::default_protocolVersion = (const OssBitString&)_v38;

static OSSC::COssBitString _v40 = {
    0,
    NULL
};

const OssBitString& CMIPUserInfo::default_functionalUnits = (const OssBitString&)_v40;

static OSSC::COssBitString _v41 = {
    0,
    NULL
};

const OssBitString& FunctionalUnitPackage::default_managerRoleFunctionalUnit = (const OssBitString&)_v41;

static OSSC::COssBitString _v42 = {
    0,
    NULL
};

const OssBitString& FunctionalUnitPackage::default_agentRoleFunctionalUnit = (const OssBitString&)_v42;

const ossBoolean __shared8::default_concatenation = FALSE;

/* Local control table initialization */

extern "C" void DLL_ENTRY _oss_run_TOED_on_INTEL_X86_WINDOWS_AND_WINNT(void);

extern "C" {
static void _oss_post_init(struct ossGlobal *world);

/* TOED internal function declarations */

#ifdef OSS_COPY_VALUE
int DLL_ENTRY _CPSMASE_A_ASSOCIATE_Informatio(struct ossGlobal * _g, int pduNum, void * src, void ** pdst);
#endif /* OSS_COPY_VALUE */

#ifdef OSS_COMPARE_VALUE
int DLL_ENTRY _CMSMASE_A_ASSOCIATE_Informatio(struct ossGlobal * _g, int _pduNum, void * _odata, void * _cdata);
#endif /* OSS_COMPARE_VALUE */

#if OSS_TOED_API_LEVEL >= 31
void DLL_ENTRY _oeSMASE_A_ASSOCIATE_Informatio(OssGlobal * _g, int _pdunum, void * _inbuf);
void * DLL_ENTRY _odSMASE_A_ASSOCIATE_Informatio(OssGlobal * _g, int _pdunum);
#endif
static const _oss_xapi_entries_struct _oss_xapi_entries = {
     31
#ifdef OSS_COPY_VALUE
    ,_CPSMASE_A_ASSOCIATE_Informatio
#else
    ,NULL
#endif
#ifdef OSS_COMPARE_VALUE
    ,_CMSMASE_A_ASSOCIATE_Informatio
#else
    ,NULL
#endif
    ,NULL
    ,NULL
    ,102
    ,NULL
    ,NULL
#if OSS_TOED_API_LEVEL >= 24
    ,NULL
    ,NULL
    ,100
#endif
#if OSS_TOED_API_LEVEL >= 31
    ,100
    ,_oeSMASE_A_ASSOCIATE_Informatio
    ,_odSMASE_A_ASSOCIATE_Informatio
#endif
};

/* Local control table initialization */

static unsigned char _privateFlags[] = {0x0f,0x00};
void DLL_ENTRY_FDEF _ossinit_SMASE_A_ASSOCIATE_Information(struct ossGlobal *world) {
    _EncDecGlobals *_oss_c;

    _v8.u.absent = 0;
    _v30.u.namedNumbers = 0;
    _v31.u.CMISFilter_and = NULL;
    _v32.u.namedNumbers = 0;
    _v33.u.CMISFilter_and = NULL;
    _v34.u.namedNumbers = 0;
    _v35.u.CMISFilter_and = NULL;
    _v36.u.namedNumbers = 0;
    _v37.u.CMISFilter_and = NULL;
    _oss_run_TOED_on_INTEL_X86_WINDOWS_AND_WINNT();
    ossPrivateSetMoreFlags(world, 13, _privateFlags);
    ossLinkBer(world);
    ossLinkPer(world);
    if (world) {
        _oss_c = (_EncDecGlobals *)world->encDecVar;
        _oss_c->der = 1;
    }
    ossInitXAPIentries(world, &_oss_xapi_entries);
    _oss_post_init(world);
}

/* TOED internal function declarations */


struct _AttributeValueAssertion {
    OSSC::COssEncOID  id;
    OSSC::COssConstrainedOpenType  value;
};

struct _RelativeDistinguishedName {
    struct _RelativeDistinguishedName * next;
    _AttributeValueAssertion  value;
};

struct _RDNSequence {
    struct _RDNSequence * next;
    _RelativeDistinguishedName * value;
};

struct _ObjectInstance {
    OSS_UINT32 choice;
    union {
	_RDNSequence * distinguishedName;
	OSSC::COssString  nonSpecificForm;
	_RDNSequence * localDistinguishedName;
    } u;
};

struct _choice1 {
    OSS_UINT32 choice;
    union {
	OSSC::COssOpen  single_ASN1_type;
	OSSC::COssString  octet_aligned;
	OSSC::COssBitString  arbitrary;
    } u;
};

struct _External {
    OSS_UINT32 bit_mask;
    OSSC::COssEncOID  direct_reference;
    OSS_INT32  indirect_reference;
    OSSC::COssString  data_value_descriptor;
    _choice1  encoding;
};

struct _ActionInfo {
    OSS_UINT32 bit_mask;
    _ActionTypeId  actionType;
    OSSC::COssConstrainedOpenType  actionInfoArg;
};

struct _ActionArgument {
    OSS_UINT32 bit_mask;
    _ActionTypeId  baseManagedObjectClass;
    _ObjectInstance  baseManagedObjectInstance;
    _External  accessControl;
    enum CMISSync  synchronization;
    _Scope  scope;
    _CMISFilter  filter;
    _ActionInfo  actionInfo;
};

struct _ActionReply {
    _ActionTypeId  actionType;
    OSSC::COssConstrainedOpenType  actionReplyInfo;
};

struct _ActionResult {
    OSS_UINT32 bit_mask;
    _ActionTypeId  managedObjectClass;
    _ObjectInstance  managedObjectInstance;
    char *  currentTime;
    _ActionReply  actionReply;
};
static long _edActionResult(OssGlobal * _g, char ** _out_pos, long * _max_len, _ActionResult * _in_data);
static void _ep_ActionResult(OssGlobal * _g, _ActionResult * _in_data);
static void _d_ActionResult(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _ActionResult * _out_data);
static void _dp_ActionResult(OssGlobal * _g, _ActionResult * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_ActionResult(OssGlobal * _g, _ActionResult * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_ActionResult(OssGlobal * _g, _ActionResult * _data_ptr);
#endif
static long _edAttribute(OssGlobal * _g, char ** _out_pos, long * _max_len, _Attribute * _in_data);
static void _ep_Attribute(OssGlobal * _g, _Attribute * _in_data);
static void _d_Attribute(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Attribute * _out_data);
static void _dp_Attribute(OssGlobal * _g, _Attribute * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_Attribute(OssGlobal * _g, _Attribute * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_Attribute(OssGlobal * _g, _Attribute * _data_ptr);
#endif
static long _edAttributeId(OssGlobal * _g, char ** _out_pos, long * _max_len, _ActionTypeId * _in_data);
static void _ep_AttributeId(OssGlobal * _g, _ActionTypeId * _in_data);
static void _d_AttributeId(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _ActionTypeId * _out_data);
static void _dp_AttributeId(OssGlobal * _g, _ActionTypeId * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_AttributeId(OssGlobal * _g, _ActionTypeId * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_AttributeId(OssGlobal * _g, _ActionTypeId * _data_ptr);
#endif

struct _BaseManagedObjectId {
    _ActionTypeId  baseManagedObjectClass;
    _ObjectInstance  baseManagedObjectInstance;
};
static long _edCMISFilter(OssGlobal * _g, char ** _out_pos, long * _max_len, _CMISFilter * _in_data);
static void _ep_CMISFilter(OssGlobal * _g, _CMISFilter * _in_data);
static void _d_CMISFilter(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _CMISFilter * _out_data);
static void _dp_CMISFilter(OssGlobal * _g, _CMISFilter * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_CMISFilter(OssGlobal * _g, _CMISFilter * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_CMISFilter(OssGlobal * _g, _CMISFilter * _data_ptr);
#endif

struct _ComplexityLimitation {
    OSS_UINT32 bit_mask;
    _Scope  scope;
    _CMISFilter  filter;
    enum CMISSync  sync;
};

struct _choice3 {
    OSS_UINT32 choice;
    union {
	_ObjectInstance * managedObjectInstance;
	_ObjectInstance * superiorObjectInstance;
    } u;
};

struct _setof3 {
    struct _setof3 * next;
    _Attribute  value;
};

struct _CreateArgument {
    OSS_UINT32 bit_mask;
    _ActionTypeId  managedObjectClass;
    _choice3  managedOrSuperiorObjectInstance;
    _External  accessControl;
    _ObjectInstance  referenceObjectInstance;
    _setof3 * attributeList;
};

struct _CreateResult {
    OSS_UINT32 bit_mask;
    _ActionTypeId  managedObjectClass;
    _ObjectInstance  managedObjectInstance;
    char *  currentTime;
    _setof3 * attributeList;
};

struct _DeleteArgument {
    OSS_UINT32 bit_mask;
    _ActionTypeId  baseManagedObjectClass;
    _ObjectInstance  baseManagedObjectInstance;
    _External  accessControl;
    enum CMISSync  synchronization;
    _Scope  scope;
    _CMISFilter  filter;
};

struct _DeleteResult {
    OSS_UINT32 bit_mask;
    _ActionTypeId  managedObjectClass;
    _ObjectInstance  managedObjectInstance;
    char *  currentTime;
};
static long _edDeleteResult(OssGlobal * _g, char ** _out_pos, long * _max_len, _DeleteResult * _in_data);
static void _ep_DeleteResult(OssGlobal * _g, _DeleteResult * _in_data);
static void _d_DeleteResult(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _DeleteResult * _out_data);
static void _dp_DeleteResult(OssGlobal * _g, _DeleteResult * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_DeleteResult(OssGlobal * _g, _DeleteResult * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_DeleteResult(OssGlobal * _g, _DeleteResult * _data_ptr);
#endif

struct _EventReportArgument {
    OSS_UINT32 bit_mask;
    _ActionTypeId  managedObjectClass;
    _ObjectInstance  managedObjectInstance;
    char *  eventTime;
    _ActionTypeId  eventType;
    OSSC::COssConstrainedOpenType  eventInfo;
};

struct _EventReply {
    OSS_UINT32 bit_mask;
    _ActionTypeId  eventType;
    OSSC::COssConstrainedOpenType  eventReplyInfo;
};

struct _EventReportResult {
    OSS_UINT32 bit_mask;
    _ActionTypeId  managedObjectClass;
    _ObjectInstance  managedObjectInstance;
    char *  currentTime;
    _EventReply  eventReply;
};

struct _MissingAttributeValue_PARAMETER {
    struct _MissingAttributeValue_PARAMETER * next;
    _ActionTypeId  value;
};

struct _GetArgument {
    OSS_UINT32 bit_mask;
    _ActionTypeId  baseManagedObjectClass;
    _ObjectInstance  baseManagedObjectInstance;
    _External  accessControl;
    enum CMISSync  synchronization;
    _Scope  scope;
    _CMISFilter  filter;
    _MissingAttributeValue_PARAMETER * attributeIdList;
};

struct _AttributeIdError {
    enum _enum4  errorStatus;
    _ActionTypeId  attributeId;
};

struct _GetInfoStatus {
    OSS_UINT32 choice;
    union {
	_AttributeIdError * attributeIdError;
	_Attribute * attribute;
    } u;
};

struct _setof6 {
    struct _setof6 * next;
    _GetInfoStatus  value;
};

struct _GetListError {
    OSS_UINT32 bit_mask;
    _ActionTypeId  managedObjectClass;
    _ObjectInstance  managedObjectInstance;
    char *  currentTime;
    _setof6 * getInfoList;
};
static long _edGetListError(OssGlobal * _g, char ** _out_pos, long * _max_len, _GetListError * _in_data);
static void _ep_GetListError(OssGlobal * _g, _GetListError * _in_data);
static void _d_GetListError(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _GetListError * _out_data);
static void _dp_GetListError(OssGlobal * _g, _GetListError * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_GetListError(OssGlobal * _g, _GetListError * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_GetListError(OssGlobal * _g, _GetListError * _data_ptr);
#endif
static long _edGetResult(OssGlobal * _g, char ** _out_pos, long * _max_len, _CreateResult * _in_data);
static void _ep_GetResult(OssGlobal * _g, _CreateResult * _in_data);
static void _d_GetResult(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _CreateResult * _out_data);
static void _dp_GetResult(OssGlobal * _g, _CreateResult * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_GetResult(OssGlobal * _g, _CreateResult * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_GetResult(OssGlobal * _g, _CreateResult * _data_ptr);
#endif

struct _seq1 {
    OSS_UINT32 bit_mask;
    _ActionTypeId  eventType;
    OSSC::COssConstrainedOpenType  eventInfo;
};

struct _InvalidArgumentValue {
    OSS_UINT32 choice;
    union {
	_ActionInfo * actionValue;
	_seq1 * eventValue;
    } u;
};
static long _edInvalidArgumentValue(OssGlobal * _g, char ** _out_pos, long * _max_len, _InvalidArgumentValue * _in_data);
static void _ep_InvalidArgumentValue(OssGlobal * _g, _InvalidArgumentValue * _in_data);
static void _d_InvalidArgumentValue(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _InvalidArgumentValue * _out_data);
static void _dp_InvalidArgumentValue(OssGlobal * _g, _InvalidArgumentValue * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_InvalidArgumentValue(OssGlobal * _g, _InvalidArgumentValue * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_InvalidArgumentValue(OssGlobal * _g, _InvalidArgumentValue * _data_ptr);
#endif

struct _AttributeError {
    OSS_UINT32 bit_mask;
    enum _enum3  errorStatus;
    OSS_INT32  modifyOperator;
    _ActionTypeId  attributeId;
    OSSC::COssConstrainedOpenType  attributeValue;
};

struct _SetInfoStatus {
    OSS_UINT32 choice;
    union {
	_AttributeError * attributeError;
	_Attribute * attribute;
    } u;
};

struct _setof9 {
    struct _setof9 * next;
    _SetInfoStatus  value;
};

struct _SetListError {
    OSS_UINT32 bit_mask;
    _ActionTypeId  managedObjectClass;
    _ObjectInstance  managedObjectInstance;
    char *  currentTime;
    _setof9 * setInfoList;
};

struct _SpecificErrorInfo {
    OSSC::COssEncOID  errorId;
    OSSC::COssConstrainedOpenType  errorInfo;
};

struct _ProcessingFailure {
    OSS_UINT32 bit_mask;
    _ActionTypeId  managedObjectClass;
    _ObjectInstance  managedObjectInstance;
    _SpecificErrorInfo  specificErrorInfo;
};

struct _seq2 {
    OSS_UINT32 bit_mask;
    _ActionTypeId  managedObjectClass;
    _ActionTypeId  actionType;
};

struct _seq3 {
    OSS_UINT32 bit_mask;
    _ActionTypeId  managedObjectClass;
    _ActionTypeId  eventType;
};

struct _NoSuchArgument {
    OSS_UINT32 choice;
    union {
	_seq2 * actionId;
	_seq3 * eventId;
    } u;
};

struct _choice2 {
    OSS_UINT32 choice;
    union {
	_ActionTypeId * actionType;
	_NoSuchArgument * actionArgument;
	_InvalidArgumentValue * argumentValue;
    } u;
};

struct _ActionErrorInfo {
    enum _enum2  errorStatus;
    _choice2  errorInfo;
};

struct _ActionError {
    OSS_UINT32 bit_mask;
    _ActionTypeId  managedObjectClass;
    _ObjectInstance  managedObjectInstance;
    char *  currentTime;
    _ActionErrorInfo  actionErrorInfo;
};

struct _DeleteError {
    OSS_UINT32 bit_mask;
    _ActionTypeId  managedObjectClass;
    _ObjectInstance  managedObjectInstance;
    char *  currentTime;
    enum _enum5  deleteErrorInfo;
};

struct _LinkedReplyArgument {
    OSS_UINT32 choice;
    union {
	_CreateResult * getResult;
	_GetListError * getListError;
	_CreateResult * setResult;
	_SetListError * setListError;
	_ActionResult * actionResult;
	_ProcessingFailure * processingFailure;
	_DeleteResult * deleteResult;
	_ActionError * actionError;
	_DeleteError * deleteError;
    } u;
};

struct _NoSuchAction {
    _ActionTypeId  managedObjectClass;
    _ActionTypeId  actionType;
};
static long _edNoSuchArgument(OssGlobal * _g, char ** _out_pos, long * _max_len, _NoSuchArgument * _in_data);
static void _ep_NoSuchArgument(OssGlobal * _g, _NoSuchArgument * _in_data);
static void _d_NoSuchArgument(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _NoSuchArgument * _out_data);
static void _dp_NoSuchArgument(OssGlobal * _g, _NoSuchArgument * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_NoSuchArgument(OssGlobal * _g, _NoSuchArgument * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_NoSuchArgument(OssGlobal * _g, _NoSuchArgument * _data_ptr);
#endif

struct _NoSuchEventType {
    _ActionTypeId  managedObjectClass;
    _ActionTypeId  eventType;
};
static long _edObjectClass(OssGlobal * _g, char ** _out_pos, long * _max_len, _ActionTypeId * _in_data);
static void _ep_ObjectClass(OssGlobal * _g, _ActionTypeId * _in_data);
static void _d_ObjectClass(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _ActionTypeId * _out_data);
static void _dp_ObjectClass(OssGlobal * _g, _ActionTypeId * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_ObjectClass(OssGlobal * _g, _ActionTypeId * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_ObjectClass(OssGlobal * _g, _ActionTypeId * _data_ptr);
#endif
static long _edObjectInstance(OssGlobal * _g, char ** _out_pos, long * _max_len, _ObjectInstance * _in_data);
static void _ep_ObjectInstance(OssGlobal * _g, _ObjectInstance * _in_data);
static void _d_ObjectInstance(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _ObjectInstance * _out_data);
static void _dp_ObjectInstance(OssGlobal * _g, _ObjectInstance * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_ObjectInstance(OssGlobal * _g, _ObjectInstance * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_ObjectInstance(OssGlobal * _g, _ObjectInstance * _data_ptr);
#endif
static long _edProcessingFailure(OssGlobal * _g, char ** _out_pos, long * _max_len, _ProcessingFailure * _in_data);
static void _ep_ProcessingFailure(OssGlobal * _g, _ProcessingFailure * _in_data);
static void _d_ProcessingFailure(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _ProcessingFailure * _out_data);
static void _dp_ProcessingFailure(OssGlobal * _g, _ProcessingFailure * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_ProcessingFailure(OssGlobal * _g, _ProcessingFailure * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_ProcessingFailure(OssGlobal * _g, _ProcessingFailure * _data_ptr);
#endif
static long _edScope(OssGlobal * _g, char ** _out_pos, long * _max_len, _Scope * _in_data);
static void _ep_Scope(OssGlobal * _g, _Scope * _in_data);
static void _d_Scope(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Scope * _out_data);
static void _dp_Scope(OssGlobal * _g, _Scope * _out_data);
#ifdef OSSPRINT
static void _p_Scope(OssGlobal * _g, _Scope * _data_ptr);
#endif

struct _seq4 {
    OSS_UINT32 bit_mask;
    OSS_INT32  modifyOperator;
    _ActionTypeId  attributeId;
    OSSC::COssConstrainedOpenType  attributeValue;
};

struct _setof8 {
    struct _setof8 * next;
    _seq4  value;
};

struct _SetArgument {
    OSS_UINT32 bit_mask;
    _ActionTypeId  baseManagedObjectClass;
    _ObjectInstance  baseManagedObjectInstance;
    _External  accessControl;
    enum CMISSync  synchronization;
    _Scope  scope;
    _CMISFilter  filter;
    _setof8 * modificationList;
};
static long _edSetListError(OssGlobal * _g, char ** _out_pos, long * _max_len, _SetListError * _in_data);
static void _ep_SetListError(OssGlobal * _g, _SetListError * _in_data);
static void _d_SetListError(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _SetListError * _out_data);
static void _dp_SetListError(OssGlobal * _g, _SetListError * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_SetListError(OssGlobal * _g, _SetListError * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_SetListError(OssGlobal * _g, _SetListError * _data_ptr);
#endif
static long _edSetResult(OssGlobal * _g, char ** _out_pos, long * _max_len, _CreateResult * _in_data);
static void _ep_SetResult(OssGlobal * _g, _CreateResult * _in_data);
static void _d_SetResult(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _CreateResult * _out_data);
static void _dp_SetResult(OssGlobal * _g, _CreateResult * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_SetResult(OssGlobal * _g, _CreateResult * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_SetResult(OssGlobal * _g, _CreateResult * _data_ptr);
#endif

struct _seq6 {
    OSS_UINT32 bit_mask;
    _InvokeId  invokeId;
    _InvokeId  linkedId;
    _Code  opcode;
    OSSC::COssConstrainedOpenType  argument;
};

struct _seq5 {
    _Code  opcode;
    OSSC::COssConstrainedOpenType  result;
};

struct _seq7 {
    OSS_UINT32 bit_mask;
    _InvokeId  invokeId;
    _seq5  result;
};

struct _seq8 {
    OSS_UINT32 bit_mask;
    _InvokeId  invokeId;
    _Code  errcode;
    OSSC::COssConstrainedOpenType  parameter;
};

struct _choice6 {
    OSS_UINT32 choice;
    union {
	OSS_INT32  general;
	OSS_INT32  invoke;
	OSS_INT32  returnResult;
	OSS_INT32  returnError;
    } u;
};

struct _Reject {
    _InvokeId  invokeId;
    _choice6  problem;
};

struct _ROSEapdus {
    OSS_UINT32 choice;
    union {
	_seq6 * invoke;
	_seq7 * returnResult;
	_seq8 * returnError;
	_Reject * reject;
    } u;
};

struct _CMIPAbortInfo {
    OSS_UINT32 bit_mask;
    enum CMIPAbortSource  abortSource;
    _External  userInfo;
};

struct _CMIPUserInfo {
    OSS_UINT32 bit_mask;
    OSSC::COssBitString  protocolVersion;
    OSSC::COssBitString  functionalUnits;
    _External  accessControl;
    _External  userInfo;
};

struct _InvokeldsOutstanding {
    struct _InvokeldsOutstanding * next;
    OSS_INT32  value;
};

struct _FunctionalUnitPackage {
    OSS_UINT32 bit_mask;
    OSSC::COssEncOID  functionalUnitPackageId;
    OSSC::COssBitString  managerRoleFunctionalUnit;
    OSSC::COssBitString  agentRoleFunctionalUnit;
};

struct _SmaseFunctionalUnits {
    struct _SmaseFunctionalUnits * next;
    _FunctionalUnitPackage  value;
};

struct _SmUserInfoSent {
    OSS_UINT32 choice;
    union {
	char  nothingSent;
	OSSC::COssString  informationSent;
    } u;
};

struct _SmUserInfoReceived {
    OSS_UINT32 choice;
    union {
	char  nothingReceived;
	OSSC::COssString  informationReceived;
    } u;
};

struct _SMASEUserData {
    OSS_UINT32 bit_mask;
    _SmaseFunctionalUnits * smfuPackages;
    OSS_INT32  reason;
    OSSC::COssString  systemsManagementUserInformation;
};

struct _RealizationParameter {
    OSS_UINT32 bit_mask;
    enum _enum1  realization_type;
    ossBoolean  concatenation;
};

struct _TYPE_IDENTIFIER {
    OSSC::COssEncOID id;
    unsigned short Type;
};
static long _ed_choice1(OssGlobal * _g, char ** _out_pos, long * _max_len, _choice1 * _in_data);
static void _ep__choice1(OssGlobal * _g, _choice1 * _in_data);
static void _d__choice1(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _choice1 * _out_data);
static void _dp__choice1(OssGlobal * _g, _choice1 * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__choice1(OssGlobal * _g, _choice1 * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__choice1(OssGlobal * _g, _choice1 * _data_ptr);
#endif
static long _edExternal(OssGlobal * _g, char ** _out_pos, long * _max_len, _External * _in_data);
static void _ep_External(OssGlobal * _g, _External * _in_data);
static void _d_External(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _External * _out_data);
static void _dp_External(OssGlobal * _g, _External * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_External(OssGlobal * _g, _External * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_External(OssGlobal * _g, _External * _data_ptr);
#endif
static long _edActionTypeId(OssGlobal * _g, char ** _out_pos, long * _max_len, _ActionTypeId * _in_data);
static void _ep_ActionTypeId(OssGlobal * _g, _ActionTypeId * _in_data);
static void _d_ActionTypeId(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _ActionTypeId * _out_data);
static void _dp_ActionTypeId(OssGlobal * _g, _ActionTypeId * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_ActionTypeId(OssGlobal * _g, _ActionTypeId * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_ActionTypeId(OssGlobal * _g, _ActionTypeId * _data_ptr);
#endif

struct _CMIP_ACTION {
    _ActionTypeId id;
    unsigned short Value;
};

struct _CMIP_AVA {
    OSSC::COssEncOID id;
    unsigned short Value;
};
static long _edEventTypeId(OssGlobal * _g, char ** _out_pos, long * _max_len, _ActionTypeId * _in_data);
static void _ep_EventTypeId(OssGlobal * _g, _ActionTypeId * _in_data);
static void _d_EventTypeId(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _ActionTypeId * _out_data);
static void _dp_EventTypeId(OssGlobal * _g, _ActionTypeId * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_EventTypeId(OssGlobal * _g, _ActionTypeId * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_EventTypeId(OssGlobal * _g, _ActionTypeId * _data_ptr);
#endif
static long _ed_setof2(OssGlobal * _g, char ** _out_pos, long * _max_len, _setof1 ** _in_data);
static void _ep__setof2(OssGlobal * _g, _setof1 ** _in_data);
static void _d__setof2(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _setof1 ** _out_data);
static void _dp__setof2(OssGlobal * _g, _setof1 ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__setof2(OssGlobal * _g, _setof1 ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__setof2(OssGlobal * _g, _setof1 ** _data_ptr);
#endif
static long _ed_setof1(OssGlobal * _g, char ** _out_pos, long * _max_len, _setof1 ** _in_data);
static void _ep__setof1(OssGlobal * _g, _setof1 ** _in_data);
static void _d__setof1(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _setof1 ** _out_data);
static void _dp__setof1(OssGlobal * _g, _setof1 ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__setof1(OssGlobal * _g, _setof1 ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__setof1(OssGlobal * _g, _setof1 ** _data_ptr);
#endif
static long _edRealizationParameter(OssGlobal * _g, char ** _out_pos, long * _max_len, _RealizationParameter * _in_data);
static void _ep_RealizationParameter(OssGlobal * _g, _RealizationParameter * _in_data);
static void _d_RealizationParameter(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _RealizationParameter * _out_data);
static void _dp_RealizationParameter(OssGlobal * _g, _RealizationParameter * _out_data);
#ifdef OSSPRINT
static void _p_RealizationParameter(OssGlobal * _g, _RealizationParameter * _data_ptr);
#endif
static long _edActionInfo(OssGlobal * _g, char ** _out_pos, long * _max_len, _ActionInfo * _in_data);
static void _ep_ActionInfo(OssGlobal * _g, _ActionInfo * _in_data);
static void _d_ActionInfo(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _ActionInfo * _out_data);
static void _dp_ActionInfo(OssGlobal * _g, _ActionInfo * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_ActionInfo(OssGlobal * _g, _ActionInfo * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_ActionInfo(OssGlobal * _g, _ActionInfo * _data_ptr);
#endif
static long _edActionReply(OssGlobal * _g, char ** _out_pos, long * _max_len, _ActionReply * _in_data);
static void _ep_ActionReply(OssGlobal * _g, _ActionReply * _in_data);
static void _d_ActionReply(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _ActionReply * _out_data);
static void _dp_ActionReply(OssGlobal * _g, _ActionReply * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_ActionReply(OssGlobal * _g, _ActionReply * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_ActionReply(OssGlobal * _g, _ActionReply * _data_ptr);
#endif
static long _ed_seqof1(OssGlobal * _g, char ** _out_pos, long * _max_len, _seqof1 ** _in_data);
static void _ep__seqof1(OssGlobal * _g, _seqof1 ** _in_data);
static void _d__seqof1(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seqof1 ** _out_data);
static void _dp__seqof1(OssGlobal * _g, _seqof1 ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__seqof1(OssGlobal * _g, _seqof1 ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__seqof1(OssGlobal * _g, _seqof1 ** _data_ptr);
#endif
static long _edFilterItem(OssGlobal * _g, char ** _out_pos, long * _max_len, _FilterItem * _in_data);
static void _ep_FilterItem(OssGlobal * _g, _FilterItem * _in_data);
static void _d_FilterItem(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _FilterItem * _out_data);
static void _dp_FilterItem(OssGlobal * _g, _FilterItem * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_FilterItem(OssGlobal * _g, _FilterItem * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_FilterItem(OssGlobal * _g, _FilterItem * _data_ptr);
#endif
static long _ed_setof6(OssGlobal * _g, char ** _out_pos, long * _max_len, _setof6 ** _in_data);
static void _ep__setof6(OssGlobal * _g, _setof6 ** _in_data);
static void _d__setof6(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _setof6 ** _out_data);
static void _dp__setof6(OssGlobal * _g, _setof6 ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__setof6(OssGlobal * _g, _setof6 ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__setof6(OssGlobal * _g, _setof6 ** _data_ptr);
#endif
static long _ed_setof7(OssGlobal * _g, char ** _out_pos, long * _max_len, _setof3 ** _in_data);
static void _ep__setof7(OssGlobal * _g, _setof3 ** _in_data);
static void _d__setof7(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _setof3 ** _out_data);
static void _dp__setof7(OssGlobal * _g, _setof3 ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__setof7(OssGlobal * _g, _setof3 ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__setof7(OssGlobal * _g, _setof3 ** _data_ptr);
#endif
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__seq1(OssGlobal * _g, _seq1 * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__seq1(OssGlobal * _g, _seq1 * _data_ptr);
#endif
static long _edInvokeId(OssGlobal * _g, char ** _out_pos, long * _max_len, _InvokeId * _in_data);
static void _ep_InvokeId(OssGlobal * _g, _InvokeId * _in_data);
static void _d_InvokeId(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _InvokeId * _out_data);
static void _dp_InvokeId(OssGlobal * _g, _InvokeId * _out_data);
#ifdef OSSPRINT
static void _p_InvokeId(OssGlobal * _g, _InvokeId * _data_ptr);
#endif
static long _edRDNSequence(OssGlobal * _g, char ** _out_pos, long * _max_len, _RDNSequence ** _in_data);
static void _ep_RDNSequence(OssGlobal * _g, _RDNSequence ** _in_data);
static void _d_RDNSequence(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _RDNSequence ** _out_data);
static void _dp_RDNSequence(OssGlobal * _g, _RDNSequence ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_RDNSequence(OssGlobal * _g, _RDNSequence ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_RDNSequence(OssGlobal * _g, _RDNSequence ** _data_ptr);
#endif
static long _edRelativeDistinguishedName(OssGlobal * _g, char ** _out_pos, long * _max_len, _RelativeDistinguishedName ** _in_data);
static void _ep_RelativeDistinguishedName(OssGlobal * _g, _RelativeDistinguishedName ** _in_data);
static void _d_RelativeDistinguishedName(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _RelativeDistinguishedName ** _out_data);
static void _dp_RelativeDistinguishedName(OssGlobal * _g, _RelativeDistinguishedName ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_RelativeDistinguishedName(OssGlobal * _g, _RelativeDistinguishedName ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_RelativeDistinguishedName(OssGlobal * _g, _RelativeDistinguishedName ** _data_ptr);
#endif
static long _edCode(OssGlobal * _g, char ** _out_pos, long * _max_len, _Code * _in_data);
static void _ep_Code(OssGlobal * _g, _Code * _in_data);
static void _d_Code(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Code * _out_data);
static void _dp_Code(OssGlobal * _g, _Code * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_Code(OssGlobal * _g, _Code * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_Code(OssGlobal * _g, _Code * _data_ptr);
#endif
static long _edFunctionalUnitPackage(OssGlobal * _g, char ** _out_pos, long * _max_len, _FunctionalUnitPackage * _in_data);
static void _ep_FunctionalUnitPackage(OssGlobal * _g, _FunctionalUnitPackage * _in_data);
static void _d_FunctionalUnitPackage(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _FunctionalUnitPackage * _out_data);
static void _dp_FunctionalUnitPackage(OssGlobal * _g, _FunctionalUnitPackage * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_FunctionalUnitPackage(OssGlobal * _g, _FunctionalUnitPackage * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_FunctionalUnitPackage(OssGlobal * _g, _FunctionalUnitPackage * _data_ptr);
#endif

struct _RTABapdu {
    OSS_UINT32 bit_mask;
    OSS_INT32  abortReason;
    OSSC::COssBitString  reflectedParameter;
    OSSC::COssOpen  userdataAB;
};
static void _eActionArgument(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epActionArgument(OssGlobal * _g, void * _inbuf);
static void * _dActionArgument(OssGlobal * _g);
static void * _dpActionArgument(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fActionArgument(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pActionArgument(OssGlobal * _g, void * _data);
#endif
static void _eActionResult(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epActionResult(OssGlobal * _g, void * _inbuf);
static void * _dActionResult(OssGlobal * _g);
static void * _dpActionResult(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fActionResult(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pActionResult(OssGlobal * _g, void * _data);
#endif
static void _eAttribute(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epAttribute(OssGlobal * _g, void * _inbuf);
static void * _dAttribute(OssGlobal * _g);
static void * _dpAttribute(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAttribute(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAttribute(OssGlobal * _g, void * _data);
#endif
static void _eAttributeId(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epAttributeId(OssGlobal * _g, void * _inbuf);
static void * _dAttributeId(OssGlobal * _g);
static void * _dpAttributeId(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAttributeId(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAttributeId(OssGlobal * _g, void * _data);
#endif
static void _eBaseManagedObjectId(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epBaseManagedObjectId(OssGlobal * _g, void * _inbuf);
static void * _dBaseManagedObjectId(OssGlobal * _g);
static void * _dpBaseManagedObjectId(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fBaseManagedObjectId(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pBaseManagedObjectId(OssGlobal * _g, void * _data);
#endif
static void _eCMISFilter(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epCMISFilter(OssGlobal * _g, void * _inbuf);
static void * _dCMISFilter(OssGlobal * _g);
static void * _dpCMISFilter(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fCMISFilter(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pCMISFilter(OssGlobal * _g, void * _data);
#endif
static void _eCMISSync(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epCMISSync(OssGlobal * _g, void * _inbuf);
static void * _dCMISSync(OssGlobal * _g);
static void * _dpCMISSync(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fCMISSync(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pCMISSync(OssGlobal * _g, void * _data);
#endif
static void _eComplexityLimitation(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epComplexityLimitation(OssGlobal * _g, void * _inbuf);
static void * _dComplexityLimitation(OssGlobal * _g);
static void * _dpComplexityLimitation(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fComplexityLimitation(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pComplexityLimitation(OssGlobal * _g, void * _data);
#endif
static void _eCreateArgument(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epCreateArgument(OssGlobal * _g, void * _inbuf);
static void * _dCreateArgument(OssGlobal * _g);
static void * _dpCreateArgument(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fCreateArgument(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pCreateArgument(OssGlobal * _g, void * _data);
#endif
static void _eCreateResult(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epCreateResult(OssGlobal * _g, void * _inbuf);
static void * _dCreateResult(OssGlobal * _g);
static void * _dpCreateResult(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fCreateResult(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pCreateResult(OssGlobal * _g, void * _data);
#endif
static void _eDeleteArgument(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epDeleteArgument(OssGlobal * _g, void * _inbuf);
static void * _dDeleteArgument(OssGlobal * _g);
static void * _dpDeleteArgument(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fDeleteArgument(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pDeleteArgument(OssGlobal * _g, void * _data);
#endif
static void _eDeleteResult(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epDeleteResult(OssGlobal * _g, void * _inbuf);
static void * _dDeleteResult(OssGlobal * _g);
static void * _dpDeleteResult(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fDeleteResult(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pDeleteResult(OssGlobal * _g, void * _data);
#endif
static void _eEventReportArgument(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epEventReportArgument(OssGlobal * _g, void * _inbuf);
static void * _dEventReportArgument(OssGlobal * _g);
static void * _dpEventReportArgument(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fEventReportArgument(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pEventReportArgument(OssGlobal * _g, void * _data);
#endif
static void _eEventReportResult(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epEventReportResult(OssGlobal * _g, void * _inbuf);
static void * _dEventReportResult(OssGlobal * _g);
static void * _dpEventReportResult(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fEventReportResult(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pEventReportResult(OssGlobal * _g, void * _data);
#endif
static void _eGetArgument(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epGetArgument(OssGlobal * _g, void * _inbuf);
static void * _dGetArgument(OssGlobal * _g);
static void * _dpGetArgument(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fGetArgument(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pGetArgument(OssGlobal * _g, void * _data);
#endif
static void _eGetListError(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epGetListError(OssGlobal * _g, void * _inbuf);
static void * _dGetListError(OssGlobal * _g);
static void * _dpGetListError(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fGetListError(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pGetListError(OssGlobal * _g, void * _data);
#endif
static void _eGetResult(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epGetResult(OssGlobal * _g, void * _inbuf);
static void * _dGetResult(OssGlobal * _g);
static void * _dpGetResult(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fGetResult(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pGetResult(OssGlobal * _g, void * _data);
#endif
static void _eInvalidArgumentValue(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epInvalidArgumentValue(OssGlobal * _g, void * _inbuf);
static void * _dInvalidArgumentValue(OssGlobal * _g);
static void * _dpInvalidArgumentValue(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fInvalidArgumentValue(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pInvalidArgumentValue(OssGlobal * _g, void * _data);
#endif
static void _eInvokeIDType(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epInvokeIDType(OssGlobal * _g, void * _inbuf);
static void * _dInvokeIDType(OssGlobal * _g);
static void * _dpInvokeIDType(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fInvokeIDType(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pInvokeIDType(OssGlobal * _g, void * _data);
#endif
static void _eLinkedReplyArgument(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epLinkedReplyArgument(OssGlobal * _g, void * _inbuf);
static void * _dLinkedReplyArgument(OssGlobal * _g);
static void * _dpLinkedReplyArgument(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fLinkedReplyArgument(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pLinkedReplyArgument(OssGlobal * _g, void * _data);
#endif
static void _eNoSuchAction(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epNoSuchAction(OssGlobal * _g, void * _inbuf);
static void * _dNoSuchAction(OssGlobal * _g);
static void * _dpNoSuchAction(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fNoSuchAction(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pNoSuchAction(OssGlobal * _g, void * _data);
#endif
static void _eNoSuchArgument(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epNoSuchArgument(OssGlobal * _g, void * _inbuf);
static void * _dNoSuchArgument(OssGlobal * _g);
static void * _dpNoSuchArgument(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fNoSuchArgument(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pNoSuchArgument(OssGlobal * _g, void * _data);
#endif
static void _eNoSuchEventType(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epNoSuchEventType(OssGlobal * _g, void * _inbuf);
static void * _dNoSuchEventType(OssGlobal * _g);
static void * _dpNoSuchEventType(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fNoSuchEventType(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pNoSuchEventType(OssGlobal * _g, void * _data);
#endif
static void _eObjectClass(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epObjectClass(OssGlobal * _g, void * _inbuf);
static void * _dObjectClass(OssGlobal * _g);
static void * _dpObjectClass(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fObjectClass(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pObjectClass(OssGlobal * _g, void * _data);
#endif
static void _eObjectInstance(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epObjectInstance(OssGlobal * _g, void * _inbuf);
static void * _dObjectInstance(OssGlobal * _g);
static void * _dpObjectInstance(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fObjectInstance(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pObjectInstance(OssGlobal * _g, void * _data);
#endif
static void _eProcessingFailure(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epProcessingFailure(OssGlobal * _g, void * _inbuf);
static void * _dProcessingFailure(OssGlobal * _g);
static void * _dpProcessingFailure(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fProcessingFailure(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pProcessingFailure(OssGlobal * _g, void * _data);
#endif
static void _eScope(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epScope(OssGlobal * _g, void * _inbuf);
static void * _dScope(OssGlobal * _g);
static void * _dpScope(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fScope(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pScope(OssGlobal * _g, void * _data);
#endif
static void _eSetArgument(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epSetArgument(OssGlobal * _g, void * _inbuf);
static void * _dSetArgument(OssGlobal * _g);
static void * _dpSetArgument(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fSetArgument(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pSetArgument(OssGlobal * _g, void * _data);
#endif
static void _eSetListError(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epSetListError(OssGlobal * _g, void * _inbuf);
static void * _dSetListError(OssGlobal * _g);
static void * _dpSetListError(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fSetListError(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pSetListError(OssGlobal * _g, void * _data);
#endif
static void _eSetResult(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epSetResult(OssGlobal * _g, void * _inbuf);
static void * _dSetResult(OssGlobal * _g);
static void * _dpSetResult(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fSetResult(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pSetResult(OssGlobal * _g, void * _data);
#endif
static void _eROSEapdus(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epROSEapdus(OssGlobal * _g, void * _inbuf);
static void * _dROSEapdus(OssGlobal * _g);
static void * _dpROSEapdus(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fROSEapdus(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pROSEapdus(OssGlobal * _g, void * _data);
#endif
static void _eCMIPAbortInfo(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epCMIPAbortInfo(OssGlobal * _g, void * _inbuf);
static void * _dCMIPAbortInfo(OssGlobal * _g);
static void * _dpCMIPAbortInfo(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fCMIPAbortInfo(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pCMIPAbortInfo(OssGlobal * _g, void * _data);
#endif
static void _eCMIPUserInfo(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epCMIPUserInfo(OssGlobal * _g, void * _inbuf);
static void * _dCMIPUserInfo(OssGlobal * _g);
static void * _dpCMIPUserInfo(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fCMIPUserInfo(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pCMIPUserInfo(OssGlobal * _g, void * _data);
#endif
static void _eCmipPduReceivingSupport(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epCmipPduReceivingSupport(OssGlobal * _g, void * _inbuf);
static void * _dCmipPduReceivingSupport(OssGlobal * _g);
static void * _dpCmipPduReceivingSupport(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fCmipPduReceivingSupport(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pCmipPduReceivingSupport(OssGlobal * _g, void * _data);
#endif
static void _eCmipPduSendingSupport(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epCmipPduSendingSupport(OssGlobal * _g, void * _inbuf);
static void * _dCmipPduSendingSupport(OssGlobal * _g);
static void * _dpCmipPduSendingSupport(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fCmipPduSendingSupport(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pCmipPduSendingSupport(OssGlobal * _g, void * _data);
#endif
static void _eCmiseFunctionalUnitsSelected(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epCmiseFunctionalUnitsSelected(OssGlobal * _g, void * _inbuf);
static void * _dCmiseFunctionalUnitsSelected(OssGlobal * _g);
static void * _dpCmiseFunctionalUnitsSelected(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fCmiseFunctionalUnitsSelected(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pCmiseFunctionalUnitsSelected(OssGlobal * _g, void * _data);
#endif
static void _e0CmiseFunctionalUnitsSupport(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep0CmiseFunctionalUnitsSupport(OssGlobal * _g, void * _inbuf);
static void * _d0CmiseFunctionalUnitsSupport(OssGlobal * _g);
static void * _dp0CmiseFunctionalUnitsSupport(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f0CmiseFunctionalUnitsSupport(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p0CmiseFunctionalUnitsSupport(OssGlobal * _g, void * _data);
#endif
static void _eInvokeldsOutstanding(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epInvokeldsOutstanding(OssGlobal * _g, void * _inbuf);
static void * _dInvokeldsOutstanding(OssGlobal * _g);
static void * _dpInvokeldsOutstanding(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fInvokeldsOutstanding(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pInvokeldsOutstanding(OssGlobal * _g, void * _data);
#endif
static void _eInvokeIdsPerforming(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epInvokeIdsPerforming(OssGlobal * _g, void * _inbuf);
static void * _dInvokeIdsPerforming(OssGlobal * _g);
static void * _dpInvokeIdsPerforming(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fInvokeIdsPerforming(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pInvokeIdsPerforming(OssGlobal * _g, void * _data);
#endif
static void _eMaxEncodedCmipPduReceiveSize(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epMaxEncodedCmipPduReceiveSize(OssGlobal * _g, void * _inbuf);
static void * _dMaxEncodedCmipPduReceiveSize(OssGlobal * _g);
static void * _dpMaxEncodedCmipPduReceiveSize(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fMaxEncodedCmipPduReceiveSize(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pMaxEncodedCmipPduReceiveSize(OssGlobal * _g, void * _data);
#endif
static void _eProtocolVersionSupported(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epProtocolVersionSupported(OssGlobal * _g, void * _inbuf);
static void * _dProtocolVersionSupported(OssGlobal * _g);
static void * _dpProtocolVersionSupported(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fProtocolVersionSupported(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pProtocolVersionSupported(OssGlobal * _g, void * _data);
#endif
static void _eSmaseFunctionalUnits(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epSmaseFunctionalUnits(OssGlobal * _g, void * _inbuf);
static void * _dSmaseFunctionalUnits(OssGlobal * _g);
static void * _dpSmaseFunctionalUnits(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fSmaseFunctionalUnits(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pSmaseFunctionalUnits(OssGlobal * _g, void * _data);
#endif
static void _eSmUserInfoSent(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epSmUserInfoSent(OssGlobal * _g, void * _inbuf);
static void * _dSmUserInfoSent(OssGlobal * _g);
static void * _dpSmUserInfoSent(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fSmUserInfoSent(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pSmUserInfoSent(OssGlobal * _g, void * _data);
#endif
static void _eSmUserInfoReceived(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epSmUserInfoReceived(OssGlobal * _g, void * _inbuf);
static void * _dSmUserInfoReceived(OssGlobal * _g);
static void * _dpSmUserInfoReceived(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fSmUserInfoReceived(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pSmUserInfoReceived(OssGlobal * _g, void * _data);
#endif
static void _eROSEInvokeIds(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epROSEInvokeIds(OssGlobal * _g, void * _inbuf);
static void * _dROSEInvokeIds(OssGlobal * _g);
static void * _dpROSEInvokeIds(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fROSEInvokeIds(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pROSEInvokeIds(OssGlobal * _g, void * _data);
#endif
static void _eNoInvokeId(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epNoInvokeId(OssGlobal * _g, void * _inbuf);
static void * _dNoInvokeId(OssGlobal * _g);
static void * _dpNoInvokeId(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fNoInvokeId(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pNoInvokeId(OssGlobal * _g, void * _data);
#endif
static void _eSMASEUserData(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epSMASEUserData(OssGlobal * _g, void * _inbuf);
static void * _dSMASEUserData(OssGlobal * _g);
static void * _dpSMASEUserData(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fSMASEUserData(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pSMASEUserData(OssGlobal * _g, void * _data);
#endif
static void _eAccessDenied_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epAccessDenied_PRIORITY(OssGlobal * _g, void * _inbuf);
static void * _dAccessDenied_PRIORITY(OssGlobal * _g);
static void * _dpAccessDenied_PRIORITY(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAccessDenied_PRIORITY(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAccessDenied_PRIORITY(OssGlobal * _g, void * _data);
#endif
static void _e1ClassInstanceConflict_PRIOR(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep1ClassInstanceConflict_PRIOR(OssGlobal * _g, void * _inbuf);
static void * _d1ClassInstanceConflict_PRIOR(OssGlobal * _g);
static void * _dp1ClassInstanceConflict_PRIOR(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f1ClassInstanceConflict_PRIOR(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p1ClassInstanceConflict_PRIOR(OssGlobal * _g, void * _data);
#endif
static void _e2ComplexityLimitation_PRIORI(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep2ComplexityLimitation_PRIORI(OssGlobal * _g, void * _inbuf);
static void * _d2ComplexityLimitation_PRIORI(OssGlobal * _g);
static void * _dp2ComplexityLimitation_PRIORI(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f2ComplexityLimitation_PRIORI(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p2ComplexityLimitation_PRIORI(OssGlobal * _g, void * _data);
#endif
static void _eInvalidScope_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epInvalidScope_PRIORITY(OssGlobal * _g, void * _inbuf);
static void * _dInvalidScope_PRIORITY(OssGlobal * _g);
static void * _dpInvalidScope_PRIORITY(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fInvalidScope_PRIORITY(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pInvalidScope_PRIORITY(OssGlobal * _g, void * _data);
#endif
static void _e3InvalidArgumentValue_PRIORI(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep3InvalidArgumentValue_PRIORI(OssGlobal * _g, void * _inbuf);
static void * _d3InvalidArgumentValue_PRIORI(OssGlobal * _g);
static void * _dp3InvalidArgumentValue_PRIORI(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f3InvalidArgumentValue_PRIORI(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p3InvalidArgumentValue_PRIORI(OssGlobal * _g, void * _data);
#endif
static void _eInvalidFilter_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epInvalidFilter_PRIORITY(OssGlobal * _g, void * _inbuf);
static void * _dInvalidFilter_PRIORITY(OssGlobal * _g);
static void * _dpInvalidFilter_PRIORITY(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fInvalidFilter_PRIORITY(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pInvalidFilter_PRIORITY(OssGlobal * _g, void * _data);
#endif
static void _eNoSuchAction_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epNoSuchAction_PRIORITY(OssGlobal * _g, void * _inbuf);
static void * _dNoSuchAction_PRIORITY(OssGlobal * _g);
static void * _dpNoSuchAction_PRIORITY(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fNoSuchAction_PRIORITY(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pNoSuchAction_PRIORITY(OssGlobal * _g, void * _data);
#endif
static void _eNoSuchArgument_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epNoSuchArgument_PRIORITY(OssGlobal * _g, void * _inbuf);
static void * _dNoSuchArgument_PRIORITY(OssGlobal * _g);
static void * _dpNoSuchArgument_PRIORITY(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fNoSuchArgument_PRIORITY(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pNoSuchArgument_PRIORITY(OssGlobal * _g, void * _data);
#endif
static void _eNoSuchObjectClass_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epNoSuchObjectClass_PRIORITY(OssGlobal * _g, void * _inbuf);
static void * _dNoSuchObjectClass_PRIORITY(OssGlobal * _g);
static void * _dpNoSuchObjectClass_PRIORITY(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fNoSuchObjectClass_PRIORITY(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pNoSuchObjectClass_PRIORITY(OssGlobal * _g, void * _data);
#endif
static void _e4NoSuchObjectInstance_PRIORI(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep4NoSuchObjectInstance_PRIORI(OssGlobal * _g, void * _inbuf);
static void * _d4NoSuchObjectInstance_PRIORI(OssGlobal * _g);
static void * _dp4NoSuchObjectInstance_PRIORI(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f4NoSuchObjectInstance_PRIORI(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p4NoSuchObjectInstance_PRIORI(OssGlobal * _g, void * _data);
#endif
static void _eProcessingFailure_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epProcessingFailure_PRIORITY(OssGlobal * _g, void * _inbuf);
static void * _dProcessingFailure_PRIORITY(OssGlobal * _g);
static void * _dpProcessingFailure_PRIORITY(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fProcessingFailure_PRIORITY(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pProcessingFailure_PRIORITY(OssGlobal * _g, void * _data);
#endif
static void _eSyncNotSupported_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epSyncNotSupported_PRIORITY(OssGlobal * _g, void * _inbuf);
static void * _dSyncNotSupported_PRIORITY(OssGlobal * _g);
static void * _dpSyncNotSupported_PRIORITY(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fSyncNotSupported_PRIORITY(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pSyncNotSupported_PRIORITY(OssGlobal * _g, void * _data);
#endif
static void _eMistypedOperation_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epMistypedOperation_PRIORITY(OssGlobal * _g, void * _inbuf);
static void * _dMistypedOperation_PRIORITY(OssGlobal * _g);
static void * _dpMistypedOperation_PRIORITY(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fMistypedOperation_PRIORITY(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pMistypedOperation_PRIORITY(OssGlobal * _g, void * _data);
#endif
static void _eNoSuchInvokeId_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epNoSuchInvokeId_PRIORITY(OssGlobal * _g, void * _inbuf);
static void * _dNoSuchInvokeId_PRIORITY(OssGlobal * _g);
static void * _dpNoSuchInvokeId_PRIORITY(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fNoSuchInvokeId_PRIORITY(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pNoSuchInvokeId_PRIORITY(OssGlobal * _g, void * _data);
#endif
static void _e5DuplicateManagedObjectInsta(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep5DuplicateManagedObjectInsta(OssGlobal * _g, void * _inbuf);
static void * _d5DuplicateManagedObjectInsta(OssGlobal * _g);
static void * _dp5DuplicateManagedObjectInsta(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f5DuplicateManagedObjectInsta(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p5DuplicateManagedObjectInsta(OssGlobal * _g, void * _data);
#endif
static void _e6InvalidAttributeValue_PRIOR(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep6InvalidAttributeValue_PRIOR(OssGlobal * _g, void * _inbuf);
static void * _d6InvalidAttributeValue_PRIOR(OssGlobal * _g);
static void * _dp6InvalidAttributeValue_PRIOR(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f6InvalidAttributeValue_PRIOR(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p6InvalidAttributeValue_PRIOR(OssGlobal * _g, void * _data);
#endif
static void _e7InvalidObjectInstance_PRIOR(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep7InvalidObjectInstance_PRIOR(OssGlobal * _g, void * _inbuf);
static void * _d7InvalidObjectInstance_PRIOR(OssGlobal * _g);
static void * _dp7InvalidObjectInstance_PRIOR(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f7InvalidObjectInstance_PRIOR(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p7InvalidObjectInstance_PRIOR(OssGlobal * _g, void * _data);
#endif
static void _e8MissingAttributeValue_PARAM(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep8MissingAttributeValue_PARAM(OssGlobal * _g, void * _inbuf);
static void * _d8MissingAttributeValue_PARAM(OssGlobal * _g);
static void * _dp8MissingAttributeValue_PARAM(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f8MissingAttributeValue_PARAM(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p8MissingAttributeValue_PARAM(OssGlobal * _g, void * _data);
#endif
static void _e9MissingAttributeValue_PRIOR(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep9MissingAttributeValue_PRIOR(OssGlobal * _g, void * _inbuf);
static void * _d9MissingAttributeValue_PRIOR(OssGlobal * _g);
static void * _dp9MissingAttributeValue_PRIOR(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f9MissingAttributeValue_PRIOR(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p9MissingAttributeValue_PRIOR(OssGlobal * _g, void * _data);
#endif
static void _eNoSuchAttribute_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epNoSuchAttribute_PRIORITY(OssGlobal * _g, void * _inbuf);
static void * _dNoSuchAttribute_PRIORITY(OssGlobal * _g);
static void * _dpNoSuchAttribute_PRIORITY(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fNoSuchAttribute_PRIORITY(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pNoSuchAttribute_PRIORITY(OssGlobal * _g, void * _data);
#endif
static void _e10NoSuchReferenceObject_PRIO(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep10NoSuchReferenceObject_PRIO(OssGlobal * _g, void * _inbuf);
static void * _d10NoSuchReferenceObject_PRIO(OssGlobal * _g);
static void * _dp10NoSuchReferenceObject_PRIO(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f10NoSuchReferenceObject_PRIO(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p10NoSuchReferenceObject_PRIO(OssGlobal * _g, void * _data);
#endif
static void _eNoSuchEventType_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epNoSuchEventType_PRIORITY(OssGlobal * _g, void * _inbuf);
static void * _dNoSuchEventType_PRIORITY(OssGlobal * _g);
static void * _dpNoSuchEventType_PRIORITY(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fNoSuchEventType_PRIORITY(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pNoSuchEventType_PRIORITY(OssGlobal * _g, void * _data);
#endif
static void _eGetListError_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epGetListError_PRIORITY(OssGlobal * _g, void * _inbuf);
static void * _dGetListError_PRIORITY(OssGlobal * _g);
static void * _dpGetListError_PRIORITY(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fGetListError_PRIORITY(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pGetListError_PRIORITY(OssGlobal * _g, void * _data);
#endif
static void _eOperationCancelled_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epOperationCancelled_PRIORITY(OssGlobal * _g, void * _inbuf);
static void * _dOperationCancelled_PRIORITY(OssGlobal * _g);
static void * _dpOperationCancelled_PRIORITY(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fOperationCancelled_PRIORITY(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pOperationCancelled_PRIORITY(OssGlobal * _g, void * _data);
#endif
static void _eSetListError_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epSetListError_PRIORITY(OssGlobal * _g, void * _inbuf);
static void * _dSetListError_PRIORITY(OssGlobal * _g);
static void * _dpSetListError_PRIORITY(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fSetListError_PRIORITY(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pSetListError_PRIORITY(OssGlobal * _g, void * _data);
#endif
static void _eAcse_RealizationParameter(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epAcse_RealizationParameter(OssGlobal * _g, void * _inbuf);
static void * _dAcse_RealizationParameter(OssGlobal * _g);
static void * _dpAcse_RealizationParameter(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAcse_RealizationParameter(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAcse_RealizationParameter(OssGlobal * _g, void * _data);
#endif
static void _e11Acse_with_concatenation_Re(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep11Acse_with_concatenation_Re(OssGlobal * _g, void * _inbuf);
static void * _d11Acse_with_concatenation_Re(OssGlobal * _g);
static void * _dp11Acse_with_concatenation_Re(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f11Acse_with_concatenation_Re(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p11Acse_with_concatenation_Re(OssGlobal * _g, void * _data);
#endif
static void _e12Association_by_RTSE_Realiz(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep12Association_by_RTSE_Realiz(OssGlobal * _g, void * _inbuf);
static void * _d12Association_by_RTSE_Realiz(OssGlobal * _g);
static void * _dp12Association_by_RTSE_Realiz(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f12Association_by_RTSE_Realiz(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p12Association_by_RTSE_Realiz(OssGlobal * _g, void * _data);
#endif
static void _ePData_RealizationParameter(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epPData_RealizationParameter(OssGlobal * _g, void * _inbuf);
static void * _dPData_RealizationParameter(OssGlobal * _g);
static void * _dpPData_RealizationParameter(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPData_RealizationParameter(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPData_RealizationParameter(OssGlobal * _g, void * _data);
#endif
static void _e13PData_with_concatenation_R(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep13PData_with_concatenation_R(OssGlobal * _g, void * _inbuf);
static void * _d13PData_with_concatenation_R(OssGlobal * _g);
static void * _dp13PData_with_concatenation_R(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f13PData_with_concatenation_R(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p13PData_with_concatenation_R(OssGlobal * _g, void * _data);
#endif
static void _e14Transfer_by_RTSE_Realizati(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep14Transfer_by_RTSE_Realizati(OssGlobal * _g, void * _inbuf);
static void * _d14Transfer_by_RTSE_Realizati(OssGlobal * _g);
static void * _dp14Transfer_by_RTSE_Realizati(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f14Transfer_by_RTSE_Realizati(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p14Transfer_by_RTSE_Realizati(OssGlobal * _g, void * _data);
#endif
void DLL_ENTRY _emSMASE_A_ASSOCIATE_Informatio(struct ossGlobal * _g, int _pdunum, void * _inbuf);
void DLL_ENTRY _peSMASE_A_ASSOCIATE_Informatio(struct ossGlobal * _g, int _pdunum, void * _inbuf);
void DLL_ENTRY _dmSMASE_A_ASSOCIATE_Informatio(struct ossGlobal * _g, int * _pdunum, void ** _outbuf);
void DLL_ENTRY _pdSMASE_A_ASSOCIATE_Informatio(struct ossGlobal * _g, int * _pdunum, void ** _outbuf);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
int DLL_ENTRY _fmSMASE_A_ASSOCIATE_Informatio(struct ossGlobal * _g, int _pdunum, void * _data);
#endif
#ifdef OSSPRINT
int DLL_ENTRY _pmSMASE_A_ASSOCIATE_Informatio(struct ossGlobal * _g, int _pdunum, void * _data);
#endif



#ifdef OSS_COPY_VALUE
static _ActionResult  * _cpActionResult(OssGlobal * _g, _ActionResult  * psVal, _ActionResult  * pdVal);
static _Attribute  * _cpAttribute(OssGlobal * _g, _Attribute  * psVal, _Attribute  * pdVal);
static _ActionTypeId  * _cpAttributeId(OssGlobal * _g, _ActionTypeId  * psVal, _ActionTypeId  * pdVal);
static _CMISFilter  * _cpCMISFilter(OssGlobal * _g, _CMISFilter  * psVal, _CMISFilter  * pdVal);
static _DeleteResult  * _cpDeleteResult(OssGlobal * _g, _DeleteResult  * psVal, _DeleteResult  * pdVal);
static _GetListError  * _cpGetListError(OssGlobal * _g, _GetListError  * psVal, _GetListError  * pdVal);
static _CreateResult  * _cpGetResult(OssGlobal * _g, _CreateResult  * psVal, _CreateResult  * pdVal);
static _InvalidArgumentValue  * _cpInvalidArgumentValue(OssGlobal * _g, _InvalidArgumentValue  * psVal, _InvalidArgumentValue  * pdVal);
static _NoSuchArgument  * _cpNoSuchArgument(OssGlobal * _g, _NoSuchArgument  * psVal, _NoSuchArgument  * pdVal);
static _ActionTypeId  * _cpObjectClass(OssGlobal * _g, _ActionTypeId  * psVal, _ActionTypeId  * pdVal);
static _ObjectInstance  * _cpObjectInstance(OssGlobal * _g, _ObjectInstance  * psVal, _ObjectInstance  * pdVal);
static _ProcessingFailure  * _cpProcessingFailure(OssGlobal * _g, _ProcessingFailure  * psVal, _ProcessingFailure  * pdVal);
static _SetListError  * _cpSetListError(OssGlobal * _g, _SetListError  * psVal, _SetListError  * pdVal);
static _CreateResult  * _cpSetResult(OssGlobal * _g, _CreateResult  * psVal, _CreateResult  * pdVal);
static _choice1  * _cp_choice1(OssGlobal * _g, _choice1  * psVal, _choice1  * pdVal);
static _External  * _cpExternal(OssGlobal * _g, _External  * psVal, _External  * pdVal);
static _ActionTypeId  * _cpActionTypeId(OssGlobal * _g, _ActionTypeId  * psVal, _ActionTypeId  * pdVal);
static _ActionTypeId  * _cpEventTypeId(OssGlobal * _g, _ActionTypeId  * psVal, _ActionTypeId  * pdVal);
static _setof1 * * _cp_setof2(OssGlobal * _g, _setof1 * * psVal, _setof1 * * pdVal);
static _setof1 * * _cp_setof1(OssGlobal * _g, _setof1 * * psVal, _setof1 * * pdVal);
static _ActionInfo  * _cpActionInfo(OssGlobal * _g, _ActionInfo  * psVal, _ActionInfo  * pdVal);
static _ActionReply  * _cpActionReply(OssGlobal * _g, _ActionReply  * psVal, _ActionReply  * pdVal);
static _seqof1 * * _cp_seqof1(OssGlobal * _g, _seqof1 * * psVal, _seqof1 * * pdVal);
static _FilterItem  * _cpFilterItem(OssGlobal * _g, _FilterItem  * psVal, _FilterItem  * pdVal);
static _setof6 * * _cp_setof6(OssGlobal * _g, _setof6 * * psVal, _setof6 * * pdVal);
static _setof3 * * _cp_setof7(OssGlobal * _g, _setof3 * * psVal, _setof3 * * pdVal);
static _seq1 * * _cp_seq1(OssGlobal * _g, _seq1 * * psVal, _seq1 * * pdVal);
static _RDNSequence * * _cpRDNSequence(OssGlobal * _g, _RDNSequence * * psVal, _RDNSequence * * pdVal);
static _RelativeDistinguishedName * * _cpRelativeDistinguishedName(OssGlobal * _g, _RelativeDistinguishedName * * psVal, _RelativeDistinguishedName * * pdVal);
static _Code  * _cpCode(OssGlobal * _g, _Code  * psVal, _Code  * pdVal);
static _FunctionalUnitPackage  * _cpFunctionalUnitPackage(OssGlobal * _g, _FunctionalUnitPackage  * psVal, _FunctionalUnitPackage  * pdVal);
#endif /* OSS_COPY_VALUE */

#ifdef OSS_COMPARE_VALUE
static int _cmActionResult(OssGlobal * _g, _ActionResult  * _odata, _ActionResult  * _cdata);
static int _cmDeleteResult(OssGlobal * _g, _DeleteResult  * _odata, _DeleteResult  * _cdata);
static int _cmGetListError(OssGlobal * _g, _GetListError  * _odata, _GetListError  * _cdata);
static int _cmGetResult(OssGlobal * _g, _CreateResult  * _odata, _CreateResult  * _cdata);
static int _cmInvalidArgumentValue(OssGlobal * _g, _InvalidArgumentValue  * _odata, _InvalidArgumentValue  * _cdata);
static int _cmNoSuchArgument(OssGlobal * _g, _NoSuchArgument  * _odata, _NoSuchArgument  * _cdata);
static int _cmObjectClass(OssGlobal * _g, _ActionTypeId  * _odata, _ActionTypeId  * _cdata);
static int _cmObjectInstance(OssGlobal * _g, _ObjectInstance  * _odata, _ObjectInstance  * _cdata);
static int _cmProcessingFailure(OssGlobal * _g, _ProcessingFailure  * _odata, _ProcessingFailure  * _cdata);
static int _cmSetListError(OssGlobal * _g, _SetListError  * _odata, _SetListError  * _cdata);
static int _cmSetResult(OssGlobal * _g, _CreateResult  * _odata, _CreateResult  * _cdata);
static int _cm_choice1(OssGlobal * _g, _choice1  * _odata, _choice1  * _cdata);
static int _cmExternal(OssGlobal * _g, _External  * _odata, _External  * _cdata);
static int _cmActionTypeId(OssGlobal * _g, _ActionTypeId  * _odata, _ActionTypeId  * _cdata);
static int _cmEventTypeId(OssGlobal * _g, _ActionTypeId  * _odata, _ActionTypeId  * _cdata);
static int _cmRealizationParameter(OssGlobal * _g, _RealizationParameter  * _odata, _RealizationParameter  * _cdata);
static int _cmActionInfo(OssGlobal * _g, _ActionInfo  * _odata, _ActionInfo  * _cdata);
static int _cmActionReply(OssGlobal * _g, _ActionReply  * _odata, _ActionReply  * _cdata);
static int _cm_setof6(OssGlobal * _g, _setof6 * * _odata, _setof6 * * _cdata);
static int _cm_setof7(OssGlobal * _g, _setof3 * * _odata, _setof3 * * _cdata);
static int _cm_seq1(OssGlobal * _g, _seq1 * * _odata, _seq1 * * _cdata);
static int _cmInvokeId(OssGlobal * _g, _InvokeId  * _odata, _InvokeId  * _cdata);
static int _cmRDNSequence(OssGlobal * _g, _RDNSequence * * _odata, _RDNSequence * * _cdata);
static int _cmRelativeDistinguishedName(OssGlobal * _g, _RelativeDistinguishedName * * _odata, _RelativeDistinguishedName * * _cdata);
static int _cmCode(OssGlobal * _g, _Code  * _odata, _Code  * _cdata);
static int _cmFunctionalUnitPackage(OssGlobal * _g, _FunctionalUnitPackage  * _odata, _FunctionalUnitPackage  * _cdata);
#endif /* OSS_COMPARE_VALUE */

static void (*_Encoders[78])(OssGlobal *, void *, char **, long *, unsigned int) = {
    _eActionArgument,
    _eActionResult,
    _eAttribute,
    _eAttributeId,
    _eBaseManagedObjectId,
    _eCMISFilter,
    _eCMISSync,
    _eComplexityLimitation,
    _eCreateArgument,
    _eCreateResult,
    _eDeleteArgument,
    _eDeleteResult,
    _eEventReportArgument,
    _eEventReportResult,
    _eGetArgument,
    _eGetListError,
    _eGetResult,
    _eInvalidArgumentValue,
    _eInvokeIDType,
    _eLinkedReplyArgument,
    _eNoSuchAction,
    _eNoSuchArgument,
    _eNoSuchEventType,
    _eObjectClass,
    _eObjectInstance,
    _eProcessingFailure,
    _eScope,
    _eSetArgument,
    _eSetListError,
    _eSetResult,
    _eROSEapdus,
    _eCMIPAbortInfo,
    _eCMIPUserInfo,
    _eCmipPduReceivingSupport,
    _eCmipPduSendingSupport,
    _eCmiseFunctionalUnitsSelected,
    _e0CmiseFunctionalUnitsSupport,
    _eInvokeldsOutstanding,
    _eInvokeIdsPerforming,
    _eMaxEncodedCmipPduReceiveSize,
    _eProtocolVersionSupported,
    _eSmaseFunctionalUnits,
    _eSmUserInfoSent,
    _eSmUserInfoReceived,
    _eROSEInvokeIds,
    _eNoInvokeId,
    _eSMASEUserData,
    _eAccessDenied_PRIORITY,
    _e1ClassInstanceConflict_PRIOR,
    _e2ComplexityLimitation_PRIORI,
    _eInvalidScope_PRIORITY,
    _e3InvalidArgumentValue_PRIORI,
    _eInvalidFilter_PRIORITY,
    _eNoSuchAction_PRIORITY,
    _eNoSuchArgument_PRIORITY,
    _eNoSuchObjectClass_PRIORITY,
    _e4NoSuchObjectInstance_PRIORI,
    _eProcessingFailure_PRIORITY,
    _eSyncNotSupported_PRIORITY,
    _eMistypedOperation_PRIORITY,
    _eNoSuchInvokeId_PRIORITY,
    _e5DuplicateManagedObjectInsta,
    _e6InvalidAttributeValue_PRIOR,
    _e7InvalidObjectInstance_PRIOR,
    _e8MissingAttributeValue_PARAM,
    _e9MissingAttributeValue_PRIOR,
    _eNoSuchAttribute_PRIORITY,
    _e10NoSuchReferenceObject_PRIO,
    _eNoSuchEventType_PRIORITY,
    _eGetListError_PRIORITY,
    _eOperationCancelled_PRIORITY,
    _eSetListError_PRIORITY,
    _eAcse_RealizationParameter,
    _e11Acse_with_concatenation_Re,
    _e12Association_by_RTSE_Realiz,
    _ePData_RealizationParameter,
    _e13PData_with_concatenation_R,
    _e14Transfer_by_RTSE_Realizati
};
static void (*_pEncoders[78])(OssGlobal *, void *) = {
    _epActionArgument,
    _epActionResult,
    _epAttribute,
    _epAttributeId,
    _epBaseManagedObjectId,
    _epCMISFilter,
    _epCMISSync,
    _epComplexityLimitation,
    _epCreateArgument,
    _epCreateResult,
    _epDeleteArgument,
    _epDeleteResult,
    _epEventReportArgument,
    _epEventReportResult,
    _epGetArgument,
    _epGetListError,
    _epGetResult,
    _epInvalidArgumentValue,
    _epInvokeIDType,
    _epLinkedReplyArgument,
    _epNoSuchAction,
    _epNoSuchArgument,
    _epNoSuchEventType,
    _epObjectClass,
    _epObjectInstance,
    _epProcessingFailure,
    _epScope,
    _epSetArgument,
    _epSetListError,
    _epSetResult,
    _epROSEapdus,
    _epCMIPAbortInfo,
    _epCMIPUserInfo,
    _epCmipPduReceivingSupport,
    _epCmipPduSendingSupport,
    _epCmiseFunctionalUnitsSelected,
    _ep0CmiseFunctionalUnitsSupport,
    _epInvokeldsOutstanding,
    _epInvokeIdsPerforming,
    _epMaxEncodedCmipPduReceiveSize,
    _epProtocolVersionSupported,
    _epSmaseFunctionalUnits,
    _epSmUserInfoSent,
    _epSmUserInfoReceived,
    _epROSEInvokeIds,
    _epNoInvokeId,
    _epSMASEUserData,
    _epAccessDenied_PRIORITY,
    _ep1ClassInstanceConflict_PRIOR,
    _ep2ComplexityLimitation_PRIORI,
    _epInvalidScope_PRIORITY,
    _ep3InvalidArgumentValue_PRIORI,
    _epInvalidFilter_PRIORITY,
    _epNoSuchAction_PRIORITY,
    _epNoSuchArgument_PRIORITY,
    _epNoSuchObjectClass_PRIORITY,
    _ep4NoSuchObjectInstance_PRIORI,
    _epProcessingFailure_PRIORITY,
    _epSyncNotSupported_PRIORITY,
    _epMistypedOperation_PRIORITY,
    _epNoSuchInvokeId_PRIORITY,
    _ep5DuplicateManagedObjectInsta,
    _ep6InvalidAttributeValue_PRIOR,
    _ep7InvalidObjectInstance_PRIOR,
    _ep8MissingAttributeValue_PARAM,
    _ep9MissingAttributeValue_PRIOR,
    _epNoSuchAttribute_PRIORITY,
    _ep10NoSuchReferenceObject_PRIO,
    _epNoSuchEventType_PRIORITY,
    _epGetListError_PRIORITY,
    _epOperationCancelled_PRIORITY,
    _epSetListError_PRIORITY,
    _epAcse_RealizationParameter,
    _ep11Acse_with_concatenation_Re,
    _ep12Association_by_RTSE_Realiz,
    _epPData_RealizationParameter,
    _ep13PData_with_concatenation_R,
    _ep14Transfer_by_RTSE_Realizati
};
static void *(*_Decoders[78])(OssGlobal *) = {
    _dActionArgument,
    _dActionResult,
    _dAttribute,
    _dAttributeId,
    _dBaseManagedObjectId,
    _dCMISFilter,
    _dCMISSync,
    _dComplexityLimitation,
    _dCreateArgument,
    _dCreateResult,
    _dDeleteArgument,
    _dDeleteResult,
    _dEventReportArgument,
    _dEventReportResult,
    _dGetArgument,
    _dGetListError,
    _dGetResult,
    _dInvalidArgumentValue,
    _dInvokeIDType,
    _dLinkedReplyArgument,
    _dNoSuchAction,
    _dNoSuchArgument,
    _dNoSuchEventType,
    _dObjectClass,
    _dObjectInstance,
    _dProcessingFailure,
    _dScope,
    _dSetArgument,
    _dSetListError,
    _dSetResult,
    _dROSEapdus,
    _dCMIPAbortInfo,
    _dCMIPUserInfo,
    _dCmipPduReceivingSupport,
    _dCmipPduSendingSupport,
    _dCmiseFunctionalUnitsSelected,
    _d0CmiseFunctionalUnitsSupport,
    _dInvokeldsOutstanding,
    _dInvokeIdsPerforming,
    _dMaxEncodedCmipPduReceiveSize,
    _dProtocolVersionSupported,
    _dSmaseFunctionalUnits,
    _dSmUserInfoSent,
    _dSmUserInfoReceived,
    _dROSEInvokeIds,
    _dNoInvokeId,
    _dSMASEUserData,
    _dAccessDenied_PRIORITY,
    _d1ClassInstanceConflict_PRIOR,
    _d2ComplexityLimitation_PRIORI,
    _dInvalidScope_PRIORITY,
    _d3InvalidArgumentValue_PRIORI,
    _dInvalidFilter_PRIORITY,
    _dNoSuchAction_PRIORITY,
    _dNoSuchArgument_PRIORITY,
    _dNoSuchObjectClass_PRIORITY,
    _d4NoSuchObjectInstance_PRIORI,
    _dProcessingFailure_PRIORITY,
    _dSyncNotSupported_PRIORITY,
    _dMistypedOperation_PRIORITY,
    _dNoSuchInvokeId_PRIORITY,
    _d5DuplicateManagedObjectInsta,
    _d6InvalidAttributeValue_PRIOR,
    _d7InvalidObjectInstance_PRIOR,
    _d8MissingAttributeValue_PARAM,
    _d9MissingAttributeValue_PRIOR,
    _dNoSuchAttribute_PRIORITY,
    _d10NoSuchReferenceObject_PRIO,
    _dNoSuchEventType_PRIORITY,
    _dGetListError_PRIORITY,
    _dOperationCancelled_PRIORITY,
    _dSetListError_PRIORITY,
    _dAcse_RealizationParameter,
    _d11Acse_with_concatenation_Re,
    _d12Association_by_RTSE_Realiz,
    _dPData_RealizationParameter,
    _d13PData_with_concatenation_R,
    _d14Transfer_by_RTSE_Realizati
};
static void *(*_pDecoders[78])(OssGlobal *) = {
    _dpActionArgument,
    _dpActionResult,
    _dpAttribute,
    _dpAttributeId,
    _dpBaseManagedObjectId,
    _dpCMISFilter,
    _dpCMISSync,
    _dpComplexityLimitation,
    _dpCreateArgument,
    _dpCreateResult,
    _dpDeleteArgument,
    _dpDeleteResult,
    _dpEventReportArgument,
    _dpEventReportResult,
    _dpGetArgument,
    _dpGetListError,
    _dpGetResult,
    _dpInvalidArgumentValue,
    _dpInvokeIDType,
    _dpLinkedReplyArgument,
    _dpNoSuchAction,
    _dpNoSuchArgument,
    _dpNoSuchEventType,
    _dpObjectClass,
    _dpObjectInstance,
    _dpProcessingFailure,
    _dpScope,
    _dpSetArgument,
    _dpSetListError,
    _dpSetResult,
    _dpROSEapdus,
    _dpCMIPAbortInfo,
    _dpCMIPUserInfo,
    _dpCmipPduReceivingSupport,
    _dpCmipPduSendingSupport,
    _dpCmiseFunctionalUnitsSelected,
    _dp0CmiseFunctionalUnitsSupport,
    _dpInvokeldsOutstanding,
    _dpInvokeIdsPerforming,
    _dpMaxEncodedCmipPduReceiveSize,
    _dpProtocolVersionSupported,
    _dpSmaseFunctionalUnits,
    _dpSmUserInfoSent,
    _dpSmUserInfoReceived,
    _dpROSEInvokeIds,
    _dpNoInvokeId,
    _dpSMASEUserData,
    _dpAccessDenied_PRIORITY,
    _dp1ClassInstanceConflict_PRIOR,
    _dp2ComplexityLimitation_PRIORI,
    _dpInvalidScope_PRIORITY,
    _dp3InvalidArgumentValue_PRIORI,
    _dpInvalidFilter_PRIORITY,
    _dpNoSuchAction_PRIORITY,
    _dpNoSuchArgument_PRIORITY,
    _dpNoSuchObjectClass_PRIORITY,
    _dp4NoSuchObjectInstance_PRIORI,
    _dpProcessingFailure_PRIORITY,
    _dpSyncNotSupported_PRIORITY,
    _dpMistypedOperation_PRIORITY,
    _dpNoSuchInvokeId_PRIORITY,
    _dp5DuplicateManagedObjectInsta,
    _dp6InvalidAttributeValue_PRIOR,
    _dp7InvalidObjectInstance_PRIOR,
    _dp8MissingAttributeValue_PARAM,
    _dp9MissingAttributeValue_PRIOR,
    _dpNoSuchAttribute_PRIORITY,
    _dp10NoSuchReferenceObject_PRIO,
    _dpNoSuchEventType_PRIORITY,
    _dpGetListError_PRIORITY,
    _dpOperationCancelled_PRIORITY,
    _dpSetListError_PRIORITY,
    _dpAcse_RealizationParameter,
    _dp11Acse_with_concatenation_Re,
    _dp12Association_by_RTSE_Realiz,
    _dpPData_RealizationParameter,
    _dp13PData_with_concatenation_R,
    _dp14Transfer_by_RTSE_Realizati
};
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void (*_FreePDU[78])(OssGlobal *, void *) = {
    _fActionArgument,
    _fActionResult,
    _fAttribute,
    _fAttributeId,
    _fBaseManagedObjectId,
    _fCMISFilter,
    _fCMISSync,
    _fComplexityLimitation,
    _fCreateArgument,
    _fCreateResult,
    _fDeleteArgument,
    _fDeleteResult,
    _fEventReportArgument,
    _fEventReportResult,
    _fGetArgument,
    _fGetListError,
    _fGetResult,
    _fInvalidArgumentValue,
    _fInvokeIDType,
    _fLinkedReplyArgument,
    _fNoSuchAction,
    _fNoSuchArgument,
    _fNoSuchEventType,
    _fObjectClass,
    _fObjectInstance,
    _fProcessingFailure,
    _fScope,
    _fSetArgument,
    _fSetListError,
    _fSetResult,
    _fROSEapdus,
    _fCMIPAbortInfo,
    _fCMIPUserInfo,
    _fCmipPduReceivingSupport,
    _fCmipPduSendingSupport,
    _fCmiseFunctionalUnitsSelected,
    _f0CmiseFunctionalUnitsSupport,
    _fInvokeldsOutstanding,
    _fInvokeIdsPerforming,
    _fMaxEncodedCmipPduReceiveSize,
    _fProtocolVersionSupported,
    _fSmaseFunctionalUnits,
    _fSmUserInfoSent,
    _fSmUserInfoReceived,
    _fROSEInvokeIds,
    _fNoInvokeId,
    _fSMASEUserData,
    _fAccessDenied_PRIORITY,
    _f1ClassInstanceConflict_PRIOR,
    _f2ComplexityLimitation_PRIORI,
    _fInvalidScope_PRIORITY,
    _f3InvalidArgumentValue_PRIORI,
    _fInvalidFilter_PRIORITY,
    _fNoSuchAction_PRIORITY,
    _fNoSuchArgument_PRIORITY,
    _fNoSuchObjectClass_PRIORITY,
    _f4NoSuchObjectInstance_PRIORI,
    _fProcessingFailure_PRIORITY,
    _fSyncNotSupported_PRIORITY,
    _fMistypedOperation_PRIORITY,
    _fNoSuchInvokeId_PRIORITY,
    _f5DuplicateManagedObjectInsta,
    _f6InvalidAttributeValue_PRIOR,
    _f7InvalidObjectInstance_PRIOR,
    _f8MissingAttributeValue_PARAM,
    _f9MissingAttributeValue_PRIOR,
    _fNoSuchAttribute_PRIORITY,
    _f10NoSuchReferenceObject_PRIO,
    _fNoSuchEventType_PRIORITY,
    _fGetListError_PRIORITY,
    _fOperationCancelled_PRIORITY,
    _fSetListError_PRIORITY,
    _fAcse_RealizationParameter,
    _f11Acse_with_concatenation_Re,
    _f12Association_by_RTSE_Realiz,
    _fPData_RealizationParameter,
    _f13PData_with_concatenation_R,
    _f14Transfer_by_RTSE_Realizati
};
#endif
#ifdef OSSPRINT
static _print_pdu_ _PrintPDU[78] = {
    { _pActionArgument, (char *)"ActionArgument" },
    { _pActionResult, (char *)"ActionResult" },
    { _pAttribute, (char *)"Attribute" },
    { _pAttributeId, (char *)"AttributeId" },
    { _pBaseManagedObjectId, (char *)"BaseManagedObjectId" },
    { _pCMISFilter, (char *)"CMISFilter" },
    { _pCMISSync, (char *)"CMISSync" },
    { _pComplexityLimitation, (char *)"ComplexityLimitation" },
    { _pCreateArgument, (char *)"CreateArgument" },
    { _pCreateResult, (char *)"CreateResult" },
    { _pDeleteArgument, (char *)"DeleteArgument" },
    { _pDeleteResult, (char *)"DeleteResult" },
    { _pEventReportArgument, (char *)"EventReportArgument" },
    { _pEventReportResult, (char *)"EventReportResult" },
    { _pGetArgument, (char *)"GetArgument" },
    { _pGetListError, (char *)"GetListError" },
    { _pGetResult, (char *)"GetResult" },
    { _pInvalidArgumentValue, (char *)"InvalidArgumentValue" },
    { _pInvokeIDType, (char *)"InvokeIDType" },
    { _pLinkedReplyArgument, (char *)"LinkedReplyArgument" },
    { _pNoSuchAction, (char *)"NoSuchAction" },
    { _pNoSuchArgument, (char *)"NoSuchArgument" },
    { _pNoSuchEventType, (char *)"NoSuchEventType" },
    { _pObjectClass, (char *)"ObjectClass" },
    { _pObjectInstance, (char *)"ObjectInstance" },
    { _pProcessingFailure, (char *)"ProcessingFailure" },
    { _pScope, (char *)"Scope" },
    { _pSetArgument, (char *)"SetArgument" },
    { _pSetListError, (char *)"SetListError" },
    { _pSetResult, (char *)"SetResult" },
    { _pROSEapdus, (char *)"ROSEapdus" },
    { _pCMIPAbortInfo, (char *)"CMIPAbortInfo" },
    { _pCMIPUserInfo, (char *)"CMIPUserInfo" },
    { _pCmipPduReceivingSupport, (char *)"CmipPduReceivingSupport" },
    { _pCmipPduSendingSupport, (char *)"CmipPduSendingSupport" },
    { _pCmiseFunctionalUnitsSelected, (char *)"CmiseFunctionalUnitsSelected" },
    { _p0CmiseFunctionalUnitsSupport, (char *)"CmiseFunctionalUnitsSupported" },
    { _pInvokeldsOutstanding, (char *)"InvokeldsOutstanding" },
    { _pInvokeIdsPerforming, (char *)"InvokeIdsPerforming" },
    { _pMaxEncodedCmipPduReceiveSize, (char *)"MaxEncodedCmipPduReceiveSize" },
    { _pProtocolVersionSupported, (char *)"ProtocolVersionSupported" },
    { _pSmaseFunctionalUnits, (char *)"SmaseFunctionalUnits" },
    { _pSmUserInfoSent, (char *)"SmUserInfoSent" },
    { _pSmUserInfoReceived, (char *)"SmUserInfoReceived" },
    { _pROSEInvokeIds, (char *)"ROSEInvokeIds" },
    { _pNoInvokeId, (char *)"NoInvokeId" },
    { _pSMASEUserData, (char *)"SMASEUserData" },
    { _pAccessDenied_PRIORITY, (char *)"AccessDenied-PRIORITY" },
    { _p1ClassInstanceConflict_PRIOR, (char *)"ClassInstanceConflict-PRIORITY" },
    { _p2ComplexityLimitation_PRIORI, (char *)"ComplexityLimitation-PRIORITY" },
    { _pInvalidScope_PRIORITY, (char *)"InvalidScope-PRIORITY" },
    { _p3InvalidArgumentValue_PRIORI, (char *)"InvalidArgumentValue-PRIORITY" },
    { _pInvalidFilter_PRIORITY, (char *)"InvalidFilter-PRIORITY" },
    { _pNoSuchAction_PRIORITY, (char *)"NoSuchAction-PRIORITY" },
    { _pNoSuchArgument_PRIORITY, (char *)"NoSuchArgument-PRIORITY" },
    { _pNoSuchObjectClass_PRIORITY, (char *)"NoSuchObjectClass-PRIORITY" },
    { _p4NoSuchObjectInstance_PRIORI, (char *)"NoSuchObjectInstance-PRIORITY" },
    { _pProcessingFailure_PRIORITY, (char *)"ProcessingFailure-PRIORITY" },
    { _pSyncNotSupported_PRIORITY, (char *)"SyncNotSupported-PRIORITY" },
    { _pMistypedOperation_PRIORITY, (char *)"MistypedOperation-PRIORITY" },
    { _pNoSuchInvokeId_PRIORITY, (char *)"NoSuchInvokeId-PRIORITY" },
    { _p5DuplicateManagedObjectInsta, (char *)"DuplicateManagedObjectInstance-PRIORITY" },
    { _p6InvalidAttributeValue_PRIOR, (char *)"InvalidAttributeValue-PRIORITY" },
    { _p7InvalidObjectInstance_PRIOR, (char *)"InvalidObjectInstance-PRIORITY" },
    { _p8MissingAttributeValue_PARAM, (char *)"MissingAttributeValue-PARAMETER" },
    { _p9MissingAttributeValue_PRIOR, (char *)"MissingAttributeValue-PRIORITY" },
    { _pNoSuchAttribute_PRIORITY, (char *)"NoSuchAttribute-PRIORITY" },
    { _p10NoSuchReferenceObject_PRIO, (char *)"NoSuchReferenceObject-PRIORITY" },
    { _pNoSuchEventType_PRIORITY, (char *)"NoSuchEventType-PRIORITY" },
    { _pGetListError_PRIORITY, (char *)"GetListError-PRIORITY" },
    { _pOperationCancelled_PRIORITY, (char *)"OperationCancelled-PRIORITY" },
    { _pSetListError_PRIORITY, (char *)"SetListError-PRIORITY" },
    { _pAcse_RealizationParameter, (char *)"Acse-RealizationParameter" },
    { _p11Acse_with_concatenation_Re, (char *)"Acse-with-concatenation-RealizationParameter" },
    { _p12Association_by_RTSE_Realiz, (char *)"Association-by-RTSE-RealizationParameter" },
    { _pPData_RealizationParameter, (char *)"PData-RealizationParameter" },
    { _p13PData_with_concatenation_R, (char *)"PData-with-concatenation-RealizationParameter" },
    { _p14Transfer_by_RTSE_Realizati, (char *)"Transfer-by-RTSE-RealizationParameter" }
};
#endif

/* TOED internal function implementations */

#if OSSDEBUG > 1
static const _Context_Id _context_id[] = {
    {(char *)"actionReply", (char *)"ActionReply", _sequence_type},
    {(char *)"currentTime", (char *)"Character String", _charstring_type},
    {(char *)"managedObjectInstance", (char *)"ObjectInstance", _choice_type},
    {(char *)"managedObjectClass", (char *)"ObjectClass", _choice_type},
    {(char *)"value", (char *)"OpenType", _opentype},
    {(char *)"id", (char *)"AttributeId", _choice_type},
    {(char *)"globalForm", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {(char *)"localForm", (char *)"INTEGER", _integer_type},
    {(char *)"item", (char *)"FilterItem", _choice_type},
    {(char *)"and", (char *)"SET OF", _set_of_type},
    {(char *)"or", (char *)"SET OF", _set_of_type},
    {(char *)"not", (char *)"CMISFilter", _choice_type},
    {(char *)"getInfoList", (char *)"SET OF", _set_of_type},
    {(char *)"attributeList", (char *)"SET OF", _set_of_type},
    {(char *)"actionValue", (char *)"ActionInfo", _sequence_type},
    {(char *)"eventValue", (char *)"SEQUENCE", _sequence_type},
    {(char *)"eventInfo", (char *)"OpenType", _opentype},
    {(char *)"eventType", (char *)"EventTypeId", _choice_type},
    {(char *)"actionId", (char *)"SEQUENCE", _sequence_type},
    {(char *)"actionType", (char *)"ActionTypeId", _choice_type},
    {(char *)"eventId", (char *)"SEQUENCE", _sequence_type},
    {(char *)"distinguishedName", (char *)"DistinguishedName", _sequence_of_type},
    {(char *)"nonSpecificForm", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"localDistinguishedName", (char *)"RDNSequence", _sequence_of_type},
    {(char *)"specificErrorInfo", (char *)"SpecificErrorInfo", _sequence_type},
    {(char *)"errorInfo", (char *)"OpenType", _opentype},
    {(char *)"errorId", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {(char *)"namedNumbers", (char *)"INTEGER", _integer_type},
    {(char *)"individualLevels", (char *)"INTEGER", _integer_type},
    {(char *)"baseToNthLevel", (char *)"INTEGER", _integer_type},
    {(char *)"setInfoList", (char *)"SET OF", _set_of_type},
    {NULL, (char *)"SetInfoStatus", _choice_type},
    {(char *)"attributeError", (char *)"AttributeError", _sequence_type},
    {(char *)"attributeValue", (char *)"OpenType", _opentype},
    {(char *)"attributeId", (char *)"AttributeId", _choice_type},
    {(char *)"modifyOperator", (char *)"ModifyOperator", _integer_type},
    {(char *)"errorStatus", (char *)"ENUMERATED", _enumerated_type},
    {(char *)"attribute", (char *)"Attribute", _sequence_type},
    {NULL, (char *)"Attribute", _sequence_type},
    {(char *)"single-ASN1-type", (char *)"OpenType", _opentype},
    {(char *)"octet-aligned", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"arbitrary", (char *)"BIT STRING", _bitstring_type},
    {(char *)"encoding", (char *)"CHOICE", _choice_type},
    {(char *)"data-value-descriptor", (char *)"Character String", _charstring_type},
    {(char *)"indirect-reference", (char *)"INTEGER", _integer_type},
    {(char *)"direct-reference", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {NULL, (char *)"CMISFilter", _choice_type},
    {(char *)"concatenation", (char *)"BOOLEAN", _boolean_type},
    {(char *)"realization-type", (char *)"ENUMERATED", _enumerated_type},
    {(char *)"actionInfoArg", (char *)"OpenType", _opentype},
    {(char *)"actionReplyInfo", (char *)"OpenType", _opentype},
    {NULL, (char *)"CHOICE", _choice_type},
    {(char *)"initialString", (char *)"Attribute", _sequence_type},
    {(char *)"anyString", (char *)"Attribute", _sequence_type},
    {(char *)"finalString", (char *)"Attribute", _sequence_type},
    {(char *)"equality", (char *)"Attribute", _sequence_type},
    {(char *)"substrings", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"greaterOrEqual", (char *)"Attribute", _sequence_type},
    {(char *)"lessOrEqual", (char *)"Attribute", _sequence_type},
    {(char *)"present", (char *)"AttributeId", _choice_type},
    {(char *)"subsetOf", (char *)"Attribute", _sequence_type},
    {(char *)"supersetOf", (char *)"Attribute", _sequence_type},
    {(char *)"nonNullSetIntersection", (char *)"Attribute", _sequence_type},
    {NULL, (char *)"GetInfoStatus", _choice_type},
    {(char *)"attributeIdError", (char *)"AttributeIdError", _sequence_type},
    {(char *)"present", (char *)"INTEGER", _integer_type},
    {(char *)"absent", (char *)"NULL", _null_type},
    {NULL, (char *)"RelativeDistinguishedName", _set_of_type},
    {NULL, (char *)"AttributeValueAssertion", _sequence_type},
    {(char *)"id", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {(char *)"local", (char *)"INTEGER", _integer_type},
    {(char *)"global", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {(char *)"agentRoleFunctionalUnit", (char *)"BIT STRING", _bitstring_type},
    {(char *)"managerRoleFunctionalUnit", (char *)"BIT STRING", _bitstring_type},
    {(char *)"functionalUnitPackageId", (char *)"FunctionalUnitPackageId", _object_identifier_type},
    {(char *)"ActionArgument", (char *)"SEQUENCE", _sequence_type},
    {(char *)"actionInfo", (char *)"ActionInfo", _sequence_type},
    {(char *)"filter", (char *)"CMISFilter", _choice_type},
    {(char *)"scope", (char *)"Scope", _choice_type},
    {(char *)"synchronization", (char *)"CMISSync", _enumerated_type},
    {(char *)"accessControl", (char *)"AccessControl", _sequence_type},
    {(char *)"baseManagedObjectInstance", (char *)"ObjectInstance", _choice_type},
    {(char *)"baseManagedObjectClass", (char *)"ObjectClass", _choice_type},
    {(char *)"ActionResult", (char *)"SEQUENCE", _sequence_type},
    {(char *)"Attribute", (char *)"SEQUENCE", _sequence_type},
    {(char *)"AttributeId", (char *)"CHOICE", _choice_type},
    {(char *)"BaseManagedObjectId", (char *)"SEQUENCE", _sequence_type},
    {(char *)"CMISFilter", (char *)"CHOICE", _choice_type},
    {(char *)"CMISSync", (char *)"ENUMERATED", _enumerated_type},
    {(char *)"ComplexityLimitation", (char *)"SET", _set_type},
    {(char *)"sync", (char *)"CMISSync", _enumerated_type},
    {(char *)"CreateArgument", (char *)"SEQUENCE", _sequence_type},
    {(char *)"referenceObjectInstance", (char *)"ObjectInstance", _choice_type},
    {(char *)"managedOrSuperiorObjectInstance", (char *)"CHOICE", _choice_type},
    {(char *)"superiorObjectInstance", (char *)"ObjectInstance", _choice_type},
    {(char *)"CreateResult", (char *)"SEQUENCE", _sequence_type},
    {(char *)"DeleteArgument", (char *)"SEQUENCE", _sequence_type},
    {(char *)"DeleteResult", (char *)"SEQUENCE", _sequence_type},
    {(char *)"EventReportArgument", (char *)"SEQUENCE", _sequence_type},
    {(char *)"eventTime", (char *)"Character String", _charstring_type},
    {(char *)"EventReportResult", (char *)"SEQUENCE", _sequence_type},
    {(char *)"eventReply", (char *)"EventReply", _sequence_type},
    {(char *)"eventReplyInfo", (char *)"OpenType", _opentype},
    {(char *)"GetArgument", (char *)"SEQUENCE", _sequence_type},
    {(char *)"attributeIdList", (char *)"SET OF", _set_of_type},
    {NULL, (char *)"AttributeId", _choice_type},
    {(char *)"GetListError", (char *)"SEQUENCE", _sequence_type},
    {(char *)"GetResult", (char *)"SEQUENCE", _sequence_type},
    {(char *)"InvalidArgumentValue", (char *)"CHOICE", _choice_type},
    {(char *)"InvokeIDType", (char *)"CHOICE", _choice_type},
    {(char *)"LinkedReplyArgument", (char *)"CHOICE", _choice_type},
    {(char *)"getResult", (char *)"GetResult", _sequence_type},
    {(char *)"getListError", (char *)"GetListError", _sequence_type},
    {(char *)"setResult", (char *)"SetResult", _sequence_type},
    {(char *)"setListError", (char *)"SetListError", _sequence_type},
    {(char *)"actionResult", (char *)"ActionResult", _sequence_type},
    {(char *)"processingFailure", (char *)"ProcessingFailure", _sequence_type},
    {(char *)"deleteResult", (char *)"DeleteResult", _sequence_type},
    {(char *)"actionError", (char *)"ActionError", _sequence_type},
    {(char *)"actionErrorInfo", (char *)"ActionErrorInfo", _sequence_type},
    {(char *)"errorInfo", (char *)"CHOICE", _choice_type},
    {(char *)"actionArgument", (char *)"NoSuchArgument", _choice_type},
    {(char *)"argumentValue", (char *)"InvalidArgumentValue", _choice_type},
    {(char *)"deleteError", (char *)"DeleteError", _sequence_type},
    {(char *)"deleteErrorInfo", (char *)"ENUMERATED", _enumerated_type},
    {(char *)"NoSuchAction", (char *)"SEQUENCE", _sequence_type},
    {(char *)"NoSuchArgument", (char *)"CHOICE", _choice_type},
    {(char *)"NoSuchEventType", (char *)"SEQUENCE", _sequence_type},
    {(char *)"ObjectClass", (char *)"CHOICE", _choice_type},
    {(char *)"ObjectInstance", (char *)"CHOICE", _choice_type},
    {(char *)"ProcessingFailure", (char *)"SEQUENCE", _sequence_type},
    {(char *)"Scope", (char *)"CHOICE", _choice_type},
    {(char *)"SetArgument", (char *)"SEQUENCE", _sequence_type},
    {(char *)"modificationList", (char *)"SET OF", _set_of_type},
    {NULL, (char *)"SEQUENCE", _sequence_type},
    {(char *)"SetListError", (char *)"SEQUENCE", _sequence_type},
    {(char *)"SetResult", (char *)"SEQUENCE", _sequence_type},
    {(char *)"ROSEapdus", (char *)"CHOICE", _choice_type},
    {(char *)"invoke", (char *)"SEQUENCE", _sequence_type},
    {(char *)"argument", (char *)"OpenType", _opentype},
    {(char *)"opcode", (char *)"Code", _choice_type},
    {(char *)"linkedId", (char *)"CHOICE", _choice_type},
    {(char *)"invokeId", (char *)"InvokeId", _choice_type},
    {(char *)"returnResult", (char *)"SEQUENCE", _sequence_type},
    {(char *)"result", (char *)"SEQUENCE", _sequence_type},
    {(char *)"result", (char *)"OpenType", _opentype},
    {(char *)"returnError", (char *)"SEQUENCE", _sequence_type},
    {(char *)"parameter", (char *)"OpenType", _opentype},
    {(char *)"errcode", (char *)"Code", _choice_type},
    {(char *)"reject", (char *)"Reject", _sequence_type},
    {(char *)"problem", (char *)"CHOICE", _choice_type},
    {(char *)"general", (char *)"GeneralProblem", _integer_type},
    {(char *)"invoke", (char *)"InvokeProblem", _integer_type},
    {(char *)"returnResult", (char *)"ReturnResultProblem", _integer_type},
    {(char *)"returnError", (char *)"ReturnErrorProblem", _integer_type},
    {(char *)"CMIPAbortInfo", (char *)"SEQUENCE", _sequence_type},
    {(char *)"userInfo", (char *)"SEQUENCE", _sequence_type},
    {(char *)"abortSource", (char *)"CMIPAbortSource", _enumerated_type},
    {(char *)"CMIPUserInfo", (char *)"SEQUENCE", _sequence_type},
    {(char *)"accessControl", (char *)"SEQUENCE", _sequence_type},
    {(char *)"functionalUnits", (char *)"FunctionalUnits", _bitstring_type},
    {(char *)"protocolVersion", (char *)"ProtocolVersion", _bitstring_type},
    {(char *)"CmipPduReceivingSupport", (char *)"BIT STRING", _bitstring_type},
    {(char *)"CmipPduSendingSupport", (char *)"BIT STRING", _bitstring_type},
    {(char *)"CmiseFunctionalUnitsSelected", (char *)"BIT STRING", _bitstring_type},
    {(char *)"CmiseFunctionalUnitsSupported", (char *)"BIT STRING", _bitstring_type},
    {(char *)"InvokeldsOutstanding", (char *)"SET OF", _set_of_type},
    {NULL, (char *)"INTEGER", _integer_type},
    {(char *)"InvokeIdsPerforming", (char *)"SET OF", _set_of_type},
    {(char *)"MaxEncodedCmipPduReceiveSize", (char *)"INTEGER", _integer_type},
    {(char *)"ProtocolVersionSupported", (char *)"BIT STRING", _bitstring_type},
    {(char *)"SmaseFunctionalUnits", (char *)"SET OF", _set_of_type},
    {NULL, (char *)"FunctionalUnitPackage", _sequence_type},
    {(char *)"SmUserInfoSent", (char *)"CHOICE", _choice_type},
    {(char *)"nothingSent", (char *)"NULL", _null_type},
    {(char *)"informationSent", (char *)"Character String", _charstring_type},
    {(char *)"SmUserInfoReceived", (char *)"CHOICE", _choice_type},
    {(char *)"nothingReceived", (char *)"NULL", _null_type},
    {(char *)"informationReceived", (char *)"Character String", _charstring_type},
    {(char *)"ROSEInvokeIds", (char *)"CHOICE", _choice_type},
    {(char *)"NoInvokeId", (char *)"CHOICE", _choice_type},
    {(char *)"SMASEUserData", (char *)"SEQUENCE", _sequence_type},
    {(char *)"systemsManagementUserInformation", (char *)"Character String", _charstring_type},
    {(char *)"reason", (char *)"Reason", _integer_type},
    {(char *)"smfuPackages", (char *)"SET OF", _set_of_type},
    {(char *)"AccessDenied-PRIORITY", (char *)"INTEGER", _integer_type},
    {(char *)"ClassInstanceConflict-PRIORITY", (char *)"INTEGER", _integer_type},
    {(char *)"ComplexityLimitation-PRIORITY", (char *)"INTEGER", _integer_type},
    {(char *)"InvalidScope-PRIORITY", (char *)"INTEGER", _integer_type},
    {(char *)"InvalidArgumentValue-PRIORITY", (char *)"INTEGER", _integer_type},
    {(char *)"InvalidFilter-PRIORITY", (char *)"INTEGER", _integer_type},
    {(char *)"NoSuchAction-PRIORITY", (char *)"INTEGER", _integer_type},
    {(char *)"NoSuchArgument-PRIORITY", (char *)"INTEGER", _integer_type},
    {(char *)"NoSuchObjectClass-PRIORITY", (char *)"INTEGER", _integer_type},
    {(char *)"NoSuchObjectInstance-PRIORITY", (char *)"INTEGER", _integer_type},
    {(char *)"ProcessingFailure-PRIORITY", (char *)"INTEGER", _integer_type},
    {(char *)"SyncNotSupported-PRIORITY", (char *)"INTEGER", _integer_type},
    {(char *)"MistypedOperation-PRIORITY", (char *)"INTEGER", _integer_type},
    {(char *)"NoSuchInvokeId-PRIORITY", (char *)"INTEGER", _integer_type},
    {(char *)"DuplicateManagedObjectInstance-PRIORITY", (char *)"INTEGER", _integer_type},
    {(char *)"InvalidAttributeValue-PRIORITY", (char *)"INTEGER", _integer_type},
    {(char *)"InvalidObjectInstance-PRIORITY", (char *)"INTEGER", _integer_type},
    {(char *)"MissingAttributeValue-PARAMETER", (char *)"SET OF", _set_of_type},
    {(char *)"MissingAttributeValue-PRIORITY", (char *)"INTEGER", _integer_type},
    {(char *)"NoSuchAttribute-PRIORITY", (char *)"INTEGER", _integer_type},
    {(char *)"NoSuchReferenceObject-PRIORITY", (char *)"INTEGER", _integer_type},
    {(char *)"NoSuchEventType-PRIORITY", (char *)"INTEGER", _integer_type},
    {(char *)"GetListError-PRIORITY", (char *)"INTEGER", _integer_type},
    {(char *)"OperationCancelled-PRIORITY", (char *)"INTEGER", _integer_type},
    {(char *)"SetListError-PRIORITY", (char *)"INTEGER", _integer_type},
    {(char *)"Acse-RealizationParameter", (char *)"SEQUENCE", _sequence_type},
    {(char *)"Acse-with-concatenation-RealizationParameter", (char *)"SEQUENCE", _sequence_type},
    {(char *)"Association-by-RTSE-RealizationParameter", (char *)"SEQUENCE", _sequence_type},
    {(char *)"PData-RealizationParameter", (char *)"SEQUENCE", _sequence_type},
    {(char *)"PData-with-concatenation-RealizationParameter", (char *)"SEQUENCE", _sequence_type},
    {(char *)"Transfer-by-RTSE-RealizationParameter", (char *)"SEQUENCE", _sequence_type}
};
#endif


static OSS_INT32 const _v167[5] = {
  2, 5, 6, 24, 25
};
static OSS_INT32 const _v173[4] = {
  2, 9, 14, 15
};
static OSS_INT32 const _v177[2] = {0, 1};
static OSS_INT32 const _v176[1] = {INT_MAX};

static struct _enum_data const _enums[] = {
	    { 5, (OSS_INT32 *)_v167 }, { 1, (OSS_INT32 *)_v176 },
	    { 2, (OSS_INT32 *)_v177 },
	    { 2, (OSS_INT32 *)_v167 }, { 1, (OSS_INT32 *)_v176 },
	    { 2, (OSS_INT32 *)_v177 },
	    { 4, (OSS_INT32 *)_v173 }, { 1, (OSS_INT32 *)_v176 },
	    { 1, (OSS_INT32 *)_v167 }, { 1, (OSS_INT32 *)_v176 },
	    { 2, (OSS_INT32 *)_v177 }
};
static const struct st_PER_String_Data _chars[1] = {
    { NULL, 1, 0, UINT_MAX, 0x18788 }
};

#ifdef OSSPRINT
static struct _string_data const _sd1[] = {
    {"noSuchAttribute", 15, 0x02, 5},
    {"accessDenied", 12, 0x02, 2},
    {"invalidAttributeValue", 21, 0x02, 6},
    {"invalidOperation", 16, 0x02, 24},
    {"invalidOperator", 15, 0x02, 25}
};

static struct _string_data const _sd2[] = {
    {"association-service", 19, 0x02, 0},
    {"transfer-service", 16, 0x02, 1}
};

static struct _string_data const _sd3[] = {
    {"accessDenied", 12, 0x02, 2},
    {"noSuchAttribute", 15, 0x02, 5}
};

static struct _string_data const _sd4[] = {
    {"atomic", 6, 0x02, 1},
    {"bestEffort", 10, 0x02, 0}
};

static struct _string_data const _sd5[] = {
    {"noSuchAction", 12, 0x02, 9},
    {"accessDenied", 12, 0x02, 2},
    {"invalidArgumentValue", 20, 0x02, 15},
    {"noSuchArgument", 14, 0x02, 14}
};

static struct _string_data const _sd6[] = {
    {"accessDenied", 12, 0x02, 2}
};

static struct _string_data const _sd7[] = {
    {"cmiseServiceProvider", 20, 0x02, 1},
    {"cmiseServiceUser", 16, 0x02, 0}
};

#endif

#ifdef OSSPRINT
static struct _string_search_data const _ssd[] = {
    {5, INT_MAX, _sd1, NULL},
    {2, 0, _sd2, NULL},
    {2, INT_MAX, _sd3, NULL},
    {2, 0, _sd4, NULL},
    {4, INT_MAX, _sd5, NULL},
    {1, INT_MAX, _sd6, NULL},
    {2, 0, _sd7, NULL}
};
#endif


#define _VARY_OFFSET_0 (int)((char *)&((OSSC::COssBitString *)NULL)->value - (char *)NULL)

static int _cmAttribute(OssGlobal * _g, _Attribute  * _odata, _Attribute  * _cdata);
static int _cmAttributeId(OssGlobal * _g, _ActionTypeId  * _odata, _ActionTypeId  * _cdata);
static int _cmCMISFilter(OssGlobal * _g, _CMISFilter  * _odata, _CMISFilter  * _cdata);
static int _nDCMISFilter(OssGlobal * _g, _CMISFilter  * _odata, _CMISFilter  * _cdata);
static int _cmScope(OssGlobal * _g, _Scope  * _odata, _Scope  * _cdata);
static int _nDScope(OssGlobal * _g, _Scope  * _odata, _Scope  * _cdata);
static int _cm_setof2(OssGlobal * _g, _setof1 * * _odata, _setof1 * * _cdata);
static int _cm_setof1(OssGlobal * _g, _setof1 * * _odata, _setof1 * * _cdata);
static int _cm_seqof1(OssGlobal * _g, _seqof1 * * _odata, _seqof1 * * _cdata);
static int _cmFilterItem(OssGlobal * _g, _FilterItem  * _odata, _FilterItem  * _cdata);

#ifdef OSS_COPY_VALUE
static void _oss_cpy_new_open_type (OssGlobal *_g, int *_pduNum,
		OssBuf *_obuf, OssBuf *_cbuf, void *_odecoded, void **_cdecoded);
#endif /* OSS_COPY_VALUE */

static int _oss_cmp_new_open_type (OssGlobal *_g, int _pduNum1, int _pduNum2,
		OssBuf *_obuf1, OssBuf *_obuf2, void *_decoded1, void *_decoded2);
#if OSS_TOED_API_LEVEL >= 31
void DLL_ENTRY_FDEF _oeSMASE_A_ASSOCIATE_Informatio(OssGlobal * _g, int _pdunum, void * _inbuf)
{
    _oss_toed_api_error(_g, _null_fcn, 0);
    _pdunum = _pdunum;	/* to avoid C-compilation warning */
    _inbuf = _inbuf;	/* to avoid C-compilation warning */
}

void * DLL_ENTRY_FDEF _odSMASE_A_ASSOCIATE_Informatio(OssGlobal * _g, int _pdunum)
{
    _oss_toed_api_error(_g, _null_fcn, 0);
    _pdunum = _pdunum;	/* to avoid C-compilation warning */
    return NULL;
}

#endif
static long _edActionResult(OssGlobal * _g, char ** _out_pos, long * _max_len, _ActionResult * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 0)
	if (_in_data->bit_mask & 0x20000000) {
	    _data_len = _edActionReply(_g, _out_pos, &_out_len, &_in_data->actionReply);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA6);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(1)
	if (_in_data->currentTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->currentTime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->currentTime, -1, 0);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA5 : 0x85);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(2)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _edObjectInstance(_g, _out_pos, &_out_len, &_in_data->managedObjectInstance);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(3)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _edObjectClass(_g, _out_pos, &_out_len, &_in_data->managedObjectClass);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_ActionResult(OssGlobal * _g, _ActionResult * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	unsigned char _pbase[1];
	unsigned char _extPres = 0x00;
	OSS_CNTX_INIT

	_pbase[0] = 0;
	if (_in_data->bit_mask & 0x80000000) {
	    _pbase[0] |= 0x80;
	}
	if (_in_data->bit_mask & 0x40000000) {
	    _pbase[0] |= 0x40;
	}
	if (_in_data->currentTime) {
	    _pbase[0] |= 0x20;
	}
	if (_in_data->bit_mask & 0x20000000) {
	    _pbase[0] |= 0x10;
	}
	_oss_append_1bit_unaligned(_g, _extPres);
	_oss_append_4bit_unaligned(_g, *_pbase);
	OSS_CNTX_PUSH(_oss_c, 3)
	if (_in_data->bit_mask & 0x80000000) {
	    _ep_ObjectClass(_g, &_in_data->managedObjectClass);
	}
	OSS_CNTX_SET(2)
	if (_in_data->bit_mask & 0x40000000) {
	    _ep_ObjectInstance(_g, &_in_data->managedObjectInstance);
	}
	OSS_CNTX_SET(1)
	if (_in_data->currentTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->currentTime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    if(!(_g->encodingFlags & NOCONSTRAIN))
		_oss_check_nullterm_time(_g, _in_data->currentTime, 0);
	    _oss_penc_kmstr(_g, _in_data->currentTime, (unsigned long)strlen(_in_data->currentTime), _chars + 0, 0);
	}
	OSS_CNTX_SET(0)
	if (_in_data->bit_mask & 0x20000000) {
	    _ep_ActionReply(_g, &_in_data->actionReply);
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edAttribute(OssGlobal * _g, char ** _out_pos, long * _max_len, _Attribute * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 4)
	if (_in_data->value.encoded.length == 0)
	    _oss_enc_error(_g, _zero_length_OpenType, 0);
	_data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _in_data->value.encoded.value, _in_data->value.encoded.length);
	_total_len += _data_len;
	OSS_CNTX_SET(5)
	_data_len = _edAttributeId(_g, _out_pos, &_out_len, &_in_data->id);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_Attribute(OssGlobal * _g, _Attribute * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 5)
	_ep_AttributeId(_g, &_in_data->id);
	OSS_CNTX_SET(4)
	if (_in_data->value.encoded.length == 0)
	    _oss_enc_error(_g, _zero_length_OpenType, 0);
	_oss_penc_unconstr_oct_l(_g, _in_data->value.encoded.value, _in_data->value.encoded.length);
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edAttributeId(OssGlobal * _g, char ** _out_pos, long * _max_len, _ActionTypeId * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 6)
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->u.globalForm.value, _in_data->u.globalForm.length, -1);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x80);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 7)
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.localForm, 0x81);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_AttributeId(OssGlobal * _g, _ActionTypeId * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 2) {

	    _oss_penc_nonneg_1int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 6)
	    _oss_penc_eobjid_ia(_g, _in_data->u.globalForm.value, _in_data->u.globalForm.length, -1);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 7)
	    _oss_penc_unconstr_int_l(_g, _in_data->u.localForm);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _edCMISFilter(OssGlobal * _g, char ** _out_pos, long * _max_len, _CMISFilter * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 8)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.item == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edFilterItem(_g, _out_pos, &_out_len, _in_data->u.item);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA8);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 9)
	    _data_len = _ed_setof1(_g, _out_pos, &_out_len, &_in_data->u.CMISFilter_and);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA9);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 10)
	    _data_len = _ed_setof2(_g, _out_pos, &_out_len, &_in_data->u.CMISFilter_or);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xAA);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 11)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.CMISFilter_not == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edCMISFilter(_g, _out_pos, &_out_len, _in_data->u.CMISFilter_not);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xAB);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_CMISFilter(OssGlobal * _g, _CMISFilter * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 4) {

	    _oss_penc_nonneg_2int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 8)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.item == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_FilterItem(_g, _in_data->u.item);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 9)
	    _ep__setof1(_g, &_in_data->u.CMISFilter_and);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 10)
	    _ep__setof2(_g, &_in_data->u.CMISFilter_or);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 11)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.CMISFilter_not == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_CMISFilter(_g, _in_data->u.CMISFilter_not);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _edDeleteResult(OssGlobal * _g, char ** _out_pos, long * _max_len, _DeleteResult * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 1)
	if (_in_data->currentTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->currentTime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->currentTime, -1, 0);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA5 : 0x85);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(2)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _edObjectInstance(_g, _out_pos, &_out_len, &_in_data->managedObjectInstance);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(3)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _edObjectClass(_g, _out_pos, &_out_len, &_in_data->managedObjectClass);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_DeleteResult(OssGlobal * _g, _DeleteResult * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	unsigned char _pbase[1];
	unsigned char _extPres = 0x00;
	OSS_CNTX_INIT

	_pbase[0] = 0;
	if (_in_data->bit_mask & 0x80000000) {
	    _pbase[0] |= 0x80;
	}
	if (_in_data->bit_mask & 0x40000000) {
	    _pbase[0] |= 0x40;
	}
	if (_in_data->currentTime) {
	    _pbase[0] |= 0x20;
	}
	_oss_append_1bit_unaligned(_g, _extPres);
	_oss_append_3bit_unaligned(_g, *_pbase);
	OSS_CNTX_PUSH(_oss_c, 3)
	if (_in_data->bit_mask & 0x80000000) {
	    _ep_ObjectClass(_g, &_in_data->managedObjectClass);
	}
	OSS_CNTX_SET(2)
	if (_in_data->bit_mask & 0x40000000) {
	    _ep_ObjectInstance(_g, &_in_data->managedObjectInstance);
	}
	OSS_CNTX_SET(1)
	if (_in_data->currentTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->currentTime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    if(!(_g->encodingFlags & NOCONSTRAIN))
		_oss_check_nullterm_time(_g, _in_data->currentTime, 0);
	    _oss_penc_kmstr(_g, _in_data->currentTime, (unsigned long)strlen(_in_data->currentTime), _chars + 0, 0);
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edGetListError(OssGlobal * _g, char ** _out_pos, long * _max_len, _GetListError * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 12)
	_data_len = _ed_setof6(_g, _out_pos, &_out_len, &_in_data->getInfoList);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA6);
	_total_len += _data_len;
	OSS_CNTX_SET(1)
	if (_in_data->currentTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->currentTime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->currentTime, -1, 0);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA5 : 0x85);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(2)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _edObjectInstance(_g, _out_pos, &_out_len, &_in_data->managedObjectInstance);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(3)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _edObjectClass(_g, _out_pos, &_out_len, &_in_data->managedObjectClass);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_GetListError(OssGlobal * _g, _GetListError * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	unsigned char _pbase[1];
	unsigned char _extPres = 0x00;
	OSS_CNTX_INIT

	_pbase[0] = 0;
	if (_in_data->bit_mask & 0x80000000) {
	    _pbase[0] |= 0x80;
	}
	if (_in_data->bit_mask & 0x40000000) {
	    _pbase[0] |= 0x40;
	}
	if (_in_data->currentTime) {
	    _pbase[0] |= 0x20;
	}
	_oss_append_1bit_unaligned(_g, _extPres);
	_oss_append_3bit_unaligned(_g, *_pbase);
	OSS_CNTX_PUSH(_oss_c, 3)
	if (_in_data->bit_mask & 0x80000000) {
	    _ep_ObjectClass(_g, &_in_data->managedObjectClass);
	}
	OSS_CNTX_SET(2)
	if (_in_data->bit_mask & 0x40000000) {
	    _ep_ObjectInstance(_g, &_in_data->managedObjectInstance);
	}
	OSS_CNTX_SET(1)
	if (_in_data->currentTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->currentTime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    if(!(_g->encodingFlags & NOCONSTRAIN))
		_oss_check_nullterm_time(_g, _in_data->currentTime, 0);
	    _oss_penc_kmstr(_g, _in_data->currentTime, (unsigned long)strlen(_in_data->currentTime), _chars + 0, 0);
	}
	OSS_CNTX_SET(12)
	_ep__setof6(_g, &_in_data->getInfoList);
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edGetResult(OssGlobal * _g, char ** _out_pos, long * _max_len, _CreateResult * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 13)
	if (_in_data->bit_mask & 0x20000000) {
	    _data_len = _ed_setof7(_g, _out_pos, &_out_len, &_in_data->attributeList);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA6);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(1)
	if (_in_data->currentTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->currentTime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->currentTime, -1, 0);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA5 : 0x85);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(2)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _edObjectInstance(_g, _out_pos, &_out_len, &_in_data->managedObjectInstance);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(3)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _edObjectClass(_g, _out_pos, &_out_len, &_in_data->managedObjectClass);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_GetResult(OssGlobal * _g, _CreateResult * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	unsigned char _pbase[1];
	unsigned char _extPres = 0x00;
	OSS_CNTX_INIT

	_pbase[0] = 0;
	if (_in_data->bit_mask & 0x80000000) {
	    _pbase[0] |= 0x80;
	}
	if (_in_data->bit_mask & 0x40000000) {
	    _pbase[0] |= 0x40;
	}
	if (_in_data->currentTime) {
	    _pbase[0] |= 0x20;
	}
	if (_in_data->bit_mask & 0x20000000) {
	    _pbase[0] |= 0x10;
	}
	_oss_append_1bit_unaligned(_g, _extPres);
	_oss_append_4bit_unaligned(_g, *_pbase);
	OSS_CNTX_PUSH(_oss_c, 3)
	if (_in_data->bit_mask & 0x80000000) {
	    _ep_ObjectClass(_g, &_in_data->managedObjectClass);
	}
	OSS_CNTX_SET(2)
	if (_in_data->bit_mask & 0x40000000) {
	    _ep_ObjectInstance(_g, &_in_data->managedObjectInstance);
	}
	OSS_CNTX_SET(1)
	if (_in_data->currentTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->currentTime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    if(!(_g->encodingFlags & NOCONSTRAIN))
		_oss_check_nullterm_time(_g, _in_data->currentTime, 0);
	    _oss_penc_kmstr(_g, _in_data->currentTime, (unsigned long)strlen(_in_data->currentTime), _chars + 0, 0);
	}
	OSS_CNTX_SET(13)
	if (_in_data->bit_mask & 0x20000000) {
	    _ep__setof7(_g, &_in_data->attributeList);
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edInvalidArgumentValue(OssGlobal * _g, char ** _out_pos, long * _max_len, _InvalidArgumentValue * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 14)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.actionValue == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edActionInfo(_g, _out_pos, &_out_len, _in_data->u.actionValue);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 15)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.eventValue == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 16)
		if (_in_data->u.eventValue->bit_mask & 0x80000000) {
		    if (_in_data->u.eventValue->eventInfo.encoded.length == 0)
			_oss_enc_error(_g, _zero_length_OpenType, 0);
		    _data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _in_data->u.eventValue->eventInfo.encoded.value, _in_data->u.eventValue->eventInfo.encoded.length);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA8);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(17)
		_data_len = _edEventTypeId(_g, _out_pos, &_out_len, &_in_data->u.eventValue->eventType);
		_total_len += _data_len;
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_InvalidArgumentValue(OssGlobal * _g, _InvalidArgumentValue * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 2) {

	    _oss_penc_nonneg_1int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 14)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.actionValue == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_ActionInfo(_g, _in_data->u.actionValue);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 15)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.eventValue == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_oss_append_1bit_unaligned(_g, (unsigned char)(_in_data->u.eventValue->bit_mask >> 24));
		OSS_CNTX_PUSH(_oss_c, 17)
		_ep_EventTypeId(_g, &_in_data->u.eventValue->eventType);
		OSS_CNTX_SET(16)
		if (_in_data->u.eventValue->bit_mask & 0x80000000) {
		    if (_in_data->u.eventValue->eventInfo.encoded.length == 0)
			_oss_enc_error(_g, _zero_length_OpenType, 0);
		    _oss_penc_unconstr_oct_l(_g, _in_data->u.eventValue->eventInfo.encoded.value, _in_data->u.eventValue->eventInfo.encoded.length);
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _edNoSuchArgument(OssGlobal * _g, char ** _out_pos, long * _max_len, _NoSuchArgument * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 18)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.actionId == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 19)
		_data_len = _edActionTypeId(_g, _out_pos, &_out_len, &_in_data->u.actionId->actionType);
		_total_len += _data_len;
		OSS_CNTX_SET(3)
		if (_in_data->u.actionId->bit_mask & 0x80000000) {
		    _data_len = _edObjectClass(_g, _out_pos, &_out_len, &_in_data->u.actionId->managedObjectClass);
		    _total_len += _data_len;
		}
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 20)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.eventId == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 17)
		_data_len = _edEventTypeId(_g, _out_pos, &_out_len, &_in_data->u.eventId->eventType);
		_total_len += _data_len;
		OSS_CNTX_SET(3)
		if (_in_data->u.eventId->bit_mask & 0x80000000) {
		    _data_len = _edObjectClass(_g, _out_pos, &_out_len, &_in_data->u.eventId->managedObjectClass);
		    _total_len += _data_len;
		}
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_NoSuchArgument(OssGlobal * _g, _NoSuchArgument * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 2) {

	    _oss_penc_nonneg_1int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 18)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.actionId == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_oss_append_1bit_unaligned(_g, (unsigned char)(_in_data->u.actionId->bit_mask >> 24));
		OSS_CNTX_PUSH(_oss_c, 3)
		if (_in_data->u.actionId->bit_mask & 0x80000000) {
		    _ep_ObjectClass(_g, &_in_data->u.actionId->managedObjectClass);
		}
		OSS_CNTX_SET(19)
		_ep_ActionTypeId(_g, &_in_data->u.actionId->actionType);
		OSS_CNTX_POP(_oss_c)
	    }
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 20)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.eventId == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_oss_append_1bit_unaligned(_g, (unsigned char)(_in_data->u.eventId->bit_mask >> 24));
		OSS_CNTX_PUSH(_oss_c, 3)
		if (_in_data->u.eventId->bit_mask & 0x80000000) {
		    _ep_ObjectClass(_g, &_in_data->u.eventId->managedObjectClass);
		}
		OSS_CNTX_SET(17)
		_ep_EventTypeId(_g, &_in_data->u.eventId->eventType);
		OSS_CNTX_POP(_oss_c)
	    }
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _edObjectClass(OssGlobal * _g, char ** _out_pos, long * _max_len, _ActionTypeId * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 6)
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->u.globalForm.value, _in_data->u.globalForm.length, -1);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x80);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 7)
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.localForm, 0x81);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_ObjectClass(OssGlobal * _g, _ActionTypeId * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 2) {

	    _oss_penc_nonneg_1int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 6)
	    _oss_penc_eobjid_ia(_g, _in_data->u.globalForm.value, _in_data->u.globalForm.length, -1);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 7)
	    _oss_penc_unconstr_int_l(_g, _in_data->u.localForm);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _edObjectInstance(OssGlobal * _g, char ** _out_pos, long * _max_len, _ObjectInstance * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 21)
	    _data_len = _edRDNSequence(_g, _out_pos, &_out_len, &_in_data->u.distinguishedName);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 22)
	    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->u.nonSpecificForm.value, _in_data->u.nonSpecificForm.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA3 : 0x83);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 23)
	    _data_len = _edRDNSequence(_g, _out_pos, &_out_len, &_in_data->u.localDistinguishedName);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA4);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_ObjectInstance(OssGlobal * _g, _ObjectInstance * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 3) {

	    _oss_penc_nonneg_2int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 21)
	    _ep_RDNSequence(_g, &_in_data->u.distinguishedName);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 22)
#if OSS_TOED_API_LEVEL >= 27
	    _oss_penc_uncon_oct(_g, (unsigned char *)_in_data->u.nonSpecificForm.value, _in_data->u.nonSpecificForm.length);
#else
	    _oss_penc_unconstr_oct_l(_g, (unsigned char *)_in_data->u.nonSpecificForm.value, _in_data->u.nonSpecificForm.length);
#endif
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 23)
	    _ep_RDNSequence(_g, &_in_data->u.localDistinguishedName);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _edProcessingFailure(OssGlobal * _g, char ** _out_pos, long * _max_len, _ProcessingFailure * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 24)
	{
	    long _total_len = 0;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 25)
	    if (_in_data->specificErrorInfo.errorInfo.encoded.length == 0)
		_oss_enc_error(_g, _zero_length_OpenType, 0);
	    _data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _in_data->specificErrorInfo.errorInfo.encoded.value, _in_data->specificErrorInfo.errorInfo.encoded.length);
	    _total_len += _data_len;
	    OSS_CNTX_SET(26)
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->specificErrorInfo.errorId.value, _in_data->specificErrorInfo.errorId.length, -1);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	    _total_len += _data_len;
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA5);
	_total_len += _data_len;
	OSS_CNTX_SET(2)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _edObjectInstance(_g, _out_pos, &_out_len, &_in_data->managedObjectInstance);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(3)
	_data_len = _edObjectClass(_g, _out_pos, &_out_len, &_in_data->managedObjectClass);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_ProcessingFailure(OssGlobal * _g, _ProcessingFailure * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	unsigned char _extPres = 0x00;
	OSS_CNTX_INIT

	_oss_append_1bit_unaligned(_g, _extPres);
	_oss_append_1bit_unaligned(_g, (unsigned char)(_in_data->bit_mask >> 24));
	OSS_CNTX_PUSH(_oss_c, 3)
	_ep_ObjectClass(_g, &_in_data->managedObjectClass);
	OSS_CNTX_SET(2)
	if (_in_data->bit_mask & 0x80000000) {
	    _ep_ObjectInstance(_g, &_in_data->managedObjectInstance);
	}
	OSS_CNTX_SET(24)
	{
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 26)
	    _oss_penc_eobjid_ia(_g, _in_data->specificErrorInfo.errorId.value, _in_data->specificErrorInfo.errorId.length, -1);
	    OSS_CNTX_SET(25)
	    if (_in_data->specificErrorInfo.errorInfo.encoded.length == 0)
		_oss_enc_error(_g, _zero_length_OpenType, 0);
	    _oss_penc_unconstr_oct_l(_g, _in_data->specificErrorInfo.errorInfo.encoded.value, _in_data->specificErrorInfo.errorInfo.encoded.length);
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edScope(OssGlobal * _g, char ** _out_pos, long * _max_len, _Scope * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 27)
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.namedNumbers, 0x2);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 28)
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.individualLevels, 0x81);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 29)
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.baseToNthLevel, 0x82);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_Scope(OssGlobal * _g, _Scope * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 3) {

	    _oss_penc_nonneg_2int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 27)
	    _oss_penc_unconstr_int_l(_g, _in_data->u.namedNumbers);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 28)
	    _oss_penc_unconstr_int_l(_g, _in_data->u.individualLevels);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 29)
	    _oss_penc_unconstr_int_l(_g, _in_data->u.baseToNthLevel);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _edSetListError(OssGlobal * _g, char ** _out_pos, long * _max_len, _SetListError * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 30)
	{
	    _setof9 * _temp;
	    unsigned long count;
	    unsigned long _lindex;
	    long _total_len = 0;
	    OSS_UINT32 _sp;
	    void **_st = _oss_load_enc_stack(_g, &_sp);
	    OSS_CNTX_NEW(_oss_c, 31)
	    for (_temp = _in_data->setInfoList, count = 0; _temp; _temp = _temp->next) {
		OSS_CNTX_SETOCC(count + 1)
		if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		_st[_sp++] = _temp;
		count++;
	    }
	    if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
	    for (_lindex = 0; _lindex < count; _lindex++) {
		OSS_CNTX_SETOCC(count - _lindex)
		_temp = (_setof9 *)_st[--_sp];
		if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		if (count > 1) _oss_nextItem(_g, &_out_len);
		_oss_save_enc_stack(_g, _sp);
		{
		    OSS_CNTX_INIT

		    switch (_temp->value.choice) {
		    case 1:
			OSS_CNTX_PUSH(_oss_c, 32)
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_temp->value.u.attributeError == NULL)
			    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
			{
			    long _total_len = 0;
			    OSS_CNTX_INIT

			    OSS_CNTX_PUSH(_oss_c, 33)
			    if (_temp->value.u.attributeError->bit_mask & 0x40000000) {
				if (_temp->value.u.attributeError->attributeValue.encoded.length == 0)
				    _oss_enc_error(_g, _zero_length_OpenType, 0);
				_data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _temp->value.u.attributeError->attributeValue.encoded.value, _temp->value.u.attributeError->attributeValue.encoded.length);
				_total_len += _data_len;
			    }
			    OSS_CNTX_SET(34)
			    _data_len = _edAttributeId(_g, _out_pos, &_out_len, &_temp->value.u.attributeError->attributeId);
			    _total_len += _data_len;
			    OSS_CNTX_SET(35)
			    if (_temp->value.u.attributeError->bit_mask & 0x80000000) {
				_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _temp->value.u.attributeError->modifyOperator, 0x82);
				_total_len += _data_len;
			    }
			    OSS_CNTX_SET(36)
			    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, (int)_temp->value.u.attributeError->errorStatus, 0xA);
			    _total_len += _data_len;
			    OSS_CNTX_POP(_oss_c)
			    _data_len = _total_len;
			}
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
			break;
		    case 2:
			OSS_CNTX_PUSH(_oss_c, 37)
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_temp->value.u.attribute == NULL)
			    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
			_data_len = _edAttribute(_g, _out_pos, &_out_len, _temp->value.u.attribute);
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
			break;
		    default:
			_oss_enc_error(_g, _bad_choice, _temp->value.choice);	/* Bad choice selector. */
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		_st = _oss_load_enc_stack(_g, &_sp);
		_total_len += _data_len;
	    }
	    if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA6);
	_total_len += _data_len;
	OSS_CNTX_SET(1)
	if (_in_data->currentTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->currentTime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->currentTime, -1, 0);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA5 : 0x85);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(2)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _edObjectInstance(_g, _out_pos, &_out_len, &_in_data->managedObjectInstance);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(3)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _edObjectClass(_g, _out_pos, &_out_len, &_in_data->managedObjectClass);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_SetListError(OssGlobal * _g, _SetListError * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	unsigned char _pbase[1];
	unsigned char _extPres = 0x00;
	OSS_CNTX_INIT

	_pbase[0] = 0;
	if (_in_data->bit_mask & 0x80000000) {
	    _pbase[0] |= 0x80;
	}
	if (_in_data->bit_mask & 0x40000000) {
	    _pbase[0] |= 0x40;
	}
	if (_in_data->currentTime) {
	    _pbase[0] |= 0x20;
	}
	_oss_append_1bit_unaligned(_g, _extPres);
	_oss_append_3bit_unaligned(_g, *_pbase);
	OSS_CNTX_PUSH(_oss_c, 3)
	if (_in_data->bit_mask & 0x80000000) {
	    _ep_ObjectClass(_g, &_in_data->managedObjectClass);
	}
	OSS_CNTX_SET(2)
	if (_in_data->bit_mask & 0x40000000) {
	    _ep_ObjectInstance(_g, &_in_data->managedObjectInstance);
	}
	OSS_CNTX_SET(1)
	if (_in_data->currentTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->currentTime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    if(!(_g->encodingFlags & NOCONSTRAIN))
		_oss_check_nullterm_time(_g, _in_data->currentTime, 0);
	    _oss_penc_kmstr(_g, _in_data->currentTime, (unsigned long)strlen(_in_data->currentTime), _chars + 0, 0);
	}
	OSS_CNTX_SET(30)
	{
	    _setof9 * _temp;
	    unsigned int _fragm_cnt;
	    unsigned int _cnt;
	    int _ext;
	    OSS_CNTX_INIT

	    for (_cnt = 0, _temp = _in_data->setInfoList; _temp; _temp = _temp->next)
		++_cnt;

	    OSS_CNTX_PUSH(_oss_c, 31)
	    _ext = (_cnt >= 16384) ? 2 : 0;
	    for (_temp = _in_data->setInfoList;; _cnt -= _fragm_cnt) {
		unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
		_fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		_fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
		for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		    OSS_CNTX_INCOCC
		    {
			OSS_CNTX_INIT

			if (_temp->value.choice <= 2) {

			    _oss_penc_nonneg_1int(_g, _temp->value.choice - 1);
			}
			switch (_temp->value.choice) {
			case 1:
			    OSS_CNTX_PUSH(_oss_c, 32)
#ifndef OSS_DO_NOT_CHECK_POINTERS
			    if (_temp->value.u.attributeError == NULL)
				_oss_enc_error(_g, _bad_pointer, 0L);
#endif
			    {
				OSS_CNTX_INIT

				_oss_append_2bit_unaligned(_g, (unsigned char)(_temp->value.u.attributeError->bit_mask >> 24));
				OSS_CNTX_PUSH(_oss_c, 36)
				_oss_penc_enum(_g, _temp->value.u.attributeError->errorStatus, (struct _enum_data *)&_enums[0], (struct _enum_data *)&_enums[1]);
				OSS_CNTX_SET(35)
				if (_temp->value.u.attributeError->bit_mask & 0x80000000) {
				    _oss_penc_unconstr_int_l(_g, _temp->value.u.attributeError->modifyOperator);
				}
				OSS_CNTX_SET(34)
				_ep_AttributeId(_g, &_temp->value.u.attributeError->attributeId);
				OSS_CNTX_SET(33)
				if (_temp->value.u.attributeError->bit_mask & 0x40000000) {
				    if (_temp->value.u.attributeError->attributeValue.encoded.length == 0)
					_oss_enc_error(_g, _zero_length_OpenType, 0);
				    _oss_penc_unconstr_oct_l(_g, _temp->value.u.attributeError->attributeValue.encoded.value, _temp->value.u.attributeError->attributeValue.encoded.length);
				}
				OSS_CNTX_POP(_oss_c)
			    }
			    break;
			case 2:
			    OSS_CNTX_PUSH(_oss_c, 37)
#ifndef OSS_DO_NOT_CHECK_POINTERS
			    if (_temp->value.u.attribute == NULL)
				_oss_enc_error(_g, _bad_pointer, 0L);
#endif
			    _ep_Attribute(_g, _temp->value.u.attribute);
			    break;
			default:
			    _oss_enc_error(_g, _bad_choice, _temp->value.choice);	/* Bad choice selector. */
			}
			OSS_CNTX_POP(_oss_c)
		    }

		}
		if (_cnt == _fragm_cnt) {
		    if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
			_oss_append_8bit_aligned(_g, 0);
		    break;
		}
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edSetResult(OssGlobal * _g, char ** _out_pos, long * _max_len, _CreateResult * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 13)
	if (_in_data->bit_mask & 0x20000000) {
	    {
		_setof3 * _temp;
		unsigned long count;
		unsigned long _lindex;
		long _total_len = 0;
		OSS_UINT32 _sp;
		void **_st = _oss_load_enc_stack(_g, &_sp);
		OSS_CNTX_NEW(_oss_c, 38)
		for (_temp = _in_data->attributeList, count = 0; _temp; _temp = _temp->next) {
		    OSS_CNTX_SETOCC(count + 1)
		    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		    _st[_sp++] = _temp;
		    count++;
		}
		if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
		for (_lindex = 0; _lindex < count; _lindex++) {
		    OSS_CNTX_SETOCC(count - _lindex)
		    _temp = (_setof3 *)_st[--_sp];
		    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		    if (count > 1) _oss_nextItem(_g, &_out_len);
		    _oss_save_enc_stack(_g, _sp);
		    _data_len = _edAttribute(_g, _out_pos, &_out_len, &_temp->value);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
		    _st = _oss_load_enc_stack(_g, &_sp);
		    _total_len += _data_len;
		}
		if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA6);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(1)
	if (_in_data->currentTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->currentTime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->currentTime, -1, 0);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA5 : 0x85);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(2)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _edObjectInstance(_g, _out_pos, &_out_len, &_in_data->managedObjectInstance);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(3)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _edObjectClass(_g, _out_pos, &_out_len, &_in_data->managedObjectClass);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_SetResult(OssGlobal * _g, _CreateResult * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	unsigned char _pbase[1];
	unsigned char _extPres = 0x00;
	OSS_CNTX_INIT

	_pbase[0] = 0;
	if (_in_data->bit_mask & 0x80000000) {
	    _pbase[0] |= 0x80;
	}
	if (_in_data->bit_mask & 0x40000000) {
	    _pbase[0] |= 0x40;
	}
	if (_in_data->currentTime) {
	    _pbase[0] |= 0x20;
	}
	if (_in_data->bit_mask & 0x20000000) {
	    _pbase[0] |= 0x10;
	}
	_oss_append_1bit_unaligned(_g, _extPres);
	_oss_append_4bit_unaligned(_g, *_pbase);
	OSS_CNTX_PUSH(_oss_c, 3)
	if (_in_data->bit_mask & 0x80000000) {
	    _ep_ObjectClass(_g, &_in_data->managedObjectClass);
	}
	OSS_CNTX_SET(2)
	if (_in_data->bit_mask & 0x40000000) {
	    _ep_ObjectInstance(_g, &_in_data->managedObjectInstance);
	}
	OSS_CNTX_SET(1)
	if (_in_data->currentTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->currentTime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    if(!(_g->encodingFlags & NOCONSTRAIN))
		_oss_check_nullterm_time(_g, _in_data->currentTime, 0);
	    _oss_penc_kmstr(_g, _in_data->currentTime, (unsigned long)strlen(_in_data->currentTime), _chars + 0, 0);
	}
	OSS_CNTX_SET(13)
	if (_in_data->bit_mask & 0x20000000) {
	    {
		_setof3 * _temp;
		unsigned int _fragm_cnt;
		unsigned int _cnt;
		int _ext;
		OSS_CNTX_INIT

		for (_cnt = 0, _temp = _in_data->attributeList; _temp; _temp = _temp->next)
		    ++_cnt;

		OSS_CNTX_PUSH(_oss_c, 38)
		_ext = (_cnt >= 16384) ? 2 : 0;
		for (_temp = _in_data->attributeList;; _cnt -= _fragm_cnt) {
		    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
		    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
		    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
			OSS_CNTX_INCOCC
			_ep_Attribute(_g, &_temp->value);
		    }
		    if (_cnt == _fragm_cnt) {
			if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
			    _oss_append_8bit_aligned(_g, 0);
			break;
		    }
		}
		OSS_CNTX_POP(_oss_c)
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _ed_choice1(OssGlobal * _g, char ** _out_pos, long * _max_len, _choice1 * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 39)
	    _data_len = _oss_encd_opentype(_g, _out_pos, &_out_len, &_in_data->u.single_ASN1_type);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 40)
	    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->u.octet_aligned.value, _in_data->u.octet_aligned.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA1 : 0x81);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 41)
	    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->u.arbitrary.value, _in_data->u.arbitrary.length, -1, FALSE);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA2 : 0x82);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep__choice1(OssGlobal * _g, _choice1 * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 3) {

	    _oss_penc_nonneg_2int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 39)
	    _oss_penc_opentype(_g, &_in_data->u.single_ASN1_type);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 40)
#if OSS_TOED_API_LEVEL >= 27
	    _oss_penc_uncon_oct(_g, (unsigned char *)_in_data->u.octet_aligned.value, _in_data->u.octet_aligned.length);
#else
	    _oss_penc_unconstr_oct_l(_g, (unsigned char *)_in_data->u.octet_aligned.value, _in_data->u.octet_aligned.length);
#endif
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 41)
#if OSS_TOED_API_LEVEL >= 27
	    _oss_penc_uncon_bit(_g, _in_data->u.arbitrary.value, _in_data->u.arbitrary.length);
#else
	    _oss_penc_unconstr_bit_l(_g, _in_data->u.arbitrary.value, _in_data->u.arbitrary.length, FALSE);
#endif
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _edExternal(OssGlobal * _g, char ** _out_pos, long * _max_len, _External * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 42)
	_data_len = _ed_choice1(_g, _out_pos, &_out_len, &_in_data->encoding);
	_total_len += _data_len;
	OSS_CNTX_SET(43)
	if (_in_data->bit_mask & 0x20000000) {
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->data_value_descriptor.value, _in_data->data_value_descriptor.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x27 : 0x7);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(44)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->indirect_reference, 0x2);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(45)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->direct_reference.value, _in_data->direct_reference.length, -1);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_External(OssGlobal * _g, _External * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	_oss_append_3bit_unaligned(_g, (unsigned char)(_in_data->bit_mask >> 24));
	OSS_CNTX_PUSH(_oss_c, 45)
	if (_in_data->bit_mask & 0x80000000) {
	    _oss_penc_eobjid_ia(_g, _in_data->direct_reference.value, _in_data->direct_reference.length, -1);
	}
	OSS_CNTX_SET(44)
	if (_in_data->bit_mask & 0x40000000) {
	    _oss_penc_unconstr_int_l(_g, _in_data->indirect_reference);
	}
	OSS_CNTX_SET(43)
	if (_in_data->bit_mask & 0x20000000) {
	    _oss_penc_nkmstr_l(_g, _in_data->data_value_descriptor.value, _in_data->data_value_descriptor.length);
	}
	OSS_CNTX_SET(42)
	_ep__choice1(_g, &_in_data->encoding);
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edActionTypeId(OssGlobal * _g, char ** _out_pos, long * _max_len, _ActionTypeId * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 6)
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->u.globalForm.value, _in_data->u.globalForm.length, -1);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x82);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 7)
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.localForm, 0x83);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_ActionTypeId(OssGlobal * _g, _ActionTypeId * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 2) {

	    _oss_penc_nonneg_1int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 6)
	    _oss_penc_eobjid_ia(_g, _in_data->u.globalForm.value, _in_data->u.globalForm.length, -1);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 7)
	    _oss_penc_unconstr_int_l(_g, _in_data->u.localForm);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _edEventTypeId(OssGlobal * _g, char ** _out_pos, long * _max_len, _ActionTypeId * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 6)
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->u.globalForm.value, _in_data->u.globalForm.length, -1);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x86);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 7)
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.localForm, 0x87);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_EventTypeId(OssGlobal * _g, _ActionTypeId * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 2) {

	    _oss_penc_nonneg_1int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 6)
	    _oss_penc_eobjid_ia(_g, _in_data->u.globalForm.value, _in_data->u.globalForm.length, -1);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 7)
	    _oss_penc_unconstr_int_l(_g, _in_data->u.localForm);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _ed_setof2(OssGlobal * _g, char ** _out_pos, long * _max_len, _setof1 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_setof1 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 46)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_setof1 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    if (count > 1) _oss_nextItem(_g, &_out_len);
	    _oss_save_enc_stack(_g, _sp);
	    _data_len = _edCMISFilter(_g, _out_pos, &_out_len, &_temp->value);
	    _st = _oss_load_enc_stack(_g, &_sp);
	    _total_len += _data_len;
	}
	if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep__setof2(OssGlobal * _g, _setof1 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	_setof1 * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	OSS_CNTX_PUSH(_oss_c, 46)
	_ext = (_cnt >= 16384) ? 2 : 0;
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
	    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
	    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		_ep_CMISFilter(_g, &_temp->value);
	    }
	    if (_cnt == _fragm_cnt) {
		if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
		    _oss_append_8bit_aligned(_g, 0);
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _ed_setof1(OssGlobal * _g, char ** _out_pos, long * _max_len, _setof1 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_setof1 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 46)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_setof1 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    if (count > 1) _oss_nextItem(_g, &_out_len);
	    _oss_save_enc_stack(_g, _sp);
	    _data_len = _edCMISFilter(_g, _out_pos, &_out_len, &_temp->value);
	    _st = _oss_load_enc_stack(_g, &_sp);
	    _total_len += _data_len;
	}
	if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep__setof1(OssGlobal * _g, _setof1 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	_setof1 * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	OSS_CNTX_PUSH(_oss_c, 46)
	_ext = (_cnt >= 16384) ? 2 : 0;
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
	    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
	    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		_ep_CMISFilter(_g, &_temp->value);
	    }
	    if (_cnt == _fragm_cnt) {
		if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
		    _oss_append_8bit_aligned(_g, 0);
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edRealizationParameter(OssGlobal * _g, char ** _out_pos, long * _max_len, _RealizationParameter * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 47)
	if (_in_data->bit_mask & 0x80000000 &&
	    _oss_not_dflt_ia(_g, &_in_data->concatenation, (ossBoolean  *)&__shared8::default_concatenation, sizeof(ossBoolean ), 0, -1, 8)) {
	    _data_len = _oss_encd_bool_tl(_g, _out_pos, &_out_len, 0x1, _in_data->concatenation);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(48)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->realization_type, 0xA);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_RealizationParameter(OssGlobal * _g, _RealizationParameter * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_UINT32 _bitmask = _in_data->bit_mask;
	OSS_CNTX_INIT

#ifdef OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES
	if (_g->encodingFlags & STRICT_PER_ENCODING_OF_DEFAULT_VALUES) {
	    if ((_bitmask & 0x80000000) &&
		!_oss_not_dflt_ia(_g, &_in_data->concatenation, (ossBoolean  *)&__shared8::default_concatenation, sizeof(ossBoolean ), 0, -1, 8))
		_bitmask ^= 0x80000000;
	}
#endif /* OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES */
	_oss_append_1bit_unaligned(_g, (unsigned char)(_bitmask >> 24));
	OSS_CNTX_PUSH(_oss_c, 48)
	_oss_penc_uenum(_g, _in_data->realization_type, (struct _enum_data *)&_enums[2], NULL);
	OSS_CNTX_SET(47)
	if (_bitmask & 0x80000000) {
	    _oss_append_1bit_unaligned(_g, (unsigned char)((_in_data->concatenation) ? 0x80 : 0x00) );
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edActionInfo(OssGlobal * _g, char ** _out_pos, long * _max_len, _ActionInfo * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 49)
	if (_in_data->bit_mask & 0x80000000) {
	    if (_in_data->actionInfoArg.encoded.length == 0)
		_oss_enc_error(_g, _zero_length_OpenType, 0);
	    _data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _in_data->actionInfoArg.encoded.value, _in_data->actionInfoArg.encoded.length);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA4);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(19)
	_data_len = _edActionTypeId(_g, _out_pos, &_out_len, &_in_data->actionType);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_ActionInfo(OssGlobal * _g, _ActionInfo * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	_oss_append_1bit_unaligned(_g, (unsigned char)(_in_data->bit_mask >> 24));
	OSS_CNTX_PUSH(_oss_c, 19)
	_ep_ActionTypeId(_g, &_in_data->actionType);
	OSS_CNTX_SET(49)
	if (_in_data->bit_mask & 0x80000000) {
	    if (_in_data->actionInfoArg.encoded.length == 0)
		_oss_enc_error(_g, _zero_length_OpenType, 0);
	    _oss_penc_unconstr_oct_l(_g, _in_data->actionInfoArg.encoded.value, _in_data->actionInfoArg.encoded.length);
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edActionReply(OssGlobal * _g, char ** _out_pos, long * _max_len, _ActionReply * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 50)
	if (_in_data->actionReplyInfo.encoded.length == 0)
	    _oss_enc_error(_g, _zero_length_OpenType, 0);
	_data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _in_data->actionReplyInfo.encoded.value, _in_data->actionReplyInfo.encoded.length);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA4);
	_total_len += _data_len;
	OSS_CNTX_SET(19)
	_data_len = _edActionTypeId(_g, _out_pos, &_out_len, &_in_data->actionType);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_ActionReply(OssGlobal * _g, _ActionReply * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 19)
	_ep_ActionTypeId(_g, &_in_data->actionType);
	OSS_CNTX_SET(50)
	if (_in_data->actionReplyInfo.encoded.length == 0)
	    _oss_enc_error(_g, _zero_length_OpenType, 0);
	_oss_penc_unconstr_oct_l(_g, _in_data->actionReplyInfo.encoded.value, _in_data->actionReplyInfo.encoded.length);
	OSS_CNTX_POP(_oss_c)
    }
}

static long _ed_seqof1(OssGlobal * _g, char ** _out_pos, long * _max_len, _seqof1 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_seqof1 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 51)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_seqof1 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _oss_save_enc_stack(_g, _sp);
	    {
		OSS_CNTX_INIT

		switch (_temp->value.choice) {
		case 1:
		    OSS_CNTX_PUSH(_oss_c, 52)
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_temp->value.u.initialString == NULL)
			_oss_enc_error(_g, _bad_pointer, 0L);
#endif
		    _data_len = _edAttribute(_g, _out_pos, &_out_len, _temp->value.u.initialString);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
		    break;
		case 2:
		    OSS_CNTX_PUSH(_oss_c, 53)
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_temp->value.u.anyString == NULL)
			_oss_enc_error(_g, _bad_pointer, 0L);
#endif
		    _data_len = _edAttribute(_g, _out_pos, &_out_len, _temp->value.u.anyString);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
		    break;
		case 3:
		    OSS_CNTX_PUSH(_oss_c, 54)
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_temp->value.u.finalString == NULL)
			_oss_enc_error(_g, _bad_pointer, 0L);
#endif
		    _data_len = _edAttribute(_g, _out_pos, &_out_len, _temp->value.u.finalString);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
		    break;
		default:
		    _oss_enc_error(_g, _bad_choice, _temp->value.choice);	/* Bad choice selector. */
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    _st = _oss_load_enc_stack(_g, &_sp);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep__seqof1(OssGlobal * _g, _seqof1 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	_seqof1 * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	OSS_CNTX_PUSH(_oss_c, 51)
	_ext = (_cnt >= 16384) ? 2 : 0;
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
	    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
	    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		{
		    OSS_CNTX_INIT

		    if (_temp->value.choice <= 3) {

			_oss_penc_nonneg_2int(_g, _temp->value.choice - 1);
		    }
		    switch (_temp->value.choice) {
		    case 1:
			OSS_CNTX_PUSH(_oss_c, 52)
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_temp->value.u.initialString == NULL)
			    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
			_ep_Attribute(_g, _temp->value.u.initialString);
			break;
		    case 2:
			OSS_CNTX_PUSH(_oss_c, 53)
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_temp->value.u.anyString == NULL)
			    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
			_ep_Attribute(_g, _temp->value.u.anyString);
			break;
		    case 3:
			OSS_CNTX_PUSH(_oss_c, 54)
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_temp->value.u.finalString == NULL)
			    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
			_ep_Attribute(_g, _temp->value.u.finalString);
			break;
		    default:
			_oss_enc_error(_g, _bad_choice, _temp->value.choice);	/* Bad choice selector. */
		    }
		    OSS_CNTX_POP(_oss_c)
		}

	    }
	    if (_cnt == _fragm_cnt) {
		if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
		    _oss_append_8bit_aligned(_g, 0);
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edFilterItem(OssGlobal * _g, char ** _out_pos, long * _max_len, _FilterItem * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 55)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.equality == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edAttribute(_g, _out_pos, &_out_len, _in_data->u.equality);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 56)
	    _data_len = _ed_seqof1(_g, _out_pos, &_out_len, &_in_data->u.substrings);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 57)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.greaterOrEqual == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edAttribute(_g, _out_pos, &_out_len, _in_data->u.greaterOrEqual);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 58)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.lessOrEqual == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edAttribute(_g, _out_pos, &_out_len, _in_data->u.lessOrEqual);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA3);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 59)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.present == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edAttributeId(_g, _out_pos, &_out_len, _in_data->u.present);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA4);
	    break;
	case 6:
	    OSS_CNTX_PUSH(_oss_c, 60)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.subsetOf == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edAttribute(_g, _out_pos, &_out_len, _in_data->u.subsetOf);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA5);
	    break;
	case 7:
	    OSS_CNTX_PUSH(_oss_c, 61)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.supersetOf == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edAttribute(_g, _out_pos, &_out_len, _in_data->u.supersetOf);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA6);
	    break;
	case 8:
	    OSS_CNTX_PUSH(_oss_c, 62)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.nonNullSetIntersection == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edAttribute(_g, _out_pos, &_out_len, _in_data->u.nonNullSetIntersection);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA7);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_FilterItem(OssGlobal * _g, _FilterItem * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 8) {

	    _oss_penc_nonneg_3int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 55)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.equality == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_Attribute(_g, _in_data->u.equality);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 56)
	    _ep__seqof1(_g, &_in_data->u.substrings);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 57)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.greaterOrEqual == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_Attribute(_g, _in_data->u.greaterOrEqual);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 58)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.lessOrEqual == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_Attribute(_g, _in_data->u.lessOrEqual);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 59)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.present == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_AttributeId(_g, _in_data->u.present);
	    break;
	case 6:
	    OSS_CNTX_PUSH(_oss_c, 60)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.subsetOf == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_Attribute(_g, _in_data->u.subsetOf);
	    break;
	case 7:
	    OSS_CNTX_PUSH(_oss_c, 61)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.supersetOf == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_Attribute(_g, _in_data->u.supersetOf);
	    break;
	case 8:
	    OSS_CNTX_PUSH(_oss_c, 62)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.nonNullSetIntersection == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_Attribute(_g, _in_data->u.nonNullSetIntersection);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _ed_setof6(OssGlobal * _g, char ** _out_pos, long * _max_len, _setof6 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_setof6 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 63)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_setof6 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    if (count > 1) _oss_nextItem(_g, &_out_len);
	    _oss_save_enc_stack(_g, _sp);
	    {
		OSS_CNTX_INIT

		switch (_temp->value.choice) {
		case 1:
		    OSS_CNTX_PUSH(_oss_c, 64)
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_temp->value.u.attributeIdError == NULL)
			_oss_enc_error(_g, _bad_pointer, 0L);
#endif
		    {
			long _total_len = 0;
			OSS_CNTX_INIT

			OSS_CNTX_PUSH(_oss_c, 34)
			_data_len = _edAttributeId(_g, _out_pos, &_out_len, &_temp->value.u.attributeIdError->attributeId);
			_total_len += _data_len;
			OSS_CNTX_SET(36)
			_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, (int)_temp->value.u.attributeIdError->errorStatus, 0xA);
			_total_len += _data_len;
			OSS_CNTX_POP(_oss_c)
			_data_len = _total_len;
		    }
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
		    break;
		case 2:
		    OSS_CNTX_PUSH(_oss_c, 37)
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_temp->value.u.attribute == NULL)
			_oss_enc_error(_g, _bad_pointer, 0L);
#endif
		    _data_len = _edAttribute(_g, _out_pos, &_out_len, _temp->value.u.attribute);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
		    break;
		default:
		    _oss_enc_error(_g, _bad_choice, _temp->value.choice);	/* Bad choice selector. */
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    _st = _oss_load_enc_stack(_g, &_sp);
	    _total_len += _data_len;
	}
	if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep__setof6(OssGlobal * _g, _setof6 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	_setof6 * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	OSS_CNTX_PUSH(_oss_c, 63)
	_ext = (_cnt >= 16384) ? 2 : 0;
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
	    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
	    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		{
		    OSS_CNTX_INIT

		    if (_temp->value.choice <= 2) {

			_oss_penc_nonneg_1int(_g, _temp->value.choice - 1);
		    }
		    switch (_temp->value.choice) {
		    case 1:
			OSS_CNTX_PUSH(_oss_c, 64)
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_temp->value.u.attributeIdError == NULL)
			    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
			{
			    unsigned char _extPres = 0x00;
			    OSS_CNTX_INIT

			    _oss_append_1bit_unaligned(_g, _extPres);
			    OSS_CNTX_PUSH(_oss_c, 36)
			    _oss_penc_enum(_g, _temp->value.u.attributeIdError->errorStatus, (struct _enum_data *)&_enums[3], (struct _enum_data *)&_enums[4]);
			    OSS_CNTX_SET(34)
			    _ep_AttributeId(_g, &_temp->value.u.attributeIdError->attributeId);
			    OSS_CNTX_POP(_oss_c)
			}
			break;
		    case 2:
			OSS_CNTX_PUSH(_oss_c, 37)
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_temp->value.u.attribute == NULL)
			    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
			_ep_Attribute(_g, _temp->value.u.attribute);
			break;
		    default:
			_oss_enc_error(_g, _bad_choice, _temp->value.choice);	/* Bad choice selector. */
		    }
		    OSS_CNTX_POP(_oss_c)
		}

	    }
	    if (_cnt == _fragm_cnt) {
		if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
		    _oss_append_8bit_aligned(_g, 0);
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _ed_setof7(OssGlobal * _g, char ** _out_pos, long * _max_len, _setof3 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_setof3 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 38)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_setof3 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    if (count > 1) _oss_nextItem(_g, &_out_len);
	    _oss_save_enc_stack(_g, _sp);
	    _data_len = _edAttribute(_g, _out_pos, &_out_len, &_temp->value);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _st = _oss_load_enc_stack(_g, &_sp);
	    _total_len += _data_len;
	}
	if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep__setof7(OssGlobal * _g, _setof3 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	_setof3 * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	OSS_CNTX_PUSH(_oss_c, 38)
	_ext = (_cnt >= 16384) ? 2 : 0;
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
	    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
	    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		_ep_Attribute(_g, &_temp->value);
	    }
	    if (_cnt == _fragm_cnt) {
		if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
		    _oss_append_8bit_aligned(_g, 0);
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edInvokeId(OssGlobal * _g, char ** _out_pos, long * _max_len, _InvokeId * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 65)
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.present, 0x2);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 66)
	    _data_len = 0;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x5);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_InvokeId(OssGlobal * _g, _InvokeId * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 2) {

	    _oss_penc_nonneg_1int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 65)
	    _oss_penc_unconstr_int_l(_g, _in_data->u.present);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 66)
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _edRDNSequence(OssGlobal * _g, char ** _out_pos, long * _max_len, _RDNSequence ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_RDNSequence * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 67)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_RDNSequence *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _oss_save_enc_stack(_g, _sp);
	    _data_len = _edRelativeDistinguishedName(_g, _out_pos, &_out_len, &_temp->value);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
	    _st = _oss_load_enc_stack(_g, &_sp);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_RDNSequence(OssGlobal * _g, _RDNSequence ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	_RDNSequence * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	OSS_CNTX_PUSH(_oss_c, 67)
	_ext = (_cnt >= 16384) ? 2 : 0;
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
	    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
	    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		_ep_RelativeDistinguishedName(_g, &_temp->value);
	    }
	    if (_cnt == _fragm_cnt) {
		if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
		    _oss_append_8bit_aligned(_g, 0);
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edRelativeDistinguishedName(OssGlobal * _g, char ** _out_pos, long * _max_len, _RelativeDistinguishedName ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_RelativeDistinguishedName * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 68)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_RelativeDistinguishedName *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    if (count > 1) _oss_nextItem(_g, &_out_len);
	    _oss_save_enc_stack(_g, _sp);
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 4)
		if (_temp->value.value.encoded.length == 0)
		    _oss_enc_error(_g, _zero_length_OpenType, 0);
		_data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _temp->value.value.encoded.value, _temp->value.value.encoded.length);
		_total_len += _data_len;
		OSS_CNTX_SET(69)
		_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _temp->value.id.value, _temp->value.id.length, -1);
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
		_total_len += _data_len;
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _st = _oss_load_enc_stack(_g, &_sp);
	    _total_len += _data_len;
	}
	if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_RelativeDistinguishedName(OssGlobal * _g, _RelativeDistinguishedName ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	_RelativeDistinguishedName * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	OSS_CNTX_PUSH(_oss_c, 68)
	_ext = (_cnt >= 16384) ? 2 : 0;
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
	    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
	    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		{
		    OSS_CNTX_INIT

		    OSS_CNTX_PUSH(_oss_c, 69)
		    _oss_penc_eobjid_ia(_g, _temp->value.id.value, _temp->value.id.length, -1);
		    OSS_CNTX_SET(4)
		    if (_temp->value.value.encoded.length == 0)
			_oss_enc_error(_g, _zero_length_OpenType, 0);
		    _oss_penc_unconstr_oct_l(_g, _temp->value.value.encoded.value, _temp->value.value.encoded.length);
		    OSS_CNTX_POP(_oss_c)
		}
	    }
	    if (_cnt == _fragm_cnt) {
		if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
		    _oss_append_8bit_aligned(_g, 0);
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edCode(OssGlobal * _g, char ** _out_pos, long * _max_len, _Code * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 70)
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.local, 0x2);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 71)
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->u.global.value, _in_data->u.global.length, -1);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_Code(OssGlobal * _g, _Code * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 2) {

	    _oss_penc_nonneg_1int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 70)
	    _oss_penc_unconstr_int_l(_g, _in_data->u.local);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 71)
	    _oss_penc_eobjid_ia(_g, _in_data->u.global.value, _in_data->u.global.length, -1);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _edFunctionalUnitPackage(OssGlobal * _g, char ** _out_pos, long * _max_len, _FunctionalUnitPackage * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 72)
	if (_in_data->bit_mask & 0x40000000 &&
	    _oss_not_dflt_ia(_g, &_in_data->agentRoleFunctionalUnit, (OSSC::COssBitString  *)&_v42, 4, _VARY_OFFSET_0, -1, 3)) {
	    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->agentRoleFunctionalUnit.value, _in_data->agentRoleFunctionalUnit.length, -1, FALSE);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA1 : 0x81);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(73)
	if (_in_data->bit_mask & 0x80000000 &&
	    _oss_not_dflt_ia(_g, &_in_data->managerRoleFunctionalUnit, (OSSC::COssBitString  *)&_v41, 4, _VARY_OFFSET_0, -1, 3)) {
	    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->managerRoleFunctionalUnit.value, _in_data->managerRoleFunctionalUnit.length, -1, FALSE);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA0 : 0x80);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(74)
	_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->functionalUnitPackageId.value, _in_data->functionalUnitPackageId.length, -1);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_FunctionalUnitPackage(OssGlobal * _g, _FunctionalUnitPackage * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_UINT32 _bitmask = _in_data->bit_mask;
	OSS_CNTX_INIT

#ifdef OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES
	if (_g->encodingFlags & STRICT_PER_ENCODING_OF_DEFAULT_VALUES) {
	    if ((_bitmask & 0x80000000) &&
		!_oss_not_dflt_ia(_g, &_in_data->managerRoleFunctionalUnit, (OSSC::COssBitString  *)&_v41, 4, _VARY_OFFSET_0, -1, 3))
		_bitmask ^= 0x80000000;
	    if ((_bitmask & 0x40000000) &&
		!_oss_not_dflt_ia(_g, &_in_data->agentRoleFunctionalUnit, (OSSC::COssBitString  *)&_v42, 4, _VARY_OFFSET_0, -1, 3))
		_bitmask ^= 0x40000000;
	}
#endif /* OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES */
	_oss_append_2bit_unaligned(_g, (unsigned char)(_bitmask >> 24));
	OSS_CNTX_PUSH(_oss_c, 74)
	_oss_penc_eobjid_ia(_g, _in_data->functionalUnitPackageId.value, _in_data->functionalUnitPackageId.length, -1);
	OSS_CNTX_SET(73)
	if (_bitmask & 0x80000000) {
#if OSS_TOED_API_LEVEL >= 27
	    _oss_penc_uncon_bit(_g, _in_data->managerRoleFunctionalUnit.value, _in_data->managerRoleFunctionalUnit.length);
#else
	    _oss_penc_unconstr_bit_l(_g, _in_data->managerRoleFunctionalUnit.value, _in_data->managerRoleFunctionalUnit.length, FALSE);
#endif
	}
	OSS_CNTX_SET(72)
	if (_bitmask & 0x40000000) {
#if OSS_TOED_API_LEVEL >= 27
	    _oss_penc_uncon_bit(_g, _in_data->agentRoleFunctionalUnit.value, _in_data->agentRoleFunctionalUnit.length);
#else
	    _oss_penc_unconstr_bit_l(_g, _in_data->agentRoleFunctionalUnit.value, _in_data->agentRoleFunctionalUnit.length, FALSE);
#endif
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static void _eActionArgument(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ActionArgument	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_ActionArgument *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(1,75)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 76)
	_data_len = _edActionInfo(_g, _out_pos, &_out_len, &_in_data->actionInfo);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xAC);
	_total_len += _data_len;
	OSS_CNTX_SET(77)
	if (_in_data->bit_mask & 0x10000000 &&
	    (_g->encRules != OSS_DER ||
	    _nDCMISFilter(_g, (_CMISFilter  *) &_in_data->filter, (_CMISFilter  *)&_v31))) {
	    _data_len = _edCMISFilter(_g, _out_pos, &_out_len, &_in_data->filter);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(78)
	if (_in_data->bit_mask & 0x20000000 &&
	    (_g->encRules != OSS_DER ||
	    _nDScope(_g, (_Scope  *) &_in_data->scope, (_Scope  *)&_v30))) {
	    _data_len = _edScope(_g, _out_pos, &_out_len, &_in_data->scope);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA7);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(79)
	if (_in_data->bit_mask & 0x40000000 &&
	    _oss_not_dflt_ia(_g, &_in_data->synchronization, (enum CMISSync  *)&ActionArgument::default_synchronization, sizeof(enum CMISSync ), 0, 1, 58)) {
	    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->synchronization, 0x86);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(80)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _edExternal(_g, _out_pos, &_out_len, &_in_data->accessControl);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x28, 0xA5);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(81)
	_data_len = _edObjectInstance(_g, _out_pos, &_out_len, &_in_data->baseManagedObjectInstance);
	_total_len += _data_len;
	OSS_CNTX_SET(82)
	_data_len = _edObjectClass(_g, _out_pos, &_out_len, &_in_data->baseManagedObjectClass);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epActionArgument(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ActionArgument	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_ActionArgument *) _inbuf;
    OSS_CNTX_ANCHOR_SET(1,75)
    {
	unsigned char _extPres = 0x00;
	OSS_UINT32 _bitmask = _in_data->bit_mask;
	OSS_CNTX_INIT

#ifdef OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES
	if (_g->encodingFlags & STRICT_PER_ENCODING_OF_DEFAULT_VALUES) {
	    if ((_bitmask & 0x40000000) &&
		!_oss_not_dflt_ia(_g, &_in_data->synchronization, (enum CMISSync  *)&ActionArgument::default_synchronization, sizeof(enum CMISSync ), 0, 1, 58))
		_bitmask ^= 0x40000000;
	}
#endif /* OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES */
	_oss_append_1bit_unaligned(_g, _extPres);
	_oss_append_4bit_unaligned(_g, (unsigned char)(_bitmask >> 24));
	OSS_CNTX_PUSH(_oss_c, 82)
	_ep_ObjectClass(_g, &_in_data->baseManagedObjectClass);
	OSS_CNTX_SET(81)
	_ep_ObjectInstance(_g, &_in_data->baseManagedObjectInstance);
	OSS_CNTX_SET(80)
	if (_bitmask & 0x80000000) {
	    _ep_External(_g, &_in_data->accessControl);
	}
	OSS_CNTX_SET(79)
	if (_bitmask & 0x40000000) {
	    _oss_penc_uenum(_g, _in_data->synchronization, (struct _enum_data *)&_enums[5], NULL);
	}
	OSS_CNTX_SET(78)
	if (_bitmask & 0x20000000) {
	    _ep_Scope(_g, &_in_data->scope);
	}
	OSS_CNTX_SET(77)
	if (_bitmask & 0x10000000) {
	    _ep_CMISFilter(_g, &_in_data->filter);
	}
	OSS_CNTX_SET(76)
	_ep_ActionInfo(_g, &_in_data->actionInfo);
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eActionResult(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ActionResult	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_ActionResult *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(2,83)
    _data_len = _edActionResult(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epActionResult(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ActionResult	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_ActionResult *) _inbuf;
    OSS_CNTX_ANCHOR_SET(2,83)
    _ep_ActionResult(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eAttribute(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Attribute	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_Attribute *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(3,84)
    _data_len = _edAttribute(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epAttribute(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Attribute	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_Attribute *) _inbuf;
    OSS_CNTX_ANCHOR_SET(3,84)
    _ep_Attribute(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eAttributeId(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ActionTypeId	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_ActionTypeId *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(4,85)
    _data_len = _edAttributeId(_g, _out_pos, &_out_len, _in_data);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epAttributeId(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ActionTypeId	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_ActionTypeId *) _inbuf;
    OSS_CNTX_ANCHOR_SET(4,85)
    _ep_AttributeId(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eBaseManagedObjectId(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _BaseManagedObjectId	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_BaseManagedObjectId *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(5,86)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 81)
	_data_len = _edObjectInstance(_g, _out_pos, &_out_len, &_in_data->baseManagedObjectInstance);
	_total_len += _data_len;
	OSS_CNTX_SET(82)
	_data_len = _edObjectClass(_g, _out_pos, &_out_len, &_in_data->baseManagedObjectClass);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epBaseManagedObjectId(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _BaseManagedObjectId	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_BaseManagedObjectId *) _inbuf;
    OSS_CNTX_ANCHOR_SET(5,86)
    {
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 82)
	_ep_ObjectClass(_g, &_in_data->baseManagedObjectClass);
	OSS_CNTX_SET(81)
	_ep_ObjectInstance(_g, &_in_data->baseManagedObjectInstance);
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eCMISFilter(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CMISFilter	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_CMISFilter *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(6,87)
    _data_len = _edCMISFilter(_g, _out_pos, &_out_len, _in_data);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epCMISFilter(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CMISFilter	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_CMISFilter *) _inbuf;
    OSS_CNTX_ANCHOR_SET(6,87)
    _ep_CMISFilter(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eCMISSync(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    enum CMISSync	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (enum CMISSync *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(7,88)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0xA);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epCMISSync(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    enum CMISSync	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (enum CMISSync *) _inbuf;
    OSS_CNTX_ANCHOR_SET(7,88)
    _oss_penc_uenum(_g, *_in_data, (struct _enum_data *)&_enums[5], NULL);
    OSS_CNTX_POP(_oss_c)
}

static void _eComplexityLimitation(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ComplexityLimitation	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_ComplexityLimitation *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(8,89)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	_oss_beginBlock(_g, 3, _out_pos, &_out_len);
	OSS_CNTX_PUSH(_oss_c, 90)
	if (_in_data->bit_mask & 0x20000000) {
	    _oss_nextItem(_g, &_out_len);
	    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->sync, 0xA);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(77)
	if (_in_data->bit_mask & 0x40000000) {
	    _oss_nextItem(_g, &_out_len);
	    _data_len = _edCMISFilter(_g, _out_pos, &_out_len, &_in_data->filter);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(78)
	if (_in_data->bit_mask & 0x80000000) {
	    _oss_nextItem(_g, &_out_len);
	    _data_len = _edScope(_g, _out_pos, &_out_len, &_in_data->scope);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_oss_endBlock(_g, _out_pos, &_out_len, 040);
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epComplexityLimitation(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ComplexityLimitation	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_ComplexityLimitation *) _inbuf;
    OSS_CNTX_ANCHOR_SET(8,89)
    {
	unsigned char _extPres = 0x00;
	OSS_CNTX_INIT

	_oss_append_1bit_unaligned(_g, _extPres);
	_oss_append_3bit_unaligned(_g, (unsigned char)(_in_data->bit_mask >> 24));
	OSS_CNTX_PUSH(_oss_c, 78)
	if (_in_data->bit_mask & 0x80000000) {
	    _ep_Scope(_g, &_in_data->scope);
	}
	OSS_CNTX_SET(77)
	if (_in_data->bit_mask & 0x40000000) {
	    _ep_CMISFilter(_g, &_in_data->filter);
	}
	OSS_CNTX_SET(90)
	if (_in_data->bit_mask & 0x20000000) {
	    _oss_penc_uenum(_g, _in_data->sync, (struct _enum_data *)&_enums[5], NULL);
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eCreateArgument(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CreateArgument	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_CreateArgument *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(9,91)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 13)
	if (_in_data->bit_mask & 0x10000000) {
	    {
		_setof3 * _temp;
		unsigned long count;
		unsigned long _lindex;
		long _total_len = 0;
		OSS_UINT32 _sp;
		void **_st = _oss_load_enc_stack(_g, &_sp);
		OSS_CNTX_NEW(_oss_c, 38)
		for (_temp = _in_data->attributeList, count = 0; _temp; _temp = _temp->next) {
		    OSS_CNTX_SETOCC(count + 1)
		    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		    _st[_sp++] = _temp;
		    count++;
		}
		if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
		for (_lindex = 0; _lindex < count; _lindex++) {
		    OSS_CNTX_SETOCC(count - _lindex)
		    _temp = (_setof3 *)_st[--_sp];
		    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		    if (count > 1) _oss_nextItem(_g, &_out_len);
		    _oss_save_enc_stack(_g, _sp);
		    _data_len = _edAttribute(_g, _out_pos, &_out_len, &_temp->value);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
		    _st = _oss_load_enc_stack(_g, &_sp);
		    _total_len += _data_len;
		}
		if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA7);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(92)
	if (_in_data->bit_mask & 0x20000000) {
	    _data_len = _edObjectInstance(_g, _out_pos, &_out_len, &_in_data->referenceObjectInstance);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA6);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(80)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _edExternal(_g, _out_pos, &_out_len, &_in_data->accessControl);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x28, 0xA5);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(93)
	if (_in_data->bit_mask & 0x80000000) {
	    {
		OSS_CNTX_INIT

		switch (_in_data->managedOrSuperiorObjectInstance.choice) {
		case 1:
		    OSS_CNTX_PUSH(_oss_c, 2)
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_in_data->managedOrSuperiorObjectInstance.u.managedObjectInstance == NULL)
			_oss_enc_error(_g, _bad_pointer, 0L);
#endif
		    _data_len = _edObjectInstance(_g, _out_pos, &_out_len, _in_data->managedOrSuperiorObjectInstance.u.managedObjectInstance);
		    break;
		case 2:
		    OSS_CNTX_PUSH(_oss_c, 94)
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_in_data->managedOrSuperiorObjectInstance.u.superiorObjectInstance == NULL)
			_oss_enc_error(_g, _bad_pointer, 0L);
#endif
		    _data_len = _edObjectInstance(_g, _out_pos, &_out_len, _in_data->managedOrSuperiorObjectInstance.u.superiorObjectInstance);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA8);
		    break;
		default:
		    _oss_enc_error(_g, _bad_choice, _in_data->managedOrSuperiorObjectInstance.choice);	/* Bad choice selector. */
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(3)
	_data_len = _edObjectClass(_g, _out_pos, &_out_len, &_in_data->managedObjectClass);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epCreateArgument(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CreateArgument	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_CreateArgument *) _inbuf;
    OSS_CNTX_ANCHOR_SET(9,91)
    {
	unsigned char _extPres = 0x00;
	OSS_CNTX_INIT

	_oss_append_1bit_unaligned(_g, _extPres);
	_oss_append_4bit_unaligned(_g, (unsigned char)(_in_data->bit_mask >> 24));
	OSS_CNTX_PUSH(_oss_c, 3)
	_ep_ObjectClass(_g, &_in_data->managedObjectClass);
	OSS_CNTX_SET(93)
	if (_in_data->bit_mask & 0x80000000) {
	    {
		OSS_CNTX_INIT

		if (_in_data->managedOrSuperiorObjectInstance.choice <= 2) {

		    _oss_penc_nonneg_1int(_g, _in_data->managedOrSuperiorObjectInstance.choice - 1);
		}
		switch (_in_data->managedOrSuperiorObjectInstance.choice) {
		case 1:
		    OSS_CNTX_PUSH(_oss_c, 2)
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_in_data->managedOrSuperiorObjectInstance.u.managedObjectInstance == NULL)
			_oss_enc_error(_g, _bad_pointer, 0L);
#endif
		    _ep_ObjectInstance(_g, _in_data->managedOrSuperiorObjectInstance.u.managedObjectInstance);
		    break;
		case 2:
		    OSS_CNTX_PUSH(_oss_c, 94)
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_in_data->managedOrSuperiorObjectInstance.u.superiorObjectInstance == NULL)
			_oss_enc_error(_g, _bad_pointer, 0L);
#endif
		    _ep_ObjectInstance(_g, _in_data->managedOrSuperiorObjectInstance.u.superiorObjectInstance);
		    break;
		default:
		    _oss_enc_error(_g, _bad_choice, _in_data->managedOrSuperiorObjectInstance.choice);	/* Bad choice selector. */
		}
		OSS_CNTX_POP(_oss_c)
	    }

	}
	OSS_CNTX_SET(80)
	if (_in_data->bit_mask & 0x40000000) {
	    _ep_External(_g, &_in_data->accessControl);
	}
	OSS_CNTX_SET(92)
	if (_in_data->bit_mask & 0x20000000) {
	    _ep_ObjectInstance(_g, &_in_data->referenceObjectInstance);
	}
	OSS_CNTX_SET(13)
	if (_in_data->bit_mask & 0x10000000) {
	    {
		_setof3 * _temp;
		unsigned int _fragm_cnt;
		unsigned int _cnt;
		int _ext;
		OSS_CNTX_INIT

		for (_cnt = 0, _temp = _in_data->attributeList; _temp; _temp = _temp->next)
		    ++_cnt;

		OSS_CNTX_PUSH(_oss_c, 38)
		_ext = (_cnt >= 16384) ? 2 : 0;
		for (_temp = _in_data->attributeList;; _cnt -= _fragm_cnt) {
		    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
		    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
		    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
			OSS_CNTX_INCOCC
			_ep_Attribute(_g, &_temp->value);
		    }
		    if (_cnt == _fragm_cnt) {
			if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
			    _oss_append_8bit_aligned(_g, 0);
			break;
		    }
		}
		OSS_CNTX_POP(_oss_c)
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eCreateResult(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CreateResult	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_CreateResult *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(10,95)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 13)
	if (_in_data->bit_mask & 0x20000000) {
	    {
		_setof3 * _temp;
		unsigned long count;
		unsigned long _lindex;
		long _total_len = 0;
		OSS_UINT32 _sp;
		void **_st = _oss_load_enc_stack(_g, &_sp);
		OSS_CNTX_NEW(_oss_c, 38)
		for (_temp = _in_data->attributeList, count = 0; _temp; _temp = _temp->next) {
		    OSS_CNTX_SETOCC(count + 1)
		    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		    _st[_sp++] = _temp;
		    count++;
		}
		if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
		for (_lindex = 0; _lindex < count; _lindex++) {
		    OSS_CNTX_SETOCC(count - _lindex)
		    _temp = (_setof3 *)_st[--_sp];
		    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		    if (count > 1) _oss_nextItem(_g, &_out_len);
		    _oss_save_enc_stack(_g, _sp);
		    _data_len = _edAttribute(_g, _out_pos, &_out_len, &_temp->value);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
		    _st = _oss_load_enc_stack(_g, &_sp);
		    _total_len += _data_len;
		}
		if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA6);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(1)
	if (_in_data->currentTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->currentTime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->currentTime, -1, 0);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA5 : 0x85);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(2)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _edObjectInstance(_g, _out_pos, &_out_len, &_in_data->managedObjectInstance);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(3)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _edObjectClass(_g, _out_pos, &_out_len, &_in_data->managedObjectClass);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epCreateResult(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CreateResult	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_CreateResult *) _inbuf;
    OSS_CNTX_ANCHOR_SET(10,95)
    {
	unsigned char _pbase[1];
	unsigned char _extPres = 0x00;
	OSS_CNTX_INIT

	_pbase[0] = 0;
	if (_in_data->bit_mask & 0x80000000) {
	    _pbase[0] |= 0x80;
	}
	if (_in_data->bit_mask & 0x40000000) {
	    _pbase[0] |= 0x40;
	}
	if (_in_data->currentTime) {
	    _pbase[0] |= 0x20;
	}
	if (_in_data->bit_mask & 0x20000000) {
	    _pbase[0] |= 0x10;
	}
	_oss_append_1bit_unaligned(_g, _extPres);
	_oss_append_4bit_unaligned(_g, *_pbase);
	OSS_CNTX_PUSH(_oss_c, 3)
	if (_in_data->bit_mask & 0x80000000) {
	    _ep_ObjectClass(_g, &_in_data->managedObjectClass);
	}
	OSS_CNTX_SET(2)
	if (_in_data->bit_mask & 0x40000000) {
	    _ep_ObjectInstance(_g, &_in_data->managedObjectInstance);
	}
	OSS_CNTX_SET(1)
	if (_in_data->currentTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->currentTime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    if(!(_g->encodingFlags & NOCONSTRAIN))
		_oss_check_nullterm_time(_g, _in_data->currentTime, 0);
	    _oss_penc_kmstr(_g, _in_data->currentTime, (unsigned long)strlen(_in_data->currentTime), _chars + 0, 0);
	}
	OSS_CNTX_SET(13)
	if (_in_data->bit_mask & 0x20000000) {
	    {
		_setof3 * _temp;
		unsigned int _fragm_cnt;
		unsigned int _cnt;
		int _ext;
		OSS_CNTX_INIT

		for (_cnt = 0, _temp = _in_data->attributeList; _temp; _temp = _temp->next)
		    ++_cnt;

		OSS_CNTX_PUSH(_oss_c, 38)
		_ext = (_cnt >= 16384) ? 2 : 0;
		for (_temp = _in_data->attributeList;; _cnt -= _fragm_cnt) {
		    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
		    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
		    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
			OSS_CNTX_INCOCC
			_ep_Attribute(_g, &_temp->value);
		    }
		    if (_cnt == _fragm_cnt) {
			if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
			    _oss_append_8bit_aligned(_g, 0);
			break;
		    }
		}
		OSS_CNTX_POP(_oss_c)
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eDeleteArgument(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _DeleteArgument	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_DeleteArgument *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(11,96)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 77)
	if (_in_data->bit_mask & 0x10000000 &&
	    (_g->encRules != OSS_DER ||
	    _nDCMISFilter(_g, (_CMISFilter  *) &_in_data->filter, (_CMISFilter  *)&_v33))) {
	    _data_len = _edCMISFilter(_g, _out_pos, &_out_len, &_in_data->filter);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(78)
	if (_in_data->bit_mask & 0x20000000 &&
	    (_g->encRules != OSS_DER ||
	    _nDScope(_g, (_Scope  *) &_in_data->scope, (_Scope  *)&_v32))) {
	    _data_len = _edScope(_g, _out_pos, &_out_len, &_in_data->scope);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA7);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(79)
	if (_in_data->bit_mask & 0x40000000 &&
	    _oss_not_dflt_ia(_g, &_in_data->synchronization, (enum CMISSync  *)&DeleteArgument::default_synchronization, sizeof(enum CMISSync ), 0, 1, 58)) {
	    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->synchronization, 0x86);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(80)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _edExternal(_g, _out_pos, &_out_len, &_in_data->accessControl);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x28, 0xA5);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(81)
	_data_len = _edObjectInstance(_g, _out_pos, &_out_len, &_in_data->baseManagedObjectInstance);
	_total_len += _data_len;
	OSS_CNTX_SET(82)
	_data_len = _edObjectClass(_g, _out_pos, &_out_len, &_in_data->baseManagedObjectClass);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epDeleteArgument(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _DeleteArgument	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_DeleteArgument *) _inbuf;
    OSS_CNTX_ANCHOR_SET(11,96)
    {
	unsigned char _extPres = 0x00;
	OSS_UINT32 _bitmask = _in_data->bit_mask;
	OSS_CNTX_INIT

#ifdef OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES
	if (_g->encodingFlags & STRICT_PER_ENCODING_OF_DEFAULT_VALUES) {
	    if ((_bitmask & 0x40000000) &&
		!_oss_not_dflt_ia(_g, &_in_data->synchronization, (enum CMISSync  *)&DeleteArgument::default_synchronization, sizeof(enum CMISSync ), 0, 1, 58))
		_bitmask ^= 0x40000000;
	}
#endif /* OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES */
	_oss_append_1bit_unaligned(_g, _extPres);
	_oss_append_4bit_unaligned(_g, (unsigned char)(_bitmask >> 24));
	OSS_CNTX_PUSH(_oss_c, 82)
	_ep_ObjectClass(_g, &_in_data->baseManagedObjectClass);
	OSS_CNTX_SET(81)
	_ep_ObjectInstance(_g, &_in_data->baseManagedObjectInstance);
	OSS_CNTX_SET(80)
	if (_bitmask & 0x80000000) {
	    _ep_External(_g, &_in_data->accessControl);
	}
	OSS_CNTX_SET(79)
	if (_bitmask & 0x40000000) {
	    _oss_penc_uenum(_g, _in_data->synchronization, (struct _enum_data *)&_enums[5], NULL);
	}
	OSS_CNTX_SET(78)
	if (_bitmask & 0x20000000) {
	    _ep_Scope(_g, &_in_data->scope);
	}
	OSS_CNTX_SET(77)
	if (_bitmask & 0x10000000) {
	    _ep_CMISFilter(_g, &_in_data->filter);
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eDeleteResult(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _DeleteResult	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_DeleteResult *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(12,97)
    _data_len = _edDeleteResult(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epDeleteResult(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _DeleteResult	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_DeleteResult *) _inbuf;
    OSS_CNTX_ANCHOR_SET(12,97)
    _ep_DeleteResult(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eEventReportArgument(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EventReportArgument	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_EventReportArgument *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(13,98)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 16)
	if (_in_data->bit_mask & 0x80000000) {
	    if (_in_data->eventInfo.encoded.length == 0)
		_oss_enc_error(_g, _zero_length_OpenType, 0);
	    _data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _in_data->eventInfo.encoded.value, _in_data->eventInfo.encoded.length);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA8);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(17)
	_data_len = _edEventTypeId(_g, _out_pos, &_out_len, &_in_data->eventType);
	_total_len += _data_len;
	OSS_CNTX_SET(99)
	if (_in_data->eventTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->eventTime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->eventTime, -1, 0);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA5 : 0x85);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(2)
	_data_len = _edObjectInstance(_g, _out_pos, &_out_len, &_in_data->managedObjectInstance);
	_total_len += _data_len;
	OSS_CNTX_SET(3)
	_data_len = _edObjectClass(_g, _out_pos, &_out_len, &_in_data->managedObjectClass);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epEventReportArgument(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EventReportArgument	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_EventReportArgument *) _inbuf;
    OSS_CNTX_ANCHOR_SET(13,98)
    {
	unsigned char _pbase[1];
	unsigned char _extPres = 0x00;
	OSS_CNTX_INIT

	_pbase[0] = 0;
	if (_in_data->eventTime) {
	    _pbase[0] |= 0x80;
	}
	if (_in_data->bit_mask & 0x80000000) {
	    _pbase[0] |= 0x40;
	}
	_oss_append_1bit_unaligned(_g, _extPres);
	_oss_append_2bit_unaligned(_g, *_pbase);
	OSS_CNTX_PUSH(_oss_c, 3)
	_ep_ObjectClass(_g, &_in_data->managedObjectClass);
	OSS_CNTX_SET(2)
	_ep_ObjectInstance(_g, &_in_data->managedObjectInstance);
	OSS_CNTX_SET(99)
	if (_in_data->eventTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->eventTime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    if(!(_g->encodingFlags & NOCONSTRAIN))
		_oss_check_nullterm_time(_g, _in_data->eventTime, 0);
	    _oss_penc_kmstr(_g, _in_data->eventTime, (unsigned long)strlen(_in_data->eventTime), _chars + 0, 0);
	}
	OSS_CNTX_SET(17)
	_ep_EventTypeId(_g, &_in_data->eventType);
	OSS_CNTX_SET(16)
	if (_in_data->bit_mask & 0x80000000) {
	    if (_in_data->eventInfo.encoded.length == 0)
		_oss_enc_error(_g, _zero_length_OpenType, 0);
	    _oss_penc_unconstr_oct_l(_g, _in_data->eventInfo.encoded.value, _in_data->eventInfo.encoded.length);
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eEventReportResult(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EventReportResult	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_EventReportResult *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(14,100)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 101)
	if (_in_data->bit_mask & 0x20000000) {
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 102)
		if (_in_data->eventReply.bit_mask & 0x80000000) {
		    if (_in_data->eventReply.eventReplyInfo.encoded.length == 0)
			_oss_enc_error(_g, _zero_length_OpenType, 0);
		    _data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _in_data->eventReply.eventReplyInfo.encoded.value, _in_data->eventReply.eventReplyInfo.encoded.length);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA8);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(17)
		_data_len = _edEventTypeId(_g, _out_pos, &_out_len, &_in_data->eventReply.eventType);
		_total_len += _data_len;
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(1)
	if (_in_data->currentTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->currentTime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->currentTime, -1, 0);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA5 : 0x85);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(2)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _edObjectInstance(_g, _out_pos, &_out_len, &_in_data->managedObjectInstance);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(3)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _edObjectClass(_g, _out_pos, &_out_len, &_in_data->managedObjectClass);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epEventReportResult(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EventReportResult	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_EventReportResult *) _inbuf;
    OSS_CNTX_ANCHOR_SET(14,100)
    {
	unsigned char _pbase[1];
	unsigned char _extPres = 0x00;
	OSS_CNTX_INIT

	_pbase[0] = 0;
	if (_in_data->bit_mask & 0x80000000) {
	    _pbase[0] |= 0x80;
	}
	if (_in_data->bit_mask & 0x40000000) {
	    _pbase[0] |= 0x40;
	}
	if (_in_data->currentTime) {
	    _pbase[0] |= 0x20;
	}
	if (_in_data->bit_mask & 0x20000000) {
	    _pbase[0] |= 0x10;
	}
	_oss_append_1bit_unaligned(_g, _extPres);
	_oss_append_4bit_unaligned(_g, *_pbase);
	OSS_CNTX_PUSH(_oss_c, 3)
	if (_in_data->bit_mask & 0x80000000) {
	    _ep_ObjectClass(_g, &_in_data->managedObjectClass);
	}
	OSS_CNTX_SET(2)
	if (_in_data->bit_mask & 0x40000000) {
	    _ep_ObjectInstance(_g, &_in_data->managedObjectInstance);
	}
	OSS_CNTX_SET(1)
	if (_in_data->currentTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->currentTime == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    if(!(_g->encodingFlags & NOCONSTRAIN))
		_oss_check_nullterm_time(_g, _in_data->currentTime, 0);
	    _oss_penc_kmstr(_g, _in_data->currentTime, (unsigned long)strlen(_in_data->currentTime), _chars + 0, 0);
	}
	OSS_CNTX_SET(101)
	if (_in_data->bit_mask & 0x20000000) {
	    {
		OSS_CNTX_INIT

		_oss_append_1bit_unaligned(_g, (unsigned char)(_in_data->eventReply.bit_mask >> 24));
		OSS_CNTX_PUSH(_oss_c, 17)
		_ep_EventTypeId(_g, &_in_data->eventReply.eventType);
		OSS_CNTX_SET(102)
		if (_in_data->eventReply.bit_mask & 0x80000000) {
		    if (_in_data->eventReply.eventReplyInfo.encoded.length == 0)
			_oss_enc_error(_g, _zero_length_OpenType, 0);
		    _oss_penc_unconstr_oct_l(_g, _in_data->eventReply.eventReplyInfo.encoded.value, _in_data->eventReply.eventReplyInfo.encoded.length);
		}
		OSS_CNTX_POP(_oss_c)
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eGetArgument(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _GetArgument	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_GetArgument *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(15,103)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 104)
	if (_in_data->bit_mask & 0x8000000) {
	    {
		_MissingAttributeValue_PARAMETER * _temp;
		unsigned long count;
		unsigned long _lindex;
		long _total_len = 0;
		OSS_UINT32 _sp;
		void **_st = _oss_load_enc_stack(_g, &_sp);
		OSS_CNTX_NEW(_oss_c, 105)
		for (_temp = _in_data->attributeIdList, count = 0; _temp; _temp = _temp->next) {
		    OSS_CNTX_SETOCC(count + 1)
		    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		    _st[_sp++] = _temp;
		    count++;
		}
		if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
		for (_lindex = 0; _lindex < count; _lindex++) {
		    OSS_CNTX_SETOCC(count - _lindex)
		    _temp = (_MissingAttributeValue_PARAMETER *)_st[--_sp];
		    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		    if (count > 1) _oss_nextItem(_g, &_out_len);
		    _data_len = _edAttributeId(_g, _out_pos, &_out_len, &_temp->value);
		    _total_len += _data_len;
		}
		_oss_save_enc_stack(_g, _sp);
		if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xAC);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(77)
	if (_in_data->bit_mask & 0x10000000 &&
	    (_g->encRules != OSS_DER ||
	    _nDCMISFilter(_g, (_CMISFilter  *) &_in_data->filter, (_CMISFilter  *)&_v35))) {
	    _data_len = _edCMISFilter(_g, _out_pos, &_out_len, &_in_data->filter);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(78)
	if (_in_data->bit_mask & 0x20000000 &&
	    (_g->encRules != OSS_DER ||
	    _nDScope(_g, (_Scope  *) &_in_data->scope, (_Scope  *)&_v34))) {
	    _data_len = _edScope(_g, _out_pos, &_out_len, &_in_data->scope);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA7);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(79)
	if (_in_data->bit_mask & 0x40000000 &&
	    _oss_not_dflt_ia(_g, &_in_data->synchronization, (enum CMISSync  *)&GetArgument::default_synchronization, sizeof(enum CMISSync ), 0, 1, 58)) {
	    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->synchronization, 0x86);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(80)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _edExternal(_g, _out_pos, &_out_len, &_in_data->accessControl);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x28, 0xA5);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(81)
	_data_len = _edObjectInstance(_g, _out_pos, &_out_len, &_in_data->baseManagedObjectInstance);
	_total_len += _data_len;
	OSS_CNTX_SET(82)
	_data_len = _edObjectClass(_g, _out_pos, &_out_len, &_in_data->baseManagedObjectClass);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epGetArgument(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _GetArgument	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_GetArgument *) _inbuf;
    OSS_CNTX_ANCHOR_SET(15,103)
    {
	unsigned char _extPres = 0x00;
	OSS_UINT32 _bitmask = _in_data->bit_mask;
	OSS_CNTX_INIT

#ifdef OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES
	if (_g->encodingFlags & STRICT_PER_ENCODING_OF_DEFAULT_VALUES) {
	    if ((_bitmask & 0x40000000) &&
		!_oss_not_dflt_ia(_g, &_in_data->synchronization, (enum CMISSync  *)&GetArgument::default_synchronization, sizeof(enum CMISSync ), 0, 1, 58))
		_bitmask ^= 0x40000000;
	}
#endif /* OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES */
	_oss_append_1bit_unaligned(_g, _extPres);
	_oss_append_5bit_unaligned(_g, (unsigned char)(_bitmask >> 24));
	OSS_CNTX_PUSH(_oss_c, 82)
	_ep_ObjectClass(_g, &_in_data->baseManagedObjectClass);
	OSS_CNTX_SET(81)
	_ep_ObjectInstance(_g, &_in_data->baseManagedObjectInstance);
	OSS_CNTX_SET(80)
	if (_bitmask & 0x80000000) {
	    _ep_External(_g, &_in_data->accessControl);
	}
	OSS_CNTX_SET(79)
	if (_bitmask & 0x40000000) {
	    _oss_penc_uenum(_g, _in_data->synchronization, (struct _enum_data *)&_enums[5], NULL);
	}
	OSS_CNTX_SET(78)
	if (_bitmask & 0x20000000) {
	    _ep_Scope(_g, &_in_data->scope);
	}
	OSS_CNTX_SET(77)
	if (_bitmask & 0x10000000) {
	    _ep_CMISFilter(_g, &_in_data->filter);
	}
	OSS_CNTX_SET(104)
	if (_bitmask & 0x8000000) {
	    {
		_MissingAttributeValue_PARAMETER * _temp;
		unsigned int _fragm_cnt;
		unsigned int _cnt;
		int _ext;
		OSS_CNTX_INIT

		for (_cnt = 0, _temp = _in_data->attributeIdList; _temp; _temp = _temp->next)
		    ++_cnt;

		OSS_CNTX_PUSH(_oss_c, 105)
		_ext = (_cnt >= 16384) ? 2 : 0;
		for (_temp = _in_data->attributeIdList;; _cnt -= _fragm_cnt) {
		    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
		    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
		    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
			OSS_CNTX_INCOCC
			_ep_AttributeId(_g, &_temp->value);
		    }
		    if (_cnt == _fragm_cnt) {
			if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
			    _oss_append_8bit_aligned(_g, 0);
			break;
		    }
		}
		OSS_CNTX_POP(_oss_c)
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eGetListError(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _GetListError	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_GetListError *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(16,106)
    _data_len = _edGetListError(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epGetListError(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _GetListError	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_GetListError *) _inbuf;
    OSS_CNTX_ANCHOR_SET(16,106)
    _ep_GetListError(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eGetResult(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CreateResult	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_CreateResult *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(17,107)
    _data_len = _edGetResult(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epGetResult(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CreateResult	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_CreateResult *) _inbuf;
    OSS_CNTX_ANCHOR_SET(17,107)
    _ep_GetResult(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eInvalidArgumentValue(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvalidArgumentValue	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_InvalidArgumentValue *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(18,108)
    _data_len = _edInvalidArgumentValue(_g, _out_pos, &_out_len, _in_data);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epInvalidArgumentValue(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvalidArgumentValue	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_InvalidArgumentValue *) _inbuf;
    OSS_CNTX_ANCHOR_SET(18,108)
    _ep_InvalidArgumentValue(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eInvokeIDType(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeId	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_InvokeId *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(19,109)
    _data_len = _edInvokeId(_g, _out_pos, &_out_len, _in_data);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epInvokeIDType(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeId	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_InvokeId *) _inbuf;
    OSS_CNTX_ANCHOR_SET(19,109)
    _ep_InvokeId(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eLinkedReplyArgument(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _LinkedReplyArgument	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_LinkedReplyArgument *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(20,110)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 111)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.getResult == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edGetResult(_g, _out_pos, &_out_len, _in_data->u.getResult);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 112)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.getListError == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edGetListError(_g, _out_pos, &_out_len, _in_data->u.getListError);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 113)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.setResult == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edSetResult(_g, _out_pos, &_out_len, _in_data->u.setResult);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 114)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.setListError == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edSetListError(_g, _out_pos, &_out_len, _in_data->u.setListError);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA3);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 115)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.actionResult == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edActionResult(_g, _out_pos, &_out_len, _in_data->u.actionResult);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA4);
	    break;
	case 6:
	    OSS_CNTX_PUSH(_oss_c, 116)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.processingFailure == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edProcessingFailure(_g, _out_pos, &_out_len, _in_data->u.processingFailure);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA5);
	    break;
	case 7:
	    OSS_CNTX_PUSH(_oss_c, 117)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.deleteResult == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edDeleteResult(_g, _out_pos, &_out_len, _in_data->u.deleteResult);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA6);
	    break;
	case 8:
	    OSS_CNTX_PUSH(_oss_c, 118)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.actionError == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 119)
		{
		    long _total_len = 0;
		    OSS_CNTX_INIT

		    OSS_CNTX_PUSH(_oss_c, 120)
		    {
			OSS_CNTX_INIT

			switch (_in_data->u.actionError->actionErrorInfo.errorInfo.choice) {
			case 1:
			    OSS_CNTX_PUSH(_oss_c, 121)
#ifndef OSS_DO_NOT_CHECK_POINTERS
			    if (_in_data->u.actionError->actionErrorInfo.errorInfo.u.actionArgument == NULL)
				_oss_enc_error(_g, _bad_pointer, 0L);
#endif
			    _data_len = _edNoSuchArgument(_g, _out_pos, &_out_len, _in_data->u.actionError->actionErrorInfo.errorInfo.u.actionArgument);
			    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
			    break;
			case 2:
			    OSS_CNTX_PUSH(_oss_c, 122)
#ifndef OSS_DO_NOT_CHECK_POINTERS
			    if (_in_data->u.actionError->actionErrorInfo.errorInfo.u.argumentValue == NULL)
				_oss_enc_error(_g, _bad_pointer, 0L);
#endif
			    _data_len = _edInvalidArgumentValue(_g, _out_pos, &_out_len, _in_data->u.actionError->actionErrorInfo.errorInfo.u.argumentValue);
			    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
			    break;
			case 3:
			    OSS_CNTX_PUSH(_oss_c, 19)
#ifndef OSS_DO_NOT_CHECK_POINTERS
			    if (_in_data->u.actionError->actionErrorInfo.errorInfo.u.actionType == NULL)
				_oss_enc_error(_g, _bad_pointer, 0L);
#endif
			    _data_len = _edActionTypeId(_g, _out_pos, &_out_len, _in_data->u.actionError->actionErrorInfo.errorInfo.u.actionType);
			    break;
			default:
			    _oss_enc_error(_g, _bad_choice, _in_data->u.actionError->actionErrorInfo.errorInfo.choice);	/* Bad choice selector. */
			}
			OSS_CNTX_POP(_oss_c)
		    }
		    _total_len += _data_len;
		    OSS_CNTX_SET(36)
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, (int)_in_data->u.actionError->actionErrorInfo.errorStatus, 0xA);
		    _total_len += _data_len;
		    OSS_CNTX_POP(_oss_c)
		    _data_len = _total_len;
		}
		_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA6);
		_total_len += _data_len;
		OSS_CNTX_SET(1)
		if (_in_data->u.actionError->currentTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_in_data->u.actionError->currentTime == NULL)
			_oss_enc_error(_g, _bad_pointer, 0L);
#endif
		    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->u.actionError->currentTime, -1, 0);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA5 : 0x85);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(2)
		if (_in_data->u.actionError->bit_mask & 0x40000000) {
		    _data_len = _edObjectInstance(_g, _out_pos, &_out_len, &_in_data->u.actionError->managedObjectInstance);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(3)
		if (_in_data->u.actionError->bit_mask & 0x80000000) {
		    _data_len = _edObjectClass(_g, _out_pos, &_out_len, &_in_data->u.actionError->managedObjectClass);
		    _total_len += _data_len;
		}
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA7);
	    break;
	case 9:
	    OSS_CNTX_PUSH(_oss_c, 123)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.deleteError == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 124)
		_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, (int)_in_data->u.deleteError->deleteErrorInfo, 0xA);
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA6);
		_total_len += _data_len;
		OSS_CNTX_SET(1)
		if (_in_data->u.deleteError->currentTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_in_data->u.deleteError->currentTime == NULL)
			_oss_enc_error(_g, _bad_pointer, 0L);
#endif
		    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->u.deleteError->currentTime, -1, 0);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA5 : 0x85);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(2)
		if (_in_data->u.deleteError->bit_mask & 0x40000000) {
		    _data_len = _edObjectInstance(_g, _out_pos, &_out_len, &_in_data->u.deleteError->managedObjectInstance);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(3)
		if (_in_data->u.deleteError->bit_mask & 0x80000000) {
		    _data_len = _edObjectClass(_g, _out_pos, &_out_len, &_in_data->u.deleteError->managedObjectClass);
		    _total_len += _data_len;
		}
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA8);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epLinkedReplyArgument(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _LinkedReplyArgument	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_LinkedReplyArgument *) _inbuf;
    OSS_CNTX_ANCHOR_SET(20,110)
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 9) {

	    _oss_penc_nonneg_4int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 111)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.getResult == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_GetResult(_g, _in_data->u.getResult);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 112)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.getListError == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_GetListError(_g, _in_data->u.getListError);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 113)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.setResult == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_SetResult(_g, _in_data->u.setResult);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 114)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.setListError == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_SetListError(_g, _in_data->u.setListError);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 115)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.actionResult == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_ActionResult(_g, _in_data->u.actionResult);
	    break;
	case 6:
	    OSS_CNTX_PUSH(_oss_c, 116)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.processingFailure == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_ProcessingFailure(_g, _in_data->u.processingFailure);
	    break;
	case 7:
	    OSS_CNTX_PUSH(_oss_c, 117)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.deleteResult == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_DeleteResult(_g, _in_data->u.deleteResult);
	    break;
	case 8:
	    OSS_CNTX_PUSH(_oss_c, 118)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.actionError == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		unsigned char _pbase[1];
		unsigned char _extPres = 0x00;
		OSS_CNTX_INIT

		_pbase[0] = 0;
		if (_in_data->u.actionError->bit_mask & 0x80000000) {
		    _pbase[0] |= 0x80;
		}
		if (_in_data->u.actionError->bit_mask & 0x40000000) {
		    _pbase[0] |= 0x40;
		}
		if (_in_data->u.actionError->currentTime) {
		    _pbase[0] |= 0x20;
		}
		_oss_append_1bit_unaligned(_g, _extPres);
		_oss_append_3bit_unaligned(_g, *_pbase);
		OSS_CNTX_PUSH(_oss_c, 3)
		if (_in_data->u.actionError->bit_mask & 0x80000000) {
		    _ep_ObjectClass(_g, &_in_data->u.actionError->managedObjectClass);
		}
		OSS_CNTX_SET(2)
		if (_in_data->u.actionError->bit_mask & 0x40000000) {
		    _ep_ObjectInstance(_g, &_in_data->u.actionError->managedObjectInstance);
		}
		OSS_CNTX_SET(1)
		if (_in_data->u.actionError->currentTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_in_data->u.actionError->currentTime == NULL)
			_oss_enc_error(_g, _bad_pointer, 0L);
#endif
		    if(!(_g->encodingFlags & NOCONSTRAIN))
			_oss_check_nullterm_time(_g, _in_data->u.actionError->currentTime, 0);
		    _oss_penc_kmstr(_g, _in_data->u.actionError->currentTime, (unsigned long)strlen(_in_data->u.actionError->currentTime), _chars + 0, 0);
		}
		OSS_CNTX_SET(119)
		{
		    unsigned char _extPres = 0x00;
		    OSS_CNTX_INIT

		    _oss_append_1bit_unaligned(_g, _extPres);
		    OSS_CNTX_PUSH(_oss_c, 36)
		    _oss_penc_enum(_g, _in_data->u.actionError->actionErrorInfo.errorStatus, (struct _enum_data *)&_enums[6], (struct _enum_data *)&_enums[7]);
		    OSS_CNTX_SET(120)
		    {
			OSS_CNTX_INIT

			if (_in_data->u.actionError->actionErrorInfo.errorInfo.choice <= 3) {

			    _oss_penc_nonneg_2int(_g, _in_data->u.actionError->actionErrorInfo.errorInfo.choice - 1);
			}
			switch (_in_data->u.actionError->actionErrorInfo.errorInfo.choice) {
			case 1:
			    OSS_CNTX_PUSH(_oss_c, 121)
#ifndef OSS_DO_NOT_CHECK_POINTERS
			    if (_in_data->u.actionError->actionErrorInfo.errorInfo.u.actionArgument == NULL)
				_oss_enc_error(_g, _bad_pointer, 0L);
#endif
			    _ep_NoSuchArgument(_g, _in_data->u.actionError->actionErrorInfo.errorInfo.u.actionArgument);
			    break;
			case 2:
			    OSS_CNTX_PUSH(_oss_c, 122)
#ifndef OSS_DO_NOT_CHECK_POINTERS
			    if (_in_data->u.actionError->actionErrorInfo.errorInfo.u.argumentValue == NULL)
				_oss_enc_error(_g, _bad_pointer, 0L);
#endif
			    _ep_InvalidArgumentValue(_g, _in_data->u.actionError->actionErrorInfo.errorInfo.u.argumentValue);
			    break;
			case 3:
			    OSS_CNTX_PUSH(_oss_c, 19)
#ifndef OSS_DO_NOT_CHECK_POINTERS
			    if (_in_data->u.actionError->actionErrorInfo.errorInfo.u.actionType == NULL)
				_oss_enc_error(_g, _bad_pointer, 0L);
#endif
			    _ep_ActionTypeId(_g, _in_data->u.actionError->actionErrorInfo.errorInfo.u.actionType);
			    break;
			default:
			    _oss_enc_error(_g, _bad_choice, _in_data->u.actionError->actionErrorInfo.errorInfo.choice);	/* Bad choice selector. */
			}
			OSS_CNTX_POP(_oss_c)
		    }

		    OSS_CNTX_POP(_oss_c)
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    break;
	case 9:
	    OSS_CNTX_PUSH(_oss_c, 123)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.deleteError == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		unsigned char _pbase[1];
		unsigned char _extPres = 0x00;
		OSS_CNTX_INIT

		_pbase[0] = 0;
		if (_in_data->u.deleteError->bit_mask & 0x80000000) {
		    _pbase[0] |= 0x80;
		}
		if (_in_data->u.deleteError->bit_mask & 0x40000000) {
		    _pbase[0] |= 0x40;
		}
		if (_in_data->u.deleteError->currentTime) {
		    _pbase[0] |= 0x20;
		}
		_oss_append_1bit_unaligned(_g, _extPres);
		_oss_append_3bit_unaligned(_g, *_pbase);
		OSS_CNTX_PUSH(_oss_c, 3)
		if (_in_data->u.deleteError->bit_mask & 0x80000000) {
		    _ep_ObjectClass(_g, &_in_data->u.deleteError->managedObjectClass);
		}
		OSS_CNTX_SET(2)
		if (_in_data->u.deleteError->bit_mask & 0x40000000) {
		    _ep_ObjectInstance(_g, &_in_data->u.deleteError->managedObjectInstance);
		}
		OSS_CNTX_SET(1)
		if (_in_data->u.deleteError->currentTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_in_data->u.deleteError->currentTime == NULL)
			_oss_enc_error(_g, _bad_pointer, 0L);
#endif
		    if(!(_g->encodingFlags & NOCONSTRAIN))
			_oss_check_nullterm_time(_g, _in_data->u.deleteError->currentTime, 0);
		    _oss_penc_kmstr(_g, _in_data->u.deleteError->currentTime, (unsigned long)strlen(_in_data->u.deleteError->currentTime), _chars + 0, 0);
		}
		OSS_CNTX_SET(124)
		_oss_penc_enum(_g, _in_data->u.deleteError->deleteErrorInfo, (struct _enum_data *)&_enums[8], (struct _enum_data *)&_enums[9]);
		OSS_CNTX_POP(_oss_c)
	    }
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eNoSuchAction(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _NoSuchAction	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_NoSuchAction *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(21,125)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 19)
	_data_len = _edActionTypeId(_g, _out_pos, &_out_len, &_in_data->actionType);
	_total_len += _data_len;
	OSS_CNTX_SET(3)
	_data_len = _edObjectClass(_g, _out_pos, &_out_len, &_in_data->managedObjectClass);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epNoSuchAction(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _NoSuchAction	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_NoSuchAction *) _inbuf;
    OSS_CNTX_ANCHOR_SET(21,125)
    {
	unsigned char _extPres = 0x00;
	OSS_CNTX_INIT

	_oss_append_1bit_unaligned(_g, _extPres);
	OSS_CNTX_PUSH(_oss_c, 3)
	_ep_ObjectClass(_g, &_in_data->managedObjectClass);
	OSS_CNTX_SET(19)
	_ep_ActionTypeId(_g, &_in_data->actionType);
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eNoSuchArgument(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _NoSuchArgument	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_NoSuchArgument *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(22,126)
    _data_len = _edNoSuchArgument(_g, _out_pos, &_out_len, _in_data);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epNoSuchArgument(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _NoSuchArgument	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_NoSuchArgument *) _inbuf;
    OSS_CNTX_ANCHOR_SET(22,126)
    _ep_NoSuchArgument(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eNoSuchEventType(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _NoSuchEventType	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_NoSuchEventType *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(23,127)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 17)
	_data_len = _edEventTypeId(_g, _out_pos, &_out_len, &_in_data->eventType);
	_total_len += _data_len;
	OSS_CNTX_SET(3)
	_data_len = _edObjectClass(_g, _out_pos, &_out_len, &_in_data->managedObjectClass);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epNoSuchEventType(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _NoSuchEventType	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_NoSuchEventType *) _inbuf;
    OSS_CNTX_ANCHOR_SET(23,127)
    {
	unsigned char _extPres = 0x00;
	OSS_CNTX_INIT

	_oss_append_1bit_unaligned(_g, _extPres);
	OSS_CNTX_PUSH(_oss_c, 3)
	_ep_ObjectClass(_g, &_in_data->managedObjectClass);
	OSS_CNTX_SET(17)
	_ep_EventTypeId(_g, &_in_data->eventType);
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eObjectClass(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ActionTypeId	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_ActionTypeId *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(24,128)
    _data_len = _edObjectClass(_g, _out_pos, &_out_len, _in_data);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epObjectClass(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ActionTypeId	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_ActionTypeId *) _inbuf;
    OSS_CNTX_ANCHOR_SET(24,128)
    _ep_ObjectClass(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eObjectInstance(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ObjectInstance	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_ObjectInstance *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(25,129)
    _data_len = _edObjectInstance(_g, _out_pos, &_out_len, _in_data);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epObjectInstance(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ObjectInstance	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_ObjectInstance *) _inbuf;
    OSS_CNTX_ANCHOR_SET(25,129)
    _ep_ObjectInstance(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eProcessingFailure(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ProcessingFailure	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_ProcessingFailure *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(26,130)
    _data_len = _edProcessingFailure(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epProcessingFailure(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ProcessingFailure	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_ProcessingFailure *) _inbuf;
    OSS_CNTX_ANCHOR_SET(26,130)
    _ep_ProcessingFailure(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eScope(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Scope	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_Scope *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(27,131)
    _data_len = _edScope(_g, _out_pos, &_out_len, _in_data);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epScope(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Scope	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_Scope *) _inbuf;
    OSS_CNTX_ANCHOR_SET(27,131)
    _ep_Scope(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eSetArgument(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SetArgument	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_SetArgument *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(28,132)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 133)
	{
	    _setof8 * _temp;
	    unsigned long count;
	    unsigned long _lindex;
	    long _total_len = 0;
	    OSS_UINT32 _sp;
	    void **_st = _oss_load_enc_stack(_g, &_sp);
	    OSS_CNTX_NEW(_oss_c, 134)
	    for (_temp = _in_data->modificationList, count = 0; _temp; _temp = _temp->next) {
		OSS_CNTX_SETOCC(count + 1)
		if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		_st[_sp++] = _temp;
		count++;
	    }
	    if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
	    for (_lindex = 0; _lindex < count; _lindex++) {
		OSS_CNTX_SETOCC(count - _lindex)
		_temp = (_setof8 *)_st[--_sp];
		if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		if (count > 1) _oss_nextItem(_g, &_out_len);
		_oss_save_enc_stack(_g, _sp);
		{
		    long _total_len = 0;
		    OSS_CNTX_INIT

		    OSS_CNTX_PUSH(_oss_c, 33)
		    if (_temp->value.bit_mask & 0x40000000) {
			if (_temp->value.attributeValue.encoded.length == 0)
			    _oss_enc_error(_g, _zero_length_OpenType, 0);
			_data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _temp->value.attributeValue.encoded.value, _temp->value.attributeValue.encoded.length);
			_total_len += _data_len;
		    }
		    OSS_CNTX_SET(34)
		    _data_len = _edAttributeId(_g, _out_pos, &_out_len, &_temp->value.attributeId);
		    _total_len += _data_len;
		    OSS_CNTX_SET(35)
		    if (_temp->value.bit_mask & 0x80000000 &&
			_oss_not_dflt_ia(_g, &_temp->value.modifyOperator, (OSS_INT32  *)&__seq4::default_modifyOperator, sizeof(OSS_INT32 ), 0, -1, 0)) {
			_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _temp->value.modifyOperator, 0x82);
			_total_len += _data_len;
		    }
		    OSS_CNTX_POP(_oss_c)
		    _data_len = _total_len;
		}
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
		_st = _oss_load_enc_stack(_g, &_sp);
		_total_len += _data_len;
	    }
	    if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xAC);
	_total_len += _data_len;
	OSS_CNTX_SET(77)
	if (_in_data->bit_mask & 0x10000000 &&
	    (_g->encRules != OSS_DER ||
	    _nDCMISFilter(_g, (_CMISFilter  *) &_in_data->filter, (_CMISFilter  *)&_v37))) {
	    _data_len = _edCMISFilter(_g, _out_pos, &_out_len, &_in_data->filter);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(78)
	if (_in_data->bit_mask & 0x20000000 &&
	    (_g->encRules != OSS_DER ||
	    _nDScope(_g, (_Scope  *) &_in_data->scope, (_Scope  *)&_v36))) {
	    _data_len = _edScope(_g, _out_pos, &_out_len, &_in_data->scope);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA7);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(79)
	if (_in_data->bit_mask & 0x40000000 &&
	    _oss_not_dflt_ia(_g, &_in_data->synchronization, (enum CMISSync  *)&SetArgument::default_synchronization, sizeof(enum CMISSync ), 0, 1, 58)) {
	    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->synchronization, 0x86);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(80)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _edExternal(_g, _out_pos, &_out_len, &_in_data->accessControl);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x28, 0xA5);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(81)
	_data_len = _edObjectInstance(_g, _out_pos, &_out_len, &_in_data->baseManagedObjectInstance);
	_total_len += _data_len;
	OSS_CNTX_SET(82)
	_data_len = _edObjectClass(_g, _out_pos, &_out_len, &_in_data->baseManagedObjectClass);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epSetArgument(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SetArgument	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_SetArgument *) _inbuf;
    OSS_CNTX_ANCHOR_SET(28,132)
    {
	unsigned char _extPres = 0x00;
	OSS_UINT32 _bitmask = _in_data->bit_mask;
	OSS_CNTX_INIT

#ifdef OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES
	if (_g->encodingFlags & STRICT_PER_ENCODING_OF_DEFAULT_VALUES) {
	    if ((_bitmask & 0x40000000) &&
		!_oss_not_dflt_ia(_g, &_in_data->synchronization, (enum CMISSync  *)&SetArgument::default_synchronization, sizeof(enum CMISSync ), 0, 1, 58))
		_bitmask ^= 0x40000000;
	}
#endif /* OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES */
	_oss_append_1bit_unaligned(_g, _extPres);
	_oss_append_4bit_unaligned(_g, (unsigned char)(_bitmask >> 24));
	OSS_CNTX_PUSH(_oss_c, 82)
	_ep_ObjectClass(_g, &_in_data->baseManagedObjectClass);
	OSS_CNTX_SET(81)
	_ep_ObjectInstance(_g, &_in_data->baseManagedObjectInstance);
	OSS_CNTX_SET(80)
	if (_bitmask & 0x80000000) {
	    _ep_External(_g, &_in_data->accessControl);
	}
	OSS_CNTX_SET(79)
	if (_bitmask & 0x40000000) {
	    _oss_penc_uenum(_g, _in_data->synchronization, (struct _enum_data *)&_enums[5], NULL);
	}
	OSS_CNTX_SET(78)
	if (_bitmask & 0x20000000) {
	    _ep_Scope(_g, &_in_data->scope);
	}
	OSS_CNTX_SET(77)
	if (_bitmask & 0x10000000) {
	    _ep_CMISFilter(_g, &_in_data->filter);
	}
	OSS_CNTX_SET(133)
	{
	    _setof8 * _temp;
	    unsigned int _fragm_cnt;
	    unsigned int _cnt;
	    int _ext;
	    OSS_CNTX_INIT

	    for (_cnt = 0, _temp = _in_data->modificationList; _temp; _temp = _temp->next)
		++_cnt;

	    OSS_CNTX_PUSH(_oss_c, 134)
	    _ext = (_cnt >= 16384) ? 2 : 0;
	    for (_temp = _in_data->modificationList;; _cnt -= _fragm_cnt) {
		unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
		_fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		_fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
		for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		    OSS_CNTX_INCOCC
		    {
			OSS_UINT32 _bitmask = _temp->value.bit_mask;
			OSS_CNTX_INIT

#ifdef OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES
			if (_g->encodingFlags & STRICT_PER_ENCODING_OF_DEFAULT_VALUES) {
			    if ((_bitmask & 0x80000000) &&
				!_oss_not_dflt_ia(_g, &_temp->value.modifyOperator, (OSS_INT32  *)&__seq4::default_modifyOperator, sizeof(OSS_INT32 ), 0, -1, 0))
				_bitmask ^= 0x80000000;
			}
#endif /* OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES */
			_oss_append_2bit_unaligned(_g, (unsigned char)(_bitmask >> 24));
			OSS_CNTX_PUSH(_oss_c, 35)
			if (_bitmask & 0x80000000) {
			    _oss_penc_unconstr_int_l(_g, _temp->value.modifyOperator);
			}
			OSS_CNTX_SET(34)
			_ep_AttributeId(_g, &_temp->value.attributeId);
			OSS_CNTX_SET(33)
			if (_bitmask & 0x40000000) {
			    if (_temp->value.attributeValue.encoded.length == 0)
				_oss_enc_error(_g, _zero_length_OpenType, 0);
			    _oss_penc_unconstr_oct_l(_g, _temp->value.attributeValue.encoded.value, _temp->value.attributeValue.encoded.length);
			}
			OSS_CNTX_POP(_oss_c)
		    }
		}
		if (_cnt == _fragm_cnt) {
		    if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
			_oss_append_8bit_aligned(_g, 0);
		    break;
		}
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eSetListError(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SetListError	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_SetListError *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(29,135)
    _data_len = _edSetListError(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epSetListError(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SetListError	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_SetListError *) _inbuf;
    OSS_CNTX_ANCHOR_SET(29,135)
    _ep_SetListError(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eSetResult(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CreateResult	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_CreateResult *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(30,136)
    _data_len = _edSetResult(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epSetResult(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CreateResult	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_CreateResult *) _inbuf;
    OSS_CNTX_ANCHOR_SET(30,136)
    _ep_SetResult(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eROSEapdus(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ROSEapdus	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_ROSEapdus *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(31,137)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 138)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.invoke == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 139)
		if (_in_data->u.invoke->bit_mask & 0x40000000) {
		    if (_in_data->u.invoke->argument.encoded.length == 0)
			_oss_enc_error(_g, _zero_length_OpenType, 0);
		    _data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _in_data->u.invoke->argument.encoded.value, _in_data->u.invoke->argument.encoded.length);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(140)
		_data_len = _edCode(_g, _out_pos, &_out_len, &_in_data->u.invoke->opcode);
		_total_len += _data_len;
		OSS_CNTX_SET(141)
		if (_in_data->u.invoke->bit_mask & 0x80000000) {
		    {
			OSS_CNTX_INIT

			switch (_in_data->u.invoke->linkedId.choice) {
			case 1:
			    OSS_CNTX_PUSH(_oss_c, 65)
			    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.invoke->linkedId.u.present, 0x80);
			    break;
			case 2:
			    OSS_CNTX_PUSH(_oss_c, 66)
			    _data_len = 0;
			    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x81);
			    break;
			default:
			    _oss_enc_error(_g, _bad_choice, _in_data->u.invoke->linkedId.choice);	/* Bad choice selector. */
			}
			OSS_CNTX_POP(_oss_c)
		    }
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(142)
		_data_len = _edInvokeId(_g, _out_pos, &_out_len, &_in_data->u.invoke->invokeId);
		_total_len += _data_len;
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 143)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.returnResult == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 144)
		if (_in_data->u.returnResult->bit_mask & 0x80000000) {
		    {
			long _total_len = 0;
			OSS_CNTX_INIT

			OSS_CNTX_PUSH(_oss_c, 145)
			if (_in_data->u.returnResult->result.result.encoded.length == 0)
			    _oss_enc_error(_g, _zero_length_OpenType, 0);
			_data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _in_data->u.returnResult->result.result.encoded.value, _in_data->u.returnResult->result.result.encoded.length);
			_total_len += _data_len;
			OSS_CNTX_SET(140)
			_data_len = _edCode(_g, _out_pos, &_out_len, &_in_data->u.returnResult->result.opcode);
			_total_len += _data_len;
			OSS_CNTX_POP(_oss_c)
			_data_len = _total_len;
		    }
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(142)
		_data_len = _edInvokeId(_g, _out_pos, &_out_len, &_in_data->u.returnResult->invokeId);
		_total_len += _data_len;
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 146)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.returnError == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 147)
		if (_in_data->u.returnError->bit_mask & 0x80000000) {
		    if (_in_data->u.returnError->parameter.encoded.length == 0)
			_oss_enc_error(_g, _zero_length_OpenType, 0);
		    _data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _in_data->u.returnError->parameter.encoded.value, _in_data->u.returnError->parameter.encoded.length);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(148)
		_data_len = _edCode(_g, _out_pos, &_out_len, &_in_data->u.returnError->errcode);
		_total_len += _data_len;
		OSS_CNTX_SET(142)
		_data_len = _edInvokeId(_g, _out_pos, &_out_len, &_in_data->u.returnError->invokeId);
		_total_len += _data_len;
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA3);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 149)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.reject == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 150)
		{
		    OSS_CNTX_INIT

		    switch (_in_data->u.reject->problem.choice) {
		    case 1:
			OSS_CNTX_PUSH(_oss_c, 151)
			_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.reject->problem.u.general, 0x80);
			break;
		    case 2:
			OSS_CNTX_PUSH(_oss_c, 152)
			_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.reject->problem.u.invoke, 0x81);
			break;
		    case 3:
			OSS_CNTX_PUSH(_oss_c, 153)
			_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.reject->problem.u.returnResult, 0x82);
			break;
		    case 4:
			OSS_CNTX_PUSH(_oss_c, 154)
			_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.reject->problem.u.returnError, 0x83);
			break;
		    default:
			_oss_enc_error(_g, _bad_choice, _in_data->u.reject->problem.choice);	/* Bad choice selector. */
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		_total_len += _data_len;
		OSS_CNTX_SET(142)
		_data_len = _edInvokeId(_g, _out_pos, &_out_len, &_in_data->u.reject->invokeId);
		_total_len += _data_len;
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA4);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epROSEapdus(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ROSEapdus	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_ROSEapdus *) _inbuf;
    OSS_CNTX_ANCHOR_SET(31,137)
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 4) {

	    _oss_penc_nonneg_2int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 138)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.invoke == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_oss_append_2bit_unaligned(_g, (unsigned char)(_in_data->u.invoke->bit_mask >> 24));
		OSS_CNTX_PUSH(_oss_c, 142)
		_ep_InvokeId(_g, &_in_data->u.invoke->invokeId);
		OSS_CNTX_SET(141)
		if (_in_data->u.invoke->bit_mask & 0x80000000) {
		    {
			OSS_CNTX_INIT

			if (_in_data->u.invoke->linkedId.choice <= 2) {

			    _oss_penc_nonneg_1int(_g, _in_data->u.invoke->linkedId.choice - 1);
			}
			switch (_in_data->u.invoke->linkedId.choice) {
			case 1:
			    OSS_CNTX_PUSH(_oss_c, 65)
			    _oss_penc_unconstr_int_l(_g, _in_data->u.invoke->linkedId.u.present);
			    break;
			case 2:
			    OSS_CNTX_PUSH(_oss_c, 66)
			    break;
			default:
			    _oss_enc_error(_g, _bad_choice, _in_data->u.invoke->linkedId.choice);	/* Bad choice selector. */
			}
			OSS_CNTX_POP(_oss_c)
		    }

		}
		OSS_CNTX_SET(140)
		_ep_Code(_g, &_in_data->u.invoke->opcode);
		OSS_CNTX_SET(139)
		if (_in_data->u.invoke->bit_mask & 0x40000000) {
		    if (_in_data->u.invoke->argument.encoded.length == 0)
			_oss_enc_error(_g, _zero_length_OpenType, 0);
		    _oss_penc_unconstr_oct_l(_g, _in_data->u.invoke->argument.encoded.value, _in_data->u.invoke->argument.encoded.length);
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 143)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.returnResult == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_oss_append_1bit_unaligned(_g, (unsigned char)(_in_data->u.returnResult->bit_mask >> 24));
		OSS_CNTX_PUSH(_oss_c, 142)
		_ep_InvokeId(_g, &_in_data->u.returnResult->invokeId);
		OSS_CNTX_SET(144)
		if (_in_data->u.returnResult->bit_mask & 0x80000000) {
		    {
			OSS_CNTX_INIT

			OSS_CNTX_PUSH(_oss_c, 140)
			_ep_Code(_g, &_in_data->u.returnResult->result.opcode);
			OSS_CNTX_SET(145)
			if (_in_data->u.returnResult->result.result.encoded.length == 0)
			    _oss_enc_error(_g, _zero_length_OpenType, 0);
			_oss_penc_unconstr_oct_l(_g, _in_data->u.returnResult->result.result.encoded.value, _in_data->u.returnResult->result.result.encoded.length);
			OSS_CNTX_POP(_oss_c)
		    }
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 146)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.returnError == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_oss_append_1bit_unaligned(_g, (unsigned char)(_in_data->u.returnError->bit_mask >> 24));
		OSS_CNTX_PUSH(_oss_c, 142)
		_ep_InvokeId(_g, &_in_data->u.returnError->invokeId);
		OSS_CNTX_SET(148)
		_ep_Code(_g, &_in_data->u.returnError->errcode);
		OSS_CNTX_SET(147)
		if (_in_data->u.returnError->bit_mask & 0x80000000) {
		    if (_in_data->u.returnError->parameter.encoded.length == 0)
			_oss_enc_error(_g, _zero_length_OpenType, 0);
		    _oss_penc_unconstr_oct_l(_g, _in_data->u.returnError->parameter.encoded.value, _in_data->u.returnError->parameter.encoded.length);
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 149)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.reject == NULL)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 142)
		_ep_InvokeId(_g, &_in_data->u.reject->invokeId);
		OSS_CNTX_SET(150)
		{
		    OSS_CNTX_INIT

		    if (_in_data->u.reject->problem.choice <= 4) {

			_oss_penc_nonneg_2int(_g, _in_data->u.reject->problem.choice - 1);
		    }
		    switch (_in_data->u.reject->problem.choice) {
		    case 1:
			OSS_CNTX_PUSH(_oss_c, 151)
			_oss_penc_unconstr_int_l(_g, _in_data->u.reject->problem.u.general);
			break;
		    case 2:
			OSS_CNTX_PUSH(_oss_c, 152)
			_oss_penc_unconstr_int_l(_g, _in_data->u.reject->problem.u.invoke);
			break;
		    case 3:
			OSS_CNTX_PUSH(_oss_c, 153)
			_oss_penc_unconstr_int_l(_g, _in_data->u.reject->problem.u.returnResult);
			break;
		    case 4:
			OSS_CNTX_PUSH(_oss_c, 154)
			_oss_penc_unconstr_int_l(_g, _in_data->u.reject->problem.u.returnError);
			break;
		    default:
			_oss_enc_error(_g, _bad_choice, _in_data->u.reject->problem.choice);	/* Bad choice selector. */
		    }
		    OSS_CNTX_POP(_oss_c)
		}

		OSS_CNTX_POP(_oss_c)
	    }
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eCMIPAbortInfo(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CMIPAbortInfo	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_CMIPAbortInfo *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(32,155)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 156)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _edExternal(_g, _out_pos, &_out_len, &_in_data->userInfo);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x28, 0xA1);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(157)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->abortSource, 0x80);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epCMIPAbortInfo(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CMIPAbortInfo	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_CMIPAbortInfo *) _inbuf;
    OSS_CNTX_ANCHOR_SET(32,155)
    {
	OSS_CNTX_INIT

	_oss_append_1bit_unaligned(_g, (unsigned char)(_in_data->bit_mask >> 24));
	OSS_CNTX_PUSH(_oss_c, 157)
	_oss_penc_uenum(_g, _in_data->abortSource, (struct _enum_data *)&_enums[10], NULL);
	OSS_CNTX_SET(156)
	if (_in_data->bit_mask & 0x80000000) {
	    _ep_External(_g, &_in_data->userInfo);
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eCMIPUserInfo(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CMIPUserInfo	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_CMIPUserInfo *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(33,158)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 156)
	if (_in_data->bit_mask & 0x10000000) {
	    _data_len = _edExternal(_g, _out_pos, &_out_len, &_in_data->userInfo);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x28, 0xA3);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(159)
	if (_in_data->bit_mask & 0x20000000) {
	    _data_len = _edExternal(_g, _out_pos, &_out_len, &_in_data->accessControl);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x28, 0xA2);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(160)
	if (_in_data->bit_mask & 0x40000000 &&
	    _oss_not_dflt_ia(_g, &_in_data->functionalUnits, (OSSC::COssBitString  *)&_v40, 4, _VARY_OFFSET_0, -1, 3)) {
	    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->functionalUnits.value, _in_data->functionalUnits.length, -1, TRUE);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA1 : 0x81);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(161)
	if (_in_data->bit_mask & 0x80000000 &&
	    _oss_not_dflt_ia(_g, &_in_data->protocolVersion, (OSSC::COssBitString  *)&_v38, 4, _VARY_OFFSET_0, -1, 3)) {
	    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->protocolVersion.value, _in_data->protocolVersion.length, -1, TRUE);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA0 : 0x80);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epCMIPUserInfo(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CMIPUserInfo	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_CMIPUserInfo *) _inbuf;
    OSS_CNTX_ANCHOR_SET(33,158)
    {
	OSS_UINT32 _bitmask = _in_data->bit_mask;
	OSS_CNTX_INIT

#ifdef OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES
	if (_g->encodingFlags & STRICT_PER_ENCODING_OF_DEFAULT_VALUES) {
	    if ((_bitmask & 0x80000000) &&
		!_oss_not_dflt_ia(_g, &_in_data->protocolVersion, (OSSC::COssBitString  *)&_v38, 4, _VARY_OFFSET_0, -1, 3))
		_bitmask ^= 0x80000000;
	    if ((_bitmask & 0x40000000) &&
		!_oss_not_dflt_ia(_g, &_in_data->functionalUnits, (OSSC::COssBitString  *)&_v40, 4, _VARY_OFFSET_0, -1, 3))
		_bitmask ^= 0x40000000;
	}
#endif /* OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES */
	_oss_append_4bit_unaligned(_g, (unsigned char)(_bitmask >> 24));
	OSS_CNTX_PUSH(_oss_c, 161)
	if (_bitmask & 0x80000000) {
#if OSS_TOED_API_LEVEL >= 27
	    _oss_penc_uncon_bit(_g, _in_data->protocolVersion.value, _in_data->protocolVersion.length ? _oss_chop_zero_bits(_in_data->protocolVersion.value, _in_data->protocolVersion.length, 0) : _in_data->protocolVersion.length);
#else
	    _oss_penc_unconstr_bit_l(_g, _in_data->protocolVersion.value, _in_data->protocolVersion.length, TRUE);
#endif
	}
	OSS_CNTX_SET(160)
	if (_bitmask & 0x40000000) {
#if OSS_TOED_API_LEVEL >= 27
	    _oss_penc_uncon_bit(_g, _in_data->functionalUnits.value, _in_data->functionalUnits.length ? _oss_chop_zero_bits(_in_data->functionalUnits.value, _in_data->functionalUnits.length, 0) : _in_data->functionalUnits.length);
#else
	    _oss_penc_unconstr_bit_l(_g, _in_data->functionalUnits.value, _in_data->functionalUnits.length, TRUE);
#endif
	}
	OSS_CNTX_SET(159)
	if (_bitmask & 0x20000000) {
	    _ep_External(_g, &_in_data->accessControl);
	}
	OSS_CNTX_SET(156)
	if (_bitmask & 0x10000000) {
	    _ep_External(_g, &_in_data->userInfo);
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eCmipPduReceivingSupport(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssBitString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(34,162)
    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1, TRUE);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x23 : 0x3);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epCmipPduReceivingSupport(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssBitString *) _inbuf;
    OSS_CNTX_ANCHOR_SET(34,162)
#if OSS_TOED_API_LEVEL >= 27
    _oss_penc_uncon_bit(_g, _in_data->value, _in_data->length ? _oss_chop_zero_bits(_in_data->value, _in_data->length, 0) : _in_data->length);
#else
    _oss_penc_unconstr_bit_l(_g, _in_data->value, _in_data->length, TRUE);
#endif
    OSS_CNTX_POP(_oss_c)
}

static void _eCmipPduSendingSupport(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssBitString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(35,163)
    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1, TRUE);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x23 : 0x3);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epCmipPduSendingSupport(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssBitString *) _inbuf;
    OSS_CNTX_ANCHOR_SET(35,163)
#if OSS_TOED_API_LEVEL >= 27
    _oss_penc_uncon_bit(_g, _in_data->value, _in_data->length ? _oss_chop_zero_bits(_in_data->value, _in_data->length, 0) : _in_data->length);
#else
    _oss_penc_unconstr_bit_l(_g, _in_data->value, _in_data->length, TRUE);
#endif
    OSS_CNTX_POP(_oss_c)
}

static void _eCmiseFunctionalUnitsSelected(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssBitString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(36,164)
    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1, TRUE);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x23 : 0x3);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epCmiseFunctionalUnitsSelected(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssBitString *) _inbuf;
    OSS_CNTX_ANCHOR_SET(36,164)
#if OSS_TOED_API_LEVEL >= 27
    _oss_penc_uncon_bit(_g, _in_data->value, _in_data->length ? _oss_chop_zero_bits(_in_data->value, _in_data->length, 0) : _in_data->length);
#else
    _oss_penc_unconstr_bit_l(_g, _in_data->value, _in_data->length, TRUE);
#endif
    OSS_CNTX_POP(_oss_c)
}

static void _e0CmiseFunctionalUnitsSupport(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssBitString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(37,165)
    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1, TRUE);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x23 : 0x3);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep0CmiseFunctionalUnitsSupport(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssBitString *) _inbuf;
    OSS_CNTX_ANCHOR_SET(37,165)
#if OSS_TOED_API_LEVEL >= 27
    _oss_penc_uncon_bit(_g, _in_data->value, _in_data->length ? _oss_chop_zero_bits(_in_data->value, _in_data->length, 0) : _in_data->length);
#else
    _oss_penc_unconstr_bit_l(_g, _in_data->value, _in_data->length, TRUE);
#endif
    OSS_CNTX_POP(_oss_c)
}

static void _eInvokeldsOutstanding(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeldsOutstanding	**_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_InvokeldsOutstanding **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(38,166)
    {
	_InvokeldsOutstanding * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 167)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_InvokeldsOutstanding *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    if (count > 1) _oss_nextItem(_g, &_out_len);
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _temp->value, 0x2);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epInvokeldsOutstanding(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeldsOutstanding	**_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_InvokeldsOutstanding **) _inbuf;
    OSS_CNTX_ANCHOR_SET(38,166)
    {
	_InvokeldsOutstanding * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	OSS_CNTX_PUSH(_oss_c, 167)
	_ext = (_cnt >= 16384) ? 2 : 0;
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
	    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
	    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		_oss_penc_unconstr_int_l(_g, _temp->value);
	    }
	    if (_cnt == _fragm_cnt) {
		if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
		    _oss_append_8bit_aligned(_g, 0);
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eInvokeIdsPerforming(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeldsOutstanding	**_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_InvokeldsOutstanding **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(39,168)
    {
	_InvokeldsOutstanding * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 167)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_InvokeldsOutstanding *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    if (count > 1) _oss_nextItem(_g, &_out_len);
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _temp->value, 0x2);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epInvokeIdsPerforming(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeldsOutstanding	**_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_InvokeldsOutstanding **) _inbuf;
    OSS_CNTX_ANCHOR_SET(39,168)
    {
	_InvokeldsOutstanding * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	OSS_CNTX_PUSH(_oss_c, 167)
	_ext = (_cnt >= 16384) ? 2 : 0;
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
	    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
	    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		_oss_penc_unconstr_int_l(_g, _temp->value);
	    }
	    if (_cnt == _fragm_cnt) {
		if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
		    _oss_append_8bit_aligned(_g, 0);
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eMaxEncodedCmipPduReceiveSize(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(40,169)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epMaxEncodedCmipPduReceiveSize(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(40,169)
    _oss_penc_semicon_uint_l(_g, *_in_data, 0);
    OSS_CNTX_POP(_oss_c)
}

static void _eProtocolVersionSupported(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssBitString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(41,170)
    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1, TRUE);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x23 : 0x3);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epProtocolVersionSupported(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssBitString *) _inbuf;
    OSS_CNTX_ANCHOR_SET(41,170)
#if OSS_TOED_API_LEVEL >= 27
    _oss_penc_uncon_bit(_g, _in_data->value, _in_data->length ? _oss_chop_zero_bits(_in_data->value, _in_data->length, 0) : _in_data->length);
#else
    _oss_penc_unconstr_bit_l(_g, _in_data->value, _in_data->length, TRUE);
#endif
    OSS_CNTX_POP(_oss_c)
}

static void _eSmaseFunctionalUnits(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SmaseFunctionalUnits	**_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_SmaseFunctionalUnits **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(42,171)
    {
	_SmaseFunctionalUnits * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 172)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_SmaseFunctionalUnits *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    if (count > 1) _oss_nextItem(_g, &_out_len);
	    _data_len = _edFunctionalUnitPackage(_g, _out_pos, &_out_len, &_temp->value);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epSmaseFunctionalUnits(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SmaseFunctionalUnits	**_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_SmaseFunctionalUnits **) _inbuf;
    OSS_CNTX_ANCHOR_SET(42,171)
    {
	_SmaseFunctionalUnits * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	OSS_CNTX_PUSH(_oss_c, 172)
	_ext = (_cnt >= 16384) ? 2 : 0;
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
	    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
	    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		_ep_FunctionalUnitPackage(_g, &_temp->value);
	    }
	    if (_cnt == _fragm_cnt) {
		if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
		    _oss_append_8bit_aligned(_g, 0);
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eSmUserInfoSent(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SmUserInfoSent	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_SmUserInfoSent *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(43,173)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 174)
	    _data_len = 0;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x5);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 175)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.informationSent.value, _in_data->u.informationSent.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x39 : 0x19);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epSmUserInfoSent(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SmUserInfoSent	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_SmUserInfoSent *) _inbuf;
    OSS_CNTX_ANCHOR_SET(43,173)
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 2) {

	    _oss_penc_nonneg_1int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 174)
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 175)
	    _oss_penc_nkmstr_l(_g, _in_data->u.informationSent.value, _in_data->u.informationSent.length);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eSmUserInfoReceived(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SmUserInfoReceived	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_SmUserInfoReceived *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(44,176)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 177)
	    _data_len = 0;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x5);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 178)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.informationReceived.value, _in_data->u.informationReceived.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x39 : 0x19);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epSmUserInfoReceived(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SmUserInfoReceived	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_SmUserInfoReceived *) _inbuf;
    OSS_CNTX_ANCHOR_SET(44,176)
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 2) {

	    _oss_penc_nonneg_1int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 177)
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 178)
	    _oss_penc_nkmstr_l(_g, _in_data->u.informationReceived.value, _in_data->u.informationReceived.length);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eROSEInvokeIds(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeId	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_InvokeId *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(45,179)
    _data_len = _edInvokeId(_g, _out_pos, &_out_len, _in_data);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epROSEInvokeIds(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeId	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_InvokeId *) _inbuf;
    OSS_CNTX_ANCHOR_SET(45,179)
    _ep_InvokeId(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eNoInvokeId(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeId	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_InvokeId *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(46,180)
    _data_len = _edInvokeId(_g, _out_pos, &_out_len, _in_data);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epNoInvokeId(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeId	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_InvokeId *) _inbuf;
    OSS_CNTX_ANCHOR_SET(46,180)
    _ep_InvokeId(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eSMASEUserData(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SMASEUserData	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_SMASEUserData *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(47,181)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 182)
	if (_in_data->bit_mask & 0x20000000) {
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->systemsManagementUserInformation.value, _in_data->systemsManagementUserInformation.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x39 : 0x19);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(183)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->reason, 0x2);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(184)
	if (_in_data->bit_mask & 0x80000000) {
	    {
		_SmaseFunctionalUnits * _temp;
		unsigned long count;
		unsigned long _lindex;
		long _total_len = 0;
		OSS_UINT32 _sp;
		void **_st = _oss_load_enc_stack(_g, &_sp);
		OSS_CNTX_NEW(_oss_c, 172)
		for (_temp = _in_data->smfuPackages, count = 0; _temp; _temp = _temp->next) {
		    OSS_CNTX_SETOCC(count + 1)
		    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		    _st[_sp++] = _temp;
		    count++;
		}
		if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
		for (_lindex = 0; _lindex < count; _lindex++) {
		    OSS_CNTX_SETOCC(count - _lindex)
		    _temp = (_SmaseFunctionalUnits *)_st[--_sp];
		    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		    if (count > 1) _oss_nextItem(_g, &_out_len);
		    _data_len = _edFunctionalUnitPackage(_g, _out_pos, &_out_len, &_temp->value);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
		    _total_len += _data_len;
		}
		_oss_save_enc_stack(_g, _sp);
		if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epSMASEUserData(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SMASEUserData	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_SMASEUserData *) _inbuf;
    OSS_CNTX_ANCHOR_SET(47,181)
    {
	OSS_CNTX_INIT

	_oss_append_3bit_unaligned(_g, (unsigned char)(_in_data->bit_mask >> 24));
	OSS_CNTX_PUSH(_oss_c, 184)
	if (_in_data->bit_mask & 0x80000000) {
	    {
		_SmaseFunctionalUnits * _temp;
		unsigned int _fragm_cnt;
		unsigned int _cnt;
		int _ext;
		OSS_CNTX_INIT

		for (_cnt = 0, _temp = _in_data->smfuPackages; _temp; _temp = _temp->next)
		    ++_cnt;

		OSS_CNTX_PUSH(_oss_c, 172)
		_ext = (_cnt >= 16384) ? 2 : 0;
		for (_temp = _in_data->smfuPackages;; _cnt -= _fragm_cnt) {
		    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
		    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
		    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
			OSS_CNTX_INCOCC
			_ep_FunctionalUnitPackage(_g, &_temp->value);
		    }
		    if (_cnt == _fragm_cnt) {
			if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
			    _oss_append_8bit_aligned(_g, 0);
			break;
		    }
		}
		OSS_CNTX_POP(_oss_c)
	    }
	}
	OSS_CNTX_SET(183)
	if (_in_data->bit_mask & 0x40000000) {
	    _oss_penc_unconstr_int_l(_g, _in_data->reason);
	}
	OSS_CNTX_SET(182)
	if (_in_data->bit_mask & 0x20000000) {
	    _oss_penc_nkmstr_l(_g, _in_data->systemsManagementUserInformation.value, _in_data->systemsManagementUserInformation.length);
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eAccessDenied_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(48,185)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epAccessDenied_PRIORITY(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(48,185)
    if (*_in_data != 0) {
	_oss_enc_error(_g, _valueRange_uinteger, *_in_data);
    }
    OSS_CNTX_POP(_oss_c)
}

static void _e1ClassInstanceConflict_PRIOR(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(49,186)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep1ClassInstanceConflict_PRIOR(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(49,186)
    if (*_in_data != 1) {
	_oss_enc_error(_g, _valueRange_uinteger, *_in_data);
    }
    OSS_CNTX_POP(_oss_c)
}

static void _e2ComplexityLimitation_PRIORI(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(50,187)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep2ComplexityLimitation_PRIORI(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(50,187)
    if (*_in_data != 1) {
	_oss_enc_error(_g, _valueRange_uinteger, *_in_data);
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eInvalidScope_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(51,188)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epInvalidScope_PRIORITY(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(51,188)
    if (*_in_data != 1) {
	_oss_enc_error(_g, _valueRange_uinteger, *_in_data);
    }
    OSS_CNTX_POP(_oss_c)
}

static void _e3InvalidArgumentValue_PRIORI(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(52,189)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep3InvalidArgumentValue_PRIORI(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(52,189)
    if (*_in_data != 1) {
	_oss_enc_error(_g, _valueRange_uinteger, *_in_data);
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eInvalidFilter_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(53,190)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epInvalidFilter_PRIORITY(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(53,190)
    if (*_in_data != 1) {
	_oss_enc_error(_g, _valueRange_uinteger, *_in_data);
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eNoSuchAction_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(54,191)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epNoSuchAction_PRIORITY(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(54,191)
    if (*_in_data != 1) {
	_oss_enc_error(_g, _valueRange_uinteger, *_in_data);
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eNoSuchArgument_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(55,192)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epNoSuchArgument_PRIORITY(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(55,192)
    if (*_in_data != 1) {
	_oss_enc_error(_g, _valueRange_uinteger, *_in_data);
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eNoSuchObjectClass_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(56,193)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epNoSuchObjectClass_PRIORITY(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(56,193)
    if (*_in_data != 1) {
	_oss_enc_error(_g, _valueRange_uinteger, *_in_data);
    }
    OSS_CNTX_POP(_oss_c)
}

static void _e4NoSuchObjectInstance_PRIORI(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(57,194)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep4NoSuchObjectInstance_PRIORI(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(57,194)
    if (*_in_data != 1) {
	_oss_enc_error(_g, _valueRange_uinteger, *_in_data);
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eProcessingFailure_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(58,195)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epProcessingFailure_PRIORITY(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(58,195)
    if (*_in_data != 1) {
	_oss_enc_error(_g, _valueRange_uinteger, *_in_data);
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eSyncNotSupported_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(59,196)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epSyncNotSupported_PRIORITY(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(59,196)
    if (*_in_data != 1) {
	_oss_enc_error(_g, _valueRange_uinteger, *_in_data);
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eMistypedOperation_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(60,197)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epMistypedOperation_PRIORITY(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(60,197)
    if (*_in_data != 1) {
	_oss_enc_error(_g, _valueRange_uinteger, *_in_data);
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eNoSuchInvokeId_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(61,198)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epNoSuchInvokeId_PRIORITY(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(61,198)
    if (*_in_data != 1) {
	_oss_enc_error(_g, _valueRange_uinteger, *_in_data);
    }
    OSS_CNTX_POP(_oss_c)
}

static void _e5DuplicateManagedObjectInsta(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(62,199)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep5DuplicateManagedObjectInsta(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(62,199)
    if (*_in_data != 1) {
	_oss_enc_error(_g, _valueRange_uinteger, *_in_data);
    }
    OSS_CNTX_POP(_oss_c)
}

static void _e6InvalidAttributeValue_PRIOR(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(63,200)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep6InvalidAttributeValue_PRIOR(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(63,200)
    if (*_in_data != 1) {
	_oss_enc_error(_g, _valueRange_uinteger, *_in_data);
    }
    OSS_CNTX_POP(_oss_c)
}

static void _e7InvalidObjectInstance_PRIOR(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(64,201)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep7InvalidObjectInstance_PRIOR(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(64,201)
    if (*_in_data != 1) {
	_oss_enc_error(_g, _valueRange_uinteger, *_in_data);
    }
    OSS_CNTX_POP(_oss_c)
}

static void _e8MissingAttributeValue_PARAM(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _MissingAttributeValue_PARAMETER	**_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_MissingAttributeValue_PARAMETER **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(65,202)
    {
	_MissingAttributeValue_PARAMETER * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 105)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_MissingAttributeValue_PARAMETER *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    if (count > 1) _oss_nextItem(_g, &_out_len);
	    _data_len = _edAttributeId(_g, _out_pos, &_out_len, &_temp->value);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep8MissingAttributeValue_PARAM(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _MissingAttributeValue_PARAMETER	**_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_MissingAttributeValue_PARAMETER **) _inbuf;
    OSS_CNTX_ANCHOR_SET(65,202)
    {
	_MissingAttributeValue_PARAMETER * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	OSS_CNTX_PUSH(_oss_c, 105)
	_ext = (_cnt >= 16384) ? 2 : 0;
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
	    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
	    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		_ep_AttributeId(_g, &_temp->value);
	    }
	    if (_cnt == _fragm_cnt) {
		if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
		    _oss_append_8bit_aligned(_g, 0);
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _e9MissingAttributeValue_PRIOR(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(66,203)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep9MissingAttributeValue_PRIOR(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(66,203)
    if (*_in_data != 1) {
	_oss_enc_error(_g, _valueRange_uinteger, *_in_data);
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eNoSuchAttribute_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(67,204)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epNoSuchAttribute_PRIORITY(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(67,204)
    if (*_in_data != 1) {
	_oss_enc_error(_g, _valueRange_uinteger, *_in_data);
    }
    OSS_CNTX_POP(_oss_c)
}

static void _e10NoSuchReferenceObject_PRIO(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(68,205)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep10NoSuchReferenceObject_PRIO(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(68,205)
    if (*_in_data != 1) {
	_oss_enc_error(_g, _valueRange_uinteger, *_in_data);
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eNoSuchEventType_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(69,206)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epNoSuchEventType_PRIORITY(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(69,206)
    if (*_in_data != 1) {
	_oss_enc_error(_g, _valueRange_uinteger, *_in_data);
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eGetListError_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(70,207)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epGetListError_PRIORITY(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(70,207)
    if (*_in_data != 1) {
	_oss_enc_error(_g, _valueRange_uinteger, *_in_data);
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eOperationCancelled_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(71,208)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epOperationCancelled_PRIORITY(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(71,208)
    if (*_in_data != 1) {
	_oss_enc_error(_g, _valueRange_uinteger, *_in_data);
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eSetListError_PRIORITY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(72,209)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epSetListError_PRIORITY(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_UINT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(72,209)
    if (*_in_data != 1) {
	_oss_enc_error(_g, _valueRange_uinteger, *_in_data);
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eAcse_RealizationParameter(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_RealizationParameter *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(73,210)
    _data_len = _edRealizationParameter(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epAcse_RealizationParameter(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_RealizationParameter *) _inbuf;
    OSS_CNTX_ANCHOR_SET(73,210)
    _ep_RealizationParameter(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _e11Acse_with_concatenation_Re(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_RealizationParameter *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(74,211)
    _data_len = _edRealizationParameter(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep11Acse_with_concatenation_Re(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_RealizationParameter *) _inbuf;
    OSS_CNTX_ANCHOR_SET(74,211)
    _ep_RealizationParameter(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _e12Association_by_RTSE_Realiz(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_RealizationParameter *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(75,212)
    _data_len = _edRealizationParameter(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep12Association_by_RTSE_Realiz(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_RealizationParameter *) _inbuf;
    OSS_CNTX_ANCHOR_SET(75,212)
    _ep_RealizationParameter(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _ePData_RealizationParameter(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_RealizationParameter *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(76,213)
    _data_len = _edRealizationParameter(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epPData_RealizationParameter(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_RealizationParameter *) _inbuf;
    OSS_CNTX_ANCHOR_SET(76,213)
    _ep_RealizationParameter(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _e13PData_with_concatenation_R(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_RealizationParameter *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(77,214)
    _data_len = _edRealizationParameter(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep13PData_with_concatenation_R(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_RealizationParameter *) _inbuf;
    OSS_CNTX_ANCHOR_SET(77,214)
    _ep_RealizationParameter(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _e14Transfer_by_RTSE_Realizati(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_RealizationParameter *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(78,215)
    _data_len = _edRealizationParameter(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep14Transfer_by_RTSE_Realizati(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_RealizationParameter *) _inbuf;
    OSS_CNTX_ANCHOR_SET(78,215)
    _ep_RealizationParameter(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

void DLL_ENTRY_FDEF _emSMASE_A_ASSOCIATE_Informatio(struct ossGlobal * _g, int _pdunum, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char **_outbuf = &_oss_c->_oss_outbufpos;
    long *_outlen = &_oss_c->_oss_outbuflen;
    unsigned int _flags = _g->encodingFlags;
    _oss_c->_oss_context_anchor._state = _encoding_data;
    _oss_c->_oss_context_anchor._pdu_number = 0;
#if OSSDEBUG > 0
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_e_pre(_g, _pdunum, _inbuf, NULL, _oss_c->_oss_outbufpos, _oss_c->_oss_outbuflen);
#else
    _oss_c->_oss_err_msg = NULL;
#endif

    if (_pdunum < 1 || _pdunum > 78)
	_oss_enc_error(_g, _pdu_range, _pdunum);
    else
	_Encoders[_pdunum - 1](_g, _inbuf, _outbuf, _outlen, _flags);
#if OSSDEBUG > 0
    _oss_c->_oss_err_msg = NULL;
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_e_post(_g, 0, *_outbuf, *_outlen);
#endif
}

void DLL_ENTRY_FDEF _peSMASE_A_ASSOCIATE_Informatio(struct ossGlobal * _g, int _pdunum, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _oss_c->_oss_context_anchor._state = _encoding_data;
    _oss_c->_oss_context_anchor._pdu_number = 0;
#if OSSDEBUG > 0
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_e_pre(_g, _pdunum, _inbuf, NULL, _oss_c->_oss_outbufpos, _oss_c->_oss_outbuflen);
#else
    _oss_c->_oss_err_msg = NULL;
#endif

    _oss_c->_aligned = (ossBoolean)(_g->encRules == OSS_PER_ALIGNED);
    if (_pdunum < 1 || _pdunum > 78)
	_oss_enc_error(_g, _pdu_range, _pdunum);
    else
	_pEncoders[_pdunum - 1](_g, _inbuf);

#if OSSDEBUG > 0
    _oss_c->_oss_err_msg = NULL;
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_e_post(_g, 0, _oss_c->_oss_outbufpos, _oss_c->_oss_outbuflen);
#endif
}

static void _d_ActionResult(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _ActionResult * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if ((_data_tag != 0x8000 && _data_tag != 0x8001)
	    || (_total_len >= 0 && _bufpos >= _end_pos))
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->managedObjectClass, 0, sizeof(_out_data->managedObjectClass));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 3)
	    _d_ObjectClass(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->managedObjectClass);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if ((_data_tag != 0x8002 && _data_tag != 0x8003 && _data_tag != 0x8004)
	    || (_total_len >= 0 && _bufpos >= _end_pos))
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    memset(&_out_data->managedObjectInstance, 0, sizeof(_out_data->managedObjectInstance));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 2)
	    _d_ObjectInstance(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->managedObjectInstance);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8005 || _bufpos >= _end_pos)
	    _out_data->currentTime = NULL;
	else {
	    OSS_CNTX_PUSH(_oss_c, 1)
	    _out_data->currentTime = NULL;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 133 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8005) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x85 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80050000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8005;
	    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->currentTime, -1, 0);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8006 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x20000000;
	    memset(&_out_data->actionReply, 0, sizeof(_out_data->actionReply));
	}
else {
	    _out_data->bit_mask |= 0x20000000;
	    OSS_CNTX_PUSH(_oss_c, 0)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 166 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8006) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x86 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80060000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8006;
	    _d_ActionReply(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->actionReply);
	    OSS_CNTX_POP(_oss_c)
	}
	while (_bufpos < _end_pos || _total_len < 0) {
	    if (!_oss_c->_tag_decoded) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (!_data_tag)
		break;
	    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    _oss_c->_tag_decoded = FALSE;
	}
	if (_total_len < 0 && !_data_tag) {
	    if (_oss_dec_length(_g, &_bufpos, &_buflen))
		_oss_dec_error(_g, _non_std_eoc, 0L);
	    _oss_c->_tag_decoded = FALSE;
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_ActionResult(OssGlobal * _g, _ActionResult * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	unsigned char _pbase[1];
	unsigned char *_pext;
	unsigned char _extPres = 0x00;
	unsigned long _ea_count = 0;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	_extPres = _oss_get_1bit_unaligned(_g);
	*_pbase = _oss_get_4bit_unaligned(_g);
	OSS_CNTX_PUSH(_oss_c, 3)
	if (_pbase[0] & 0x80) {
	    _out_data->bit_mask |= 0x80000000;
	    _dp_ObjectClass(_g, &_out_data->managedObjectClass);
	} else {
	    memset(&(_out_data->managedObjectClass), 0, sizeof(_ActionTypeId ));
	}
	OSS_CNTX_SET(2)
	if (_pbase[0] & 0x40) {
	    _out_data->bit_mask |= 0x40000000;
	    _dp_ObjectInstance(_g, &_out_data->managedObjectInstance);
	} else {
	    memset(&(_out_data->managedObjectInstance), 0, sizeof(_ObjectInstance ));
	}
	OSS_CNTX_SET(1)
	if (_pbase[0] & 0x20) {
	    _oss_pdec_ntp_kmstr(_g, &_out_data->currentTime, _chars + 0);
	} else {
	    _out_data->currentTime = NULL;
	}
	OSS_CNTX_SET(0)
	if (_pbase[0] & 0x10) {
	    _out_data->bit_mask |= 0x20000000;
	    _dp_ActionReply(_g, &_out_data->actionReply);
	} else {
	    memset(&(_out_data->actionReply), 0, sizeof(_ActionReply ));
	}
	OSS_CNTX_POP(_oss_c)
	if (_extPres) {
	    _ea_count = _oss_pdec_eap(_g, &_pext);
	    _oss_pdec_eas(_g, _pext, _ea_count, 0);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_Attribute(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Attribute * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 5)
	_d_AttributeId(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->id);
	OSS_CNTX_SET(4)
	if (_data_length == 0) _data_length = 1;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
	_out_data->value.userField = NULL;
#endif
	_oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->value.encoded);
	_out_data->value.pduNum = 0;
	*(void **)&_out_data->value.decoded = NULL;
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_Attribute(OssGlobal * _g, _Attribute * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 5)
	_dp_AttributeId(_g, &_out_data->id);
	OSS_CNTX_SET(4)
#ifdef OSS_OPENTYPE_HAS_USERFIELD
	_out_data->value.userField = NULL;
#endif
	_out_data->value.encoded.length = _oss_pdec_unconstr_uoct_ia(_g, &_out_data->value.encoded.value);
	if (_out_data->value.encoded.length == 0 && ((STRICT_ENCODING_DECODING_RULES | AUTOMATIC_ENCDEC) & _g->decodingFlags))
	    _oss_dec_error(_g, _zero_length_OpenType, 0L);
	_out_data->value.pduNum = 0;
	*(void **)&_out_data->value.decoded = NULL;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_AttributeId(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _ActionTypeId * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	default:
	    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
	    switch (_data_tag & 0x7fff) {
	    case 0x0: {
		OSS_CNTX_PUSH(_oss_c, 6)
		_out_data->choice = 1;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.globalForm.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.globalForm.value, -1);
	    }   break;
	    case 0x1: {
		OSS_CNTX_PUSH(_oss_c, 7)
		_out_data->choice = 2;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.localForm = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    break;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_AttributeId(OssGlobal * _g, _ActionTypeId * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 6)
	    _out_data->u.globalForm.length = _oss_pdec_eobjid_ia(_g, &_out_data->u.globalForm.value, -1);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 7)
	    _out_data->u.localForm = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_CMISFilter(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _CMISFilter * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	default:
	    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
	    switch (_data_tag & 0x7fff) {
	    case 0x8: {
		OSS_CNTX_PUSH(_oss_c, 8)
		_out_data->choice = 1;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		_out_data->u.item = (_FilterItem *)_oss_dec_const_alloc(_g, sizeof(_FilterItem));
		_d_FilterItem(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.item);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
	    }   break;
	    case 0x9: {
		OSS_CNTX_PUSH(_oss_c, 9)
		_out_data->choice = 2;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_d__setof1(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.CMISFilter_and);
	    }   break;
	    case 0xA: {
		OSS_CNTX_PUSH(_oss_c, 10)
		_out_data->choice = 3;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_d__setof2(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.CMISFilter_or);
	    }   break;
	    case 0xB: {
		OSS_CNTX_PUSH(_oss_c, 11)
		_out_data->choice = 4;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		_out_data->u.CMISFilter_not = (_CMISFilter *)_oss_dec_const_alloc(_g, sizeof(_CMISFilter));
		_d_CMISFilter(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.CMISFilter_not);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    break;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_CMISFilter(OssGlobal * _g, _CMISFilter * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_2int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 8)
	    _out_data->u.item = (_FilterItem *)_oss_dec_const_alloc(_g, sizeof(_FilterItem));
	    _dp_FilterItem(_g, _out_data->u.item);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 9)
	    _dp__setof1(_g, &_out_data->u.CMISFilter_and);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 10)
	    _dp__setof2(_g, &_out_data->u.CMISFilter_or);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 11)
	    _out_data->u.CMISFilter_not = (_CMISFilter *)_oss_dec_const_alloc(_g, sizeof(_CMISFilter));
	    _dp_CMISFilter(_g, _out_data->u.CMISFilter_not);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_DeleteResult(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _DeleteResult * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if ((_data_tag != 0x8000 && _data_tag != 0x8001)
	    || (_total_len >= 0 && _bufpos >= _end_pos))
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->managedObjectClass, 0, sizeof(_out_data->managedObjectClass));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 3)
	    _d_ObjectClass(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->managedObjectClass);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if ((_data_tag != 0x8002 && _data_tag != 0x8003 && _data_tag != 0x8004)
	    || (_total_len >= 0 && _bufpos >= _end_pos))
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    memset(&_out_data->managedObjectInstance, 0, sizeof(_out_data->managedObjectInstance));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 2)
	    _d_ObjectInstance(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->managedObjectInstance);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8005 || _bufpos >= _end_pos)
	    _out_data->currentTime = NULL;
	else {
	    OSS_CNTX_PUSH(_oss_c, 1)
	    _out_data->currentTime = NULL;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 133 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8005) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x85 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80050000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8005;
	    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->currentTime, -1, 0);
	    OSS_CNTX_POP(_oss_c)
	}
	while (_bufpos < _end_pos || _total_len < 0) {
	    if (!_oss_c->_tag_decoded) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (!_data_tag)
		break;
	    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    _oss_c->_tag_decoded = FALSE;
	}
	if (_total_len < 0 && !_data_tag) {
	    if (_oss_dec_length(_g, &_bufpos, &_buflen))
		_oss_dec_error(_g, _non_std_eoc, 0L);
	    _oss_c->_tag_decoded = FALSE;
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_DeleteResult(OssGlobal * _g, _DeleteResult * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	unsigned char _pbase[1];
	unsigned char *_pext;
	unsigned char _extPres = 0x00;
	unsigned long _ea_count = 0;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	_extPres = _oss_get_1bit_unaligned(_g);
	*_pbase = _oss_get_3bit_unaligned(_g);
	OSS_CNTX_PUSH(_oss_c, 3)
	if (_pbase[0] & 0x80) {
	    _out_data->bit_mask |= 0x80000000;
	    _dp_ObjectClass(_g, &_out_data->managedObjectClass);
	} else {
	    memset(&(_out_data->managedObjectClass), 0, sizeof(_ActionTypeId ));
	}
	OSS_CNTX_SET(2)
	if (_pbase[0] & 0x40) {
	    _out_data->bit_mask |= 0x40000000;
	    _dp_ObjectInstance(_g, &_out_data->managedObjectInstance);
	} else {
	    memset(&(_out_data->managedObjectInstance), 0, sizeof(_ObjectInstance ));
	}
	OSS_CNTX_SET(1)
	if (_pbase[0] & 0x20) {
	    _oss_pdec_ntp_kmstr(_g, &_out_data->currentTime, _chars + 0);
	} else {
	    _out_data->currentTime = NULL;
	}
	OSS_CNTX_POP(_oss_c)
	if (_extPres) {
	    _ea_count = _oss_pdec_eap(_g, &_pext);
	    _oss_pdec_eas(_g, _pext, _ea_count, 0);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_GetListError(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _GetListError * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if ((_data_tag != 0x8000 && _data_tag != 0x8001)
	    || (_total_len >= 0 && _bufpos >= _end_pos))
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->managedObjectClass, 0, sizeof(_out_data->managedObjectClass));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 3)
	    _d_ObjectClass(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->managedObjectClass);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if ((_data_tag != 0x8002 && _data_tag != 0x8003 && _data_tag != 0x8004)
	    || (_total_len >= 0 && _bufpos >= _end_pos))
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    memset(&_out_data->managedObjectInstance, 0, sizeof(_out_data->managedObjectInstance));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 2)
	    _d_ObjectInstance(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->managedObjectInstance);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8005 || _bufpos >= _end_pos)
	    _out_data->currentTime = NULL;
	else {
	    OSS_CNTX_PUSH(_oss_c, 1)
	    _out_data->currentTime = NULL;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 133 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8005) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x85 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80050000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8005;
	    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->currentTime, -1, 0);
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 12)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 166 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8006) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x86 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80060000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8006;
	_d__setof6(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->getInfoList);
	OSS_CNTX_POP(_oss_c)
	while (_bufpos < _end_pos || _total_len < 0) {
	    if (!_oss_c->_tag_decoded) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (!_data_tag)
		break;
	    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    _oss_c->_tag_decoded = FALSE;
	}
	if (_total_len < 0 && !_data_tag) {
	    if (_oss_dec_length(_g, &_bufpos, &_buflen))
		_oss_dec_error(_g, _non_std_eoc, 0L);
	    _oss_c->_tag_decoded = FALSE;
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_GetListError(OssGlobal * _g, _GetListError * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	unsigned char _pbase[1];
	unsigned char *_pext;
	unsigned char _extPres = 0x00;
	unsigned long _ea_count = 0;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	_extPres = _oss_get_1bit_unaligned(_g);
	*_pbase = _oss_get_3bit_unaligned(_g);
	OSS_CNTX_PUSH(_oss_c, 3)
	if (_pbase[0] & 0x80) {
	    _out_data->bit_mask |= 0x80000000;
	    _dp_ObjectClass(_g, &_out_data->managedObjectClass);
	} else {
	    memset(&(_out_data->managedObjectClass), 0, sizeof(_ActionTypeId ));
	}
	OSS_CNTX_SET(2)
	if (_pbase[0] & 0x40) {
	    _out_data->bit_mask |= 0x40000000;
	    _dp_ObjectInstance(_g, &_out_data->managedObjectInstance);
	} else {
	    memset(&(_out_data->managedObjectInstance), 0, sizeof(_ObjectInstance ));
	}
	OSS_CNTX_SET(1)
	if (_pbase[0] & 0x20) {
	    _oss_pdec_ntp_kmstr(_g, &_out_data->currentTime, _chars + 0);
	} else {
	    _out_data->currentTime = NULL;
	}
	OSS_CNTX_SET(12)
	_dp__setof6(_g, &_out_data->getInfoList);
	OSS_CNTX_POP(_oss_c)
	if (_extPres) {
	    _ea_count = _oss_pdec_eap(_g, &_pext);
	    _oss_pdec_eas(_g, _pext, _ea_count, 0);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_GetResult(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _CreateResult * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if ((_data_tag != 0x8000 && _data_tag != 0x8001)
	    || (_total_len >= 0 && _bufpos >= _end_pos))
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->managedObjectClass, 0, sizeof(_out_data->managedObjectClass));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 3)
	    _d_ObjectClass(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->managedObjectClass);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if ((_data_tag != 0x8002 && _data_tag != 0x8003 && _data_tag != 0x8004)
	    || (_total_len >= 0 && _bufpos >= _end_pos))
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    memset(&_out_data->managedObjectInstance, 0, sizeof(_out_data->managedObjectInstance));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 2)
	    _d_ObjectInstance(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->managedObjectInstance);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8005 || _bufpos >= _end_pos)
	    _out_data->currentTime = NULL;
	else {
	    OSS_CNTX_PUSH(_oss_c, 1)
	    _out_data->currentTime = NULL;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 133 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8005) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x85 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80050000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8005;
	    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->currentTime, -1, 0);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8006 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x20000000;
	    memset(&_out_data->attributeList, 0, sizeof(_out_data->attributeList));
	}
else {
	    _out_data->bit_mask |= 0x20000000;
	    OSS_CNTX_PUSH(_oss_c, 13)
	    _out_data->attributeList = NULL;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 166 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8006) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x86 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80060000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8006;
	    _d__setof7(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->attributeList);
	    OSS_CNTX_POP(_oss_c)
	}
	while (_bufpos < _end_pos || _total_len < 0) {
	    if (!_oss_c->_tag_decoded) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (!_data_tag)
		break;
	    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    _oss_c->_tag_decoded = FALSE;
	}
	if (_total_len < 0 && !_data_tag) {
	    if (_oss_dec_length(_g, &_bufpos, &_buflen))
		_oss_dec_error(_g, _non_std_eoc, 0L);
	    _oss_c->_tag_decoded = FALSE;
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_GetResult(OssGlobal * _g, _CreateResult * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	unsigned char _pbase[1];
	unsigned char *_pext;
	unsigned char _extPres = 0x00;
	unsigned long _ea_count = 0;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	_extPres = _oss_get_1bit_unaligned(_g);
	*_pbase = _oss_get_4bit_unaligned(_g);
	OSS_CNTX_PUSH(_oss_c, 3)
	if (_pbase[0] & 0x80) {
	    _out_data->bit_mask |= 0x80000000;
	    _dp_ObjectClass(_g, &_out_data->managedObjectClass);
	} else {
	    memset(&(_out_data->managedObjectClass), 0, sizeof(_ActionTypeId ));
	}
	OSS_CNTX_SET(2)
	if (_pbase[0] & 0x40) {
	    _out_data->bit_mask |= 0x40000000;
	    _dp_ObjectInstance(_g, &_out_data->managedObjectInstance);
	} else {
	    memset(&(_out_data->managedObjectInstance), 0, sizeof(_ObjectInstance ));
	}
	OSS_CNTX_SET(1)
	if (_pbase[0] & 0x20) {
	    _oss_pdec_ntp_kmstr(_g, &_out_data->currentTime, _chars + 0);
	} else {
	    _out_data->currentTime = NULL;
	}
	OSS_CNTX_SET(13)
	_out_data->attributeList = NULL;
	if (_pbase[0] & 0x10) {
	    _out_data->bit_mask |= 0x20000000;
	    _dp__setof7(_g, &_out_data->attributeList);
	} else {
	    _out_data->attributeList = NULL;
	}
	OSS_CNTX_POP(_oss_c)
	if (_extPres) {
	    _ea_count = _oss_pdec_eap(_g, &_pext);
	    _oss_pdec_eas(_g, _pext, _ea_count, 0);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_InvalidArgumentValue(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _InvalidArgumentValue * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	default:
	    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
	    switch (_data_tag & 0x7fff) {
	    case 0x0: {
		OSS_CNTX_PUSH(_oss_c, 14)
		_out_data->choice = 1;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.actionValue = (_ActionInfo *)_oss_dec_const_alloc(_g, sizeof(_ActionInfo));
		_d_ActionInfo(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.actionValue);
	    }   break;
	    case 0x1: {
		OSS_CNTX_PUSH(_oss_c, 15)
		_out_data->choice = 2;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.eventValue = (_seq1 *)_oss_dec_const_alloc(_g, sizeof(_seq1));
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    int _indef_tags = 0;
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    OSS_CNTX_INIT

		    _out_data->u.eventValue->bit_mask = 0;
		    OSS_CNTX_PUSH(_oss_c, 17)
		    _d_EventTypeId(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.eventValue->eventType);
		    OSS_CNTX_POP(_oss_c)
		    if (_bufpos < _end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if (_data_tag != 0x8008 || _bufpos >= _end_pos)
		     {
			_out_data->u.eventValue->bit_mask &= ~0x80000000;
			memset(&_out_data->u.eventValue->eventInfo, 0, sizeof(_out_data->u.eventValue->eventInfo));
		    }
else {
			_out_data->u.eventValue->bit_mask |= 0x80000000;
			OSS_CNTX_PUSH(_oss_c, 16)
			if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 168 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else {
			    if (!_oss_c->_tag_decoded || _data_tag == 0x8008) {
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x88 : 0);
			    } else
				_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80080000);
			    _oss_c->_tag_decoded = FALSE;
			}
			_data_tag = 0x8008;
			if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
			_out_data->u.eventValue->eventInfo.userField = NULL;
#endif
			_oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.eventValue->eventInfo.encoded);
			_out_data->u.eventValue->eventInfo.pduNum = 0;
			*(void **)&_out_data->u.eventValue->eventInfo.decoded = NULL;
			while (_indef_tags > 0) {
			    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				if (!_buflen || _bufpos[0])
				    _oss_dec_error(_g, _expec_eoc, 0L);
				else
				    _oss_dec_error(_g, _non_std_eoc, 0L);
			    _indef_tags--;
			}
			OSS_CNTX_POP(_oss_c)
		    }
		    if (_bufpos != _end_pos) {
			if (_total_len < 0) {
			    if (!_oss_c->_tag_decoded)
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			    if (_data_tag)
				_oss_dec_error(_g, _expec_eoc, 0L);
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			} else
			    _oss_dec_error(_g, _inconsis_len, 0L);
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    break;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_InvalidArgumentValue(OssGlobal * _g, _InvalidArgumentValue * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 14)
	    _out_data->u.actionValue = (_ActionInfo *)_oss_dec_const_alloc(_g, sizeof(_ActionInfo));
	    _dp_ActionInfo(_g, _out_data->u.actionValue);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 15)
	    _out_data->u.eventValue = (_seq1 *)_oss_dec_const_alloc(_g, sizeof(_seq1));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_out_data->u.eventValue->bit_mask = (OSS_UINT32)_oss_get_1bit_unaligned(_g) << 24;
		OSS_CNTX_PUSH(_oss_c, 17)
		_dp_EventTypeId(_g, &_out_data->u.eventValue->eventType);
		OSS_CNTX_SET(16)
		if (_out_data->u.eventValue->bit_mask & 0x80000000) {
#ifdef OSS_OPENTYPE_HAS_USERFIELD
		    _out_data->u.eventValue->eventInfo.userField = NULL;
#endif
		    _out_data->u.eventValue->eventInfo.encoded.length = _oss_pdec_unconstr_uoct_ia(_g, &_out_data->u.eventValue->eventInfo.encoded.value);
		    if (_out_data->u.eventValue->eventInfo.encoded.length == 0 && ((STRICT_ENCODING_DECODING_RULES | AUTOMATIC_ENCDEC) & _g->decodingFlags))
			_oss_dec_error(_g, _zero_length_OpenType, 0L);
		    _out_data->u.eventValue->eventInfo.pduNum = 0;
		    *(void **)&_out_data->u.eventValue->eventInfo.decoded = NULL;
		} else {
		    memset(&(_out_data->u.eventValue->eventInfo), 0, sizeof(OSSC::COssConstrainedOpenType ));
		}
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_NoSuchArgument(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _NoSuchArgument * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	default:
	    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
	    switch (_data_tag & 0x7fff) {
	    case 0x0: {
		OSS_CNTX_PUSH(_oss_c, 18)
		_out_data->choice = 1;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.actionId = (_seq2 *)_oss_dec_const_alloc(_g, sizeof(_seq2));
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    OSS_CNTX_INIT

		    _out_data->u.actionId->bit_mask = 0;
		    if (_bufpos < _end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if ((_data_tag != 0x8000 && _data_tag != 0x8001)
			|| (_total_len >= 0 && _bufpos >= _end_pos))
		     {
			_out_data->u.actionId->bit_mask &= ~0x80000000;
			memset(&_out_data->u.actionId->managedObjectClass, 0, sizeof(_out_data->u.actionId->managedObjectClass));
		    }
else {
			_out_data->u.actionId->bit_mask |= 0x80000000;
			OSS_CNTX_PUSH(_oss_c, 3)
			_d_ObjectClass(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.actionId->managedObjectClass);
			OSS_CNTX_POP(_oss_c)
		    }
		    OSS_CNTX_PUSH(_oss_c, 19)
		    _d_ActionTypeId(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.actionId->actionType);
		    OSS_CNTX_POP(_oss_c)
		    if (_bufpos != _end_pos) {
			if (_total_len < 0) {
			    if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
				_buflen--;
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			    if (_data_tag)
				_oss_dec_error(_g, _expec_eoc, 0L);
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			} else
			    _oss_dec_error(_g, _inconsis_len, 0L);
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    }   break;
	    case 0x1: {
		OSS_CNTX_PUSH(_oss_c, 20)
		_out_data->choice = 2;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.eventId = (_seq3 *)_oss_dec_const_alloc(_g, sizeof(_seq3));
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    OSS_CNTX_INIT

		    _out_data->u.eventId->bit_mask = 0;
		    if (_bufpos < _end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if ((_data_tag != 0x8000 && _data_tag != 0x8001)
			|| (_total_len >= 0 && _bufpos >= _end_pos))
		     {
			_out_data->u.eventId->bit_mask &= ~0x80000000;
			memset(&_out_data->u.eventId->managedObjectClass, 0, sizeof(_out_data->u.eventId->managedObjectClass));
		    }
else {
			_out_data->u.eventId->bit_mask |= 0x80000000;
			OSS_CNTX_PUSH(_oss_c, 3)
			_d_ObjectClass(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.eventId->managedObjectClass);
			OSS_CNTX_POP(_oss_c)
		    }
		    OSS_CNTX_PUSH(_oss_c, 17)
		    _d_EventTypeId(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.eventId->eventType);
		    OSS_CNTX_POP(_oss_c)
		    if (_bufpos != _end_pos) {
			if (_total_len < 0) {
			    if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
				_buflen--;
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			    if (_data_tag)
				_oss_dec_error(_g, _expec_eoc, 0L);
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			} else
			    _oss_dec_error(_g, _inconsis_len, 0L);
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    break;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_NoSuchArgument(OssGlobal * _g, _NoSuchArgument * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 18)
	    _out_data->u.actionId = (_seq2 *)_oss_dec_const_alloc(_g, sizeof(_seq2));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_out_data->u.actionId->bit_mask = (OSS_UINT32)_oss_get_1bit_unaligned(_g) << 24;
		OSS_CNTX_PUSH(_oss_c, 3)
		if (_out_data->u.actionId->bit_mask & 0x80000000) {
		    _dp_ObjectClass(_g, &_out_data->u.actionId->managedObjectClass);
		} else {
		    memset(&(_out_data->u.actionId->managedObjectClass), 0, sizeof(_ActionTypeId ));
		}
		OSS_CNTX_SET(19)
		_dp_ActionTypeId(_g, &_out_data->u.actionId->actionType);
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 20)
	    _out_data->u.eventId = (_seq3 *)_oss_dec_const_alloc(_g, sizeof(_seq3));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_out_data->u.eventId->bit_mask = (OSS_UINT32)_oss_get_1bit_unaligned(_g) << 24;
		OSS_CNTX_PUSH(_oss_c, 3)
		if (_out_data->u.eventId->bit_mask & 0x80000000) {
		    _dp_ObjectClass(_g, &_out_data->u.eventId->managedObjectClass);
		} else {
		    memset(&(_out_data->u.eventId->managedObjectClass), 0, sizeof(_ActionTypeId ));
		}
		OSS_CNTX_SET(17)
		_dp_EventTypeId(_g, &_out_data->u.eventId->eventType);
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_ObjectClass(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _ActionTypeId * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	default:
	    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
	    switch (_data_tag & 0x7fff) {
	    case 0x0: {
		OSS_CNTX_PUSH(_oss_c, 6)
		_out_data->choice = 1;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.globalForm.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.globalForm.value, -1);
	    }   break;
	    case 0x1: {
		OSS_CNTX_PUSH(_oss_c, 7)
		_out_data->choice = 2;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.localForm = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    break;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_ObjectClass(OssGlobal * _g, _ActionTypeId * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 6)
	    _out_data->u.globalForm.length = _oss_pdec_eobjid_ia(_g, &_out_data->u.globalForm.value, -1);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 7)
	    _out_data->u.localForm = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_ObjectInstance(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _ObjectInstance * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	default:
	    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
	    switch (_data_tag & 0x7fff) {
	    case 0x2: {
		OSS_CNTX_PUSH(_oss_c, 21)
		_out_data->choice = 1;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_d_RDNSequence(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.distinguishedName);
	    }   break;
	    case 0x3: {
		OSS_CNTX_PUSH(_oss_c, 22)
		_out_data->choice = 2;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.nonSpecificForm.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.nonSpecificForm.value, 0);
	    }   break;
	    case 0x4: {
		OSS_CNTX_PUSH(_oss_c, 23)
		_out_data->choice = 3;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_d_RDNSequence(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.localDistinguishedName);
	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    break;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_ObjectInstance(OssGlobal * _g, _ObjectInstance * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_2int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 21)
	    _dp_RDNSequence(_g, &_out_data->u.distinguishedName);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 22)
	    _out_data->u.nonSpecificForm.length = _oss_pdec_unconstr_uoct_ia(_g, (unsigned char **)&_out_data->u.nonSpecificForm.value);

	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 23)
	    _dp_RDNSequence(_g, &_out_data->u.localDistinguishedName);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_ProcessingFailure(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _ProcessingFailure * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 3)
	_d_ObjectClass(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->managedObjectClass);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if ((_data_tag != 0x8002 && _data_tag != 0x8003 && _data_tag != 0x8004)
	    || (_total_len >= 0 && _bufpos >= _end_pos))
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->managedObjectInstance, 0, sizeof(_out_data->managedObjectInstance));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 2)
	    _d_ObjectInstance(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->managedObjectInstance);
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 24)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 165 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8005) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x85 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80050000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8005;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 26)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x6) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x6 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x60000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x6;
	    _out_data->specificErrorInfo.errorId.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->specificErrorInfo.errorId.value, -1);
	    OSS_CNTX_SET(25)
	    if (_data_length == 0) _data_length = 1;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
	    _out_data->specificErrorInfo.errorInfo.userField = NULL;
#endif
	    _oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->specificErrorInfo.errorInfo.encoded);
	    _out_data->specificErrorInfo.errorInfo.pduNum = 0;
	    *(void **)&_out_data->specificErrorInfo.errorInfo.decoded = NULL;
	    OSS_CNTX_POP(_oss_c)
	    if (_bufpos != _end_pos) {
		if (_total_len < 0) {
		    if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
			_buflen--;
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		    if (_data_tag)
			_oss_dec_error(_g, _expec_eoc, 0L);
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		} else
		    _oss_dec_error(_g, _inconsis_len, 0L);
	    }
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	while (_bufpos < _end_pos || _total_len < 0) {
	    if (!_oss_c->_tag_decoded) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (!_data_tag)
		break;
	    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    _oss_c->_tag_decoded = FALSE;
	}
	if (_total_len < 0 && !_data_tag) {
	    if (_oss_dec_length(_g, &_bufpos, &_buflen))
		_oss_dec_error(_g, _non_std_eoc, 0L);
	    _oss_c->_tag_decoded = FALSE;
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_ProcessingFailure(OssGlobal * _g, _ProcessingFailure * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	unsigned char *_pext;
	unsigned char _extPres = 0x00;
	unsigned long _ea_count = 0;
	OSS_CNTX_INIT

	_extPres = _oss_get_1bit_unaligned(_g);
	_out_data->bit_mask = (OSS_UINT32)_oss_get_1bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 3)
	_dp_ObjectClass(_g, &_out_data->managedObjectClass);
	OSS_CNTX_SET(2)
	if (_out_data->bit_mask & 0x80000000) {
	    _dp_ObjectInstance(_g, &_out_data->managedObjectInstance);
	} else {
	    memset(&(_out_data->managedObjectInstance), 0, sizeof(_ObjectInstance ));
	}
	OSS_CNTX_SET(24)
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 26)
	    _out_data->specificErrorInfo.errorId.length = _oss_pdec_eobjid_ia(_g, &_out_data->specificErrorInfo.errorId.value, -1);
	    OSS_CNTX_SET(25)
#ifdef OSS_OPENTYPE_HAS_USERFIELD
	    _out_data->specificErrorInfo.errorInfo.userField = NULL;
#endif
	    _out_data->specificErrorInfo.errorInfo.encoded.length = _oss_pdec_unconstr_uoct_ia(_g, &_out_data->specificErrorInfo.errorInfo.encoded.value);
	    if (_out_data->specificErrorInfo.errorInfo.encoded.length == 0 && ((STRICT_ENCODING_DECODING_RULES | AUTOMATIC_ENCDEC) & _g->decodingFlags))
		_oss_dec_error(_g, _zero_length_OpenType, 0L);
	    _out_data->specificErrorInfo.errorInfo.pduNum = 0;
	    *(void **)&_out_data->specificErrorInfo.errorInfo.decoded = NULL;
	    OSS_CNTX_POP(_oss_c)
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
	if (_extPres) {
	    _ea_count = _oss_pdec_eap(_g, &_pext);
	    _oss_pdec_eas(_g, _pext, _ea_count, 0);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_Scope(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Scope * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	case 0x2: {
	    OSS_CNTX_PUSH(_oss_c, 27)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.namedNumbers = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	}   break;
	default:
	    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
	    switch (_data_tag & 0x7fff) {
	    case 0x1: {
		OSS_CNTX_PUSH(_oss_c, 28)
		_out_data->choice = 2;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.individualLevels = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	    }   break;
	    case 0x2: {
		OSS_CNTX_PUSH(_oss_c, 29)
		_out_data->choice = 3;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.baseToNthLevel = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    break;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_Scope(OssGlobal * _g, _Scope * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_2int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 27)
	    _out_data->u.namedNumbers = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 28)
	    _out_data->u.individualLevels = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 29)
	    _out_data->u.baseToNthLevel = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_SetListError(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _SetListError * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if ((_data_tag != 0x8000 && _data_tag != 0x8001)
	    || (_total_len >= 0 && _bufpos >= _end_pos))
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->managedObjectClass, 0, sizeof(_out_data->managedObjectClass));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 3)
	    _d_ObjectClass(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->managedObjectClass);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if ((_data_tag != 0x8002 && _data_tag != 0x8003 && _data_tag != 0x8004)
	    || (_total_len >= 0 && _bufpos >= _end_pos))
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    memset(&_out_data->managedObjectInstance, 0, sizeof(_out_data->managedObjectInstance));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 2)
	    _d_ObjectInstance(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->managedObjectInstance);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8005 || _bufpos >= _end_pos)
	    _out_data->currentTime = NULL;
	else {
	    OSS_CNTX_PUSH(_oss_c, 1)
	    _out_data->currentTime = NULL;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 133 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8005) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x85 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80050000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8005;
	    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->currentTime, -1, 0);
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 30)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 166 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8006) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x86 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80060000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8006;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _setof9 * _temp = (_setof9 *)&_out_data->setInfoList;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	    unsigned long count = 0;
#endif
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 31)
	    for (;;) {
		if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos > _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
		count++;
#endif
		_temp->next = (_setof9 *)_oss_dec_const_alloc(_g, sizeof(_setof9));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(count)
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    OSS_CNTX_INIT

		    switch (_data_tag) {
		    default:
			if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
			switch (_data_tag & 0x7fff) {
			case 0x0: {
			    OSS_CNTX_PUSH(_oss_c, 32)
			    _temp->value.choice = 1;

			    _oss_c->_tag_decoded = FALSE;
			    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				_buflen--;
				_bufpos++;
			    } else
				_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			    _temp->value.u.attributeError = (_AttributeError *)_oss_dec_const_alloc(_g, sizeof(_AttributeError));
#ifndef OSS_NO_NESTING_CONTROL
			    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				    _oss_c->reserved.fields.ext->seqSetNestingLimit)
				_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			    {
				long _total_len = _data_length;
				char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
				OSS_CNTX_INIT

				_temp->value.u.attributeError->bit_mask = 0;
				OSS_CNTX_PUSH(_oss_c, 36)
				if (_buflen >= 2 && (unsigned char)_bufpos[0] == 10 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0xA);
				_data_tag = 0xA;
				_temp->value.u.attributeError->errorStatus = (enum _enum3 )_oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
				OSS_CNTX_POP(_oss_c)
				if (_bufpos < _end_pos) {
				    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
					_buflen--;
					_oss_c->_bitpos = _bufpos[0] & 0x20;
					_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
					_bufpos++;
				    } else
					_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
				    _oss_c->_tag_decoded = TRUE;
				}
				if (_data_tag != 0x8002 || _bufpos >= _end_pos)
				 {
				    _temp->value.u.attributeError->bit_mask &= ~0x80000000;
				}
else {
				    _temp->value.u.attributeError->bit_mask |= 0x80000000;
				    OSS_CNTX_PUSH(_oss_c, 35)
				    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 130 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
					_buflen -= 2;
					_bufpos += 2;
				    } else {
					if (!_oss_c->_tag_decoded || _data_tag == 0x8002) {
					    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x82 : 0);
					} else
					    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80020000);
					_oss_c->_tag_decoded = FALSE;
				    }
				    _data_tag = 0x8002;
				    _temp->value.u.attributeError->modifyOperator = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
				    OSS_CNTX_POP(_oss_c)
				}
				OSS_CNTX_PUSH(_oss_c, 34)
				_d_AttributeId(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value.u.attributeError->attributeId);
				OSS_CNTX_POP(_oss_c)
				if (_total_len < 0) {
				    if (*_bufpos == 0) {
					if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
					    _buflen--;
					    _oss_c->_bitpos = _bufpos[0] & 0x20;
					    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
					    _bufpos++;
					} else
					    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
					_oss_c->_tag_decoded = TRUE;
				    } else
					_data_tag = 1;
				}
				if (_bufpos >= _end_pos || (_total_len < 0 && _data_tag == 0))
				 {
				    _temp->value.u.attributeError->bit_mask &= ~0x40000000;
				    memset(&_temp->value.u.attributeError->attributeValue, 0, sizeof(_temp->value.u.attributeError->attributeValue));
				}
else {
				    _temp->value.u.attributeError->bit_mask |= 0x40000000;
				    OSS_CNTX_PUSH(_oss_c, 33)
				    if (_data_length == 0) _data_length = 1;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
				    _temp->value.u.attributeError->attributeValue.userField = NULL;
#endif
				    _oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_temp->value.u.attributeError->attributeValue.encoded);
				    _temp->value.u.attributeError->attributeValue.pduNum = 0;
				    *(void **)&_temp->value.u.attributeError->attributeValue.decoded = NULL;
				    OSS_CNTX_POP(_oss_c)
				}
				if (_bufpos != _end_pos) {
				    if (_total_len < 0) {
					if (!_oss_c->_tag_decoded)
					    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

					if (_data_tag)
					    _oss_dec_error(_g, _expec_eoc, 0L);
					if (_oss_dec_length(_g, &_bufpos, &_buflen))
					    _oss_dec_error(_g, _non_std_eoc, 0L);
					_oss_c->_tag_decoded = FALSE;
				    } else
					_oss_dec_error(_g, _inconsis_len, 0L);
				}
			    }
#ifndef OSS_NO_NESTING_CONTROL
			    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
				_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			}   break;
			case 0x1: {
			    OSS_CNTX_PUSH(_oss_c, 37)
			    _temp->value.choice = 2;

			    _oss_c->_tag_decoded = FALSE;
			    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				_buflen--;
				_bufpos++;
			    } else
				_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			    _temp->value.u.attribute = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
			    _d_Attribute(_g, &_bufpos, &_buflen, _data_length, _data_tag, _temp->value.u.attribute);
			}   break;
			default:
			    _oss_dec_error(_g, _unknown_field, _data_tag);
			}
			break;
		    }
		    OSS_CNTX_POP(_oss_c)
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    }
	    _temp->next = NULL;
	    OSS_CNTX_POP(_oss_c)
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
	while (_bufpos < _end_pos || _total_len < 0) {
	    if (!_oss_c->_tag_decoded) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (!_data_tag)
		break;
	    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    _oss_c->_tag_decoded = FALSE;
	}
	if (_total_len < 0 && !_data_tag) {
	    if (_oss_dec_length(_g, &_bufpos, &_buflen))
		_oss_dec_error(_g, _non_std_eoc, 0L);
	    _oss_c->_tag_decoded = FALSE;
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_SetListError(OssGlobal * _g, _SetListError * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	unsigned char _pbase[1];
	unsigned char *_pext;
	unsigned char _extPres = 0x00;
	unsigned long _ea_count = 0;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	_extPres = _oss_get_1bit_unaligned(_g);
	*_pbase = _oss_get_3bit_unaligned(_g);
	OSS_CNTX_PUSH(_oss_c, 3)
	if (_pbase[0] & 0x80) {
	    _out_data->bit_mask |= 0x80000000;
	    _dp_ObjectClass(_g, &_out_data->managedObjectClass);
	} else {
	    memset(&(_out_data->managedObjectClass), 0, sizeof(_ActionTypeId ));
	}
	OSS_CNTX_SET(2)
	if (_pbase[0] & 0x40) {
	    _out_data->bit_mask |= 0x40000000;
	    _dp_ObjectInstance(_g, &_out_data->managedObjectInstance);
	} else {
	    memset(&(_out_data->managedObjectInstance), 0, sizeof(_ObjectInstance ));
	}
	OSS_CNTX_SET(1)
	if (_pbase[0] & 0x20) {
	    _oss_pdec_ntp_kmstr(_g, &_out_data->currentTime, _chars + 0);
	} else {
	    _out_data->currentTime = NULL;
	}
	OSS_CNTX_SET(30)
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _setof9 * _temp = (_setof9 *)&_out_data->setInfoList;
	    unsigned long count = 0;
	    ossBoolean _last = FALSE;
	    unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    unsigned long _prev_fragm0 = 0;
#endif

	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 31)
	    while (!_last) {
		count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		    if ((!_last) && _index && (_prev_fragm0 < 65536))
			_oss_dec_error(_g, _invalid_fragmentation, 0L);
		    _prev_fragm0 = count - _index;
		}
#endif
		for (; (unsigned long)_index < count; _index++) {
		    _temp->next = (_setof9 *)_oss_dec_const_alloc(_g, sizeof(_setof9));
		    _temp = _temp->next;
		    OSS_CNTX_SETOCC(_index + 1)
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			OSS_CNTX_INIT

			{

			    _temp->value.choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
			}
			switch (_temp->value.choice) {
			case 1:
			    OSS_CNTX_PUSH(_oss_c, 32)
			    _temp->value.u.attributeError = (_AttributeError *)_oss_dec_const_alloc(_g, sizeof(_AttributeError));
#ifndef OSS_NO_NESTING_CONTROL
			    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				    _oss_c->reserved.fields.ext->seqSetNestingLimit)
				_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			    {
				OSS_CNTX_INIT

				_temp->value.u.attributeError->bit_mask = (OSS_UINT32)_oss_get_2bit_unaligned(_g) << 24;
				OSS_CNTX_PUSH(_oss_c, 36)
				_temp->value.u.attributeError->errorStatus = (enum _enum3)_oss_pdec_enum(_g, (struct _enum_data*)&_enums[0], (struct _enum_data*)&_enums[1]);
				OSS_CNTX_SET(35)
				if (_temp->value.u.attributeError->bit_mask & 0x80000000) {
				    _temp->value.u.attributeError->modifyOperator = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
				}
				OSS_CNTX_SET(34)
				_dp_AttributeId(_g, &_temp->value.u.attributeError->attributeId);
				OSS_CNTX_SET(33)
				if (_temp->value.u.attributeError->bit_mask & 0x40000000) {
#ifdef OSS_OPENTYPE_HAS_USERFIELD
				    _temp->value.u.attributeError->attributeValue.userField = NULL;
#endif
				    _temp->value.u.attributeError->attributeValue.encoded.length = _oss_pdec_unconstr_uoct_ia(_g, &_temp->value.u.attributeError->attributeValue.encoded.value);
				    if (_temp->value.u.attributeError->attributeValue.encoded.length == 0 && ((STRICT_ENCODING_DECODING_RULES | AUTOMATIC_ENCDEC) & _g->decodingFlags))
					_oss_dec_error(_g, _zero_length_OpenType, 0L);
				    _temp->value.u.attributeError->attributeValue.pduNum = 0;
				    *(void **)&_temp->value.u.attributeError->attributeValue.decoded = NULL;
				} else {
				    memset(&(_temp->value.u.attributeError->attributeValue), 0, sizeof(OSSC::COssConstrainedOpenType ));
				}
				OSS_CNTX_POP(_oss_c)
			    }
#ifndef OSS_NO_NESTING_CONTROL
			    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
				_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			    break;
			case 2:
			    OSS_CNTX_PUSH(_oss_c, 37)
			    _temp->value.u.attribute = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
			    _dp_Attribute(_g, _temp->value.u.attribute);
			    break;
			default:
			    _oss_enc_error(_g, _bad_choice, _temp->value.choice);	/* Bad choice selector. */
			}
			OSS_CNTX_POP(_oss_c)
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    _temp->next = NULL;
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
	if (_extPres) {
	    _ea_count = _oss_pdec_eap(_g, &_pext);
	    _oss_pdec_eas(_g, _pext, _ea_count, 0);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_SetResult(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _CreateResult * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if ((_data_tag != 0x8000 && _data_tag != 0x8001)
	    || (_total_len >= 0 && _bufpos >= _end_pos))
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->managedObjectClass, 0, sizeof(_out_data->managedObjectClass));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 3)
	    _d_ObjectClass(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->managedObjectClass);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if ((_data_tag != 0x8002 && _data_tag != 0x8003 && _data_tag != 0x8004)
	    || (_total_len >= 0 && _bufpos >= _end_pos))
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    memset(&_out_data->managedObjectInstance, 0, sizeof(_out_data->managedObjectInstance));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 2)
	    _d_ObjectInstance(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->managedObjectInstance);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8005 || _bufpos >= _end_pos)
	    _out_data->currentTime = NULL;
	else {
	    OSS_CNTX_PUSH(_oss_c, 1)
	    _out_data->currentTime = NULL;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 133 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8005) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x85 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80050000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8005;
	    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->currentTime, -1, 0);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8006 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x20000000;
	    memset(&_out_data->attributeList, 0, sizeof(_out_data->attributeList));
	}
else {
	    _out_data->bit_mask |= 0x20000000;
	    OSS_CNTX_PUSH(_oss_c, 13)
	    _out_data->attributeList = NULL;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 166 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8006) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x86 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80060000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8006;
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_setof3 * _temp = (_setof3 *)&_out_data->attributeList;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
		unsigned long count = 0;
#endif
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 38)
		for (;;) {
		    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos > _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
		    count++;
#endif
		    if (_data_tag != 0x10)
			_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		    _temp->next = (_setof3 *)_oss_dec_const_alloc(_g, sizeof(_setof3));
		    _temp = _temp->next;
		    OSS_CNTX_SETOCC(count)
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _d_Attribute(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
		}
		_temp->next = NULL;
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    OSS_CNTX_POP(_oss_c)
	}
	while (_bufpos < _end_pos || _total_len < 0) {
	    if (!_oss_c->_tag_decoded) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (!_data_tag)
		break;
	    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    _oss_c->_tag_decoded = FALSE;
	}
	if (_total_len < 0 && !_data_tag) {
	    if (_oss_dec_length(_g, &_bufpos, &_buflen))
		_oss_dec_error(_g, _non_std_eoc, 0L);
	    _oss_c->_tag_decoded = FALSE;
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_SetResult(OssGlobal * _g, _CreateResult * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	unsigned char _pbase[1];
	unsigned char *_pext;
	unsigned char _extPres = 0x00;
	unsigned long _ea_count = 0;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	_extPres = _oss_get_1bit_unaligned(_g);
	*_pbase = _oss_get_4bit_unaligned(_g);
	OSS_CNTX_PUSH(_oss_c, 3)
	if (_pbase[0] & 0x80) {
	    _out_data->bit_mask |= 0x80000000;
	    _dp_ObjectClass(_g, &_out_data->managedObjectClass);
	} else {
	    memset(&(_out_data->managedObjectClass), 0, sizeof(_ActionTypeId ));
	}
	OSS_CNTX_SET(2)
	if (_pbase[0] & 0x40) {
	    _out_data->bit_mask |= 0x40000000;
	    _dp_ObjectInstance(_g, &_out_data->managedObjectInstance);
	} else {
	    memset(&(_out_data->managedObjectInstance), 0, sizeof(_ObjectInstance ));
	}
	OSS_CNTX_SET(1)
	if (_pbase[0] & 0x20) {
	    _oss_pdec_ntp_kmstr(_g, &_out_data->currentTime, _chars + 0);
	} else {
	    _out_data->currentTime = NULL;
	}
	OSS_CNTX_SET(13)
	_out_data->attributeList = NULL;
	if (_pbase[0] & 0x10) {
	    _out_data->bit_mask |= 0x20000000;
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_setof3 * _temp = (_setof3 *)&_out_data->attributeList;
		unsigned long count = 0;
		ossBoolean _last = FALSE;
		unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		unsigned long _prev_fragm0 = 0;
#endif

		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 38)
		while (!_last) {
		    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
			if ((!_last) && _index && (_prev_fragm0 < 65536))
			    _oss_dec_error(_g, _invalid_fragmentation, 0L);
			_prev_fragm0 = count - _index;
		    }
#endif
		    for (; (unsigned long)_index < count; _index++) {
			_temp->next = (_setof3 *)_oss_dec_const_alloc(_g, sizeof(_setof3));
			_temp = _temp->next;
			OSS_CNTX_SETOCC(_index + 1)
			_dp_Attribute(_g, &_temp->value);
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		_temp->next = NULL;
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	} else {
	    _out_data->attributeList = NULL;
	}
	OSS_CNTX_POP(_oss_c)
	if (_extPres) {
	    _ea_count = _oss_pdec_eap(_g, &_pext);
	    _oss_pdec_eas(_g, _pext, _ea_count, 0);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d__choice1(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _choice1 * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	default:
	    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
	    switch (_data_tag & 0x7fff) {
	    case 0x0: {
		OSS_CNTX_PUSH(_oss_c, 39)
		_out_data->choice = 1;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
		_out_data->u.single_ASN1_type.userField = NULL;
#endif
		_oss_dec_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.single_ASN1_type);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
	    }   break;
	    case 0x1: {
		OSS_CNTX_PUSH(_oss_c, 40)
		_out_data->choice = 2;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.octet_aligned.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.octet_aligned.value, 0);
	    }   break;
	    case 0x2: {
		OSS_CNTX_PUSH(_oss_c, 41)
		_out_data->choice = 3;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.arbitrary.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.arbitrary.value, 0, 0);

	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    break;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp__choice1(OssGlobal * _g, _choice1 * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_2int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 39)
#ifdef OSS_OPENTYPE_HAS_USERFIELD
	    _out_data->u.single_ASN1_type.userField = NULL;
#endif
	    _oss_pdec_opentype(_g, &_out_data->u.single_ASN1_type);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 40)
	    _out_data->u.octet_aligned.length = _oss_pdec_unconstr_uoct_ia(_g, (unsigned char **)&_out_data->u.octet_aligned.value);

	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 41)
	    _out_data->u.arbitrary.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->u.arbitrary.value);

	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_External(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _External * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x6 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->direct_reference, 0, sizeof(_out_data->direct_reference));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 45)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x6) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x6 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x60000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x6;
	    _out_data->direct_reference.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->direct_reference.value, -1);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x2 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 44)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x2) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x2 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x20000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x2;
	    _out_data->indirect_reference = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x7 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x20000000;
	    memset(&_out_data->data_value_descriptor, 0, sizeof(_out_data->data_value_descriptor));
	}
else {
	    _out_data->bit_mask |= 0x20000000;
	    OSS_CNTX_PUSH(_oss_c, 43)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 7 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x7) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x7 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x70000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x7;
	    _out_data->data_value_descriptor.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->data_value_descriptor.value, 0);
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 42)
	_d__choice1(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->encoding);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_External(OssGlobal * _g, _External * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_3bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 45)
	if (_out_data->bit_mask & 0x80000000) {
	    _out_data->direct_reference.length = _oss_pdec_eobjid_ia(_g, &_out_data->direct_reference.value, -1);
	} else {
	    _out_data->direct_reference.length = 0;
	    _out_data->direct_reference.value = NULL;
	}
	OSS_CNTX_SET(44)
	if (_out_data->bit_mask & 0x40000000) {
	    _out_data->indirect_reference = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	}
	OSS_CNTX_SET(43)
	if (_out_data->bit_mask & 0x20000000) {
	    _out_data->data_value_descriptor.length = _oss_pdec_ub_nkmstr_ia(_g, &_out_data->data_value_descriptor.value);

	} else {
	    _out_data->data_value_descriptor.length = 0;
	    _out_data->data_value_descriptor.value = NULL;
	}
	OSS_CNTX_SET(42)
	_dp__choice1(_g, &_out_data->encoding);
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_ActionTypeId(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _ActionTypeId * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	default:
	    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
	    switch (_data_tag & 0x7fff) {
	    case 0x2: {
		OSS_CNTX_PUSH(_oss_c, 6)
		_out_data->choice = 1;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.globalForm.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.globalForm.value, -1);
	    }   break;
	    case 0x3: {
		OSS_CNTX_PUSH(_oss_c, 7)
		_out_data->choice = 2;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.localForm = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    break;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_ActionTypeId(OssGlobal * _g, _ActionTypeId * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 6)
	    _out_data->u.globalForm.length = _oss_pdec_eobjid_ia(_g, &_out_data->u.globalForm.value, -1);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 7)
	    _out_data->u.localForm = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_EventTypeId(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _ActionTypeId * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	default:
	    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
	    switch (_data_tag & 0x7fff) {
	    case 0x6: {
		OSS_CNTX_PUSH(_oss_c, 6)
		_out_data->choice = 1;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.globalForm.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.globalForm.value, -1);
	    }   break;
	    case 0x7: {
		OSS_CNTX_PUSH(_oss_c, 7)
		_out_data->choice = 2;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.localForm = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    break;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_EventTypeId(OssGlobal * _g, _ActionTypeId * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 6)
	    _out_data->u.globalForm.length = _oss_pdec_eobjid_ia(_g, &_out_data->u.globalForm.value, -1);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 7)
	    _out_data->u.localForm = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d__setof2(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _setof1 ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_setof1 * _temp = (_setof1 *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 46)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    _temp->next = (_setof1 *)_oss_dec_const_alloc(_g, sizeof(_setof1));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
	    _d_CMISFilter(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
	}
	_temp->next = NULL;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp__setof2(OssGlobal * _g, _setof1 ** _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_setof1 * _temp = (_setof1 *)_out_data;
	unsigned long count = 0;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 46)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_setof1 *)_oss_dec_const_alloc(_g, sizeof(_setof1));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
		_dp_CMISFilter(_g, &_temp->value);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = NULL;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d__setof1(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _setof1 ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_setof1 * _temp = (_setof1 *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 46)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    _temp->next = (_setof1 *)_oss_dec_const_alloc(_g, sizeof(_setof1));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
	    _d_CMISFilter(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
	}
	_temp->next = NULL;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp__setof1(OssGlobal * _g, _setof1 ** _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_setof1 * _temp = (_setof1 *)_out_data;
	unsigned long count = 0;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 46)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_setof1 *)_oss_dec_const_alloc(_g, sizeof(_setof1));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
		_dp_CMISFilter(_g, &_temp->value);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = NULL;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_RealizationParameter(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _RealizationParameter * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 48)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 10 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0xA) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0xA : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0xA0000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0xA;
	_out_data->realization_type = (enum _enum1 )_oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x1 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->concatenation, &__shared8::default_concatenation, sizeof(__shared8::default_concatenation));
#else
	    _out_data->concatenation = 0;
#endif
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 47)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 1 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x1) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x1 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x10000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x1;
	    _out_data->concatenation = _oss_dec_bool(_g, &_bufpos, &_buflen, _data_length);
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_RealizationParameter(OssGlobal * _g, _RealizationParameter * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_1bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 48)
	_out_data->realization_type = (enum _enum1)_oss_pdec_uenum(_g, (struct _enum_data*)&_enums[2], NULL);
	OSS_CNTX_SET(47)
	if (_out_data->bit_mask & 0x80000000) {
	    _out_data->concatenation = _oss_get_1bit_unaligned(_g) ? TRUE : FALSE;
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->concatenation, &__shared8::default_concatenation, sizeof(__shared8::default_concatenation));
#else
	    _out_data->concatenation = 0;
#endif
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_ActionInfo(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _ActionInfo * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 19)
	_d_ActionTypeId(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->actionType);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8004 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->actionInfoArg, 0, sizeof(_out_data->actionInfoArg));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 49)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 164 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8004) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x84 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80040000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8004;
	    if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
	    _out_data->actionInfoArg.userField = NULL;
#endif
	    _oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->actionInfoArg.encoded);
	    _out_data->actionInfoArg.pduNum = 0;
	    *(void **)&_out_data->actionInfoArg.decoded = NULL;
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_ActionInfo(OssGlobal * _g, _ActionInfo * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_1bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 19)
	_dp_ActionTypeId(_g, &_out_data->actionType);
	OSS_CNTX_SET(49)
	if (_out_data->bit_mask & 0x80000000) {
#ifdef OSS_OPENTYPE_HAS_USERFIELD
	    _out_data->actionInfoArg.userField = NULL;
#endif
	    _out_data->actionInfoArg.encoded.length = _oss_pdec_unconstr_uoct_ia(_g, &_out_data->actionInfoArg.encoded.value);
	    if (_out_data->actionInfoArg.encoded.length == 0 && ((STRICT_ENCODING_DECODING_RULES | AUTOMATIC_ENCDEC) & _g->decodingFlags))
		_oss_dec_error(_g, _zero_length_OpenType, 0L);
	    _out_data->actionInfoArg.pduNum = 0;
	    *(void **)&_out_data->actionInfoArg.decoded = NULL;
	} else {
	    memset(&(_out_data->actionInfoArg), 0, sizeof(OSSC::COssConstrainedOpenType ));
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_ActionReply(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _ActionReply * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 19)
	_d_ActionTypeId(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->actionType);
	OSS_CNTX_SET(50)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 164 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x84);
	_data_tag = 0x8004;
	if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
	_out_data->actionReplyInfo.userField = NULL;
#endif
	_oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->actionReplyInfo.encoded);
	_out_data->actionReplyInfo.pduNum = 0;
	*(void **)&_out_data->actionReplyInfo.decoded = NULL;
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_ActionReply(OssGlobal * _g, _ActionReply * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 19)
	_dp_ActionTypeId(_g, &_out_data->actionType);
	OSS_CNTX_SET(50)
#ifdef OSS_OPENTYPE_HAS_USERFIELD
	_out_data->actionReplyInfo.userField = NULL;
#endif
	_out_data->actionReplyInfo.encoded.length = _oss_pdec_unconstr_uoct_ia(_g, &_out_data->actionReplyInfo.encoded.value);
	if (_out_data->actionReplyInfo.encoded.length == 0 && ((STRICT_ENCODING_DECODING_RULES | AUTOMATIC_ENCDEC) & _g->decodingFlags))
	    _oss_dec_error(_g, _zero_length_OpenType, 0L);
	_out_data->actionReplyInfo.pduNum = 0;
	*(void **)&_out_data->actionReplyInfo.decoded = NULL;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d__seqof1(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seqof1 ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_seqof1 * _temp = (_seqof1 *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 51)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    _temp->next = (_seqof1 *)_oss_dec_const_alloc(_g, sizeof(_seqof1));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		OSS_CNTX_INIT

		switch (_data_tag) {
		default:
		    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
		    switch (_data_tag & 0x7fff) {
		    case 0x0: {
			OSS_CNTX_PUSH(_oss_c, 52)
			_temp->value.choice = 1;

			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			_temp->value.u.initialString = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
			_d_Attribute(_g, &_bufpos, &_buflen, _data_length, _data_tag, _temp->value.u.initialString);
		    }   break;
		    case 0x1: {
			OSS_CNTX_PUSH(_oss_c, 53)
			_temp->value.choice = 2;

			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			_temp->value.u.anyString = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
			_d_Attribute(_g, &_bufpos, &_buflen, _data_length, _data_tag, _temp->value.u.anyString);
		    }   break;
		    case 0x2: {
			OSS_CNTX_PUSH(_oss_c, 54)
			_temp->value.choice = 3;

			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			_temp->value.u.finalString = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
			_d_Attribute(_g, &_bufpos, &_buflen, _data_length, _data_tag, _temp->value.u.finalString);
		    }   break;
		    default:
			_oss_dec_error(_g, _unknown_field, _data_tag);
		    }
		    break;
		}
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	}
	_temp->next = NULL;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp__seqof1(OssGlobal * _g, _seqof1 ** _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_seqof1 * _temp = (_seqof1 *)_out_data;
	unsigned long count = 0;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 51)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_seqof1 *)_oss_dec_const_alloc(_g, sizeof(_seqof1));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    OSS_CNTX_INIT

		    {

			_temp->value.choice = (int)_oss_pdec_nonneg_2int(_g) + 1;
		    }
		    switch (_temp->value.choice) {
		    case 1:
			OSS_CNTX_PUSH(_oss_c, 52)
			_temp->value.u.initialString = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
			_dp_Attribute(_g, _temp->value.u.initialString);
			break;
		    case 2:
			OSS_CNTX_PUSH(_oss_c, 53)
			_temp->value.u.anyString = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
			_dp_Attribute(_g, _temp->value.u.anyString);
			break;
		    case 3:
			OSS_CNTX_PUSH(_oss_c, 54)
			_temp->value.u.finalString = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
			_dp_Attribute(_g, _temp->value.u.finalString);
			break;
		    default:
			_oss_enc_error(_g, _bad_choice, _temp->value.choice);	/* Bad choice selector. */
		    }
		    OSS_CNTX_POP(_oss_c)
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = NULL;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_FilterItem(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _FilterItem * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	default:
	    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
	    switch (_data_tag & 0x7fff) {
	    case 0x0: {
		OSS_CNTX_PUSH(_oss_c, 55)
		_out_data->choice = 1;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.equality = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
		_d_Attribute(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.equality);
	    }   break;
	    case 0x1: {
		OSS_CNTX_PUSH(_oss_c, 56)
		_out_data->choice = 2;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_d__seqof1(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.substrings);
	    }   break;
	    case 0x2: {
		OSS_CNTX_PUSH(_oss_c, 57)
		_out_data->choice = 3;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.greaterOrEqual = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
		_d_Attribute(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.greaterOrEqual);
	    }   break;
	    case 0x3: {
		OSS_CNTX_PUSH(_oss_c, 58)
		_out_data->choice = 4;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.lessOrEqual = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
		_d_Attribute(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.lessOrEqual);
	    }   break;
	    case 0x4: {
		OSS_CNTX_PUSH(_oss_c, 59)
		_out_data->choice = 5;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		_out_data->u.present = (_ActionTypeId *)_oss_dec_const_alloc(_g, sizeof(_ActionTypeId));
		_d_AttributeId(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.present);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
	    }   break;
	    case 0x5: {
		OSS_CNTX_PUSH(_oss_c, 60)
		_out_data->choice = 6;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.subsetOf = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
		_d_Attribute(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.subsetOf);
	    }   break;
	    case 0x6: {
		OSS_CNTX_PUSH(_oss_c, 61)
		_out_data->choice = 7;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.supersetOf = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
		_d_Attribute(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.supersetOf);
	    }   break;
	    case 0x7: {
		OSS_CNTX_PUSH(_oss_c, 62)
		_out_data->choice = 8;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.nonNullSetIntersection = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
		_d_Attribute(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.nonNullSetIntersection);
	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    break;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_FilterItem(OssGlobal * _g, _FilterItem * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_3int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 55)
	    _out_data->u.equality = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
	    _dp_Attribute(_g, _out_data->u.equality);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 56)
	    _dp__seqof1(_g, &_out_data->u.substrings);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 57)
	    _out_data->u.greaterOrEqual = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
	    _dp_Attribute(_g, _out_data->u.greaterOrEqual);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 58)
	    _out_data->u.lessOrEqual = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
	    _dp_Attribute(_g, _out_data->u.lessOrEqual);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 59)
	    _out_data->u.present = (_ActionTypeId *)_oss_dec_const_alloc(_g, sizeof(_ActionTypeId));
	    _dp_AttributeId(_g, _out_data->u.present);
	    break;
	case 6:
	    OSS_CNTX_PUSH(_oss_c, 60)
	    _out_data->u.subsetOf = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
	    _dp_Attribute(_g, _out_data->u.subsetOf);
	    break;
	case 7:
	    OSS_CNTX_PUSH(_oss_c, 61)
	    _out_data->u.supersetOf = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
	    _dp_Attribute(_g, _out_data->u.supersetOf);
	    break;
	case 8:
	    OSS_CNTX_PUSH(_oss_c, 62)
	    _out_data->u.nonNullSetIntersection = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
	    _dp_Attribute(_g, _out_data->u.nonNullSetIntersection);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d__setof6(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _setof6 ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_setof6 * _temp = (_setof6 *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 63)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    _temp->next = (_setof6 *)_oss_dec_const_alloc(_g, sizeof(_setof6));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		OSS_CNTX_INIT

		switch (_data_tag) {
		default:
		    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
		    switch (_data_tag & 0x7fff) {
		    case 0x0: {
			OSS_CNTX_PUSH(_oss_c, 64)
			_temp->value.choice = 1;

			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			_temp->value.u.attributeIdError = (_AttributeIdError *)_oss_dec_const_alloc(_g, sizeof(_AttributeIdError));
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			{
			    long _total_len = _data_length;
			    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
			    OSS_CNTX_INIT

			    OSS_CNTX_PUSH(_oss_c, 36)
			    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 10 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0xA);
			    _data_tag = 0xA;
			    _temp->value.u.attributeIdError->errorStatus = (enum _enum4 )_oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
			    OSS_CNTX_SET(34)
			    _d_AttributeId(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value.u.attributeIdError->attributeId);
			    OSS_CNTX_POP(_oss_c)
			    while (_bufpos < _end_pos || _total_len < 0) {
				if (!_oss_c->_tag_decoded) {
				    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
					_buflen--;
					_oss_c->_bitpos = _bufpos[0] & 0x20;
					_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
					_bufpos++;
				    } else
					_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
				    _oss_c->_tag_decoded = TRUE;
				}
				if (!_data_tag)
				    break;
				_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				_oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
				_oss_c->_tag_decoded = FALSE;
			    }
			    if (_total_len < 0 && !_data_tag) {
				if (_oss_dec_length(_g, &_bufpos, &_buflen))
				    _oss_dec_error(_g, _non_std_eoc, 0L);
				_oss_c->_tag_decoded = FALSE;
			    }
			}
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		    }   break;
		    case 0x1: {
			OSS_CNTX_PUSH(_oss_c, 37)
			_temp->value.choice = 2;

			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			_temp->value.u.attribute = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
			_d_Attribute(_g, &_bufpos, &_buflen, _data_length, _data_tag, _temp->value.u.attribute);
		    }   break;
		    default:
			_oss_dec_error(_g, _unknown_field, _data_tag);
		    }
		    break;
		}
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	}
	_temp->next = NULL;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp__setof6(OssGlobal * _g, _setof6 ** _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_setof6 * _temp = (_setof6 *)_out_data;
	unsigned long count = 0;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 63)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_setof6 *)_oss_dec_const_alloc(_g, sizeof(_setof6));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    OSS_CNTX_INIT

		    {

			_temp->value.choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
		    }
		    switch (_temp->value.choice) {
		    case 1:
			OSS_CNTX_PUSH(_oss_c, 64)
			_temp->value.u.attributeIdError = (_AttributeIdError *)_oss_dec_const_alloc(_g, sizeof(_AttributeIdError));
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			{
			    unsigned char *_pext;
			    unsigned char _extPres = 0x00;
			    unsigned long _ea_count = 0;
			    OSS_CNTX_INIT

			    _extPres = _oss_get_1bit_unaligned(_g);
			    OSS_CNTX_PUSH(_oss_c, 36)
			    _temp->value.u.attributeIdError->errorStatus = (enum _enum4)_oss_pdec_enum(_g, (struct _enum_data*)&_enums[3], (struct _enum_data*)&_enums[4]);
			    OSS_CNTX_SET(34)
			    _dp_AttributeId(_g, &_temp->value.u.attributeIdError->attributeId);
			    OSS_CNTX_POP(_oss_c)
			    if (_extPres) {
				_ea_count = _oss_pdec_eap(_g, &_pext);
				_oss_pdec_eas(_g, _pext, _ea_count, 0);
			    }
			}
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			break;
		    case 2:
			OSS_CNTX_PUSH(_oss_c, 37)
			_temp->value.u.attribute = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
			_dp_Attribute(_g, _temp->value.u.attribute);
			break;
		    default:
			_oss_enc_error(_g, _bad_choice, _temp->value.choice);	/* Bad choice selector. */
		    }
		    OSS_CNTX_POP(_oss_c)
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = NULL;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d__setof7(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _setof3 ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_setof3 * _temp = (_setof3 *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 38)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    if (_data_tag != 0x10)
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
	    _temp->next = (_setof3 *)_oss_dec_const_alloc(_g, sizeof(_setof3));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _d_Attribute(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
	}
	_temp->next = NULL;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp__setof7(OssGlobal * _g, _setof3 ** _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_setof3 * _temp = (_setof3 *)_out_data;
	unsigned long count = 0;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 38)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_setof3 *)_oss_dec_const_alloc(_g, sizeof(_setof3));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
		_dp_Attribute(_g, &_temp->value);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = NULL;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_InvokeId(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _InvokeId * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	case 0x2: {
	    OSS_CNTX_PUSH(_oss_c, 65)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.present = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	}   break;
	case 0x5: {
	    OSS_CNTX_PUSH(_oss_c, 66)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.absent = 0;
	    if (_data_length != 0)
		_oss_dec_error(_g, _inval_enc, 0L);
	}   break;
	default:
	    _oss_dec_error(_g, _unknown_field, _data_tag);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_InvokeId(OssGlobal * _g, _InvokeId * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 65)
	    _out_data->u.present = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 66)
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_RDNSequence(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _RDNSequence ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_RDNSequence * _temp = (_RDNSequence *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 67)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    if (_data_tag != 0x11)
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x110000);
	    _temp->next = (_RDNSequence *)_oss_dec_const_alloc(_g, sizeof(_RDNSequence));
	    _temp = _temp->next;
	    _temp->value = NULL;
	    OSS_CNTX_SETOCC(count)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _d_RelativeDistinguishedName(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
	}
	_temp->next = NULL;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_RDNSequence(OssGlobal * _g, _RDNSequence ** _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_RDNSequence * _temp = (_RDNSequence *)_out_data;
	unsigned long count = 0;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 67)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_RDNSequence *)_oss_dec_const_alloc(_g, sizeof(_RDNSequence));
		_temp = _temp->next;
		_temp->value = NULL;
		OSS_CNTX_SETOCC(_index + 1)
		_dp_RelativeDistinguishedName(_g, &_temp->value);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = NULL;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_RelativeDistinguishedName(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _RelativeDistinguishedName ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_RelativeDistinguishedName * _temp = (_RelativeDistinguishedName *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 68)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    if (_data_tag != 0x10)
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
	    _temp->next = (_RelativeDistinguishedName *)_oss_dec_const_alloc(_g, sizeof(_RelativeDistinguishedName));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 69)
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
		_data_tag = 0x6;
		_temp->value.id.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.id.value, -1);
		OSS_CNTX_SET(4)
		if (_data_length == 0) _data_length = 1;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
		_temp->value.value.userField = NULL;
#endif
		_oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_temp->value.value.encoded);
		_temp->value.value.pduNum = 0;
		*(void **)&_temp->value.value.decoded = NULL;
		OSS_CNTX_POP(_oss_c)
		if (_bufpos != _end_pos) {
		    if (_total_len < 0) {
			if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			if (_data_tag)
			    _oss_dec_error(_g, _expec_eoc, 0L);
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
		    } else
			_oss_dec_error(_g, _inconsis_len, 0L);
		}
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	}
	_temp->next = NULL;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_RelativeDistinguishedName(OssGlobal * _g, _RelativeDistinguishedName ** _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_RelativeDistinguishedName * _temp = (_RelativeDistinguishedName *)_out_data;
	unsigned long count = 0;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 68)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_RelativeDistinguishedName *)_oss_dec_const_alloc(_g, sizeof(_RelativeDistinguishedName));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    OSS_CNTX_INIT

		    OSS_CNTX_PUSH(_oss_c, 69)
		    _temp->value.id.length = _oss_pdec_eobjid_ia(_g, &_temp->value.id.value, -1);
		    OSS_CNTX_SET(4)
#ifdef OSS_OPENTYPE_HAS_USERFIELD
		    _temp->value.value.userField = NULL;
#endif
		    _temp->value.value.encoded.length = _oss_pdec_unconstr_uoct_ia(_g, &_temp->value.value.encoded.value);
		    if (_temp->value.value.encoded.length == 0 && ((STRICT_ENCODING_DECODING_RULES | AUTOMATIC_ENCDEC) & _g->decodingFlags))
			_oss_dec_error(_g, _zero_length_OpenType, 0L);
		    _temp->value.value.pduNum = 0;
		    *(void **)&_temp->value.value.decoded = NULL;
		    OSS_CNTX_POP(_oss_c)
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = NULL;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_Code(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Code * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	case 0x2: {
	    OSS_CNTX_PUSH(_oss_c, 70)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.local = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	}   break;
	case 0x6: {
	    OSS_CNTX_PUSH(_oss_c, 71)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.global.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.global.value, -1);
	}   break;
	default:
	    _oss_dec_error(_g, _unknown_field, _data_tag);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_Code(OssGlobal * _g, _Code * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 70)
	    _out_data->u.local = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 71)
	    _out_data->u.global.length = _oss_pdec_eobjid_ia(_g, &_out_data->u.global.value, -1);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_FunctionalUnitPackage(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _FunctionalUnitPackage * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 74)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x6) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x6 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x60000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x6;
	_out_data->functionalUnitPackageId.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->functionalUnitPackageId.value, -1);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8000 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->managerRoleFunctionalUnit, &_v41, sizeof(_v41));
#else
	    _out_data->managerRoleFunctionalUnit.length = 0;
	    _out_data->managerRoleFunctionalUnit.value = NULL;
#endif
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 73)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 128 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8000;
	    _out_data->managerRoleFunctionalUnit.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->managerRoleFunctionalUnit.value, 0, 0);

	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8001 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->agentRoleFunctionalUnit, &_v42, sizeof(_v42));
#else
	    _out_data->agentRoleFunctionalUnit.length = 0;
	    _out_data->agentRoleFunctionalUnit.value = NULL;
#endif
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 72)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 129 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8001) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x81 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80010000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8001;
	    _out_data->agentRoleFunctionalUnit.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->agentRoleFunctionalUnit.value, 0, 0);

	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_FunctionalUnitPackage(OssGlobal * _g, _FunctionalUnitPackage * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_2bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 74)
	_out_data->functionalUnitPackageId.length = _oss_pdec_eobjid_ia(_g, &_out_data->functionalUnitPackageId.value, -1);
	OSS_CNTX_SET(73)
	if (_out_data->bit_mask & 0x80000000) {
	    _out_data->managerRoleFunctionalUnit.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->managerRoleFunctionalUnit.value);

	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->managerRoleFunctionalUnit, &_v41, sizeof(_v41));
#else
	    _out_data->managerRoleFunctionalUnit.length = 0;
	    _out_data->managerRoleFunctionalUnit.value = NULL;
#endif
	}
	OSS_CNTX_SET(72)
	if (_out_data->bit_mask & 0x40000000) {
	    _out_data->agentRoleFunctionalUnit.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->agentRoleFunctionalUnit.value);

	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->agentRoleFunctionalUnit, &_v42, sizeof(_v42));
#else
	    _out_data->agentRoleFunctionalUnit.length = 0;
	    _out_data->agentRoleFunctionalUnit.value = NULL;
#endif
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void * _dActionArgument(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ActionArgument *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(1,75)
    _out_data = (_ActionArgument *)_oss_dec_const_alloc(_g, sizeof(_ActionArgument));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 82)
	_d_ObjectClass(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->baseManagedObjectClass);
	OSS_CNTX_SET(81)
	_d_ObjectInstance(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->baseManagedObjectInstance);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8005 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->accessControl, 0, sizeof(_out_data->accessControl));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 80)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 165 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8005) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x85 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80050000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8005;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8);
	    _data_tag = 0x8;
	    _d_External(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->accessControl);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8006 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->synchronization, &ActionArgument::default_synchronization, sizeof(ActionArgument::default_synchronization));
#else
	    _out_data->synchronization = bestEffort;
#endif
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 79)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 134 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8006) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x86 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80060000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8006;
	    _out_data->synchronization = (enum CMISSync )_oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8007 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x20000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->scope, &_v30, sizeof(_v30));
#else
	    memset(&(_out_data->scope), 0, sizeof(_Scope ));
#endif
	}
else {
	    _out_data->bit_mask |= 0x20000000;
	    OSS_CNTX_PUSH(_oss_c, 78)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 167 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8007) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x87 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80070000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8007;
	    if (_data_length < 0) ++_indef_tags;
	    _d_Scope(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->scope);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if ((_data_tag != 0x8008 && _data_tag != 0x8009 && _data_tag != 0x800A && _data_tag != 0x800B)
	    || (_total_len >= 0 && _bufpos >= _end_pos))
	 {
	    _out_data->bit_mask &= ~0x10000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->filter, &_v31, sizeof(_v31));
#else
	    memset(&(_out_data->filter), 0, sizeof(_CMISFilter ));
#endif
	}
else {
	    _out_data->bit_mask |= 0x10000000;
	    OSS_CNTX_PUSH(_oss_c, 77)
	    _d_CMISFilter(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->filter);
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 76)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 172 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x800C) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x8C : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x800C0000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x800C;
	_d_ActionInfo(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->actionInfo);
	OSS_CNTX_POP(_oss_c)
	while (_bufpos < _end_pos || _total_len < 0) {
	    if (!_oss_c->_tag_decoded) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (!_data_tag)
		break;
	    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    _oss_c->_tag_decoded = FALSE;
	}
	if (_total_len < 0 && !_data_tag) {
	    if (_oss_dec_length(_g, &_bufpos, &_buflen))
		_oss_dec_error(_g, _non_std_eoc, 0L);
	    _oss_c->_tag_decoded = FALSE;
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpActionArgument(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ActionArgument	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(1,75)
    _out_data = (_ActionArgument *)_oss_dec_const_alloc(_g, sizeof(_ActionArgument));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	unsigned char *_pext;
	unsigned char _extPres = 0x00;
	unsigned long _ea_count = 0;
	OSS_CNTX_INIT

	_extPres = _oss_get_1bit_unaligned(_g);
	_out_data->bit_mask = (OSS_UINT32)_oss_get_4bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 82)
	_dp_ObjectClass(_g, &_out_data->baseManagedObjectClass);
	OSS_CNTX_SET(81)
	_dp_ObjectInstance(_g, &_out_data->baseManagedObjectInstance);
	OSS_CNTX_SET(80)
	if (_out_data->bit_mask & 0x80000000) {
	    _dp_External(_g, &_out_data->accessControl);
	} else {
	    memset(&(_out_data->accessControl), 0, sizeof(_External ));
	}
	OSS_CNTX_SET(79)
	if (_out_data->bit_mask & 0x40000000) {
	    _out_data->synchronization = (enum CMISSync)_oss_pdec_uenum(_g, (struct _enum_data*)&_enums[5], NULL);
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->synchronization, &ActionArgument::default_synchronization, sizeof(ActionArgument::default_synchronization));
#else
	    _out_data->synchronization = bestEffort;
#endif
	}
	OSS_CNTX_SET(78)
	if (_out_data->bit_mask & 0x20000000) {
	    _dp_Scope(_g, &_out_data->scope);
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->scope, &_v30, sizeof(_v30));
#else
	    memset(&(_out_data->scope), 0, sizeof(_Scope ));
#endif
	}
	OSS_CNTX_SET(77)
	if (_out_data->bit_mask & 0x10000000) {
	    _dp_CMISFilter(_g, &_out_data->filter);
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->filter, &_v31, sizeof(_v31));
#else
	    memset(&(_out_data->filter), 0, sizeof(_CMISFilter ));
#endif
	}
	OSS_CNTX_SET(76)
	_dp_ActionInfo(_g, &_out_data->actionInfo);
	OSS_CNTX_POP(_oss_c)
	if (_extPres) {
	    _ea_count = _oss_pdec_eap(_g, &_pext);
	    _oss_pdec_eas(_g, _pext, _ea_count, 0);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dActionResult(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ActionResult *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(2,83)
    _out_data = (_ActionResult *)_oss_dec_const_alloc(_g, sizeof(_ActionResult));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_ActionResult(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpActionResult(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ActionResult	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(2,83)
    _out_data = (_ActionResult *)_oss_dec_const_alloc(_g, sizeof(_ActionResult));
    _dp_ActionResult(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dAttribute(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Attribute *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(3,84)
    _out_data = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_Attribute(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpAttribute(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Attribute	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(3,84)
    _out_data = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
    _dp_Attribute(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dAttributeId(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ActionTypeId *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(4,85)
    _out_data = (_ActionTypeId *)_oss_dec_const_alloc(_g, sizeof(_ActionTypeId));
    _oss_c->_tag_decoded = FALSE;
    _d_AttributeId(_g, &_bufpos, &_buflen, 0, 0, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpAttributeId(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ActionTypeId	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(4,85)
    _out_data = (_ActionTypeId *)_oss_dec_const_alloc(_g, sizeof(_ActionTypeId));
    _dp_AttributeId(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dBaseManagedObjectId(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _BaseManagedObjectId *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(5,86)
    _out_data = (_BaseManagedObjectId *)_oss_dec_const_alloc(_g, sizeof(_BaseManagedObjectId));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 82)
	_d_ObjectClass(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->baseManagedObjectClass);
	OSS_CNTX_SET(81)
	_d_ObjectInstance(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->baseManagedObjectInstance);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpBaseManagedObjectId(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _BaseManagedObjectId	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(5,86)
    _out_data = (_BaseManagedObjectId *)_oss_dec_const_alloc(_g, sizeof(_BaseManagedObjectId));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 82)
	_dp_ObjectClass(_g, &_out_data->baseManagedObjectClass);
	OSS_CNTX_SET(81)
	_dp_ObjectInstance(_g, &_out_data->baseManagedObjectInstance);
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dCMISFilter(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CMISFilter *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(6,87)
    _out_data = (_CMISFilter *)_oss_dec_const_alloc(_g, sizeof(_CMISFilter));
    _oss_c->_tag_decoded = FALSE;
    _d_CMISFilter(_g, &_bufpos, &_buflen, 0, 0, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpCMISFilter(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CMISFilter	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(6,87)
    _out_data = (_CMISFilter *)_oss_dec_const_alloc(_g, sizeof(_CMISFilter));
    _dp_CMISFilter(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dCMISSync(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    enum CMISSync *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(7,88)
    _out_data = (enum CMISSync *)_oss_dec_const_alloc(_g, sizeof(enum CMISSync));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 10 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0xA);
    _data_tag = 0xA;
    *_out_data = (enum CMISSync )_oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpCMISSync(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    enum CMISSync	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(7,88)
    _out_data = (enum CMISSync *)_oss_dec_const_alloc(_g, sizeof(enum CMISSync));
    *_out_data = (enum CMISSync)_oss_pdec_uenum(_g, (struct _enum_data*)&_enums[5], NULL);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dComplexityLimitation(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ComplexityLimitation *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(8,89)
    _out_data = (_ComplexityLimitation *)_oss_dec_const_alloc(_g, sizeof(_ComplexityLimitation));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
    _data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	unsigned short _present_flags = 0;
	OSS_CNTX_DEF
	OSS_CNTX_SETOCC(0)
	_out_data->bit_mask = 0;
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    switch (_data_tag) {
	    default:
		if (_data_tag < 0x8000U) {
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
		    OSS_CNTX_PUSH(_oss_c, 0)
		    break;
		}
		switch (_data_tag & 0x7fff) {
		case 0x0: {
		    OSS_CNTX_PUSH(_oss_c, 78)
		    if (_out_data->bit_mask & 0x80000000)
			_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		    _out_data->bit_mask |= 0x80000000;
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    if (_data_length < 0) ++_indef_tags;
		    _d_Scope(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->scope);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    _present_flags |= 0x1;
		}   break;
		case 0x1: {
		    OSS_CNTX_PUSH(_oss_c, 77)
		    if (_out_data->bit_mask & 0x40000000)
			_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		    _out_data->bit_mask |= 0x40000000;
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    if (_data_length < 0) ++_indef_tags;
		    _d_CMISFilter(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->filter);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    _present_flags |= 0x2;
		}   break;
		case 0x2: {
		    OSS_CNTX_PUSH(_oss_c, 90)
		    if (_out_data->bit_mask & 0x20000000)
			_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		    _out_data->bit_mask |= 0x20000000;
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    if (_data_length < 0) ++_indef_tags;
		    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 10 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0xA);
		    _data_tag = 0xA;
		    _out_data->sync = (enum CMISSync )_oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    _present_flags |= 0x4;
		}   break;
		default:
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
		    OSS_CNTX_PUSH(_oss_c, 0)
		    break;
		}
		break;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!(_present_flags & 0x1)) {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->scope, 0, sizeof(_out_data->scope));
	}
	if (!(_present_flags & 0x2)) {
	    _out_data->bit_mask &= ~0x40000000;
	    memset(&_out_data->filter, 0, sizeof(_out_data->filter));
	}
	if (!(_present_flags & 0x4)) {
	    _out_data->bit_mask &= ~0x20000000;
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpComplexityLimitation(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ComplexityLimitation	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(8,89)
    _out_data = (_ComplexityLimitation *)_oss_dec_const_alloc(_g, sizeof(_ComplexityLimitation));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	unsigned char *_pext;
	unsigned char _extPres = 0x00;
	unsigned long _ea_count = 0;
	OSS_CNTX_INIT

	_extPres = _oss_get_1bit_unaligned(_g);
	_out_data->bit_mask = (OSS_UINT32)_oss_get_3bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 78)
	if (_out_data->bit_mask & 0x80000000) {
	    _dp_Scope(_g, &_out_data->scope);
	} else {
	    memset(&(_out_data->scope), 0, sizeof(_Scope ));
	}
	OSS_CNTX_SET(77)
	if (_out_data->bit_mask & 0x40000000) {
	    _dp_CMISFilter(_g, &_out_data->filter);
	} else {
	    memset(&(_out_data->filter), 0, sizeof(_CMISFilter ));
	}
	OSS_CNTX_SET(90)
	if (_out_data->bit_mask & 0x20000000) {
	    _out_data->sync = (enum CMISSync)_oss_pdec_uenum(_g, (struct _enum_data*)&_enums[5], NULL);
	}
	OSS_CNTX_POP(_oss_c)
	if (_extPres) {
	    _ea_count = _oss_pdec_eap(_g, &_pext);
	    _oss_pdec_eas(_g, _pext, _ea_count, 0);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dCreateArgument(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CreateArgument *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(9,91)
    _out_data = (_CreateArgument *)_oss_dec_const_alloc(_g, sizeof(_CreateArgument));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 3)
	_d_ObjectClass(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->managedObjectClass);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if ((_data_tag != 0x8002 && _data_tag != 0x8003 && _data_tag != 0x8004 && _data_tag != 0x8008)
	    || (_total_len >= 0 && _bufpos >= _end_pos))
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->managedOrSuperiorObjectInstance, 0, sizeof(_out_data->managedOrSuperiorObjectInstance));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 93)
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		int _indef_tags = 0;
		OSS_CNTX_INIT

		if (!_oss_c->_tag_decoded) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag == 0x8002 || _data_tag == 0x8003 || _data_tag == 0x8004) {
		    OSS_CNTX_PUSH(_oss_c, 2)
		    _out_data->managedOrSuperiorObjectInstance.choice = 1;
		    _out_data->managedOrSuperiorObjectInstance.u.managedObjectInstance = (_ObjectInstance *)_oss_dec_const_alloc(_g, sizeof(_ObjectInstance));
		    _d_ObjectInstance(_g, &_bufpos, &_buflen, 0, _data_tag, _out_data->managedOrSuperiorObjectInstance.u.managedObjectInstance);
		    OSS_CNTX_POP(_oss_c)
		} else
		switch (_data_tag) {
		default:
		    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
		    switch (_data_tag & 0x7fff) {
		    case 0x8: {
			OSS_CNTX_PUSH(_oss_c, 94)
			_out_data->managedOrSuperiorObjectInstance.choice = 2;

			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			if (_data_length < 0) ++_indef_tags;
			_out_data->managedOrSuperiorObjectInstance.u.superiorObjectInstance = (_ObjectInstance *)_oss_dec_const_alloc(_g, sizeof(_ObjectInstance));
			_d_ObjectInstance(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->managedOrSuperiorObjectInstance.u.superiorObjectInstance);
			while (_indef_tags > 0) {
			    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				if (!_buflen || _bufpos[0])
				    _oss_dec_error(_g, _expec_eoc, 0L);
				else
				    _oss_dec_error(_g, _non_std_eoc, 0L);
			    _indef_tags--;
			}
		    }   break;
		    default:
			_oss_dec_error(_g, _unknown_field, _data_tag);
		    }
		    break;
		}
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8005 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    memset(&_out_data->accessControl, 0, sizeof(_out_data->accessControl));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 80)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 165 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8005) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x85 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80050000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8005;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8);
	    _data_tag = 0x8;
	    _d_External(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->accessControl);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8006 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x20000000;
	    memset(&_out_data->referenceObjectInstance, 0, sizeof(_out_data->referenceObjectInstance));
	}
else {
	    _out_data->bit_mask |= 0x20000000;
	    OSS_CNTX_PUSH(_oss_c, 92)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 166 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8006) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x86 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80060000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8006;
	    if (_data_length < 0) ++_indef_tags;
	    _d_ObjectInstance(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->referenceObjectInstance);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8007 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x10000000;
	    memset(&_out_data->attributeList, 0, sizeof(_out_data->attributeList));
	}
else {
	    _out_data->bit_mask |= 0x10000000;
	    OSS_CNTX_PUSH(_oss_c, 13)
	    _out_data->attributeList = NULL;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 167 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8007) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x87 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80070000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8007;
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_setof3 * _temp = (_setof3 *)&_out_data->attributeList;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
		unsigned long count = 0;
#endif
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 38)
		for (;;) {
		    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos > _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
		    count++;
#endif
		    if (_data_tag != 0x10)
			_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		    _temp->next = (_setof3 *)_oss_dec_const_alloc(_g, sizeof(_setof3));
		    _temp = _temp->next;
		    OSS_CNTX_SETOCC(count)
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _d_Attribute(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
		}
		_temp->next = NULL;
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    OSS_CNTX_POP(_oss_c)
	}
	while (_bufpos < _end_pos || _total_len < 0) {
	    if (!_oss_c->_tag_decoded) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (!_data_tag)
		break;
	    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    _oss_c->_tag_decoded = FALSE;
	}
	if (_total_len < 0 && !_data_tag) {
	    if (_oss_dec_length(_g, &_bufpos, &_buflen))
		_oss_dec_error(_g, _non_std_eoc, 0L);
	    _oss_c->_tag_decoded = FALSE;
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpCreateArgument(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CreateArgument	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(9,91)
    _out_data = (_CreateArgument *)_oss_dec_const_alloc(_g, sizeof(_CreateArgument));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	unsigned char *_pext;
	unsigned char _extPres = 0x00;
	unsigned long _ea_count = 0;
	OSS_CNTX_INIT

	_extPres = _oss_get_1bit_unaligned(_g);
	_out_data->bit_mask = (OSS_UINT32)_oss_get_4bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 3)
	_dp_ObjectClass(_g, &_out_data->managedObjectClass);
	OSS_CNTX_SET(93)
	if (_out_data->bit_mask & 0x80000000) {
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		OSS_CNTX_INIT

		{

		    _out_data->managedOrSuperiorObjectInstance.choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
		}
		switch (_out_data->managedOrSuperiorObjectInstance.choice) {
		case 1:
		    OSS_CNTX_PUSH(_oss_c, 2)
		    _out_data->managedOrSuperiorObjectInstance.u.managedObjectInstance = (_ObjectInstance *)_oss_dec_const_alloc(_g, sizeof(_ObjectInstance));
		    _dp_ObjectInstance(_g, _out_data->managedOrSuperiorObjectInstance.u.managedObjectInstance);
		    break;
		case 2:
		    OSS_CNTX_PUSH(_oss_c, 94)
		    _out_data->managedOrSuperiorObjectInstance.u.superiorObjectInstance = (_ObjectInstance *)_oss_dec_const_alloc(_g, sizeof(_ObjectInstance));
		    _dp_ObjectInstance(_g, _out_data->managedOrSuperiorObjectInstance.u.superiorObjectInstance);
		    break;
		default:
		    _oss_enc_error(_g, _bad_choice, _out_data->managedOrSuperiorObjectInstance.choice);	/* Bad choice selector. */
		}
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	} else {
	    memset(&(_out_data->managedOrSuperiorObjectInstance), 0, sizeof(_choice3 ));
	}
	OSS_CNTX_SET(80)
	if (_out_data->bit_mask & 0x40000000) {
	    _dp_External(_g, &_out_data->accessControl);
	} else {
	    memset(&(_out_data->accessControl), 0, sizeof(_External ));
	}
	OSS_CNTX_SET(92)
	if (_out_data->bit_mask & 0x20000000) {
	    _dp_ObjectInstance(_g, &_out_data->referenceObjectInstance);
	} else {
	    memset(&(_out_data->referenceObjectInstance), 0, sizeof(_ObjectInstance ));
	}
	OSS_CNTX_SET(13)
	_out_data->attributeList = NULL;
	if (_out_data->bit_mask & 0x10000000) {
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_setof3 * _temp = (_setof3 *)&_out_data->attributeList;
		unsigned long count = 0;
		ossBoolean _last = FALSE;
		unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		unsigned long _prev_fragm0 = 0;
#endif

		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 38)
		while (!_last) {
		    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
			if ((!_last) && _index && (_prev_fragm0 < 65536))
			    _oss_dec_error(_g, _invalid_fragmentation, 0L);
			_prev_fragm0 = count - _index;
		    }
#endif
		    for (; (unsigned long)_index < count; _index++) {
			_temp->next = (_setof3 *)_oss_dec_const_alloc(_g, sizeof(_setof3));
			_temp = _temp->next;
			OSS_CNTX_SETOCC(_index + 1)
			_dp_Attribute(_g, &_temp->value);
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		_temp->next = NULL;
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	} else {
	    _out_data->attributeList = NULL;
	}
	OSS_CNTX_POP(_oss_c)
	if (_extPres) {
	    _ea_count = _oss_pdec_eap(_g, &_pext);
	    _oss_pdec_eas(_g, _pext, _ea_count, 0);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dCreateResult(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CreateResult *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(10,95)
    _out_data = (_CreateResult *)_oss_dec_const_alloc(_g, sizeof(_CreateResult));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if ((_data_tag != 0x8000 && _data_tag != 0x8001)
	    || (_total_len >= 0 && _bufpos >= _end_pos))
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->managedObjectClass, 0, sizeof(_out_data->managedObjectClass));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 3)
	    _d_ObjectClass(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->managedObjectClass);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if ((_data_tag != 0x8002 && _data_tag != 0x8003 && _data_tag != 0x8004)
	    || (_total_len >= 0 && _bufpos >= _end_pos))
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    memset(&_out_data->managedObjectInstance, 0, sizeof(_out_data->managedObjectInstance));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 2)
	    _d_ObjectInstance(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->managedObjectInstance);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8005 || _bufpos >= _end_pos)
	    _out_data->currentTime = NULL;
	else {
	    OSS_CNTX_PUSH(_oss_c, 1)
	    _out_data->currentTime = NULL;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 133 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8005) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x85 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80050000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8005;
	    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->currentTime, -1, 0);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8006 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x20000000;
	    memset(&_out_data->attributeList, 0, sizeof(_out_data->attributeList));
	}
else {
	    _out_data->bit_mask |= 0x20000000;
	    OSS_CNTX_PUSH(_oss_c, 13)
	    _out_data->attributeList = NULL;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 166 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8006) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x86 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80060000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8006;
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_setof3 * _temp = (_setof3 *)&_out_data->attributeList;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
		unsigned long count = 0;
#endif
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 38)
		for (;;) {
		    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos > _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
		    count++;
#endif
		    if (_data_tag != 0x10)
			_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		    _temp->next = (_setof3 *)_oss_dec_const_alloc(_g, sizeof(_setof3));
		    _temp = _temp->next;
		    OSS_CNTX_SETOCC(count)
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _d_Attribute(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
		}
		_temp->next = NULL;
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    OSS_CNTX_POP(_oss_c)
	}
	while (_bufpos < _end_pos || _total_len < 0) {
	    if (!_oss_c->_tag_decoded) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (!_data_tag)
		break;
	    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    _oss_c->_tag_decoded = FALSE;
	}
	if (_total_len < 0 && !_data_tag) {
	    if (_oss_dec_length(_g, &_bufpos, &_buflen))
		_oss_dec_error(_g, _non_std_eoc, 0L);
	    _oss_c->_tag_decoded = FALSE;
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpCreateResult(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CreateResult	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(10,95)
    _out_data = (_CreateResult *)_oss_dec_const_alloc(_g, sizeof(_CreateResult));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	unsigned char _pbase[1];
	unsigned char *_pext;
	unsigned char _extPres = 0x00;
	unsigned long _ea_count = 0;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	_extPres = _oss_get_1bit_unaligned(_g);
	*_pbase = _oss_get_4bit_unaligned(_g);
	OSS_CNTX_PUSH(_oss_c, 3)
	if (_pbase[0] & 0x80) {
	    _out_data->bit_mask |= 0x80000000;
	    _dp_ObjectClass(_g, &_out_data->managedObjectClass);
	} else {
	    memset(&(_out_data->managedObjectClass), 0, sizeof(_ActionTypeId ));
	}
	OSS_CNTX_SET(2)
	if (_pbase[0] & 0x40) {
	    _out_data->bit_mask |= 0x40000000;
	    _dp_ObjectInstance(_g, &_out_data->managedObjectInstance);
	} else {
	    memset(&(_out_data->managedObjectInstance), 0, sizeof(_ObjectInstance ));
	}
	OSS_CNTX_SET(1)
	if (_pbase[0] & 0x20) {
	    _oss_pdec_ntp_kmstr(_g, &_out_data->currentTime, _chars + 0);
	} else {
	    _out_data->currentTime = NULL;
	}
	OSS_CNTX_SET(13)
	_out_data->attributeList = NULL;
	if (_pbase[0] & 0x10) {
	    _out_data->bit_mask |= 0x20000000;
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_setof3 * _temp = (_setof3 *)&_out_data->attributeList;
		unsigned long count = 0;
		ossBoolean _last = FALSE;
		unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		unsigned long _prev_fragm0 = 0;
#endif

		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 38)
		while (!_last) {
		    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
			if ((!_last) && _index && (_prev_fragm0 < 65536))
			    _oss_dec_error(_g, _invalid_fragmentation, 0L);
			_prev_fragm0 = count - _index;
		    }
#endif
		    for (; (unsigned long)_index < count; _index++) {
			_temp->next = (_setof3 *)_oss_dec_const_alloc(_g, sizeof(_setof3));
			_temp = _temp->next;
			OSS_CNTX_SETOCC(_index + 1)
			_dp_Attribute(_g, &_temp->value);
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		_temp->next = NULL;
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	} else {
	    _out_data->attributeList = NULL;
	}
	OSS_CNTX_POP(_oss_c)
	if (_extPres) {
	    _ea_count = _oss_pdec_eap(_g, &_pext);
	    _oss_pdec_eas(_g, _pext, _ea_count, 0);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dDeleteArgument(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _DeleteArgument *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(11,96)
    _out_data = (_DeleteArgument *)_oss_dec_const_alloc(_g, sizeof(_DeleteArgument));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 82)
	_d_ObjectClass(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->baseManagedObjectClass);
	OSS_CNTX_SET(81)
	_d_ObjectInstance(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->baseManagedObjectInstance);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8005 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->accessControl, 0, sizeof(_out_data->accessControl));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 80)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 165 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8005) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x85 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80050000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8005;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8);
	    _data_tag = 0x8;
	    _d_External(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->accessControl);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8006 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->synchronization, &DeleteArgument::default_synchronization, sizeof(DeleteArgument::default_synchronization));
#else
	    _out_data->synchronization = bestEffort;
#endif
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 79)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 134 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8006) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x86 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80060000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8006;
	    _out_data->synchronization = (enum CMISSync )_oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8007 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x20000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->scope, &_v32, sizeof(_v32));
#else
	    memset(&(_out_data->scope), 0, sizeof(_Scope ));
#endif
	}
else {
	    _out_data->bit_mask |= 0x20000000;
	    OSS_CNTX_PUSH(_oss_c, 78)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 167 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8007) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x87 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80070000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8007;
	    if (_data_length < 0) ++_indef_tags;
	    _d_Scope(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->scope);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if ((_data_tag != 0x8008 && _data_tag != 0x8009 && _data_tag != 0x800A && _data_tag != 0x800B)
	    || (_total_len >= 0 && _bufpos >= _end_pos))
	 {
	    _out_data->bit_mask &= ~0x10000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->filter, &_v33, sizeof(_v33));
#else
	    memset(&(_out_data->filter), 0, sizeof(_CMISFilter ));
#endif
	}
else {
	    _out_data->bit_mask |= 0x10000000;
	    OSS_CNTX_PUSH(_oss_c, 77)
	    _d_CMISFilter(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->filter);
	    OSS_CNTX_POP(_oss_c)
	}
	while (_bufpos < _end_pos || _total_len < 0) {
	    if (!_oss_c->_tag_decoded) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (!_data_tag)
		break;
	    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    _oss_c->_tag_decoded = FALSE;
	}
	if (_total_len < 0 && !_data_tag) {
	    if (_oss_dec_length(_g, &_bufpos, &_buflen))
		_oss_dec_error(_g, _non_std_eoc, 0L);
	    _oss_c->_tag_decoded = FALSE;
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpDeleteArgument(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _DeleteArgument	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(11,96)
    _out_data = (_DeleteArgument *)_oss_dec_const_alloc(_g, sizeof(_DeleteArgument));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	unsigned char *_pext;
	unsigned char _extPres = 0x00;
	unsigned long _ea_count = 0;
	OSS_CNTX_INIT

	_extPres = _oss_get_1bit_unaligned(_g);
	_out_data->bit_mask = (OSS_UINT32)_oss_get_4bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 82)
	_dp_ObjectClass(_g, &_out_data->baseManagedObjectClass);
	OSS_CNTX_SET(81)
	_dp_ObjectInstance(_g, &_out_data->baseManagedObjectInstance);
	OSS_CNTX_SET(80)
	if (_out_data->bit_mask & 0x80000000) {
	    _dp_External(_g, &_out_data->accessControl);
	} else {
	    memset(&(_out_data->accessControl), 0, sizeof(_External ));
	}
	OSS_CNTX_SET(79)
	if (_out_data->bit_mask & 0x40000000) {
	    _out_data->synchronization = (enum CMISSync)_oss_pdec_uenum(_g, (struct _enum_data*)&_enums[5], NULL);
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->synchronization, &DeleteArgument::default_synchronization, sizeof(DeleteArgument::default_synchronization));
#else
	    _out_data->synchronization = bestEffort;
#endif
	}
	OSS_CNTX_SET(78)
	if (_out_data->bit_mask & 0x20000000) {
	    _dp_Scope(_g, &_out_data->scope);
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->scope, &_v32, sizeof(_v32));
#else
	    memset(&(_out_data->scope), 0, sizeof(_Scope ));
#endif
	}
	OSS_CNTX_SET(77)
	if (_out_data->bit_mask & 0x10000000) {
	    _dp_CMISFilter(_g, &_out_data->filter);
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->filter, &_v33, sizeof(_v33));
#else
	    memset(&(_out_data->filter), 0, sizeof(_CMISFilter ));
#endif
	}
	OSS_CNTX_POP(_oss_c)
	if (_extPres) {
	    _ea_count = _oss_pdec_eap(_g, &_pext);
	    _oss_pdec_eas(_g, _pext, _ea_count, 0);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dDeleteResult(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _DeleteResult *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(12,97)
    _out_data = (_DeleteResult *)_oss_dec_const_alloc(_g, sizeof(_DeleteResult));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_DeleteResult(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpDeleteResult(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _DeleteResult	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(12,97)
    _out_data = (_DeleteResult *)_oss_dec_const_alloc(_g, sizeof(_DeleteResult));
    _dp_DeleteResult(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dEventReportArgument(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EventReportArgument *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(13,98)
    _out_data = (_EventReportArgument *)_oss_dec_const_alloc(_g, sizeof(_EventReportArgument));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 3)
	_d_ObjectClass(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->managedObjectClass);
	OSS_CNTX_SET(2)
	_d_ObjectInstance(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->managedObjectInstance);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8005 || _bufpos >= _end_pos)
	    _out_data->eventTime = NULL;
	else {
	    OSS_CNTX_PUSH(_oss_c, 99)
	    _out_data->eventTime = NULL;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 133 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8005) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x85 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80050000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8005;
	    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->eventTime, -1, 0);
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 17)
	_d_EventTypeId(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->eventType);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8008 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->eventInfo, 0, sizeof(_out_data->eventInfo));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 16)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 168 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8008) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x88 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80080000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8008;
	    if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
	    _out_data->eventInfo.userField = NULL;
#endif
	    _oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->eventInfo.encoded);
	    _out_data->eventInfo.pduNum = 0;
	    *(void **)&_out_data->eventInfo.decoded = NULL;
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	while (_bufpos < _end_pos || _total_len < 0) {
	    if (!_oss_c->_tag_decoded) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (!_data_tag)
		break;
	    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    _oss_c->_tag_decoded = FALSE;
	}
	if (_total_len < 0 && !_data_tag) {
	    if (_oss_dec_length(_g, &_bufpos, &_buflen))
		_oss_dec_error(_g, _non_std_eoc, 0L);
	    _oss_c->_tag_decoded = FALSE;
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpEventReportArgument(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EventReportArgument	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(13,98)
    _out_data = (_EventReportArgument *)_oss_dec_const_alloc(_g, sizeof(_EventReportArgument));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	unsigned char _pbase[1];
	unsigned char *_pext;
	unsigned char _extPres = 0x00;
	unsigned long _ea_count = 0;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	_extPres = _oss_get_1bit_unaligned(_g);
	*_pbase = _oss_get_2bit_unaligned(_g);
	OSS_CNTX_PUSH(_oss_c, 3)
	_dp_ObjectClass(_g, &_out_data->managedObjectClass);
	OSS_CNTX_SET(2)
	_dp_ObjectInstance(_g, &_out_data->managedObjectInstance);
	OSS_CNTX_SET(99)
	if (_pbase[0] & 0x80) {
	    _oss_pdec_ntp_kmstr(_g, &_out_data->eventTime, _chars + 0);
	} else {
	    _out_data->eventTime = NULL;
	}
	OSS_CNTX_SET(17)
	_dp_EventTypeId(_g, &_out_data->eventType);
	OSS_CNTX_SET(16)
	if (_pbase[0] & 0x40) {
	    _out_data->bit_mask |= 0x80000000;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
	    _out_data->eventInfo.userField = NULL;
#endif
	    _out_data->eventInfo.encoded.length = _oss_pdec_unconstr_uoct_ia(_g, &_out_data->eventInfo.encoded.value);
	    if (_out_data->eventInfo.encoded.length == 0 && ((STRICT_ENCODING_DECODING_RULES | AUTOMATIC_ENCDEC) & _g->decodingFlags))
		_oss_dec_error(_g, _zero_length_OpenType, 0L);
	    _out_data->eventInfo.pduNum = 0;
	    *(void **)&_out_data->eventInfo.decoded = NULL;
	} else {
	    memset(&(_out_data->eventInfo), 0, sizeof(OSSC::COssConstrainedOpenType ));
	}
	OSS_CNTX_POP(_oss_c)
	if (_extPres) {
	    _ea_count = _oss_pdec_eap(_g, &_pext);
	    _oss_pdec_eas(_g, _pext, _ea_count, 0);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dEventReportResult(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EventReportResult *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(14,100)
    _out_data = (_EventReportResult *)_oss_dec_const_alloc(_g, sizeof(_EventReportResult));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if ((_data_tag != 0x8000 && _data_tag != 0x8001)
	    || (_total_len >= 0 && _bufpos >= _end_pos))
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->managedObjectClass, 0, sizeof(_out_data->managedObjectClass));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 3)
	    _d_ObjectClass(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->managedObjectClass);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if ((_data_tag != 0x8002 && _data_tag != 0x8003 && _data_tag != 0x8004)
	    || (_total_len >= 0 && _bufpos >= _end_pos))
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    memset(&_out_data->managedObjectInstance, 0, sizeof(_out_data->managedObjectInstance));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 2)
	    _d_ObjectInstance(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->managedObjectInstance);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8005 || _bufpos >= _end_pos)
	    _out_data->currentTime = NULL;
	else {
	    OSS_CNTX_PUSH(_oss_c, 1)
	    _out_data->currentTime = NULL;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 133 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8005) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x85 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80050000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8005;
	    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->currentTime, -1, 0);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x10 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x20000000;
	    memset(&_out_data->eventReply, 0, sizeof(_out_data->eventReply));
	}
else {
	    _out_data->bit_mask |= 0x20000000;
	    OSS_CNTX_PUSH(_oss_c, 101)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x10) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x10 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		int _indef_tags = 0;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		OSS_CNTX_INIT

		_out_data->eventReply.bit_mask = 0;
		OSS_CNTX_PUSH(_oss_c, 17)
		_d_EventTypeId(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->eventReply.eventType);
		OSS_CNTX_POP(_oss_c)
		if (_bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8008 || _bufpos >= _end_pos)
		 {
		    _out_data->eventReply.bit_mask &= ~0x80000000;
		    memset(&_out_data->eventReply.eventReplyInfo, 0, sizeof(_out_data->eventReply.eventReplyInfo));
		}
else {
		    _out_data->eventReply.bit_mask |= 0x80000000;
		    OSS_CNTX_PUSH(_oss_c, 102)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 168 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8008) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x88 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80080000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8008;
		    if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
		    _out_data->eventReply.eventReplyInfo.userField = NULL;
#endif
		    _oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->eventReply.eventReplyInfo.encoded);
		    _out_data->eventReply.eventReplyInfo.pduNum = 0;
		    *(void **)&_out_data->eventReply.eventReplyInfo.decoded = NULL;
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		if (_bufpos != _end_pos) {
		    if (_total_len < 0) {
			if (!_oss_c->_tag_decoded)
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			if (_data_tag)
			    _oss_dec_error(_g, _expec_eoc, 0L);
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
		    } else
			_oss_dec_error(_g, _inconsis_len, 0L);
		}
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    OSS_CNTX_POP(_oss_c)
	}
	while (_bufpos < _end_pos || _total_len < 0) {
	    if (!_oss_c->_tag_decoded) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (!_data_tag)
		break;
	    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    _oss_c->_tag_decoded = FALSE;
	}
	if (_total_len < 0 && !_data_tag) {
	    if (_oss_dec_length(_g, &_bufpos, &_buflen))
		_oss_dec_error(_g, _non_std_eoc, 0L);
	    _oss_c->_tag_decoded = FALSE;
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpEventReportResult(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EventReportResult	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(14,100)
    _out_data = (_EventReportResult *)_oss_dec_const_alloc(_g, sizeof(_EventReportResult));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	unsigned char _pbase[1];
	unsigned char *_pext;
	unsigned char _extPres = 0x00;
	unsigned long _ea_count = 0;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	_extPres = _oss_get_1bit_unaligned(_g);
	*_pbase = _oss_get_4bit_unaligned(_g);
	OSS_CNTX_PUSH(_oss_c, 3)
	if (_pbase[0] & 0x80) {
	    _out_data->bit_mask |= 0x80000000;
	    _dp_ObjectClass(_g, &_out_data->managedObjectClass);
	} else {
	    memset(&(_out_data->managedObjectClass), 0, sizeof(_ActionTypeId ));
	}
	OSS_CNTX_SET(2)
	if (_pbase[0] & 0x40) {
	    _out_data->bit_mask |= 0x40000000;
	    _dp_ObjectInstance(_g, &_out_data->managedObjectInstance);
	} else {
	    memset(&(_out_data->managedObjectInstance), 0, sizeof(_ObjectInstance ));
	}
	OSS_CNTX_SET(1)
	if (_pbase[0] & 0x20) {
	    _oss_pdec_ntp_kmstr(_g, &_out_data->currentTime, _chars + 0);
	} else {
	    _out_data->currentTime = NULL;
	}
	OSS_CNTX_SET(101)
	if (_pbase[0] & 0x10) {
	    _out_data->bit_mask |= 0x20000000;
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_out_data->eventReply.bit_mask = (OSS_UINT32)_oss_get_1bit_unaligned(_g) << 24;
		OSS_CNTX_PUSH(_oss_c, 17)
		_dp_EventTypeId(_g, &_out_data->eventReply.eventType);
		OSS_CNTX_SET(102)
		if (_out_data->eventReply.bit_mask & 0x80000000) {
#ifdef OSS_OPENTYPE_HAS_USERFIELD
		    _out_data->eventReply.eventReplyInfo.userField = NULL;
#endif
		    _out_data->eventReply.eventReplyInfo.encoded.length = _oss_pdec_unconstr_uoct_ia(_g, &_out_data->eventReply.eventReplyInfo.encoded.value);
		    if (_out_data->eventReply.eventReplyInfo.encoded.length == 0 && ((STRICT_ENCODING_DECODING_RULES | AUTOMATIC_ENCDEC) & _g->decodingFlags))
			_oss_dec_error(_g, _zero_length_OpenType, 0L);
		    _out_data->eventReply.eventReplyInfo.pduNum = 0;
		    *(void **)&_out_data->eventReply.eventReplyInfo.decoded = NULL;
		} else {
		    memset(&(_out_data->eventReply.eventReplyInfo), 0, sizeof(OSSC::COssConstrainedOpenType ));
		}
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	} else {
	    memset(&(_out_data->eventReply), 0, sizeof(_EventReply ));
	}
	OSS_CNTX_POP(_oss_c)
	if (_extPres) {
	    _ea_count = _oss_pdec_eap(_g, &_pext);
	    _oss_pdec_eas(_g, _pext, _ea_count, 0);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dGetArgument(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _GetArgument *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(15,103)
    _out_data = (_GetArgument *)_oss_dec_const_alloc(_g, sizeof(_GetArgument));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 82)
	_d_ObjectClass(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->baseManagedObjectClass);
	OSS_CNTX_SET(81)
	_d_ObjectInstance(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->baseManagedObjectInstance);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8005 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->accessControl, 0, sizeof(_out_data->accessControl));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 80)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 165 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8005) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x85 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80050000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8005;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8);
	    _data_tag = 0x8;
	    _d_External(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->accessControl);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8006 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->synchronization, &GetArgument::default_synchronization, sizeof(GetArgument::default_synchronization));
#else
	    _out_data->synchronization = bestEffort;
#endif
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 79)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 134 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8006) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x86 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80060000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8006;
	    _out_data->synchronization = (enum CMISSync )_oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8007 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x20000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->scope, &_v34, sizeof(_v34));
#else
	    memset(&(_out_data->scope), 0, sizeof(_Scope ));
#endif
	}
else {
	    _out_data->bit_mask |= 0x20000000;
	    OSS_CNTX_PUSH(_oss_c, 78)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 167 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8007) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x87 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80070000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8007;
	    if (_data_length < 0) ++_indef_tags;
	    _d_Scope(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->scope);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if ((_data_tag != 0x8008 && _data_tag != 0x8009 && _data_tag != 0x800A && _data_tag != 0x800B)
	    || (_total_len >= 0 && _bufpos >= _end_pos))
	 {
	    _out_data->bit_mask &= ~0x10000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->filter, &_v35, sizeof(_v35));
#else
	    memset(&(_out_data->filter), 0, sizeof(_CMISFilter ));
#endif
	}
else {
	    _out_data->bit_mask |= 0x10000000;
	    OSS_CNTX_PUSH(_oss_c, 77)
	    _d_CMISFilter(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->filter);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x800C || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x8000000;
	    memset(&_out_data->attributeIdList, 0, sizeof(_out_data->attributeIdList));
	}
else {
	    _out_data->bit_mask |= 0x8000000;
	    OSS_CNTX_PUSH(_oss_c, 104)
	    _out_data->attributeIdList = NULL;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 172 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x800C) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x8C : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x800C0000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x800C;
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_MissingAttributeValue_PARAMETER * _temp = (_MissingAttributeValue_PARAMETER *)&_out_data->attributeIdList;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
		unsigned long count = 0;
#endif
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 105)
		for (;;) {
		    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos > _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
		    count++;
#endif
		    _temp->next = (_MissingAttributeValue_PARAMETER *)_oss_dec_const_alloc(_g, sizeof(_MissingAttributeValue_PARAMETER));
		    _temp = _temp->next;
		    OSS_CNTX_SETOCC(count)
		    _d_AttributeId(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
		}
		_temp->next = NULL;
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    OSS_CNTX_POP(_oss_c)
	}
	while (_bufpos < _end_pos || _total_len < 0) {
	    if (!_oss_c->_tag_decoded) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (!_data_tag)
		break;
	    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    _oss_c->_tag_decoded = FALSE;
	}
	if (_total_len < 0 && !_data_tag) {
	    if (_oss_dec_length(_g, &_bufpos, &_buflen))
		_oss_dec_error(_g, _non_std_eoc, 0L);
	    _oss_c->_tag_decoded = FALSE;
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpGetArgument(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _GetArgument	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(15,103)
    _out_data = (_GetArgument *)_oss_dec_const_alloc(_g, sizeof(_GetArgument));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	unsigned char *_pext;
	unsigned char _extPres = 0x00;
	unsigned long _ea_count = 0;
	OSS_CNTX_INIT

	_extPres = _oss_get_1bit_unaligned(_g);
	_out_data->bit_mask = (OSS_UINT32)_oss_get_5bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 82)
	_dp_ObjectClass(_g, &_out_data->baseManagedObjectClass);
	OSS_CNTX_SET(81)
	_dp_ObjectInstance(_g, &_out_data->baseManagedObjectInstance);
	OSS_CNTX_SET(80)
	if (_out_data->bit_mask & 0x80000000) {
	    _dp_External(_g, &_out_data->accessControl);
	} else {
	    memset(&(_out_data->accessControl), 0, sizeof(_External ));
	}
	OSS_CNTX_SET(79)
	if (_out_data->bit_mask & 0x40000000) {
	    _out_data->synchronization = (enum CMISSync)_oss_pdec_uenum(_g, (struct _enum_data*)&_enums[5], NULL);
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->synchronization, &GetArgument::default_synchronization, sizeof(GetArgument::default_synchronization));
#else
	    _out_data->synchronization = bestEffort;
#endif
	}
	OSS_CNTX_SET(78)
	if (_out_data->bit_mask & 0x20000000) {
	    _dp_Scope(_g, &_out_data->scope);
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->scope, &_v34, sizeof(_v34));
#else
	    memset(&(_out_data->scope), 0, sizeof(_Scope ));
#endif
	}
	OSS_CNTX_SET(77)
	if (_out_data->bit_mask & 0x10000000) {
	    _dp_CMISFilter(_g, &_out_data->filter);
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->filter, &_v35, sizeof(_v35));
#else
	    memset(&(_out_data->filter), 0, sizeof(_CMISFilter ));
#endif
	}
	OSS_CNTX_SET(104)
	_out_data->attributeIdList = NULL;
	if (_out_data->bit_mask & 0x8000000) {
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_MissingAttributeValue_PARAMETER * _temp = (_MissingAttributeValue_PARAMETER *)&_out_data->attributeIdList;
		unsigned long count = 0;
		ossBoolean _last = FALSE;
		unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		unsigned long _prev_fragm0 = 0;
#endif

		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 105)
		while (!_last) {
		    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
			if ((!_last) && _index && (_prev_fragm0 < 65536))
			    _oss_dec_error(_g, _invalid_fragmentation, 0L);
			_prev_fragm0 = count - _index;
		    }
#endif
		    for (; (unsigned long)_index < count; _index++) {
			_temp->next = (_MissingAttributeValue_PARAMETER *)_oss_dec_const_alloc(_g, sizeof(_MissingAttributeValue_PARAMETER));
			_temp = _temp->next;
			OSS_CNTX_SETOCC(_index + 1)
			_dp_AttributeId(_g, &_temp->value);
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		_temp->next = NULL;
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	} else {
	    _out_data->attributeIdList = NULL;
	}
	OSS_CNTX_POP(_oss_c)
	if (_extPres) {
	    _ea_count = _oss_pdec_eap(_g, &_pext);
	    _oss_pdec_eas(_g, _pext, _ea_count, 0);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dGetListError(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _GetListError *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(16,106)
    _out_data = (_GetListError *)_oss_dec_const_alloc(_g, sizeof(_GetListError));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_GetListError(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpGetListError(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _GetListError	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(16,106)
    _out_data = (_GetListError *)_oss_dec_const_alloc(_g, sizeof(_GetListError));
    _dp_GetListError(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dGetResult(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CreateResult *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(17,107)
    _out_data = (_CreateResult *)_oss_dec_const_alloc(_g, sizeof(_CreateResult));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_GetResult(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpGetResult(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CreateResult	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(17,107)
    _out_data = (_CreateResult *)_oss_dec_const_alloc(_g, sizeof(_CreateResult));
    _dp_GetResult(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dInvalidArgumentValue(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvalidArgumentValue *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(18,108)
    _out_data = (_InvalidArgumentValue *)_oss_dec_const_alloc(_g, sizeof(_InvalidArgumentValue));
    _oss_c->_tag_decoded = FALSE;
    _d_InvalidArgumentValue(_g, &_bufpos, &_buflen, 0, 0, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpInvalidArgumentValue(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvalidArgumentValue	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(18,108)
    _out_data = (_InvalidArgumentValue *)_oss_dec_const_alloc(_g, sizeof(_InvalidArgumentValue));
    _dp_InvalidArgumentValue(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dInvokeIDType(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeId *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(19,109)
    _out_data = (_InvokeId *)_oss_dec_const_alloc(_g, sizeof(_InvokeId));
    _oss_c->_tag_decoded = FALSE;
    _d_InvokeId(_g, &_bufpos, &_buflen, 0, 0, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpInvokeIDType(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeId	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(19,109)
    _out_data = (_InvokeId *)_oss_dec_const_alloc(_g, sizeof(_InvokeId));
    _dp_InvokeId(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dLinkedReplyArgument(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _LinkedReplyArgument *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(20,110)
    _out_data = (_LinkedReplyArgument *)_oss_dec_const_alloc(_g, sizeof(_LinkedReplyArgument));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	switch (_data_tag) {
	default:
	    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
	    switch (_data_tag & 0x7fff) {
	    case 0x0: {
		OSS_CNTX_PUSH(_oss_c, 111)
		_out_data->choice = 1;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.getResult = (_CreateResult *)_oss_dec_const_alloc(_g, sizeof(_CreateResult));
		_d_GetResult(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.getResult);
	    }   break;
	    case 0x1: {
		OSS_CNTX_PUSH(_oss_c, 112)
		_out_data->choice = 2;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.getListError = (_GetListError *)_oss_dec_const_alloc(_g, sizeof(_GetListError));
		_d_GetListError(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.getListError);
	    }   break;
	    case 0x2: {
		OSS_CNTX_PUSH(_oss_c, 113)
		_out_data->choice = 3;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.setResult = (_CreateResult *)_oss_dec_const_alloc(_g, sizeof(_CreateResult));
		_d_SetResult(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.setResult);
	    }   break;
	    case 0x3: {
		OSS_CNTX_PUSH(_oss_c, 114)
		_out_data->choice = 4;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.setListError = (_SetListError *)_oss_dec_const_alloc(_g, sizeof(_SetListError));
		_d_SetListError(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.setListError);
	    }   break;
	    case 0x4: {
		OSS_CNTX_PUSH(_oss_c, 115)
		_out_data->choice = 5;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.actionResult = (_ActionResult *)_oss_dec_const_alloc(_g, sizeof(_ActionResult));
		_d_ActionResult(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.actionResult);
	    }   break;
	    case 0x5: {
		OSS_CNTX_PUSH(_oss_c, 116)
		_out_data->choice = 6;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.processingFailure = (_ProcessingFailure *)_oss_dec_const_alloc(_g, sizeof(_ProcessingFailure));
		_d_ProcessingFailure(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.processingFailure);
	    }   break;
	    case 0x6: {
		OSS_CNTX_PUSH(_oss_c, 117)
		_out_data->choice = 7;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.deleteResult = (_DeleteResult *)_oss_dec_const_alloc(_g, sizeof(_DeleteResult));
		_d_DeleteResult(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.deleteResult);
	    }   break;
	    case 0x7: {
		OSS_CNTX_PUSH(_oss_c, 118)
		_out_data->choice = 8;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.actionError = (_ActionError *)_oss_dec_const_alloc(_g, sizeof(_ActionError));
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    int _indef_tags = 0;
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    OSS_CNTX_INIT

		    _out_data->u.actionError->bit_mask = 0;
		    if (_bufpos < _end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if ((_data_tag != 0x8000 && _data_tag != 0x8001)
			|| (_total_len >= 0 && _bufpos >= _end_pos))
		     {
			_out_data->u.actionError->bit_mask &= ~0x80000000;
			memset(&_out_data->u.actionError->managedObjectClass, 0, sizeof(_out_data->u.actionError->managedObjectClass));
		    }
else {
			_out_data->u.actionError->bit_mask |= 0x80000000;
			OSS_CNTX_PUSH(_oss_c, 3)
			_d_ObjectClass(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.actionError->managedObjectClass);
			OSS_CNTX_POP(_oss_c)
		    }
		    if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if ((_data_tag != 0x8002 && _data_tag != 0x8003 && _data_tag != 0x8004)
			|| (_total_len >= 0 && _bufpos >= _end_pos))
		     {
			_out_data->u.actionError->bit_mask &= ~0x40000000;
			memset(&_out_data->u.actionError->managedObjectInstance, 0, sizeof(_out_data->u.actionError->managedObjectInstance));
		    }
else {
			_out_data->u.actionError->bit_mask |= 0x40000000;
			OSS_CNTX_PUSH(_oss_c, 2)
			_d_ObjectInstance(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.actionError->managedObjectInstance);
			OSS_CNTX_POP(_oss_c)
		    }
		    if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if (_data_tag != 0x8005 || _bufpos >= _end_pos)
			_out_data->u.actionError->currentTime = NULL;
		    else {
			OSS_CNTX_PUSH(_oss_c, 1)
			_out_data->u.actionError->currentTime = NULL;
			if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 133 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else {
			    if (!_oss_c->_tag_decoded || _data_tag == 0x8005) {
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x85 : 0);
			    } else
				_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80050000);
			    _oss_c->_tag_decoded = FALSE;
			}
			_data_tag = 0x8005;
			_oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.actionError->currentTime, -1, 0);
			OSS_CNTX_POP(_oss_c)
		    }
		    OSS_CNTX_PUSH(_oss_c, 119)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 166 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8006) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x86 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80060000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8006;
		    if (_data_length < 0) ++_indef_tags;
		    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
		    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			long _total_len = _data_length;
			char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
			OSS_CNTX_INIT

			OSS_CNTX_PUSH(_oss_c, 36)
			if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 10 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else {
			    if (!_oss_c->_tag_decoded || _data_tag == 0xA) {
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0xA : 0);
			    } else
				_oss_dec_error(_g, _tag_mismatch, _data_tag | 0xA0000);
			    _oss_c->_tag_decoded = FALSE;
			}
			_data_tag = 0xA;
			_out_data->u.actionError->actionErrorInfo.errorStatus = (enum _enum2 )_oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
			OSS_CNTX_SET(120)
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			{
			    int _indef_tags = 0;
			    OSS_CNTX_INIT

			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			    if (_data_tag == 0x8002 || _data_tag == 0x8003) {
				OSS_CNTX_PUSH(_oss_c, 19)
				_out_data->u.actionError->actionErrorInfo.errorInfo.choice = 3;
				_out_data->u.actionError->actionErrorInfo.errorInfo.u.actionType = (_ActionTypeId *)_oss_dec_const_alloc(_g, sizeof(_ActionTypeId));
				_d_ActionTypeId(_g, &_bufpos, &_buflen, 0, _data_tag, _out_data->u.actionError->actionErrorInfo.errorInfo.u.actionType);
				OSS_CNTX_POP(_oss_c)
			    } else
			    switch (_data_tag) {
			    default:
				if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
				switch (_data_tag & 0x7fff) {
				case 0x0: {
				    OSS_CNTX_PUSH(_oss_c, 121)
				    _out_data->u.actionError->actionErrorInfo.errorInfo.choice = 1;

				    _oss_c->_tag_decoded = FALSE;
				    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					_buflen--;
					_bufpos++;
				    } else
					_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				    if (_data_length < 0) ++_indef_tags;
				    _out_data->u.actionError->actionErrorInfo.errorInfo.u.actionArgument = (_NoSuchArgument *)_oss_dec_const_alloc(_g, sizeof(_NoSuchArgument));
				    _d_NoSuchArgument(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.actionError->actionErrorInfo.errorInfo.u.actionArgument);
				    while (_indef_tags > 0) {
					if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
					    _buflen -= 2;
					    _bufpos += 2;
					} else
					    if (!_buflen || _bufpos[0])
						_oss_dec_error(_g, _expec_eoc, 0L);
					    else
						_oss_dec_error(_g, _non_std_eoc, 0L);
					_indef_tags--;
				    }
				}   break;
				case 0x1: {
				    OSS_CNTX_PUSH(_oss_c, 122)
				    _out_data->u.actionError->actionErrorInfo.errorInfo.choice = 2;

				    _oss_c->_tag_decoded = FALSE;
				    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					_buflen--;
					_bufpos++;
				    } else
					_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				    if (_data_length < 0) ++_indef_tags;
				    _out_data->u.actionError->actionErrorInfo.errorInfo.u.argumentValue = (_InvalidArgumentValue *)_oss_dec_const_alloc(_g, sizeof(_InvalidArgumentValue));
				    _d_InvalidArgumentValue(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.actionError->actionErrorInfo.errorInfo.u.argumentValue);
				    while (_indef_tags > 0) {
					if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
					    _buflen -= 2;
					    _bufpos += 2;
					} else
					    if (!_buflen || _bufpos[0])
						_oss_dec_error(_g, _expec_eoc, 0L);
					    else
						_oss_dec_error(_g, _non_std_eoc, 0L);
					_indef_tags--;
				    }
				}   break;
				default:
				    _oss_dec_error(_g, _unknown_field, _data_tag);
				}
				break;
			    }
			    OSS_CNTX_POP(_oss_c)
			}
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			OSS_CNTX_POP(_oss_c)
			while (_bufpos < _end_pos || _total_len < 0) {
			    if (!_oss_c->_tag_decoded) {
				if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				    _buflen--;
				    _oss_c->_bitpos = _bufpos[0] & 0x20;
				    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				    _bufpos++;
				} else
				    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
				_oss_c->_tag_decoded = TRUE;
			    }
			    if (!_data_tag)
				break;
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
			    _oss_c->_tag_decoded = FALSE;
			}
			if (_total_len < 0 && !_data_tag) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			}
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    OSS_CNTX_POP(_oss_c)
		    while (_bufpos < _end_pos || _total_len < 0) {
			if (!_oss_c->_tag_decoded) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (!_data_tag)
			    break;
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			_oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
			_oss_c->_tag_decoded = FALSE;
		    }
		    if (_total_len < 0 && !_data_tag) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    }   break;
	    case 0x8: {
		OSS_CNTX_PUSH(_oss_c, 123)
		_out_data->choice = 9;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.deleteError = (_DeleteError *)_oss_dec_const_alloc(_g, sizeof(_DeleteError));
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    int _indef_tags = 0;
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    OSS_CNTX_INIT

		    _out_data->u.deleteError->bit_mask = 0;
		    if (_bufpos < _end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if ((_data_tag != 0x8000 && _data_tag != 0x8001)
			|| (_total_len >= 0 && _bufpos >= _end_pos))
		     {
			_out_data->u.deleteError->bit_mask &= ~0x80000000;
			memset(&_out_data->u.deleteError->managedObjectClass, 0, sizeof(_out_data->u.deleteError->managedObjectClass));
		    }
else {
			_out_data->u.deleteError->bit_mask |= 0x80000000;
			OSS_CNTX_PUSH(_oss_c, 3)
			_d_ObjectClass(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.deleteError->managedObjectClass);
			OSS_CNTX_POP(_oss_c)
		    }
		    if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if ((_data_tag != 0x8002 && _data_tag != 0x8003 && _data_tag != 0x8004)
			|| (_total_len >= 0 && _bufpos >= _end_pos))
		     {
			_out_data->u.deleteError->bit_mask &= ~0x40000000;
			memset(&_out_data->u.deleteError->managedObjectInstance, 0, sizeof(_out_data->u.deleteError->managedObjectInstance));
		    }
else {
			_out_data->u.deleteError->bit_mask |= 0x40000000;
			OSS_CNTX_PUSH(_oss_c, 2)
			_d_ObjectInstance(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.deleteError->managedObjectInstance);
			OSS_CNTX_POP(_oss_c)
		    }
		    if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if (_data_tag != 0x8005 || _bufpos >= _end_pos)
			_out_data->u.deleteError->currentTime = NULL;
		    else {
			OSS_CNTX_PUSH(_oss_c, 1)
			_out_data->u.deleteError->currentTime = NULL;
			if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 133 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else {
			    if (!_oss_c->_tag_decoded || _data_tag == 0x8005) {
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x85 : 0);
			    } else
				_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80050000);
			    _oss_c->_tag_decoded = FALSE;
			}
			_data_tag = 0x8005;
			_oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.deleteError->currentTime, -1, 0);
			OSS_CNTX_POP(_oss_c)
		    }
		    OSS_CNTX_PUSH(_oss_c, 124)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 166 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8006) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x86 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80060000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8006;
		    if (_data_length < 0) ++_indef_tags;
		    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 10 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0xA);
		    _data_tag = 0xA;
		    _out_data->u.deleteError->deleteErrorInfo = (enum _enum5 )_oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    OSS_CNTX_POP(_oss_c)
		    while (_bufpos < _end_pos || _total_len < 0) {
			if (!_oss_c->_tag_decoded) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (!_data_tag)
			    break;
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			_oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
			_oss_c->_tag_decoded = FALSE;
		    }
		    if (_total_len < 0 && !_data_tag) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    break;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpLinkedReplyArgument(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _LinkedReplyArgument	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(20,110)
    _out_data = (_LinkedReplyArgument *)_oss_dec_const_alloc(_g, sizeof(_LinkedReplyArgument));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_4int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 111)
	    _out_data->u.getResult = (_CreateResult *)_oss_dec_const_alloc(_g, sizeof(_CreateResult));
	    _dp_GetResult(_g, _out_data->u.getResult);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 112)
	    _out_data->u.getListError = (_GetListError *)_oss_dec_const_alloc(_g, sizeof(_GetListError));
	    _dp_GetListError(_g, _out_data->u.getListError);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 113)
	    _out_data->u.setResult = (_CreateResult *)_oss_dec_const_alloc(_g, sizeof(_CreateResult));
	    _dp_SetResult(_g, _out_data->u.setResult);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 114)
	    _out_data->u.setListError = (_SetListError *)_oss_dec_const_alloc(_g, sizeof(_SetListError));
	    _dp_SetListError(_g, _out_data->u.setListError);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 115)
	    _out_data->u.actionResult = (_ActionResult *)_oss_dec_const_alloc(_g, sizeof(_ActionResult));
	    _dp_ActionResult(_g, _out_data->u.actionResult);
	    break;
	case 6:
	    OSS_CNTX_PUSH(_oss_c, 116)
	    _out_data->u.processingFailure = (_ProcessingFailure *)_oss_dec_const_alloc(_g, sizeof(_ProcessingFailure));
	    _dp_ProcessingFailure(_g, _out_data->u.processingFailure);
	    break;
	case 7:
	    OSS_CNTX_PUSH(_oss_c, 117)
	    _out_data->u.deleteResult = (_DeleteResult *)_oss_dec_const_alloc(_g, sizeof(_DeleteResult));
	    _dp_DeleteResult(_g, _out_data->u.deleteResult);
	    break;
	case 8:
	    OSS_CNTX_PUSH(_oss_c, 118)
	    _out_data->u.actionError = (_ActionError *)_oss_dec_const_alloc(_g, sizeof(_ActionError));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		unsigned char _pbase[1];
		unsigned char *_pext;
		unsigned char _extPres = 0x00;
		unsigned long _ea_count = 0;
		OSS_CNTX_INIT

		_out_data->u.actionError->bit_mask = 0;
		_extPres = _oss_get_1bit_unaligned(_g);
		*_pbase = _oss_get_3bit_unaligned(_g);
		OSS_CNTX_PUSH(_oss_c, 3)
		if (_pbase[0] & 0x80) {
		    _out_data->u.actionError->bit_mask |= 0x80000000;
		    _dp_ObjectClass(_g, &_out_data->u.actionError->managedObjectClass);
		} else {
		    memset(&(_out_data->u.actionError->managedObjectClass), 0, sizeof(_ActionTypeId ));
		}
		OSS_CNTX_SET(2)
		if (_pbase[0] & 0x40) {
		    _out_data->u.actionError->bit_mask |= 0x40000000;
		    _dp_ObjectInstance(_g, &_out_data->u.actionError->managedObjectInstance);
		} else {
		    memset(&(_out_data->u.actionError->managedObjectInstance), 0, sizeof(_ObjectInstance ));
		}
		OSS_CNTX_SET(1)
		if (_pbase[0] & 0x20) {
		    _oss_pdec_ntp_kmstr(_g, &_out_data->u.actionError->currentTime, _chars + 0);
		} else {
		    _out_data->u.actionError->currentTime = NULL;
		}
		OSS_CNTX_SET(119)
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    unsigned char *_pext;
		    unsigned char _extPres = 0x00;
		    unsigned long _ea_count = 0;
		    OSS_CNTX_INIT

		    _extPres = _oss_get_1bit_unaligned(_g);
		    OSS_CNTX_PUSH(_oss_c, 36)
		    _out_data->u.actionError->actionErrorInfo.errorStatus = (enum _enum2)_oss_pdec_enum(_g, (struct _enum_data*)&_enums[6], (struct _enum_data*)&_enums[7]);
		    OSS_CNTX_SET(120)
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			OSS_CNTX_INIT

			{

			    _out_data->u.actionError->actionErrorInfo.errorInfo.choice = (int)_oss_pdec_nonneg_2int(_g) + 1;
			}
			switch (_out_data->u.actionError->actionErrorInfo.errorInfo.choice) {
			case 1:
			    OSS_CNTX_PUSH(_oss_c, 121)
			    _out_data->u.actionError->actionErrorInfo.errorInfo.u.actionArgument = (_NoSuchArgument *)_oss_dec_const_alloc(_g, sizeof(_NoSuchArgument));
			    _dp_NoSuchArgument(_g, _out_data->u.actionError->actionErrorInfo.errorInfo.u.actionArgument);
			    break;
			case 2:
			    OSS_CNTX_PUSH(_oss_c, 122)
			    _out_data->u.actionError->actionErrorInfo.errorInfo.u.argumentValue = (_InvalidArgumentValue *)_oss_dec_const_alloc(_g, sizeof(_InvalidArgumentValue));
			    _dp_InvalidArgumentValue(_g, _out_data->u.actionError->actionErrorInfo.errorInfo.u.argumentValue);
			    break;
			case 3:
			    OSS_CNTX_PUSH(_oss_c, 19)
			    _out_data->u.actionError->actionErrorInfo.errorInfo.u.actionType = (_ActionTypeId *)_oss_dec_const_alloc(_g, sizeof(_ActionTypeId));
			    _dp_ActionTypeId(_g, _out_data->u.actionError->actionErrorInfo.errorInfo.u.actionType);
			    break;
			default:
			    _oss_enc_error(_g, _bad_choice, _out_data->u.actionError->actionErrorInfo.errorInfo.choice);	/* Bad choice selector. */
			}
			OSS_CNTX_POP(_oss_c)
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		    OSS_CNTX_POP(_oss_c)
		    if (_extPres) {
			_ea_count = _oss_pdec_eap(_g, &_pext);
			_oss_pdec_eas(_g, _pext, _ea_count, 0);
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		OSS_CNTX_POP(_oss_c)
		if (_extPres) {
		    _ea_count = _oss_pdec_eap(_g, &_pext);
		    _oss_pdec_eas(_g, _pext, _ea_count, 0);
		}
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    break;
	case 9:
	    OSS_CNTX_PUSH(_oss_c, 123)
	    _out_data->u.deleteError = (_DeleteError *)_oss_dec_const_alloc(_g, sizeof(_DeleteError));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		unsigned char _pbase[1];
		unsigned char *_pext;
		unsigned char _extPres = 0x00;
		unsigned long _ea_count = 0;
		OSS_CNTX_INIT

		_out_data->u.deleteError->bit_mask = 0;
		_extPres = _oss_get_1bit_unaligned(_g);
		*_pbase = _oss_get_3bit_unaligned(_g);
		OSS_CNTX_PUSH(_oss_c, 3)
		if (_pbase[0] & 0x80) {
		    _out_data->u.deleteError->bit_mask |= 0x80000000;
		    _dp_ObjectClass(_g, &_out_data->u.deleteError->managedObjectClass);
		} else {
		    memset(&(_out_data->u.deleteError->managedObjectClass), 0, sizeof(_ActionTypeId ));
		}
		OSS_CNTX_SET(2)
		if (_pbase[0] & 0x40) {
		    _out_data->u.deleteError->bit_mask |= 0x40000000;
		    _dp_ObjectInstance(_g, &_out_data->u.deleteError->managedObjectInstance);
		} else {
		    memset(&(_out_data->u.deleteError->managedObjectInstance), 0, sizeof(_ObjectInstance ));
		}
		OSS_CNTX_SET(1)
		if (_pbase[0] & 0x20) {
		    _oss_pdec_ntp_kmstr(_g, &_out_data->u.deleteError->currentTime, _chars + 0);
		} else {
		    _out_data->u.deleteError->currentTime = NULL;
		}
		OSS_CNTX_SET(124)
		_out_data->u.deleteError->deleteErrorInfo = (enum _enum5)_oss_pdec_enum(_g, (struct _enum_data*)&_enums[8], (struct _enum_data*)&_enums[9]);
		OSS_CNTX_POP(_oss_c)
		if (_extPres) {
		    _ea_count = _oss_pdec_eap(_g, &_pext);
		    _oss_pdec_eas(_g, _pext, _ea_count, 0);
		}
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dNoSuchAction(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _NoSuchAction *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(21,125)
    _out_data = (_NoSuchAction *)_oss_dec_const_alloc(_g, sizeof(_NoSuchAction));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 3)
	_d_ObjectClass(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->managedObjectClass);
	OSS_CNTX_SET(19)
	_d_ActionTypeId(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->actionType);
	OSS_CNTX_POP(_oss_c)
	while (_bufpos < _end_pos || _total_len < 0) {
	    if (!_oss_c->_tag_decoded) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (!_data_tag)
		break;
	    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    _oss_c->_tag_decoded = FALSE;
	}
	if (_total_len < 0 && !_data_tag) {
	    if (_oss_dec_length(_g, &_bufpos, &_buflen))
		_oss_dec_error(_g, _non_std_eoc, 0L);
	    _oss_c->_tag_decoded = FALSE;
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpNoSuchAction(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _NoSuchAction	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(21,125)
    _out_data = (_NoSuchAction *)_oss_dec_const_alloc(_g, sizeof(_NoSuchAction));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	unsigned char *_pext;
	unsigned char _extPres = 0x00;
	unsigned long _ea_count = 0;
	OSS_CNTX_INIT

	_extPres = _oss_get_1bit_unaligned(_g);
	OSS_CNTX_PUSH(_oss_c, 3)
	_dp_ObjectClass(_g, &_out_data->managedObjectClass);
	OSS_CNTX_SET(19)
	_dp_ActionTypeId(_g, &_out_data->actionType);
	OSS_CNTX_POP(_oss_c)
	if (_extPres) {
	    _ea_count = _oss_pdec_eap(_g, &_pext);
	    _oss_pdec_eas(_g, _pext, _ea_count, 0);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dNoSuchArgument(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _NoSuchArgument *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(22,126)
    _out_data = (_NoSuchArgument *)_oss_dec_const_alloc(_g, sizeof(_NoSuchArgument));
    _oss_c->_tag_decoded = FALSE;
    _d_NoSuchArgument(_g, &_bufpos, &_buflen, 0, 0, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpNoSuchArgument(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _NoSuchArgument	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(22,126)
    _out_data = (_NoSuchArgument *)_oss_dec_const_alloc(_g, sizeof(_NoSuchArgument));
    _dp_NoSuchArgument(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dNoSuchEventType(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _NoSuchEventType *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(23,127)
    _out_data = (_NoSuchEventType *)_oss_dec_const_alloc(_g, sizeof(_NoSuchEventType));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 3)
	_d_ObjectClass(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->managedObjectClass);
	OSS_CNTX_SET(17)
	_d_EventTypeId(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->eventType);
	OSS_CNTX_POP(_oss_c)
	while (_bufpos < _end_pos || _total_len < 0) {
	    if (!_oss_c->_tag_decoded) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (!_data_tag)
		break;
	    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    _oss_c->_tag_decoded = FALSE;
	}
	if (_total_len < 0 && !_data_tag) {
	    if (_oss_dec_length(_g, &_bufpos, &_buflen))
		_oss_dec_error(_g, _non_std_eoc, 0L);
	    _oss_c->_tag_decoded = FALSE;
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpNoSuchEventType(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _NoSuchEventType	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(23,127)
    _out_data = (_NoSuchEventType *)_oss_dec_const_alloc(_g, sizeof(_NoSuchEventType));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	unsigned char *_pext;
	unsigned char _extPres = 0x00;
	unsigned long _ea_count = 0;
	OSS_CNTX_INIT

	_extPres = _oss_get_1bit_unaligned(_g);
	OSS_CNTX_PUSH(_oss_c, 3)
	_dp_ObjectClass(_g, &_out_data->managedObjectClass);
	OSS_CNTX_SET(17)
	_dp_EventTypeId(_g, &_out_data->eventType);
	OSS_CNTX_POP(_oss_c)
	if (_extPres) {
	    _ea_count = _oss_pdec_eap(_g, &_pext);
	    _oss_pdec_eas(_g, _pext, _ea_count, 0);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dObjectClass(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ActionTypeId *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(24,128)
    _out_data = (_ActionTypeId *)_oss_dec_const_alloc(_g, sizeof(_ActionTypeId));
    _oss_c->_tag_decoded = FALSE;
    _d_ObjectClass(_g, &_bufpos, &_buflen, 0, 0, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpObjectClass(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ActionTypeId	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(24,128)
    _out_data = (_ActionTypeId *)_oss_dec_const_alloc(_g, sizeof(_ActionTypeId));
    _dp_ObjectClass(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dObjectInstance(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ObjectInstance *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(25,129)
    _out_data = (_ObjectInstance *)_oss_dec_const_alloc(_g, sizeof(_ObjectInstance));
    _oss_c->_tag_decoded = FALSE;
    _d_ObjectInstance(_g, &_bufpos, &_buflen, 0, 0, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpObjectInstance(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ObjectInstance	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(25,129)
    _out_data = (_ObjectInstance *)_oss_dec_const_alloc(_g, sizeof(_ObjectInstance));
    _dp_ObjectInstance(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dProcessingFailure(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ProcessingFailure *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(26,130)
    _out_data = (_ProcessingFailure *)_oss_dec_const_alloc(_g, sizeof(_ProcessingFailure));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_ProcessingFailure(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpProcessingFailure(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ProcessingFailure	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(26,130)
    _out_data = (_ProcessingFailure *)_oss_dec_const_alloc(_g, sizeof(_ProcessingFailure));
    _dp_ProcessingFailure(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dScope(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Scope *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(27,131)
    _out_data = (_Scope *)_oss_dec_const_alloc(_g, sizeof(_Scope));
    _oss_c->_tag_decoded = FALSE;
    _d_Scope(_g, &_bufpos, &_buflen, 0, 0, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpScope(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Scope	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(27,131)
    _out_data = (_Scope *)_oss_dec_const_alloc(_g, sizeof(_Scope));
    _dp_Scope(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dSetArgument(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SetArgument *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(28,132)
    _out_data = (_SetArgument *)_oss_dec_const_alloc(_g, sizeof(_SetArgument));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 82)
	_d_ObjectClass(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->baseManagedObjectClass);
	OSS_CNTX_SET(81)
	_d_ObjectInstance(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->baseManagedObjectInstance);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8005 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->accessControl, 0, sizeof(_out_data->accessControl));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 80)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 165 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8005) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x85 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80050000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8005;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8);
	    _data_tag = 0x8;
	    _d_External(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->accessControl);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8006 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->synchronization, &SetArgument::default_synchronization, sizeof(SetArgument::default_synchronization));
#else
	    _out_data->synchronization = bestEffort;
#endif
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 79)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 134 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8006) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x86 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80060000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8006;
	    _out_data->synchronization = (enum CMISSync )_oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8007 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x20000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->scope, &_v36, sizeof(_v36));
#else
	    memset(&(_out_data->scope), 0, sizeof(_Scope ));
#endif
	}
else {
	    _out_data->bit_mask |= 0x20000000;
	    OSS_CNTX_PUSH(_oss_c, 78)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 167 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8007) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x87 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80070000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8007;
	    if (_data_length < 0) ++_indef_tags;
	    _d_Scope(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->scope);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if ((_data_tag != 0x8008 && _data_tag != 0x8009 && _data_tag != 0x800A && _data_tag != 0x800B)
	    || (_total_len >= 0 && _bufpos >= _end_pos))
	 {
	    _out_data->bit_mask &= ~0x10000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->filter, &_v37, sizeof(_v37));
#else
	    memset(&(_out_data->filter), 0, sizeof(_CMISFilter ));
#endif
	}
else {
	    _out_data->bit_mask |= 0x10000000;
	    OSS_CNTX_PUSH(_oss_c, 77)
	    _d_CMISFilter(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->filter);
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 133)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 172 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x800C) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x8C : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x800C0000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x800C;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _setof8 * _temp = (_setof8 *)&_out_data->modificationList;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	    unsigned long count = 0;
#endif
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 134)
	    for (;;) {
		if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos > _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x10)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		_temp->next = (_setof8 *)_oss_dec_const_alloc(_g, sizeof(_setof8));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    OSS_CNTX_INIT

		    _temp->value.bit_mask = 0;
		    if (_bufpos < _end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if (_data_tag != 0x8002 || _bufpos >= _end_pos)
		     {
			_temp->value.bit_mask &= ~0x80000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
			memcpy(&_temp->value.modifyOperator, &__seq4::default_modifyOperator, sizeof(__seq4::default_modifyOperator));
#else
			_temp->value.modifyOperator = 0;
#endif
		    }
else {
			_temp->value.bit_mask |= 0x80000000;
			OSS_CNTX_PUSH(_oss_c, 35)
			if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 130 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else {
			    if (!_oss_c->_tag_decoded || _data_tag == 0x8002) {
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x82 : 0);
			    } else
				_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80020000);
			    _oss_c->_tag_decoded = FALSE;
			}
			_data_tag = 0x8002;
			_temp->value.modifyOperator = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
			OSS_CNTX_POP(_oss_c)
		    }
		    OSS_CNTX_PUSH(_oss_c, 34)
		    _d_AttributeId(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value.attributeId);
		    OSS_CNTX_POP(_oss_c)
		    if (_total_len < 0) {
			if (*_bufpos == 0) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			} else
			    _data_tag = 1;
		    }
		    if (_bufpos >= _end_pos || (_total_len < 0 && _data_tag == 0))
		     {
			_temp->value.bit_mask &= ~0x40000000;
			memset(&_temp->value.attributeValue, 0, sizeof(_temp->value.attributeValue));
		    }
else {
			_temp->value.bit_mask |= 0x40000000;
			OSS_CNTX_PUSH(_oss_c, 33)
			if (_data_length == 0) _data_length = 1;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
			_temp->value.attributeValue.userField = NULL;
#endif
			_oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_temp->value.attributeValue.encoded);
			_temp->value.attributeValue.pduNum = 0;
			*(void **)&_temp->value.attributeValue.decoded = NULL;
			OSS_CNTX_POP(_oss_c)
		    }
		    if (_bufpos != _end_pos) {
			if (_total_len < 0) {
			    if (!_oss_c->_tag_decoded)
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			    if (_data_tag)
				_oss_dec_error(_g, _expec_eoc, 0L);
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			} else
			    _oss_dec_error(_g, _inconsis_len, 0L);
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    }
	    _temp->next = NULL;
	    OSS_CNTX_POP(_oss_c)
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
	while (_bufpos < _end_pos || _total_len < 0) {
	    if (!_oss_c->_tag_decoded) {
		if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		_oss_c->_tag_decoded = TRUE;
	    }
	    if (!_data_tag)
		break;
	    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    _oss_c->_tag_decoded = FALSE;
	}
	if (_total_len < 0 && !_data_tag) {
	    if (_oss_dec_length(_g, &_bufpos, &_buflen))
		_oss_dec_error(_g, _non_std_eoc, 0L);
	    _oss_c->_tag_decoded = FALSE;
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpSetArgument(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SetArgument	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(28,132)
    _out_data = (_SetArgument *)_oss_dec_const_alloc(_g, sizeof(_SetArgument));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	unsigned char *_pext;
	unsigned char _extPres = 0x00;
	unsigned long _ea_count = 0;
	OSS_CNTX_INIT

	_extPres = _oss_get_1bit_unaligned(_g);
	_out_data->bit_mask = (OSS_UINT32)_oss_get_4bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 82)
	_dp_ObjectClass(_g, &_out_data->baseManagedObjectClass);
	OSS_CNTX_SET(81)
	_dp_ObjectInstance(_g, &_out_data->baseManagedObjectInstance);
	OSS_CNTX_SET(80)
	if (_out_data->bit_mask & 0x80000000) {
	    _dp_External(_g, &_out_data->accessControl);
	} else {
	    memset(&(_out_data->accessControl), 0, sizeof(_External ));
	}
	OSS_CNTX_SET(79)
	if (_out_data->bit_mask & 0x40000000) {
	    _out_data->synchronization = (enum CMISSync)_oss_pdec_uenum(_g, (struct _enum_data*)&_enums[5], NULL);
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->synchronization, &SetArgument::default_synchronization, sizeof(SetArgument::default_synchronization));
#else
	    _out_data->synchronization = bestEffort;
#endif
	}
	OSS_CNTX_SET(78)
	if (_out_data->bit_mask & 0x20000000) {
	    _dp_Scope(_g, &_out_data->scope);
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->scope, &_v36, sizeof(_v36));
#else
	    memset(&(_out_data->scope), 0, sizeof(_Scope ));
#endif
	}
	OSS_CNTX_SET(77)
	if (_out_data->bit_mask & 0x10000000) {
	    _dp_CMISFilter(_g, &_out_data->filter);
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->filter, &_v37, sizeof(_v37));
#else
	    memset(&(_out_data->filter), 0, sizeof(_CMISFilter ));
#endif
	}
	OSS_CNTX_SET(133)
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _setof8 * _temp = (_setof8 *)&_out_data->modificationList;
	    unsigned long count = 0;
	    ossBoolean _last = FALSE;
	    unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    unsigned long _prev_fragm0 = 0;
#endif

	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 134)
	    while (!_last) {
		count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		    if ((!_last) && _index && (_prev_fragm0 < 65536))
			_oss_dec_error(_g, _invalid_fragmentation, 0L);
		    _prev_fragm0 = count - _index;
		}
#endif
		for (; (unsigned long)_index < count; _index++) {
		    _temp->next = (_setof8 *)_oss_dec_const_alloc(_g, sizeof(_setof8));
		    _temp = _temp->next;
		    OSS_CNTX_SETOCC(_index + 1)
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			OSS_CNTX_INIT

			_temp->value.bit_mask = (OSS_UINT32)_oss_get_2bit_unaligned(_g) << 24;
			OSS_CNTX_PUSH(_oss_c, 35)
			if (_temp->value.bit_mask & 0x80000000) {
			    _temp->value.modifyOperator = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
			} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
			    memcpy(&_temp->value.modifyOperator, &__seq4::default_modifyOperator, sizeof(__seq4::default_modifyOperator));
#else
			    _temp->value.modifyOperator = 0;
#endif
			}
			OSS_CNTX_SET(34)
			_dp_AttributeId(_g, &_temp->value.attributeId);
			OSS_CNTX_SET(33)
			if (_temp->value.bit_mask & 0x40000000) {
#ifdef OSS_OPENTYPE_HAS_USERFIELD
			    _temp->value.attributeValue.userField = NULL;
#endif
			    _temp->value.attributeValue.encoded.length = _oss_pdec_unconstr_uoct_ia(_g, &_temp->value.attributeValue.encoded.value);
			    if (_temp->value.attributeValue.encoded.length == 0 && ((STRICT_ENCODING_DECODING_RULES | AUTOMATIC_ENCDEC) & _g->decodingFlags))
				_oss_dec_error(_g, _zero_length_OpenType, 0L);
			    _temp->value.attributeValue.pduNum = 0;
			    *(void **)&_temp->value.attributeValue.decoded = NULL;
			} else {
			    memset(&(_temp->value.attributeValue), 0, sizeof(OSSC::COssConstrainedOpenType ));
			}
			OSS_CNTX_POP(_oss_c)
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    _temp->next = NULL;
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
	if (_extPres) {
	    _ea_count = _oss_pdec_eap(_g, &_pext);
	    _oss_pdec_eas(_g, _pext, _ea_count, 0);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dSetListError(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SetListError *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(29,135)
    _out_data = (_SetListError *)_oss_dec_const_alloc(_g, sizeof(_SetListError));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_SetListError(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpSetListError(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SetListError	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(29,135)
    _out_data = (_SetListError *)_oss_dec_const_alloc(_g, sizeof(_SetListError));
    _dp_SetListError(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dSetResult(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CreateResult *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(30,136)
    _out_data = (_CreateResult *)_oss_dec_const_alloc(_g, sizeof(_CreateResult));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_SetResult(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpSetResult(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CreateResult	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(30,136)
    _out_data = (_CreateResult *)_oss_dec_const_alloc(_g, sizeof(_CreateResult));
    _dp_SetResult(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dROSEapdus(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ROSEapdus *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(31,137)
    _out_data = (_ROSEapdus *)_oss_dec_const_alloc(_g, sizeof(_ROSEapdus));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	switch (_data_tag) {
	default:
	    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
	    switch (_data_tag & 0x7fff) {
	    case 0x1: {
		OSS_CNTX_PUSH(_oss_c, 138)
		_out_data->choice = 1;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.invoke = (_seq6 *)_oss_dec_const_alloc(_g, sizeof(_seq6));
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    OSS_CNTX_INIT

		    _out_data->u.invoke->bit_mask = 0;
		    OSS_CNTX_PUSH(_oss_c, 142)
		    _d_InvokeId(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.invoke->invokeId);
		    OSS_CNTX_POP(_oss_c)
		    if (_bufpos < _end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if ((_data_tag != 0x8000 && _data_tag != 0x8001)
			|| (_total_len >= 0 && _bufpos >= _end_pos))
		     {
			_out_data->u.invoke->bit_mask &= ~0x80000000;
			memset(&_out_data->u.invoke->linkedId, 0, sizeof(_out_data->u.invoke->linkedId));
		    }
else {
			_out_data->u.invoke->bit_mask |= 0x80000000;
			OSS_CNTX_PUSH(_oss_c, 141)
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			{
			    OSS_CNTX_INIT

			    if (!_oss_c->_tag_decoded) {
				if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				    _buflen--;
				    _oss_c->_bitpos = _bufpos[0] & 0x20;
				    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				    _bufpos++;
				} else
				    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
				_oss_c->_tag_decoded = TRUE;
			    }
			    switch (_data_tag) {
			    default:
				if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
				switch (_data_tag & 0x7fff) {
				case 0x0: {
				    OSS_CNTX_PUSH(_oss_c, 65)
				    _out_data->u.invoke->linkedId.choice = 1;

				    _oss_c->_tag_decoded = FALSE;
				    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					_buflen--;
					_bufpos++;
				    } else
					_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				    _out_data->u.invoke->linkedId.u.present = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
				}   break;
				case 0x1: {
				    OSS_CNTX_PUSH(_oss_c, 66)
				    _out_data->u.invoke->linkedId.choice = 2;

				    _oss_c->_tag_decoded = FALSE;
				    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					_buflen--;
					_bufpos++;
				    } else
					_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				    _out_data->u.invoke->linkedId.u.absent = 0;
				    if (_data_length != 0)
					_oss_dec_error(_g, _inval_enc, 0L);
				}   break;
				default:
				    _oss_dec_error(_g, _unknown_field, _data_tag);
				}
				break;
			    }
			    OSS_CNTX_POP(_oss_c)
			}
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			OSS_CNTX_POP(_oss_c)
		    }
		    OSS_CNTX_PUSH(_oss_c, 140)
		    _d_Code(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.invoke->opcode);
		    OSS_CNTX_POP(_oss_c)
		    if (_total_len < 0) {
			if (*_bufpos == 0) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			} else
			    _data_tag = 1;
		    }
		    if (_bufpos >= _end_pos || (_total_len < 0 && _data_tag == 0))
		     {
			_out_data->u.invoke->bit_mask &= ~0x40000000;
			memset(&_out_data->u.invoke->argument, 0, sizeof(_out_data->u.invoke->argument));
		    }
else {
			_out_data->u.invoke->bit_mask |= 0x40000000;
			OSS_CNTX_PUSH(_oss_c, 139)
			if (_data_length == 0) _data_length = 1;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
			_out_data->u.invoke->argument.userField = NULL;
#endif
			_oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.invoke->argument.encoded);
			_out_data->u.invoke->argument.pduNum = 0;
			*(void **)&_out_data->u.invoke->argument.decoded = NULL;
			OSS_CNTX_POP(_oss_c)
		    }
		    if (_bufpos != _end_pos) {
			if (_total_len < 0) {
			    if (!_oss_c->_tag_decoded)
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			    if (_data_tag)
				_oss_dec_error(_g, _expec_eoc, 0L);
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			} else
			    _oss_dec_error(_g, _inconsis_len, 0L);
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    }   break;
	    case 0x2: {
		OSS_CNTX_PUSH(_oss_c, 143)
		_out_data->choice = 2;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.returnResult = (_seq7 *)_oss_dec_const_alloc(_g, sizeof(_seq7));
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    OSS_CNTX_INIT

		    _out_data->u.returnResult->bit_mask = 0;
		    OSS_CNTX_PUSH(_oss_c, 142)
		    _d_InvokeId(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.returnResult->invokeId);
		    OSS_CNTX_POP(_oss_c)
		    if (_bufpos < _end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if (_data_tag != 0x10 || _bufpos >= _end_pos)
		     {
			_out_data->u.returnResult->bit_mask &= ~0x80000000;
			memset(&_out_data->u.returnResult->result, 0, sizeof(_out_data->u.returnResult->result));
		    }
else {
			_out_data->u.returnResult->bit_mask |= 0x80000000;
			OSS_CNTX_PUSH(_oss_c, 144)
			if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else {
			    if (!_oss_c->_tag_decoded || _data_tag == 0x10) {
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x10 : 0);
			    } else
				_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
			    _oss_c->_tag_decoded = FALSE;
			}
			_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			{
			    long _total_len = _data_length;
			    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
			    OSS_CNTX_INIT

			    OSS_CNTX_PUSH(_oss_c, 140)
			    _d_Code(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.returnResult->result.opcode);
			    OSS_CNTX_SET(145)
			    if (_data_length == 0) _data_length = 1;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
			    _out_data->u.returnResult->result.result.userField = NULL;
#endif
			    _oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.returnResult->result.result.encoded);
			    _out_data->u.returnResult->result.result.pduNum = 0;
			    *(void **)&_out_data->u.returnResult->result.result.decoded = NULL;
			    OSS_CNTX_POP(_oss_c)
			    if (_bufpos != _end_pos) {
				if (_total_len < 0) {
				    if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
					_buflen--;
					_bufpos++;
				    } else
					_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

				    if (_data_tag)
					_oss_dec_error(_g, _expec_eoc, 0L);
				    if (_oss_dec_length(_g, &_bufpos, &_buflen))
					_oss_dec_error(_g, _non_std_eoc, 0L);
				    _oss_c->_tag_decoded = FALSE;
				} else
				    _oss_dec_error(_g, _inconsis_len, 0L);
			    }
			}
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			OSS_CNTX_POP(_oss_c)
		    }
		    if (_bufpos != _end_pos) {
			if (_total_len < 0) {
			    if (!_oss_c->_tag_decoded)
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			    if (_data_tag)
				_oss_dec_error(_g, _expec_eoc, 0L);
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			} else
			    _oss_dec_error(_g, _inconsis_len, 0L);
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    }   break;
	    case 0x3: {
		OSS_CNTX_PUSH(_oss_c, 146)
		_out_data->choice = 3;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.returnError = (_seq8 *)_oss_dec_const_alloc(_g, sizeof(_seq8));
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    OSS_CNTX_INIT

		    _out_data->u.returnError->bit_mask = 0;
		    OSS_CNTX_PUSH(_oss_c, 142)
		    _d_InvokeId(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.returnError->invokeId);
		    OSS_CNTX_SET(148)
		    _d_Code(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.returnError->errcode);
		    OSS_CNTX_POP(_oss_c)
		    if (_total_len < 0) {
			if (*_bufpos == 0) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			} else
			    _data_tag = 1;
		    }
		    if (_bufpos >= _end_pos || (_total_len < 0 && _data_tag == 0))
		     {
			_out_data->u.returnError->bit_mask &= ~0x80000000;
			memset(&_out_data->u.returnError->parameter, 0, sizeof(_out_data->u.returnError->parameter));
		    }
else {
			_out_data->u.returnError->bit_mask |= 0x80000000;
			OSS_CNTX_PUSH(_oss_c, 147)
			if (_data_length == 0) _data_length = 1;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
			_out_data->u.returnError->parameter.userField = NULL;
#endif
			_oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.returnError->parameter.encoded);
			_out_data->u.returnError->parameter.pduNum = 0;
			*(void **)&_out_data->u.returnError->parameter.decoded = NULL;
			OSS_CNTX_POP(_oss_c)
		    }
		    if (_bufpos != _end_pos) {
			if (_total_len < 0) {
			    if (!_oss_c->_tag_decoded)
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			    if (_data_tag)
				_oss_dec_error(_g, _expec_eoc, 0L);
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			} else
			    _oss_dec_error(_g, _inconsis_len, 0L);
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    }   break;
	    case 0x4: {
		OSS_CNTX_PUSH(_oss_c, 149)
		_out_data->choice = 4;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.reject = (_Reject *)_oss_dec_const_alloc(_g, sizeof(_Reject));
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    OSS_CNTX_INIT

		    OSS_CNTX_PUSH(_oss_c, 142)
		    _d_InvokeId(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.reject->invokeId);
		    OSS_CNTX_SET(150)
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			OSS_CNTX_INIT

			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
			switch (_data_tag) {
			default:
			    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
			    switch (_data_tag & 0x7fff) {
			    case 0x0: {
				OSS_CNTX_PUSH(_oss_c, 151)
				_out_data->u.reject->problem.choice = 1;

				_oss_c->_tag_decoded = FALSE;
				if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				    _buflen--;
				    _bufpos++;
				} else
				    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				_out_data->u.reject->problem.u.general = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
			    }   break;
			    case 0x1: {
				OSS_CNTX_PUSH(_oss_c, 152)
				_out_data->u.reject->problem.choice = 2;

				_oss_c->_tag_decoded = FALSE;
				if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				    _buflen--;
				    _bufpos++;
				} else
				    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				_out_data->u.reject->problem.u.invoke = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
			    }   break;
			    case 0x2: {
				OSS_CNTX_PUSH(_oss_c, 153)
				_out_data->u.reject->problem.choice = 3;

				_oss_c->_tag_decoded = FALSE;
				if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				    _buflen--;
				    _bufpos++;
				} else
				    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				_out_data->u.reject->problem.u.returnResult = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
			    }   break;
			    case 0x3: {
				OSS_CNTX_PUSH(_oss_c, 154)
				_out_data->u.reject->problem.choice = 4;

				_oss_c->_tag_decoded = FALSE;
				if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				    _buflen--;
				    _bufpos++;
				} else
				    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				_out_data->u.reject->problem.u.returnError = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
			    }   break;
			    default:
				_oss_dec_error(_g, _unknown_field, _data_tag);
			    }
			    break;
			}
			OSS_CNTX_POP(_oss_c)
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		    OSS_CNTX_POP(_oss_c)
		    if (_bufpos != _end_pos) {
			if (_total_len < 0) {
			    if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
				_buflen--;
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			    if (_data_tag)
				_oss_dec_error(_g, _expec_eoc, 0L);
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			} else
			    _oss_dec_error(_g, _inconsis_len, 0L);
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    break;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpROSEapdus(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ROSEapdus	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(31,137)
    _out_data = (_ROSEapdus *)_oss_dec_const_alloc(_g, sizeof(_ROSEapdus));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_2int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 138)
	    _out_data->u.invoke = (_seq6 *)_oss_dec_const_alloc(_g, sizeof(_seq6));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_out_data->u.invoke->bit_mask = (OSS_UINT32)_oss_get_2bit_unaligned(_g) << 24;
		OSS_CNTX_PUSH(_oss_c, 142)
		_dp_InvokeId(_g, &_out_data->u.invoke->invokeId);
		OSS_CNTX_SET(141)
		if (_out_data->u.invoke->bit_mask & 0x80000000) {
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			OSS_CNTX_INIT

			{

			    _out_data->u.invoke->linkedId.choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
			}
			switch (_out_data->u.invoke->linkedId.choice) {
			case 1:
			    OSS_CNTX_PUSH(_oss_c, 65)
			    _out_data->u.invoke->linkedId.u.present = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
			    break;
			case 2:
			    OSS_CNTX_PUSH(_oss_c, 66)
			    break;
			default:
			    _oss_enc_error(_g, _bad_choice, _out_data->u.invoke->linkedId.choice);	/* Bad choice selector. */
			}
			OSS_CNTX_POP(_oss_c)
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		} else {
		    memset(&(_out_data->u.invoke->linkedId), 0, sizeof(_InvokeId ));
		}
		OSS_CNTX_SET(140)
		_dp_Code(_g, &_out_data->u.invoke->opcode);
		OSS_CNTX_SET(139)
		if (_out_data->u.invoke->bit_mask & 0x40000000) {
#ifdef OSS_OPENTYPE_HAS_USERFIELD
		    _out_data->u.invoke->argument.userField = NULL;
#endif
		    _out_data->u.invoke->argument.encoded.length = _oss_pdec_unconstr_uoct_ia(_g, &_out_data->u.invoke->argument.encoded.value);
		    if (_out_data->u.invoke->argument.encoded.length == 0 && ((STRICT_ENCODING_DECODING_RULES | AUTOMATIC_ENCDEC) & _g->decodingFlags))
			_oss_dec_error(_g, _zero_length_OpenType, 0L);
		    _out_data->u.invoke->argument.pduNum = 0;
		    *(void **)&_out_data->u.invoke->argument.decoded = NULL;
		} else {
		    memset(&(_out_data->u.invoke->argument), 0, sizeof(OSSC::COssConstrainedOpenType ));
		}
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 143)
	    _out_data->u.returnResult = (_seq7 *)_oss_dec_const_alloc(_g, sizeof(_seq7));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_out_data->u.returnResult->bit_mask = (OSS_UINT32)_oss_get_1bit_unaligned(_g) << 24;
		OSS_CNTX_PUSH(_oss_c, 142)
		_dp_InvokeId(_g, &_out_data->u.returnResult->invokeId);
		OSS_CNTX_SET(144)
		if (_out_data->u.returnResult->bit_mask & 0x80000000) {
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			OSS_CNTX_INIT

			OSS_CNTX_PUSH(_oss_c, 140)
			_dp_Code(_g, &_out_data->u.returnResult->result.opcode);
			OSS_CNTX_SET(145)
#ifdef OSS_OPENTYPE_HAS_USERFIELD
			_out_data->u.returnResult->result.result.userField = NULL;
#endif
			_out_data->u.returnResult->result.result.encoded.length = _oss_pdec_unconstr_uoct_ia(_g, &_out_data->u.returnResult->result.result.encoded.value);
			if (_out_data->u.returnResult->result.result.encoded.length == 0 && ((STRICT_ENCODING_DECODING_RULES | AUTOMATIC_ENCDEC) & _g->decodingFlags))
			    _oss_dec_error(_g, _zero_length_OpenType, 0L);
			_out_data->u.returnResult->result.result.pduNum = 0;
			*(void **)&_out_data->u.returnResult->result.result.decoded = NULL;
			OSS_CNTX_POP(_oss_c)
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		} else {
		    memset(&(_out_data->u.returnResult->result), 0, sizeof(_seq5 ));
		}
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 146)
	    _out_data->u.returnError = (_seq8 *)_oss_dec_const_alloc(_g, sizeof(_seq8));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_out_data->u.returnError->bit_mask = (OSS_UINT32)_oss_get_1bit_unaligned(_g) << 24;
		OSS_CNTX_PUSH(_oss_c, 142)
		_dp_InvokeId(_g, &_out_data->u.returnError->invokeId);
		OSS_CNTX_SET(148)
		_dp_Code(_g, &_out_data->u.returnError->errcode);
		OSS_CNTX_SET(147)
		if (_out_data->u.returnError->bit_mask & 0x80000000) {
#ifdef OSS_OPENTYPE_HAS_USERFIELD
		    _out_data->u.returnError->parameter.userField = NULL;
#endif
		    _out_data->u.returnError->parameter.encoded.length = _oss_pdec_unconstr_uoct_ia(_g, &_out_data->u.returnError->parameter.encoded.value);
		    if (_out_data->u.returnError->parameter.encoded.length == 0 && ((STRICT_ENCODING_DECODING_RULES | AUTOMATIC_ENCDEC) & _g->decodingFlags))
			_oss_dec_error(_g, _zero_length_OpenType, 0L);
		    _out_data->u.returnError->parameter.pduNum = 0;
		    *(void **)&_out_data->u.returnError->parameter.decoded = NULL;
		} else {
		    memset(&(_out_data->u.returnError->parameter), 0, sizeof(OSSC::COssConstrainedOpenType ));
		}
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 149)
	    _out_data->u.reject = (_Reject *)_oss_dec_const_alloc(_g, sizeof(_Reject));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 142)
		_dp_InvokeId(_g, &_out_data->u.reject->invokeId);
		OSS_CNTX_SET(150)
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    OSS_CNTX_INIT

		    {

			_out_data->u.reject->problem.choice = (int)_oss_pdec_nonneg_2int(_g) + 1;
		    }
		    switch (_out_data->u.reject->problem.choice) {
		    case 1:
			OSS_CNTX_PUSH(_oss_c, 151)
			_out_data->u.reject->problem.u.general = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
			break;
		    case 2:
			OSS_CNTX_PUSH(_oss_c, 152)
			_out_data->u.reject->problem.u.invoke = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
			break;
		    case 3:
			OSS_CNTX_PUSH(_oss_c, 153)
			_out_data->u.reject->problem.u.returnResult = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
			break;
		    case 4:
			OSS_CNTX_PUSH(_oss_c, 154)
			_out_data->u.reject->problem.u.returnError = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
			break;
		    default:
			_oss_enc_error(_g, _bad_choice, _out_data->u.reject->problem.choice);	/* Bad choice selector. */
		    }
		    OSS_CNTX_POP(_oss_c)
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dCMIPAbortInfo(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CMIPAbortInfo *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(32,155)
    _out_data = (_CMIPAbortInfo *)_oss_dec_const_alloc(_g, sizeof(_CMIPAbortInfo));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 157)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 128 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	_out_data->abortSource = (enum CMIPAbortSource )_oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8001 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->userInfo, 0, sizeof(_out_data->userInfo));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 156)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8001) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x81 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80010000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8001;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8);
	    _data_tag = 0x8;
	    _d_External(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->userInfo);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpCMIPAbortInfo(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CMIPAbortInfo	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(32,155)
    _out_data = (_CMIPAbortInfo *)_oss_dec_const_alloc(_g, sizeof(_CMIPAbortInfo));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_1bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 157)
	_out_data->abortSource = (enum CMIPAbortSource)_oss_pdec_uenum(_g, (struct _enum_data*)&_enums[10], NULL);
	OSS_CNTX_SET(156)
	if (_out_data->bit_mask & 0x80000000) {
	    _dp_External(_g, &_out_data->userInfo);
	} else {
	    memset(&(_out_data->userInfo), 0, sizeof(_External ));
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dCMIPUserInfo(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CMIPUserInfo *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(33,158)
    _out_data = (_CMIPUserInfo *)_oss_dec_const_alloc(_g, sizeof(_CMIPUserInfo));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8000 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->protocolVersion, &_v38, sizeof(_v38));
#else
	    _out_data->protocolVersion.length = 0;
	    _out_data->protocolVersion.value = NULL;
#endif
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 161)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 128 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8000;
	    _out_data->protocolVersion.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->protocolVersion.value, 0, 128);

	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8001 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->functionalUnits, &_v40, sizeof(_v40));
#else
	    _out_data->functionalUnits.length = 0;
	    _out_data->functionalUnits.value = NULL;
#endif
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 160)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 129 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8001) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x81 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80010000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8001;
	    _out_data->functionalUnits.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->functionalUnits.value, 0, 128);

	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8002 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x20000000;
	    memset(&_out_data->accessControl, 0, sizeof(_out_data->accessControl));
	}
else {
	    _out_data->bit_mask |= 0x20000000;
	    OSS_CNTX_PUSH(_oss_c, 159)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8002) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x82 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80020000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8002;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8);
	    _data_tag = 0x8;
	    _d_External(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->accessControl);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8003 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x10000000;
	    memset(&_out_data->userInfo, 0, sizeof(_out_data->userInfo));
	}
else {
	    _out_data->bit_mask |= 0x10000000;
	    OSS_CNTX_PUSH(_oss_c, 156)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 163 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8003) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x83 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80030000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8003;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8);
	    _data_tag = 0x8;
	    _d_External(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->userInfo);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpCMIPUserInfo(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CMIPUserInfo	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(33,158)
    _out_data = (_CMIPUserInfo *)_oss_dec_const_alloc(_g, sizeof(_CMIPUserInfo));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_4bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 161)
	if (_out_data->bit_mask & 0x80000000) {
	    _out_data->protocolVersion.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->protocolVersion.value);

	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->protocolVersion, &_v38, sizeof(_v38));
#else
	    _out_data->protocolVersion.length = 0;
	    _out_data->protocolVersion.value = NULL;
#endif
	}
	OSS_CNTX_SET(160)
	if (_out_data->bit_mask & 0x40000000) {
	    _out_data->functionalUnits.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->functionalUnits.value);

	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->functionalUnits, &_v40, sizeof(_v40));
#else
	    _out_data->functionalUnits.length = 0;
	    _out_data->functionalUnits.value = NULL;
#endif
	}
	OSS_CNTX_SET(159)
	if (_out_data->bit_mask & 0x20000000) {
	    _dp_External(_g, &_out_data->accessControl);
	} else {
	    memset(&(_out_data->accessControl), 0, sizeof(_External ));
	}
	OSS_CNTX_SET(156)
	if (_out_data->bit_mask & 0x10000000) {
	    _dp_External(_g, &_out_data->userInfo);
	} else {
	    memset(&(_out_data->userInfo), 0, sizeof(_External ));
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dCmipPduReceivingSupport(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(34,162)
    _out_data = (OSSC::COssBitString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssBitString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 3 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x3);
    _data_tag = 0x3;
    _out_data->length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 0, 128);

    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpCmipPduReceivingSupport(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(34,162)
    _out_data = (OSSC::COssBitString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssBitString));
    _out_data->length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->value);

    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dCmipPduSendingSupport(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(35,163)
    _out_data = (OSSC::COssBitString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssBitString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 3 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x3);
    _data_tag = 0x3;
    _out_data->length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 0, 128);

    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpCmipPduSendingSupport(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(35,163)
    _out_data = (OSSC::COssBitString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssBitString));
    _out_data->length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->value);

    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dCmiseFunctionalUnitsSelected(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(36,164)
    _out_data = (OSSC::COssBitString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssBitString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 3 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x3);
    _data_tag = 0x3;
    _out_data->length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 0, 128);

    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpCmiseFunctionalUnitsSelected(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(36,164)
    _out_data = (OSSC::COssBitString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssBitString));
    _out_data->length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->value);

    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _d0CmiseFunctionalUnitsSupport(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(37,165)
    _out_data = (OSSC::COssBitString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssBitString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 3 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x3);
    _data_tag = 0x3;
    _out_data->length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 0, 128);

    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp0CmiseFunctionalUnitsSupport(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(37,165)
    _out_data = (OSSC::COssBitString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssBitString));
    _out_data->length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->value);

    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dInvokeldsOutstanding(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeldsOutstanding **_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(38,166)
    _out_data = (_InvokeldsOutstanding **)_oss_dec_const_init_alloc(_g, sizeof(_InvokeldsOutstanding *));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
    _data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_InvokeldsOutstanding * _temp = (_InvokeldsOutstanding *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 167)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    if (_data_tag != 0x2)
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x20000);
	    _temp->next = (_InvokeldsOutstanding *)_oss_dec_const_alloc(_g, sizeof(_InvokeldsOutstanding));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _temp->value = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	}
	_temp->next = NULL;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpInvokeldsOutstanding(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeldsOutstanding	**_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(38,166)
    _out_data = (_InvokeldsOutstanding **)_oss_dec_const_init_alloc(_g, sizeof(_InvokeldsOutstanding *));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_InvokeldsOutstanding * _temp = (_InvokeldsOutstanding *)_out_data;
	unsigned long count = 0;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 167)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_InvokeldsOutstanding *)_oss_dec_const_alloc(_g, sizeof(_InvokeldsOutstanding));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
		_temp->value = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = NULL;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dInvokeIdsPerforming(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeldsOutstanding **_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(39,168)
    _out_data = (_InvokeldsOutstanding **)_oss_dec_const_init_alloc(_g, sizeof(_InvokeldsOutstanding *));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
    _data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_InvokeldsOutstanding * _temp = (_InvokeldsOutstanding *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 167)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    if (_data_tag != 0x2)
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x20000);
	    _temp->next = (_InvokeldsOutstanding *)_oss_dec_const_alloc(_g, sizeof(_InvokeldsOutstanding));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _temp->value = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	}
	_temp->next = NULL;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpInvokeIdsPerforming(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeldsOutstanding	**_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(39,168)
    _out_data = (_InvokeldsOutstanding **)_oss_dec_const_init_alloc(_g, sizeof(_InvokeldsOutstanding *));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_InvokeldsOutstanding * _temp = (_InvokeldsOutstanding *)_out_data;
	unsigned long count = 0;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 167)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_InvokeldsOutstanding *)_oss_dec_const_alloc(_g, sizeof(_InvokeldsOutstanding));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
		_temp->value = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = NULL;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dMaxEncodedCmipPduReceiveSize(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(40,169)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpMaxEncodedCmipPduReceiveSize(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(40,169)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    {
	*_out_data = (OSS_UINT32)_oss_pdec_semicon_limited_int_l(_g, 0, 0, -1);
    }
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dProtocolVersionSupported(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(41,170)
    _out_data = (OSSC::COssBitString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssBitString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 3 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x3);
    _data_tag = 0x3;
    _out_data->length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 0, 128);

    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpProtocolVersionSupported(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(41,170)
    _out_data = (OSSC::COssBitString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssBitString));
    _out_data->length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->value);

    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dSmaseFunctionalUnits(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SmaseFunctionalUnits **_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(42,171)
    _out_data = (_SmaseFunctionalUnits **)_oss_dec_const_init_alloc(_g, sizeof(_SmaseFunctionalUnits *));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
    _data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_SmaseFunctionalUnits * _temp = (_SmaseFunctionalUnits *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 172)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    if (_data_tag != 0x10)
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
	    _temp->next = (_SmaseFunctionalUnits *)_oss_dec_const_alloc(_g, sizeof(_SmaseFunctionalUnits));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _d_FunctionalUnitPackage(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
	}
	_temp->next = NULL;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpSmaseFunctionalUnits(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SmaseFunctionalUnits	**_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(42,171)
    _out_data = (_SmaseFunctionalUnits **)_oss_dec_const_init_alloc(_g, sizeof(_SmaseFunctionalUnits *));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_SmaseFunctionalUnits * _temp = (_SmaseFunctionalUnits *)_out_data;
	unsigned long count = 0;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 172)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_SmaseFunctionalUnits *)_oss_dec_const_alloc(_g, sizeof(_SmaseFunctionalUnits));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
		_dp_FunctionalUnitPackage(_g, &_temp->value);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = NULL;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dSmUserInfoSent(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SmUserInfoSent *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(43,173)
    _out_data = (_SmUserInfoSent *)_oss_dec_const_alloc(_g, sizeof(_SmUserInfoSent));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	switch (_data_tag) {
	case 0x5: {
	    OSS_CNTX_PUSH(_oss_c, 174)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.nothingSent = 0;
	    if (_data_length != 0)
		_oss_dec_error(_g, _inval_enc, 0L);
	}   break;
	case 0x19: {
	    OSS_CNTX_PUSH(_oss_c, 175)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.informationSent.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.informationSent.value, 0);
	}   break;
	default:
	    _oss_dec_error(_g, _unknown_field, _data_tag);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpSmUserInfoSent(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SmUserInfoSent	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(43,173)
    _out_data = (_SmUserInfoSent *)_oss_dec_const_alloc(_g, sizeof(_SmUserInfoSent));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 174)
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 175)
	    _out_data->u.informationSent.length = _oss_pdec_ub_nkmstr_ia(_g, &_out_data->u.informationSent.value);

	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dSmUserInfoReceived(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SmUserInfoReceived *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(44,176)
    _out_data = (_SmUserInfoReceived *)_oss_dec_const_alloc(_g, sizeof(_SmUserInfoReceived));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	switch (_data_tag) {
	case 0x5: {
	    OSS_CNTX_PUSH(_oss_c, 177)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.nothingReceived = 0;
	    if (_data_length != 0)
		_oss_dec_error(_g, _inval_enc, 0L);
	}   break;
	case 0x19: {
	    OSS_CNTX_PUSH(_oss_c, 178)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.informationReceived.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.informationReceived.value, 0);
	}   break;
	default:
	    _oss_dec_error(_g, _unknown_field, _data_tag);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpSmUserInfoReceived(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SmUserInfoReceived	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(44,176)
    _out_data = (_SmUserInfoReceived *)_oss_dec_const_alloc(_g, sizeof(_SmUserInfoReceived));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 177)
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 178)
	    _out_data->u.informationReceived.length = _oss_pdec_ub_nkmstr_ia(_g, &_out_data->u.informationReceived.value);

	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dROSEInvokeIds(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeId *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(45,179)
    _out_data = (_InvokeId *)_oss_dec_const_alloc(_g, sizeof(_InvokeId));
    _oss_c->_tag_decoded = FALSE;
    _d_InvokeId(_g, &_bufpos, &_buflen, 0, 0, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpROSEInvokeIds(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeId	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(45,179)
    _out_data = (_InvokeId *)_oss_dec_const_alloc(_g, sizeof(_InvokeId));
    _dp_InvokeId(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dNoInvokeId(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeId *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(46,180)
    _out_data = (_InvokeId *)_oss_dec_const_alloc(_g, sizeof(_InvokeId));
    _oss_c->_tag_decoded = FALSE;
    _d_InvokeId(_g, &_bufpos, &_buflen, 0, 0, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpNoInvokeId(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeId	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(46,180)
    _out_data = (_InvokeId *)_oss_dec_const_alloc(_g, sizeof(_InvokeId));
    _dp_InvokeId(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dSMASEUserData(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SMASEUserData *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(47,181)
    _out_data = (_SMASEUserData *)_oss_dec_const_alloc(_g, sizeof(_SMASEUserData));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x11 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->smfuPackages, 0, sizeof(_out_data->smfuPackages));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 184)
	    _out_data->smfuPackages = NULL;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x11) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x11 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x110000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_SmaseFunctionalUnits * _temp = (_SmaseFunctionalUnits *)&_out_data->smfuPackages;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
		unsigned long count = 0;
#endif
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 172)
		for (;;) {
		    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos > _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
		    count++;
#endif
		    if (_data_tag != 0x10)
			_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		    _temp->next = (_SmaseFunctionalUnits *)_oss_dec_const_alloc(_g, sizeof(_SmaseFunctionalUnits));
		    _temp = _temp->next;
		    OSS_CNTX_SETOCC(count)
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _d_FunctionalUnitPackage(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
		}
		_temp->next = NULL;
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x2 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 183)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x2) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x2 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x20000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x2;
	    _out_data->reason = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x19 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x20000000;
	    memset(&_out_data->systemsManagementUserInformation, 0, sizeof(_out_data->systemsManagementUserInformation));
	}
else {
	    _out_data->bit_mask |= 0x20000000;
	    OSS_CNTX_PUSH(_oss_c, 182)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 25 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x19) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x19 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x190000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x19;
	    _out_data->systemsManagementUserInformation.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->systemsManagementUserInformation.value, 0);
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpSMASEUserData(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SMASEUserData	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(47,181)
    _out_data = (_SMASEUserData *)_oss_dec_const_alloc(_g, sizeof(_SMASEUserData));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_3bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 184)
	_out_data->smfuPackages = NULL;
	if (_out_data->bit_mask & 0x80000000) {
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_SmaseFunctionalUnits * _temp = (_SmaseFunctionalUnits *)&_out_data->smfuPackages;
		unsigned long count = 0;
		ossBoolean _last = FALSE;
		unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		unsigned long _prev_fragm0 = 0;
#endif

		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 172)
		while (!_last) {
		    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
			if ((!_last) && _index && (_prev_fragm0 < 65536))
			    _oss_dec_error(_g, _invalid_fragmentation, 0L);
			_prev_fragm0 = count - _index;
		    }
#endif
		    for (; (unsigned long)_index < count; _index++) {
			_temp->next = (_SmaseFunctionalUnits *)_oss_dec_const_alloc(_g, sizeof(_SmaseFunctionalUnits));
			_temp = _temp->next;
			OSS_CNTX_SETOCC(_index + 1)
			_dp_FunctionalUnitPackage(_g, &_temp->value);
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		_temp->next = NULL;
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	} else {
	    _out_data->smfuPackages = NULL;
	}
	OSS_CNTX_SET(183)
	if (_out_data->bit_mask & 0x40000000) {
	    _out_data->reason = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	}
	OSS_CNTX_SET(182)
	if (_out_data->bit_mask & 0x20000000) {
	    _out_data->systemsManagementUserInformation.length = _oss_pdec_ub_nkmstr_ia(_g, &_out_data->systemsManagementUserInformation.value);

	} else {
	    _out_data->systemsManagementUserInformation.length = 0;
	    _out_data->systemsManagementUserInformation.value = NULL;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dAccessDenied_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(48,185)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpAccessDenied_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(48,185)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    {
	*_out_data = 0;
    }
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _d1ClassInstanceConflict_PRIOR(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(49,186)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp1ClassInstanceConflict_PRIOR(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(49,186)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    {
	*_out_data = 1;
    }
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _d2ComplexityLimitation_PRIORI(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(50,187)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp2ComplexityLimitation_PRIORI(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(50,187)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    {
	*_out_data = 1;
    }
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dInvalidScope_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(51,188)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpInvalidScope_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(51,188)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    {
	*_out_data = 1;
    }
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _d3InvalidArgumentValue_PRIORI(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(52,189)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp3InvalidArgumentValue_PRIORI(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(52,189)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    {
	*_out_data = 1;
    }
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dInvalidFilter_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(53,190)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpInvalidFilter_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(53,190)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    {
	*_out_data = 1;
    }
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dNoSuchAction_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(54,191)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpNoSuchAction_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(54,191)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    {
	*_out_data = 1;
    }
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dNoSuchArgument_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(55,192)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpNoSuchArgument_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(55,192)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    {
	*_out_data = 1;
    }
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dNoSuchObjectClass_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(56,193)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpNoSuchObjectClass_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(56,193)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    {
	*_out_data = 1;
    }
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _d4NoSuchObjectInstance_PRIORI(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(57,194)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp4NoSuchObjectInstance_PRIORI(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(57,194)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    {
	*_out_data = 1;
    }
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dProcessingFailure_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(58,195)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpProcessingFailure_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(58,195)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    {
	*_out_data = 1;
    }
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dSyncNotSupported_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(59,196)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpSyncNotSupported_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(59,196)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    {
	*_out_data = 1;
    }
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dMistypedOperation_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(60,197)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpMistypedOperation_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(60,197)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    {
	*_out_data = 1;
    }
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dNoSuchInvokeId_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(61,198)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpNoSuchInvokeId_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(61,198)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    {
	*_out_data = 1;
    }
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _d5DuplicateManagedObjectInsta(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(62,199)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp5DuplicateManagedObjectInsta(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(62,199)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    {
	*_out_data = 1;
    }
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _d6InvalidAttributeValue_PRIOR(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(63,200)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp6InvalidAttributeValue_PRIOR(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(63,200)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    {
	*_out_data = 1;
    }
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _d7InvalidObjectInstance_PRIOR(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(64,201)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp7InvalidObjectInstance_PRIOR(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(64,201)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    {
	*_out_data = 1;
    }
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _d8MissingAttributeValue_PARAM(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _MissingAttributeValue_PARAMETER **_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(65,202)
    _out_data = (_MissingAttributeValue_PARAMETER **)_oss_dec_const_init_alloc(_g, sizeof(_MissingAttributeValue_PARAMETER *));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
    _data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_MissingAttributeValue_PARAMETER * _temp = (_MissingAttributeValue_PARAMETER *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 105)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    _temp->next = (_MissingAttributeValue_PARAMETER *)_oss_dec_const_alloc(_g, sizeof(_MissingAttributeValue_PARAMETER));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
	    _d_AttributeId(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
	}
	_temp->next = NULL;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp8MissingAttributeValue_PARAM(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _MissingAttributeValue_PARAMETER	**_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(65,202)
    _out_data = (_MissingAttributeValue_PARAMETER **)_oss_dec_const_init_alloc(_g, sizeof(_MissingAttributeValue_PARAMETER *));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_MissingAttributeValue_PARAMETER * _temp = (_MissingAttributeValue_PARAMETER *)_out_data;
	unsigned long count = 0;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 105)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_MissingAttributeValue_PARAMETER *)_oss_dec_const_alloc(_g, sizeof(_MissingAttributeValue_PARAMETER));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
		_dp_AttributeId(_g, &_temp->value);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = NULL;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _d9MissingAttributeValue_PRIOR(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(66,203)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp9MissingAttributeValue_PRIOR(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(66,203)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    {
	*_out_data = 1;
    }
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dNoSuchAttribute_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(67,204)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpNoSuchAttribute_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(67,204)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    {
	*_out_data = 1;
    }
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _d10NoSuchReferenceObject_PRIO(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(68,205)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp10NoSuchReferenceObject_PRIO(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(68,205)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    {
	*_out_data = 1;
    }
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dNoSuchEventType_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(69,206)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpNoSuchEventType_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(69,206)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    {
	*_out_data = 1;
    }
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dGetListError_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(70,207)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpGetListError_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(70,207)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    {
	*_out_data = 1;
    }
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dOperationCancelled_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(71,208)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpOperationCancelled_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(71,208)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    {
	*_out_data = 1;
    }
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dSetListError_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(72,209)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpSetListError_PRIORITY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_UINT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(72,209)
    _out_data = (OSS_UINT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32));
    {
	*_out_data = 1;
    }
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dAcse_RealizationParameter(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(73,210)
    _out_data = (_RealizationParameter *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_RealizationParameter(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpAcse_RealizationParameter(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(73,210)
    _out_data = (_RealizationParameter *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter));
    _dp_RealizationParameter(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _d11Acse_with_concatenation_Re(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(74,211)
    _out_data = (_RealizationParameter *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_RealizationParameter(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp11Acse_with_concatenation_Re(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(74,211)
    _out_data = (_RealizationParameter *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter));
    _dp_RealizationParameter(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _d12Association_by_RTSE_Realiz(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(75,212)
    _out_data = (_RealizationParameter *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_RealizationParameter(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp12Association_by_RTSE_Realiz(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(75,212)
    _out_data = (_RealizationParameter *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter));
    _dp_RealizationParameter(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dPData_RealizationParameter(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(76,213)
    _out_data = (_RealizationParameter *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_RealizationParameter(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpPData_RealizationParameter(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(76,213)
    _out_data = (_RealizationParameter *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter));
    _dp_RealizationParameter(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _d13PData_with_concatenation_R(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(77,214)
    _out_data = (_RealizationParameter *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_RealizationParameter(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp13PData_with_concatenation_R(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(77,214)
    _out_data = (_RealizationParameter *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter));
    _dp_RealizationParameter(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _d14Transfer_by_RTSE_Realizati(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(78,215)
    _out_data = (_RealizationParameter *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_RealizationParameter(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp14Transfer_by_RTSE_Realizati(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(78,215)
    _out_data = (_RealizationParameter *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter));
    _dp_RealizationParameter(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

void DLL_ENTRY_FDEF _dmSMASE_A_ASSOCIATE_Informatio(struct ossGlobal * _g, int * _pdunum, void ** _outbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;

    _oss_c->_oss_context_anchor._state = _decoding_data;
    _oss_c->_oss_context_anchor._pdu_number = 0;
#if OSSDEBUG > 0
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_d_pre(_g, _oss_c->_oss_inbufpos, _oss_c->_oss_inbuflen, NULL);
#else
    _oss_c->_oss_err_msg = NULL;
#endif

    if (*_pdunum < 1 || *_pdunum > 78)
	_oss_dec_error(_g, _pdu_range, *_pdunum);
    *_outbuf = _Decoders[*_pdunum - 1](_g);

#if OSSDEBUG > 0
    _oss_c->_oss_err_msg = NULL;
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_d_post(_g, 0, *_pdunum, _outbuf);
#endif
}

void DLL_ENTRY_FDEF _pdSMASE_A_ASSOCIATE_Informatio(struct ossGlobal * _g, int * _pdunum, void ** _outbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _oss_c->_oss_context_anchor._state = _decoding_data;
    _oss_c->_oss_context_anchor._pdu_number = 0;
#if OSSDEBUG > 0
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_d_pre(_g, _oss_c->_oss_inbufpos, _oss_c->_oss_inbuflen, NULL);
#else
    _oss_c->_oss_err_msg = NULL;
#endif

    _oss_c->_aligned = (ossBoolean)(_g->encRules == OSS_PER_ALIGNED);
    if (*_pdunum < 1 || *_pdunum > 78)
	_oss_dec_error(_g, _pdu_range, *_pdunum);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
    if (!_oss_c->_oss_inbuflen && (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES)) {
	_oss_c->_oss_context_anchor._pdu_number = *_pdunum;
	_oss_dec_error(_g, _more_input, 0L);
    }
#endif
    *_outbuf = _pDecoders[*_pdunum - 1](_g);

#if OSSDEBUG > 0
    _oss_c->_oss_err_msg = NULL;
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_d_post(_g, 0, *_pdunum, _outbuf);
#endif
}

#if (OSS_TOED_API_LEVEL < 22) || !defined(OSSNOFREEPDU)
static void _f_ActionResult(OssGlobal * _g, _ActionResult * _data_ptr)
{
    if (_data_ptr->bit_mask & 0x80000000) {
	_f_ObjectClass(_g, &_data_ptr->managedObjectClass);
    }
    if (_data_ptr->bit_mask & 0x40000000) {
	_f_ObjectInstance(_g, &_data_ptr->managedObjectInstance);
    }
    if (_data_ptr->currentTime) {
	_oss_dec_free(_g, _data_ptr->currentTime);
    }
    if (_data_ptr->bit_mask & 0x20000000) {
	_f_ActionReply(_g, &_data_ptr->actionReply);
    }
}

static void _f_Attribute(OssGlobal * _g, _Attribute * _data_ptr)
{
    _f_AttributeId(_g, &_data_ptr->id);
    if (_data_ptr->value.encoded.value)
	_oss_dec_free(_g, _data_ptr->value.encoded.value);
    if (_data_ptr->value.pduNum != 0 && *(void **)&_data_ptr->value.decoded)
	_fmSMASE_A_ASSOCIATE_Informatio(_g, _data_ptr->value.pduNum, *(void **)&_data_ptr->value.decoded);
}

static void _f_AttributeId(OssGlobal * _g, _ActionTypeId * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	if (_data_ptr->u.globalForm.value)
	    _oss_dec_free(_g, _data_ptr->u.globalForm.value);
	break;
    default:
	/* Ignore for now */	;
    }
}

static void _f_CMISFilter(OssGlobal * _g, _CMISFilter * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	_f_FilterItem(_g, _data_ptr->u.item);
	_oss_dec_free(_g, _data_ptr->u.item);
	break;
    case 2:
	_f__setof1(_g, &_data_ptr->u.CMISFilter_and);
	break;
    case 3:
	_f__setof2(_g, &_data_ptr->u.CMISFilter_or);
	break;
    case 4:
	_f_CMISFilter(_g, _data_ptr->u.CMISFilter_not);
	_oss_dec_free(_g, _data_ptr->u.CMISFilter_not);
	break;
    default:
	/* Ignore for now */	;
    }
}

static void _f_DeleteResult(OssGlobal * _g, _DeleteResult * _data_ptr)
{
    if (_data_ptr->bit_mask & 0x80000000) {
	_f_ObjectClass(_g, &_data_ptr->managedObjectClass);
    }
    if (_data_ptr->bit_mask & 0x40000000) {
	_f_ObjectInstance(_g, &_data_ptr->managedObjectInstance);
    }
    if (_data_ptr->currentTime) {
	_oss_dec_free(_g, _data_ptr->currentTime);
    }
}

static void _f_GetListError(OssGlobal * _g, _GetListError * _data_ptr)
{
    if (_data_ptr->bit_mask & 0x80000000) {
	_f_ObjectClass(_g, &_data_ptr->managedObjectClass);
    }
    if (_data_ptr->bit_mask & 0x40000000) {
	_f_ObjectInstance(_g, &_data_ptr->managedObjectInstance);
    }
    if (_data_ptr->currentTime) {
	_oss_dec_free(_g, _data_ptr->currentTime);
    }
    _f__setof6(_g, &_data_ptr->getInfoList);
}

static void _f_GetResult(OssGlobal * _g, _CreateResult * _data_ptr)
{
    if (_data_ptr->bit_mask & 0x80000000) {
	_f_ObjectClass(_g, &_data_ptr->managedObjectClass);
    }
    if (_data_ptr->bit_mask & 0x40000000) {
	_f_ObjectInstance(_g, &_data_ptr->managedObjectInstance);
    }
    if (_data_ptr->currentTime) {
	_oss_dec_free(_g, _data_ptr->currentTime);
    }
    if (_data_ptr->bit_mask & 0x20000000) {
	_f__setof7(_g, &_data_ptr->attributeList);
    }
}

static void _f_InvalidArgumentValue(OssGlobal * _g, _InvalidArgumentValue * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	_f_ActionInfo(_g, _data_ptr->u.actionValue);
	_oss_dec_free(_g, _data_ptr->u.actionValue);
	break;
    case 2:
	_f__seq1(_g, _data_ptr->u.eventValue);
	_oss_dec_free(_g, _data_ptr->u.eventValue);
	break;
    default:
	/* Ignore for now */	;
    }
}

static void _f_NoSuchArgument(OssGlobal * _g, _NoSuchArgument * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	if (_data_ptr->u.actionId->bit_mask & 0x80000000) {
	    _f_ObjectClass(_g, &_data_ptr->u.actionId->managedObjectClass);
	}
	_f_ActionTypeId(_g, &_data_ptr->u.actionId->actionType);
	_oss_dec_free(_g, _data_ptr->u.actionId);
	break;
    case 2:
	if (_data_ptr->u.eventId->bit_mask & 0x80000000) {
	    _f_ObjectClass(_g, &_data_ptr->u.eventId->managedObjectClass);
	}
	_f_EventTypeId(_g, &_data_ptr->u.eventId->eventType);
	_oss_dec_free(_g, _data_ptr->u.eventId);
	break;
    default:
	/* Ignore for now */	;
    }
}

static void _f_ObjectClass(OssGlobal * _g, _ActionTypeId * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	if (_data_ptr->u.globalForm.value)
	    _oss_dec_free(_g, _data_ptr->u.globalForm.value);
	break;
    default:
	/* Ignore for now */	;
    }
}

static void _f_ObjectInstance(OssGlobal * _g, _ObjectInstance * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	_f_RDNSequence(_g, &_data_ptr->u.distinguishedName);
	break;
    case 2:
	if (_data_ptr->u.nonSpecificForm.value)
	    _oss_dec_free(_g, _data_ptr->u.nonSpecificForm.value);
	break;
    case 3:
	_f_RDNSequence(_g, &_data_ptr->u.localDistinguishedName);
	break;
    default:
	/* Ignore for now */	;
    }
}

static void _f_ProcessingFailure(OssGlobal * _g, _ProcessingFailure * _data_ptr)
{
    _f_ObjectClass(_g, &_data_ptr->managedObjectClass);
    if (_data_ptr->bit_mask & 0x80000000) {
	_f_ObjectInstance(_g, &_data_ptr->managedObjectInstance);
    }
    if (_data_ptr->specificErrorInfo.errorId.value)
	_oss_dec_free(_g, _data_ptr->specificErrorInfo.errorId.value);
    if (_data_ptr->specificErrorInfo.errorInfo.encoded.value)
	_oss_dec_free(_g, _data_ptr->specificErrorInfo.errorInfo.encoded.value);
    if (_data_ptr->specificErrorInfo.errorInfo.pduNum != 0 && *(void **)&_data_ptr->specificErrorInfo.errorInfo.decoded)
	_fmSMASE_A_ASSOCIATE_Informatio(_g, _data_ptr->specificErrorInfo.errorInfo.pduNum, *(void **)&_data_ptr->specificErrorInfo.errorInfo.decoded);
}

static void _f_SetListError(OssGlobal * _g, _SetListError * _data_ptr)
{
    if (_data_ptr->bit_mask & 0x80000000) {
	_f_ObjectClass(_g, &_data_ptr->managedObjectClass);
    }
    if (_data_ptr->bit_mask & 0x40000000) {
	_f_ObjectInstance(_g, &_data_ptr->managedObjectInstance);
    }
    if (_data_ptr->currentTime) {
	_oss_dec_free(_g, _data_ptr->currentTime);
    }
    if (_data_ptr->setInfoList) {
	_setof9 * _tempa = _data_ptr->setInfoList;
	_setof9 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    switch (_tempa->value.choice) {
	    case 1:
		_f_AttributeId(_g, &_tempa->value.u.attributeError->attributeId);
		if (_tempa->value.u.attributeError->bit_mask & 0x40000000) {
		    if (_tempa->value.u.attributeError->attributeValue.encoded.value)
			_oss_dec_free(_g, _tempa->value.u.attributeError->attributeValue.encoded.value);
		    if (_tempa->value.u.attributeError->attributeValue.pduNum != 0 && *(void **)&_tempa->value.u.attributeError->attributeValue.decoded)
			_fmSMASE_A_ASSOCIATE_Informatio(_g, _tempa->value.u.attributeError->attributeValue.pduNum, *(void **)&_tempa->value.u.attributeError->attributeValue.decoded);
		}
		_oss_dec_free(_g, _tempa->value.u.attributeError);
		break;
	    case 2:
		_f_Attribute(_g, _tempa->value.u.attribute);
		_oss_dec_free(_g, _tempa->value.u.attribute);
		break;
	    default:
		/* Ignore for now */	;
	    }
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
}

static void _f_SetResult(OssGlobal * _g, _CreateResult * _data_ptr)
{
    if (_data_ptr->bit_mask & 0x80000000) {
	_f_ObjectClass(_g, &_data_ptr->managedObjectClass);
    }
    if (_data_ptr->bit_mask & 0x40000000) {
	_f_ObjectInstance(_g, &_data_ptr->managedObjectInstance);
    }
    if (_data_ptr->currentTime) {
	_oss_dec_free(_g, _data_ptr->currentTime);
    }
    if (_data_ptr->bit_mask & 0x20000000) {
	if (_data_ptr->attributeList) {
	    _setof3 * _tempa = _data_ptr->attributeList;
	    _setof3 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f_Attribute(_g, &_tempa->value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
}

static void _f__choice1(OssGlobal * _g, _choice1 * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	if (_data_ptr->u.single_ASN1_type.encoded)
	    _oss_dec_free(_g, _data_ptr->u.single_ASN1_type.encoded);
	if (_data_ptr->u.single_ASN1_type.pduNum && _data_ptr->u.single_ASN1_type.decoded)
	    _fmSMASE_A_ASSOCIATE_Informatio(_g, _data_ptr->u.single_ASN1_type.pduNum, _data_ptr->u.single_ASN1_type.decoded);
	break;
    case 2:
	if (_data_ptr->u.octet_aligned.value)
	    _oss_dec_free(_g, _data_ptr->u.octet_aligned.value);
	break;
    case 3:
	if (_data_ptr->u.arbitrary.value)
	    _oss_dec_free(_g, _data_ptr->u.arbitrary.value);
	break;
    default:
	/* Ignore for now */	;
    }
}

static void _f_External(OssGlobal * _g, _External * _data_ptr)
{
    if (_data_ptr->bit_mask & 0x80000000) {
	if (_data_ptr->direct_reference.value)
	    _oss_dec_free(_g, _data_ptr->direct_reference.value);
    }
    if (_data_ptr->bit_mask & 0x20000000) {
	if (_data_ptr->data_value_descriptor.value)
	    _oss_dec_free(_g, _data_ptr->data_value_descriptor.value);
    }
    _f__choice1(_g, &_data_ptr->encoding);
}

static void _f_ActionTypeId(OssGlobal * _g, _ActionTypeId * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	if (_data_ptr->u.globalForm.value)
	    _oss_dec_free(_g, _data_ptr->u.globalForm.value);
	break;
    default:
	/* Ignore for now */	;
    }
}

static void _f_EventTypeId(OssGlobal * _g, _ActionTypeId * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	if (_data_ptr->u.globalForm.value)
	    _oss_dec_free(_g, _data_ptr->u.globalForm.value);
	break;
    default:
	/* Ignore for now */	;
    }
}

static void _f__setof2(OssGlobal * _g, _setof1 ** _data_ptr)
{
    if (*_data_ptr) {
	_setof1 * _tempa = *_data_ptr;
	_setof1 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _f_CMISFilter(_g, &_tempa->value);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
}

static void _f__setof1(OssGlobal * _g, _setof1 ** _data_ptr)
{
    if (*_data_ptr) {
	_setof1 * _tempa = *_data_ptr;
	_setof1 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _f_CMISFilter(_g, &_tempa->value);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
}

static void _f_ActionInfo(OssGlobal * _g, _ActionInfo * _data_ptr)
{
    _f_ActionTypeId(_g, &_data_ptr->actionType);
    if (_data_ptr->bit_mask & 0x80000000) {
	if (_data_ptr->actionInfoArg.encoded.value)
	    _oss_dec_free(_g, _data_ptr->actionInfoArg.encoded.value);
	if (_data_ptr->actionInfoArg.pduNum != 0 && *(void **)&_data_ptr->actionInfoArg.decoded)
	    _fmSMASE_A_ASSOCIATE_Informatio(_g, _data_ptr->actionInfoArg.pduNum, *(void **)&_data_ptr->actionInfoArg.decoded);
    }
}

static void _f_ActionReply(OssGlobal * _g, _ActionReply * _data_ptr)
{
    _f_ActionTypeId(_g, &_data_ptr->actionType);
    if (_data_ptr->actionReplyInfo.encoded.value)
	_oss_dec_free(_g, _data_ptr->actionReplyInfo.encoded.value);
    if (_data_ptr->actionReplyInfo.pduNum != 0 && *(void **)&_data_ptr->actionReplyInfo.decoded)
	_fmSMASE_A_ASSOCIATE_Informatio(_g, _data_ptr->actionReplyInfo.pduNum, *(void **)&_data_ptr->actionReplyInfo.decoded);
}

static void _f__seqof1(OssGlobal * _g, _seqof1 ** _data_ptr)
{
    if (*_data_ptr) {
	_seqof1 * _tempa = *_data_ptr;
	_seqof1 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    switch (_tempa->value.choice) {
	    case 1:
		_f_Attribute(_g, _tempa->value.u.initialString);
		_oss_dec_free(_g, _tempa->value.u.initialString);
		break;
	    case 2:
		_f_Attribute(_g, _tempa->value.u.anyString);
		_oss_dec_free(_g, _tempa->value.u.anyString);
		break;
	    case 3:
		_f_Attribute(_g, _tempa->value.u.finalString);
		_oss_dec_free(_g, _tempa->value.u.finalString);
		break;
	    default:
		/* Ignore for now */	;
	    }
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
}

static void _f_FilterItem(OssGlobal * _g, _FilterItem * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	_f_Attribute(_g, _data_ptr->u.equality);
	_oss_dec_free(_g, _data_ptr->u.equality);
	break;
    case 2:
	_f__seqof1(_g, &_data_ptr->u.substrings);
	break;
    case 3:
	_f_Attribute(_g, _data_ptr->u.greaterOrEqual);
	_oss_dec_free(_g, _data_ptr->u.greaterOrEqual);
	break;
    case 4:
	_f_Attribute(_g, _data_ptr->u.lessOrEqual);
	_oss_dec_free(_g, _data_ptr->u.lessOrEqual);
	break;
    case 5:
	_f_AttributeId(_g, _data_ptr->u.present);
	_oss_dec_free(_g, _data_ptr->u.present);
	break;
    case 6:
	_f_Attribute(_g, _data_ptr->u.subsetOf);
	_oss_dec_free(_g, _data_ptr->u.subsetOf);
	break;
    case 7:
	_f_Attribute(_g, _data_ptr->u.supersetOf);
	_oss_dec_free(_g, _data_ptr->u.supersetOf);
	break;
    case 8:
	_f_Attribute(_g, _data_ptr->u.nonNullSetIntersection);
	_oss_dec_free(_g, _data_ptr->u.nonNullSetIntersection);
	break;
    default:
	/* Ignore for now */	;
    }
}

static void _f__setof6(OssGlobal * _g, _setof6 ** _data_ptr)
{
    if (*_data_ptr) {
	_setof6 * _tempa = *_data_ptr;
	_setof6 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    switch (_tempa->value.choice) {
	    case 1:
		_f_AttributeId(_g, &_tempa->value.u.attributeIdError->attributeId);
		_oss_dec_free(_g, _tempa->value.u.attributeIdError);
		break;
	    case 2:
		_f_Attribute(_g, _tempa->value.u.attribute);
		_oss_dec_free(_g, _tempa->value.u.attribute);
		break;
	    default:
		/* Ignore for now */	;
	    }
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
}

static void _f__setof7(OssGlobal * _g, _setof3 ** _data_ptr)
{
    if (*_data_ptr) {
	_setof3 * _tempa = *_data_ptr;
	_setof3 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _f_Attribute(_g, &_tempa->value);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
}

static void _f__seq1(OssGlobal * _g, _seq1 * _data_ptr)
{
    _f_EventTypeId(_g, &_data_ptr->eventType);
    if (_data_ptr->bit_mask & 0x80000000) {
	if (_data_ptr->eventInfo.encoded.value)
	    _oss_dec_free(_g, _data_ptr->eventInfo.encoded.value);
	if (_data_ptr->eventInfo.pduNum != 0 && *(void **)&_data_ptr->eventInfo.decoded)
	    _fmSMASE_A_ASSOCIATE_Informatio(_g, _data_ptr->eventInfo.pduNum, *(void **)&_data_ptr->eventInfo.decoded);
    }
}

static void _f_RDNSequence(OssGlobal * _g, _RDNSequence ** _data_ptr)
{
    if (*_data_ptr) {
	_RDNSequence * _tempa = *_data_ptr;
	_RDNSequence * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _f_RelativeDistinguishedName(_g, &_tempa->value);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
}

static void _f_RelativeDistinguishedName(OssGlobal * _g, _RelativeDistinguishedName ** _data_ptr)
{
    if (*_data_ptr) {
	_RelativeDistinguishedName * _tempa = *_data_ptr;
	_RelativeDistinguishedName * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    if (_tempa->value.id.value)
		_oss_dec_free(_g, _tempa->value.id.value);
	    if (_tempa->value.value.encoded.value)
		_oss_dec_free(_g, _tempa->value.value.encoded.value);
	    if (_tempa->value.value.pduNum != 0 && *(void **)&_tempa->value.value.decoded)
		_fmSMASE_A_ASSOCIATE_Informatio(_g, _tempa->value.value.pduNum, *(void **)&_tempa->value.value.decoded);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
}

static void _f_Code(OssGlobal * _g, _Code * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 2:
	if (_data_ptr->u.global.value)
	    _oss_dec_free(_g, _data_ptr->u.global.value);
	break;
    default:
	/* Ignore for now */	;
    }
}

static void _f_FunctionalUnitPackage(OssGlobal * _g, _FunctionalUnitPackage * _data_ptr)
{
    if (_data_ptr->functionalUnitPackageId.value)
	_oss_dec_free(_g, _data_ptr->functionalUnitPackageId.value);
    if (_data_ptr->bit_mask & 0x80000000) {
	if (_data_ptr->managerRoleFunctionalUnit.value)
	    _oss_dec_free(_g, _data_ptr->managerRoleFunctionalUnit.value);
    }
    if (_data_ptr->bit_mask & 0x40000000) {
	if (_data_ptr->agentRoleFunctionalUnit.value)
	    _oss_dec_free(_g, _data_ptr->agentRoleFunctionalUnit.value);
    }
}

static void _fActionArgument(OssGlobal * _g, void * _data)
{
    _ActionArgument	*_data_ptr;
    _data_ptr = (_ActionArgument *)_data;
    _f_ObjectClass(_g, &_data_ptr->baseManagedObjectClass);
    _f_ObjectInstance(_g, &_data_ptr->baseManagedObjectInstance);
    if (_data_ptr->bit_mask & 0x80000000) {
	_f_External(_g, &_data_ptr->accessControl);
    }
    if (_data_ptr->bit_mask & 0x10000000) {
	_f_CMISFilter(_g, &_data_ptr->filter);
    }
    _f_ActionInfo(_g, &_data_ptr->actionInfo);
    _oss_dec_free(_g, _data_ptr);
}

static void _fActionResult(OssGlobal * _g, void * _data)
{
    _ActionResult	*_data_ptr;
    _data_ptr = (_ActionResult *)_data;
    _f_ActionResult(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fAttribute(OssGlobal * _g, void * _data)
{
    _Attribute	*_data_ptr;
    _data_ptr = (_Attribute *)_data;
    _f_Attribute(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fAttributeId(OssGlobal * _g, void * _data)
{
    _ActionTypeId	*_data_ptr;
    _data_ptr = (_ActionTypeId *)_data;
    _f_AttributeId(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fBaseManagedObjectId(OssGlobal * _g, void * _data)
{
    _BaseManagedObjectId	*_data_ptr;
    _data_ptr = (_BaseManagedObjectId *)_data;
    _f_ObjectClass(_g, &_data_ptr->baseManagedObjectClass);
    _f_ObjectInstance(_g, &_data_ptr->baseManagedObjectInstance);
    _oss_dec_free(_g, _data_ptr);
}

static void _fCMISFilter(OssGlobal * _g, void * _data)
{
    _CMISFilter	*_data_ptr;
    _data_ptr = (_CMISFilter *)_data;
    _f_CMISFilter(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fCMISSync(OssGlobal * _g, void * _data)
{
    enum CMISSync	*_data_ptr;
    _data_ptr = (enum CMISSync *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fComplexityLimitation(OssGlobal * _g, void * _data)
{
    _ComplexityLimitation	*_data_ptr;
    _data_ptr = (_ComplexityLimitation *)_data;
    if (_data_ptr->bit_mask & 0x40000000) {
	_f_CMISFilter(_g, &_data_ptr->filter);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fCreateArgument(OssGlobal * _g, void * _data)
{
    _CreateArgument	*_data_ptr;
    _data_ptr = (_CreateArgument *)_data;
    _f_ObjectClass(_g, &_data_ptr->managedObjectClass);
    if (_data_ptr->bit_mask & 0x80000000) {
	switch (_data_ptr->managedOrSuperiorObjectInstance.choice) {
	case 1:
	    _f_ObjectInstance(_g, _data_ptr->managedOrSuperiorObjectInstance.u.managedObjectInstance);
	    _oss_dec_free(_g, _data_ptr->managedOrSuperiorObjectInstance.u.managedObjectInstance);
	    break;
	case 2:
	    _f_ObjectInstance(_g, _data_ptr->managedOrSuperiorObjectInstance.u.superiorObjectInstance);
	    _oss_dec_free(_g, _data_ptr->managedOrSuperiorObjectInstance.u.superiorObjectInstance);
	    break;
	default:
	    /* Ignore for now */	;
	}
    }
    if (_data_ptr->bit_mask & 0x40000000) {
	_f_External(_g, &_data_ptr->accessControl);
    }
    if (_data_ptr->bit_mask & 0x20000000) {
	_f_ObjectInstance(_g, &_data_ptr->referenceObjectInstance);
    }
    if (_data_ptr->bit_mask & 0x10000000) {
	if (_data_ptr->attributeList) {
	    _setof3 * _tempa = _data_ptr->attributeList;
	    _setof3 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f_Attribute(_g, &_tempa->value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fCreateResult(OssGlobal * _g, void * _data)
{
    _CreateResult	*_data_ptr;
    _data_ptr = (_CreateResult *)_data;
    if (_data_ptr->bit_mask & 0x80000000) {
	_f_ObjectClass(_g, &_data_ptr->managedObjectClass);
    }
    if (_data_ptr->bit_mask & 0x40000000) {
	_f_ObjectInstance(_g, &_data_ptr->managedObjectInstance);
    }
    if (_data_ptr->currentTime) {
	_oss_dec_free(_g, _data_ptr->currentTime);
    }
    if (_data_ptr->bit_mask & 0x20000000) {
	if (_data_ptr->attributeList) {
	    _setof3 * _tempa = _data_ptr->attributeList;
	    _setof3 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f_Attribute(_g, &_tempa->value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fDeleteArgument(OssGlobal * _g, void * _data)
{
    _DeleteArgument	*_data_ptr;
    _data_ptr = (_DeleteArgument *)_data;
    _f_ObjectClass(_g, &_data_ptr->baseManagedObjectClass);
    _f_ObjectInstance(_g, &_data_ptr->baseManagedObjectInstance);
    if (_data_ptr->bit_mask & 0x80000000) {
	_f_External(_g, &_data_ptr->accessControl);
    }
    if (_data_ptr->bit_mask & 0x10000000) {
	_f_CMISFilter(_g, &_data_ptr->filter);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fDeleteResult(OssGlobal * _g, void * _data)
{
    _DeleteResult	*_data_ptr;
    _data_ptr = (_DeleteResult *)_data;
    _f_DeleteResult(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fEventReportArgument(OssGlobal * _g, void * _data)
{
    _EventReportArgument	*_data_ptr;
    _data_ptr = (_EventReportArgument *)_data;
    _f_ObjectClass(_g, &_data_ptr->managedObjectClass);
    _f_ObjectInstance(_g, &_data_ptr->managedObjectInstance);
    if (_data_ptr->eventTime) {
	_oss_dec_free(_g, _data_ptr->eventTime);
    }
    _f_EventTypeId(_g, &_data_ptr->eventType);
    if (_data_ptr->bit_mask & 0x80000000) {
	if (_data_ptr->eventInfo.encoded.value)
	    _oss_dec_free(_g, _data_ptr->eventInfo.encoded.value);
	if (_data_ptr->eventInfo.pduNum != 0 && *(void **)&_data_ptr->eventInfo.decoded)
	    _fmSMASE_A_ASSOCIATE_Informatio(_g, _data_ptr->eventInfo.pduNum, *(void **)&_data_ptr->eventInfo.decoded);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fEventReportResult(OssGlobal * _g, void * _data)
{
    _EventReportResult	*_data_ptr;
    _data_ptr = (_EventReportResult *)_data;
    if (_data_ptr->bit_mask & 0x80000000) {
	_f_ObjectClass(_g, &_data_ptr->managedObjectClass);
    }
    if (_data_ptr->bit_mask & 0x40000000) {
	_f_ObjectInstance(_g, &_data_ptr->managedObjectInstance);
    }
    if (_data_ptr->currentTime) {
	_oss_dec_free(_g, _data_ptr->currentTime);
    }
    if (_data_ptr->bit_mask & 0x20000000) {
	_f_EventTypeId(_g, &_data_ptr->eventReply.eventType);
	if (_data_ptr->eventReply.bit_mask & 0x80000000) {
	    if (_data_ptr->eventReply.eventReplyInfo.encoded.value)
		_oss_dec_free(_g, _data_ptr->eventReply.eventReplyInfo.encoded.value);
	    if (_data_ptr->eventReply.eventReplyInfo.pduNum != 0 && *(void **)&_data_ptr->eventReply.eventReplyInfo.decoded)
		_fmSMASE_A_ASSOCIATE_Informatio(_g, _data_ptr->eventReply.eventReplyInfo.pduNum, *(void **)&_data_ptr->eventReply.eventReplyInfo.decoded);
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fGetArgument(OssGlobal * _g, void * _data)
{
    _GetArgument	*_data_ptr;
    _data_ptr = (_GetArgument *)_data;
    _f_ObjectClass(_g, &_data_ptr->baseManagedObjectClass);
    _f_ObjectInstance(_g, &_data_ptr->baseManagedObjectInstance);
    if (_data_ptr->bit_mask & 0x80000000) {
	_f_External(_g, &_data_ptr->accessControl);
    }
    if (_data_ptr->bit_mask & 0x10000000) {
	_f_CMISFilter(_g, &_data_ptr->filter);
    }
    if (_data_ptr->bit_mask & 0x8000000) {
	if (_data_ptr->attributeIdList) {
	    _MissingAttributeValue_PARAMETER * _tempa = _data_ptr->attributeIdList;
	    _MissingAttributeValue_PARAMETER * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f_AttributeId(_g, &_tempa->value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fGetListError(OssGlobal * _g, void * _data)
{
    _GetListError	*_data_ptr;
    _data_ptr = (_GetListError *)_data;
    _f_GetListError(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fGetResult(OssGlobal * _g, void * _data)
{
    _CreateResult	*_data_ptr;
    _data_ptr = (_CreateResult *)_data;
    _f_GetResult(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fInvalidArgumentValue(OssGlobal * _g, void * _data)
{
    _InvalidArgumentValue	*_data_ptr;
    _data_ptr = (_InvalidArgumentValue *)_data;
    _f_InvalidArgumentValue(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fInvokeIDType(OssGlobal * _g, void * _data)
{
    _InvokeId	*_data_ptr;
    _data_ptr = (_InvokeId *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fLinkedReplyArgument(OssGlobal * _g, void * _data)
{
    _LinkedReplyArgument	*_data_ptr;
    _data_ptr = (_LinkedReplyArgument *)_data;
    switch (_data_ptr->choice) {
    case 1:
	_f_GetResult(_g, _data_ptr->u.getResult);
	_oss_dec_free(_g, _data_ptr->u.getResult);
	break;
    case 2:
	_f_GetListError(_g, _data_ptr->u.getListError);
	_oss_dec_free(_g, _data_ptr->u.getListError);
	break;
    case 3:
	_f_SetResult(_g, _data_ptr->u.setResult);
	_oss_dec_free(_g, _data_ptr->u.setResult);
	break;
    case 4:
	_f_SetListError(_g, _data_ptr->u.setListError);
	_oss_dec_free(_g, _data_ptr->u.setListError);
	break;
    case 5:
	_f_ActionResult(_g, _data_ptr->u.actionResult);
	_oss_dec_free(_g, _data_ptr->u.actionResult);
	break;
    case 6:
	_f_ProcessingFailure(_g, _data_ptr->u.processingFailure);
	_oss_dec_free(_g, _data_ptr->u.processingFailure);
	break;
    case 7:
	_f_DeleteResult(_g, _data_ptr->u.deleteResult);
	_oss_dec_free(_g, _data_ptr->u.deleteResult);
	break;
    case 8:
	if (_data_ptr->u.actionError->bit_mask & 0x80000000) {
	    _f_ObjectClass(_g, &_data_ptr->u.actionError->managedObjectClass);
	}
	if (_data_ptr->u.actionError->bit_mask & 0x40000000) {
	    _f_ObjectInstance(_g, &_data_ptr->u.actionError->managedObjectInstance);
	}
	if (_data_ptr->u.actionError->currentTime) {
	    _oss_dec_free(_g, _data_ptr->u.actionError->currentTime);
	}
	switch (_data_ptr->u.actionError->actionErrorInfo.errorInfo.choice) {
	case 1:
	    _f_NoSuchArgument(_g, _data_ptr->u.actionError->actionErrorInfo.errorInfo.u.actionArgument);
	    _oss_dec_free(_g, _data_ptr->u.actionError->actionErrorInfo.errorInfo.u.actionArgument);
	    break;
	case 2:
	    _f_InvalidArgumentValue(_g, _data_ptr->u.actionError->actionErrorInfo.errorInfo.u.argumentValue);
	    _oss_dec_free(_g, _data_ptr->u.actionError->actionErrorInfo.errorInfo.u.argumentValue);
	    break;
	case 3:
	    _f_ActionTypeId(_g, _data_ptr->u.actionError->actionErrorInfo.errorInfo.u.actionType);
	    _oss_dec_free(_g, _data_ptr->u.actionError->actionErrorInfo.errorInfo.u.actionType);
	    break;
	default:
	    /* Ignore for now */	;
	}
	_oss_dec_free(_g, _data_ptr->u.actionError);
	break;
    case 9:
	if (_data_ptr->u.deleteError->bit_mask & 0x80000000) {
	    _f_ObjectClass(_g, &_data_ptr->u.deleteError->managedObjectClass);
	}
	if (_data_ptr->u.deleteError->bit_mask & 0x40000000) {
	    _f_ObjectInstance(_g, &_data_ptr->u.deleteError->managedObjectInstance);
	}
	if (_data_ptr->u.deleteError->currentTime) {
	    _oss_dec_free(_g, _data_ptr->u.deleteError->currentTime);
	}
	_oss_dec_free(_g, _data_ptr->u.deleteError);
	break;
    default:
	/* Ignore for now */	;
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fNoSuchAction(OssGlobal * _g, void * _data)
{
    _NoSuchAction	*_data_ptr;
    _data_ptr = (_NoSuchAction *)_data;
    _f_ObjectClass(_g, &_data_ptr->managedObjectClass);
    _f_ActionTypeId(_g, &_data_ptr->actionType);
    _oss_dec_free(_g, _data_ptr);
}

static void _fNoSuchArgument(OssGlobal * _g, void * _data)
{
    _NoSuchArgument	*_data_ptr;
    _data_ptr = (_NoSuchArgument *)_data;
    _f_NoSuchArgument(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fNoSuchEventType(OssGlobal * _g, void * _data)
{
    _NoSuchEventType	*_data_ptr;
    _data_ptr = (_NoSuchEventType *)_data;
    _f_ObjectClass(_g, &_data_ptr->managedObjectClass);
    _f_EventTypeId(_g, &_data_ptr->eventType);
    _oss_dec_free(_g, _data_ptr);
}

static void _fObjectClass(OssGlobal * _g, void * _data)
{
    _ActionTypeId	*_data_ptr;
    _data_ptr = (_ActionTypeId *)_data;
    _f_ObjectClass(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fObjectInstance(OssGlobal * _g, void * _data)
{
    _ObjectInstance	*_data_ptr;
    _data_ptr = (_ObjectInstance *)_data;
    _f_ObjectInstance(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fProcessingFailure(OssGlobal * _g, void * _data)
{
    _ProcessingFailure	*_data_ptr;
    _data_ptr = (_ProcessingFailure *)_data;
    _f_ProcessingFailure(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fScope(OssGlobal * _g, void * _data)
{
    _Scope	*_data_ptr;
    _data_ptr = (_Scope *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fSetArgument(OssGlobal * _g, void * _data)
{
    _SetArgument	*_data_ptr;
    _data_ptr = (_SetArgument *)_data;
    _f_ObjectClass(_g, &_data_ptr->baseManagedObjectClass);
    _f_ObjectInstance(_g, &_data_ptr->baseManagedObjectInstance);
    if (_data_ptr->bit_mask & 0x80000000) {
	_f_External(_g, &_data_ptr->accessControl);
    }
    if (_data_ptr->bit_mask & 0x10000000) {
	_f_CMISFilter(_g, &_data_ptr->filter);
    }
    if (_data_ptr->modificationList) {
	_setof8 * _tempa = _data_ptr->modificationList;
	_setof8 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _f_AttributeId(_g, &_tempa->value.attributeId);
	    if (_tempa->value.bit_mask & 0x40000000) {
		if (_tempa->value.attributeValue.encoded.value)
		    _oss_dec_free(_g, _tempa->value.attributeValue.encoded.value);
		if (_tempa->value.attributeValue.pduNum != 0 && *(void **)&_tempa->value.attributeValue.decoded)
		    _fmSMASE_A_ASSOCIATE_Informatio(_g, _tempa->value.attributeValue.pduNum, *(void **)&_tempa->value.attributeValue.decoded);
	    }
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fSetListError(OssGlobal * _g, void * _data)
{
    _SetListError	*_data_ptr;
    _data_ptr = (_SetListError *)_data;
    _f_SetListError(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fSetResult(OssGlobal * _g, void * _data)
{
    _CreateResult	*_data_ptr;
    _data_ptr = (_CreateResult *)_data;
    _f_SetResult(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fROSEapdus(OssGlobal * _g, void * _data)
{
    _ROSEapdus	*_data_ptr;
    _data_ptr = (_ROSEapdus *)_data;
    switch (_data_ptr->choice) {
    case 1:
	_f_Code(_g, &_data_ptr->u.invoke->opcode);
	if (_data_ptr->u.invoke->bit_mask & 0x40000000) {
	    if (_data_ptr->u.invoke->argument.encoded.value)
		_oss_dec_free(_g, _data_ptr->u.invoke->argument.encoded.value);
	    if (_data_ptr->u.invoke->argument.pduNum != 0 && *(void **)&_data_ptr->u.invoke->argument.decoded)
		_fmSMASE_A_ASSOCIATE_Informatio(_g, _data_ptr->u.invoke->argument.pduNum, *(void **)&_data_ptr->u.invoke->argument.decoded);
	}
	_oss_dec_free(_g, _data_ptr->u.invoke);
	break;
    case 2:
	if (_data_ptr->u.returnResult->bit_mask & 0x80000000) {
	    _f_Code(_g, &_data_ptr->u.returnResult->result.opcode);
	    if (_data_ptr->u.returnResult->result.result.encoded.value)
		_oss_dec_free(_g, _data_ptr->u.returnResult->result.result.encoded.value);
	    if (_data_ptr->u.returnResult->result.result.pduNum != 0 && *(void **)&_data_ptr->u.returnResult->result.result.decoded)
		_fmSMASE_A_ASSOCIATE_Informatio(_g, _data_ptr->u.returnResult->result.result.pduNum, *(void **)&_data_ptr->u.returnResult->result.result.decoded);
	}
	_oss_dec_free(_g, _data_ptr->u.returnResult);
	break;
    case 3:
	_f_Code(_g, &_data_ptr->u.returnError->errcode);
	if (_data_ptr->u.returnError->bit_mask & 0x80000000) {
	    if (_data_ptr->u.returnError->parameter.encoded.value)
		_oss_dec_free(_g, _data_ptr->u.returnError->parameter.encoded.value);
	    if (_data_ptr->u.returnError->parameter.pduNum != 0 && *(void **)&_data_ptr->u.returnError->parameter.decoded)
		_fmSMASE_A_ASSOCIATE_Informatio(_g, _data_ptr->u.returnError->parameter.pduNum, *(void **)&_data_ptr->u.returnError->parameter.decoded);
	}
	_oss_dec_free(_g, _data_ptr->u.returnError);
	break;
    case 4:
	_oss_dec_free(_g, _data_ptr->u.reject);
	break;
    default:
	/* Ignore for now */	;
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fCMIPAbortInfo(OssGlobal * _g, void * _data)
{
    _CMIPAbortInfo	*_data_ptr;
    _data_ptr = (_CMIPAbortInfo *)_data;
    if (_data_ptr->bit_mask & 0x80000000) {
	_f_External(_g, &_data_ptr->userInfo);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fCMIPUserInfo(OssGlobal * _g, void * _data)
{
    _CMIPUserInfo	*_data_ptr;
    _data_ptr = (_CMIPUserInfo *)_data;
    if (_data_ptr->bit_mask & 0x80000000) {
	if (_data_ptr->protocolVersion.value)
	    _oss_dec_free(_g, _data_ptr->protocolVersion.value);
    }
    if (_data_ptr->bit_mask & 0x40000000) {
	if (_data_ptr->functionalUnits.value)
	    _oss_dec_free(_g, _data_ptr->functionalUnits.value);
    }
    if (_data_ptr->bit_mask & 0x20000000) {
	_f_External(_g, &_data_ptr->accessControl);
    }
    if (_data_ptr->bit_mask & 0x10000000) {
	_f_External(_g, &_data_ptr->userInfo);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fCmipPduReceivingSupport(OssGlobal * _g, void * _data)
{
    OSSC::COssBitString	*_data_ptr;
    _data_ptr = (OSSC::COssBitString *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _fCmipPduSendingSupport(OssGlobal * _g, void * _data)
{
    OSSC::COssBitString	*_data_ptr;
    _data_ptr = (OSSC::COssBitString *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _fCmiseFunctionalUnitsSelected(OssGlobal * _g, void * _data)
{
    OSSC::COssBitString	*_data_ptr;
    _data_ptr = (OSSC::COssBitString *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _f0CmiseFunctionalUnitsSupport(OssGlobal * _g, void * _data)
{
    OSSC::COssBitString	*_data_ptr;
    _data_ptr = (OSSC::COssBitString *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _fInvokeldsOutstanding(OssGlobal * _g, void * _data)
{
    _InvokeldsOutstanding	**_data_ptr;
    _data_ptr = (_InvokeldsOutstanding **)_data;
    if (*_data_ptr) {
	_InvokeldsOutstanding * _tempa = *_data_ptr;
	_InvokeldsOutstanding * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fInvokeIdsPerforming(OssGlobal * _g, void * _data)
{
    _InvokeldsOutstanding	**_data_ptr;
    _data_ptr = (_InvokeldsOutstanding **)_data;
    if (*_data_ptr) {
	_InvokeldsOutstanding * _tempa = *_data_ptr;
	_InvokeldsOutstanding * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fMaxEncodedCmipPduReceiveSize(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fProtocolVersionSupported(OssGlobal * _g, void * _data)
{
    OSSC::COssBitString	*_data_ptr;
    _data_ptr = (OSSC::COssBitString *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _fSmaseFunctionalUnits(OssGlobal * _g, void * _data)
{
    _SmaseFunctionalUnits	**_data_ptr;
    _data_ptr = (_SmaseFunctionalUnits **)_data;
    if (*_data_ptr) {
	_SmaseFunctionalUnits * _tempa = *_data_ptr;
	_SmaseFunctionalUnits * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _f_FunctionalUnitPackage(_g, &_tempa->value);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fSmUserInfoSent(OssGlobal * _g, void * _data)
{
    _SmUserInfoSent	*_data_ptr;
    _data_ptr = (_SmUserInfoSent *)_data;
    switch (_data_ptr->choice) {
    case 2:
	if (_data_ptr->u.informationSent.value)
	    _oss_dec_free(_g, _data_ptr->u.informationSent.value);
	break;
    default:
	/* Ignore for now */	;
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fSmUserInfoReceived(OssGlobal * _g, void * _data)
{
    _SmUserInfoReceived	*_data_ptr;
    _data_ptr = (_SmUserInfoReceived *)_data;
    switch (_data_ptr->choice) {
    case 2:
	if (_data_ptr->u.informationReceived.value)
	    _oss_dec_free(_g, _data_ptr->u.informationReceived.value);
	break;
    default:
	/* Ignore for now */	;
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fROSEInvokeIds(OssGlobal * _g, void * _data)
{
    _InvokeId	*_data_ptr;
    _data_ptr = (_InvokeId *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fNoInvokeId(OssGlobal * _g, void * _data)
{
    _InvokeId	*_data_ptr;
    _data_ptr = (_InvokeId *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fSMASEUserData(OssGlobal * _g, void * _data)
{
    _SMASEUserData	*_data_ptr;
    _data_ptr = (_SMASEUserData *)_data;
    if (_data_ptr->bit_mask & 0x80000000) {
	if (_data_ptr->smfuPackages) {
	    _SmaseFunctionalUnits * _tempa = _data_ptr->smfuPackages;
	    _SmaseFunctionalUnits * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f_FunctionalUnitPackage(_g, &_tempa->value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    if (_data_ptr->bit_mask & 0x20000000) {
	if (_data_ptr->systemsManagementUserInformation.value)
	    _oss_dec_free(_g, _data_ptr->systemsManagementUserInformation.value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fAccessDenied_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _f1ClassInstanceConflict_PRIOR(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _f2ComplexityLimitation_PRIORI(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fInvalidScope_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _f3InvalidArgumentValue_PRIORI(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fInvalidFilter_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fNoSuchAction_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fNoSuchArgument_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fNoSuchObjectClass_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _f4NoSuchObjectInstance_PRIORI(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fProcessingFailure_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fSyncNotSupported_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fMistypedOperation_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fNoSuchInvokeId_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _f5DuplicateManagedObjectInsta(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _f6InvalidAttributeValue_PRIOR(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _f7InvalidObjectInstance_PRIOR(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _f8MissingAttributeValue_PARAM(OssGlobal * _g, void * _data)
{
    _MissingAttributeValue_PARAMETER	**_data_ptr;
    _data_ptr = (_MissingAttributeValue_PARAMETER **)_data;
    if (*_data_ptr) {
	_MissingAttributeValue_PARAMETER * _tempa = *_data_ptr;
	_MissingAttributeValue_PARAMETER * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _f_AttributeId(_g, &_tempa->value);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _f9MissingAttributeValue_PRIOR(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fNoSuchAttribute_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _f10NoSuchReferenceObject_PRIO(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fNoSuchEventType_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fGetListError_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fOperationCancelled_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fSetListError_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fAcse_RealizationParameter(OssGlobal * _g, void * _data)
{
    _RealizationParameter	*_data_ptr;
    _data_ptr = (_RealizationParameter *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _f11Acse_with_concatenation_Re(OssGlobal * _g, void * _data)
{
    _RealizationParameter	*_data_ptr;
    _data_ptr = (_RealizationParameter *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _f12Association_by_RTSE_Realiz(OssGlobal * _g, void * _data)
{
    _RealizationParameter	*_data_ptr;
    _data_ptr = (_RealizationParameter *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fPData_RealizationParameter(OssGlobal * _g, void * _data)
{
    _RealizationParameter	*_data_ptr;
    _data_ptr = (_RealizationParameter *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _f13PData_with_concatenation_R(OssGlobal * _g, void * _data)
{
    _RealizationParameter	*_data_ptr;
    _data_ptr = (_RealizationParameter *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _f14Transfer_by_RTSE_Realizati(OssGlobal * _g, void * _data)
{
    _RealizationParameter	*_data_ptr;
    _data_ptr = (_RealizationParameter *)_data;
    _oss_dec_free(_g, _data_ptr);
}

int DLL_ENTRY_FDEF _fmSMASE_A_ASSOCIATE_Informatio(struct ossGlobal * _g, int _pdunum, void * _data)
{
    if (_pdunum < 1 || _pdunum > 78)
	return PDU_RANGE;
    else
	_FreePDU[_pdunum - 1](_g, _data);

    return PDU_FREED;
}

#endif
#ifdef OSSPRINT
static void _p_ActionResult(OssGlobal * _g, _ActionResult * _data_ptr)
{
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "managedObjectClass ");
	    _p_ObjectClass(_g, &_data_ptr->managedObjectClass);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "managedObjectInstance ");
	    _p_ObjectInstance(_g, &_data_ptr->managedObjectInstance);
	    _comma = 1;
	}
	if (_data_ptr->currentTime) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "currentTime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_data_ptr->currentTime == NULL)
		ossPrint(_g, "<<<<<<NULL>>>>>>");
	    else
#endif
		_oss_prt_nchar(_g, (char *)_data_ptr->currentTime);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "actionReply ");
	    _p_ActionReply(_g, &_data_ptr->actionReply);
	    _comma = 1;
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_Attribute(OssGlobal * _g, _Attribute * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "id ");
	_p_AttributeId(_g, &_data_ptr->id);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "value ");
	_oss_prt_new_opentype(_g, _data_ptr->value.pduNum, *(void **)&_data_ptr->value.decoded, &_data_ptr->value.encoded);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_AttributeId(OssGlobal * _g, _ActionTypeId * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "globalForm : ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = NULL;
	    _e.length = (unsigned short)_data_ptr->u.globalForm.length;
	    _e.value = _data_ptr->u.globalForm.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	break;
    case 2:
	ossPrint(_g, "localForm : ");
	{
	    LONG_LONG value = _data_ptr->u.localForm;

	    ossPrint(_g, LLONG_FMT, value);
	}
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p_CMISFilter(OssGlobal * _g, _CMISFilter * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "item : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.item == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    _p_FilterItem(_g, _data_ptr->u.item);
	break;
    case 2:
	ossPrint(_g, "and : ");
	_p__setof1(_g, &_data_ptr->u.CMISFilter_and);
	break;
    case 3:
	ossPrint(_g, "or : ");
	_p__setof2(_g, &_data_ptr->u.CMISFilter_or);
	break;
    case 4:
	ossPrint(_g, "not : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.CMISFilter_not == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    _p_CMISFilter(_g, _data_ptr->u.CMISFilter_not);
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p_DeleteResult(OssGlobal * _g, _DeleteResult * _data_ptr)
{
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "managedObjectClass ");
	    _p_ObjectClass(_g, &_data_ptr->managedObjectClass);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "managedObjectInstance ");
	    _p_ObjectInstance(_g, &_data_ptr->managedObjectInstance);
	    _comma = 1;
	}
	if (_data_ptr->currentTime) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "currentTime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_data_ptr->currentTime == NULL)
		ossPrint(_g, "<<<<<<NULL>>>>>>");
	    else
#endif
		_oss_prt_nchar(_g, (char *)_data_ptr->currentTime);
	    _comma = 1;
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_GetListError(OssGlobal * _g, _GetListError * _data_ptr)
{
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "managedObjectClass ");
	    _p_ObjectClass(_g, &_data_ptr->managedObjectClass);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "managedObjectInstance ");
	    _p_ObjectInstance(_g, &_data_ptr->managedObjectInstance);
	    _comma = 1;
	}
	if (_data_ptr->currentTime) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "currentTime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_data_ptr->currentTime == NULL)
		ossPrint(_g, "<<<<<<NULL>>>>>>");
	    else
#endif
		_oss_prt_nchar(_g, (char *)_data_ptr->currentTime);
	    _comma = 1;
	}
	if (_comma) ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "getInfoList ");
	_p__setof6(_g, &_data_ptr->getInfoList);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_GetResult(OssGlobal * _g, _CreateResult * _data_ptr)
{
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "managedObjectClass ");
	    _p_ObjectClass(_g, &_data_ptr->managedObjectClass);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "managedObjectInstance ");
	    _p_ObjectInstance(_g, &_data_ptr->managedObjectInstance);
	    _comma = 1;
	}
	if (_data_ptr->currentTime) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "currentTime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_data_ptr->currentTime == NULL)
		ossPrint(_g, "<<<<<<NULL>>>>>>");
	    else
#endif
		_oss_prt_nchar(_g, (char *)_data_ptr->currentTime);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "attributeList ");
	    _p__setof7(_g, &_data_ptr->attributeList);
	    _comma = 1;
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_InvalidArgumentValue(OssGlobal * _g, _InvalidArgumentValue * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "actionValue : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.actionValue == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    _p_ActionInfo(_g, _data_ptr->u.actionValue);
	break;
    case 2:
	ossPrint(_g, "eventValue : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.eventValue == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    _p__seq1(_g, _data_ptr->u.eventValue);
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p_NoSuchArgument(OssGlobal * _g, _NoSuchArgument * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "actionId : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.actionId == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    {
		short _comma = 0;

		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		if (_data_ptr->u.actionId->bit_mask & 0x80000000) {
		    _oss_indent(_g, 0);
		    ossPrint(_g, "managedObjectClass ");
		    _p_ObjectClass(_g, &_data_ptr->u.actionId->managedObjectClass);
		    _comma = 1;
		}
		if (_comma) ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "actionType ");
		_p_ActionTypeId(_g, &_data_ptr->u.actionId->actionType);
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	break;
    case 2:
	ossPrint(_g, "eventId : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.eventId == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    {
		short _comma = 0;

		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		if (_data_ptr->u.eventId->bit_mask & 0x80000000) {
		    _oss_indent(_g, 0);
		    ossPrint(_g, "managedObjectClass ");
		    _p_ObjectClass(_g, &_data_ptr->u.eventId->managedObjectClass);
		    _comma = 1;
		}
		if (_comma) ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "eventType ");
		_p_EventTypeId(_g, &_data_ptr->u.eventId->eventType);
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p_ObjectClass(OssGlobal * _g, _ActionTypeId * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "globalForm : ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = NULL;
	    _e.length = (unsigned short)_data_ptr->u.globalForm.length;
	    _e.value = _data_ptr->u.globalForm.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	break;
    case 2:
	ossPrint(_g, "localForm : ");
	{
	    LONG_LONG value = _data_ptr->u.localForm;

	    ossPrint(_g, LLONG_FMT, value);
	}
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p_ObjectInstance(OssGlobal * _g, _ObjectInstance * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "distinguishedName : ");
	_p_RDNSequence(_g, &_data_ptr->u.distinguishedName);
	break;
    case 2:
	ossPrint(_g, "nonSpecificForm : ");
	_oss_prt_oct(_g, _data_ptr->u.nonSpecificForm.value, _data_ptr->u.nonSpecificForm.length);
	break;
    case 3:
	ossPrint(_g, "localDistinguishedName : ");
	_p_RDNSequence(_g, &_data_ptr->u.localDistinguishedName);
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p_ProcessingFailure(OssGlobal * _g, _ProcessingFailure * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "managedObjectClass ");
	_p_ObjectClass(_g, &_data_ptr->managedObjectClass);
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "managedObjectInstance ");
	    _p_ObjectInstance(_g, &_data_ptr->managedObjectInstance);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "specificErrorInfo ");
	{
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "errorId ");
	    {
		OssBuf _val;
		OssEncodedOID _e;
		_val.length = 0;
		_val.value = NULL;
		_e.length = (unsigned short)_data_ptr->specificErrorInfo.errorId.length;
		_e.value = _data_ptr->specificErrorInfo.errorId.value;
		ossEncodedOidToAsnVal(_g, &_e, &_val);
		if (_val.length) {
		    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		    _oss_dec_free(_g, _val.value);
		} else
		    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	    }
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "errorInfo ");
	    _oss_prt_new_opentype(_g, _data_ptr->specificErrorInfo.errorInfo.pduNum, *(void **)&_data_ptr->specificErrorInfo.errorInfo.decoded, &_data_ptr->specificErrorInfo.errorInfo.encoded);
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_Scope(OssGlobal * _g, _Scope * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "namedNumbers : ");
	{
	    LONG_LONG value = _data_ptr->u.namedNumbers;

	    ossPrint(_g, LLONG_FMT, value);
	}
	break;
    case 2:
	ossPrint(_g, "individualLevels : ");
	{
	    LONG_LONG value = _data_ptr->u.individualLevels;

	    ossPrint(_g, LLONG_FMT, value);
	}
	break;
    case 3:
	ossPrint(_g, "baseToNthLevel : ");
	{
	    LONG_LONG value = _data_ptr->u.baseToNthLevel;

	    ossPrint(_g, LLONG_FMT, value);
	}
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p_SetListError(OssGlobal * _g, _SetListError * _data_ptr)
{
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "managedObjectClass ");
	    _p_ObjectClass(_g, &_data_ptr->managedObjectClass);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "managedObjectInstance ");
	    _p_ObjectInstance(_g, &_data_ptr->managedObjectInstance);
	    _comma = 1;
	}
	if (_data_ptr->currentTime) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "currentTime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_data_ptr->currentTime == NULL)
		ossPrint(_g, "<<<<<<NULL>>>>>>");
	    else
#endif
		_oss_prt_nchar(_g, (char *)_data_ptr->currentTime);
	    _comma = 1;
	}
	if (_comma) ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "setInfoList ");
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->setInfoList) {
	    _setof9 * _tempa = _data_ptr->setInfoList;
	    _setof9 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_oss_indent(_g, 0);
		switch (_tempa->value.choice) {
		case 1:
		    ossPrint(_g, "attributeError : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_tempa->value.u.attributeError == NULL)
			ossPrint(_g, "<<<<<<NULL>>>>>>");
		    else
#endif
			{
			    _oss_indent(_g, 1);
			    ossPrint(_g, "{");
			    _oss_indent(_g, 0);
			    ossPrint(_g, "errorStatus ");
			    {
				LONG_LONG value = _tempa->value.u.attributeError->errorStatus;
				_oss_prt_enum(_g, (unsigned)value, _ssd[0].sa, (int)_ssd[0].alen);
			    }
			    if (_tempa->value.u.attributeError->bit_mask & 0x80000000) {
				ossPrint(_g, ",");
				_oss_indent(_g, 0);
				ossPrint(_g, "modifyOperator ");
				{
				    LONG_LONG value = _tempa->value.u.attributeError->modifyOperator;

				    ossPrint(_g, LLONG_FMT, value);
				}
			    }
			    ossPrint(_g, ",");
			    _oss_indent(_g, 0);
			    ossPrint(_g, "attributeId ");
			    _p_AttributeId(_g, &_tempa->value.u.attributeError->attributeId);
			    if (_tempa->value.u.attributeError->bit_mask & 0x40000000) {
				ossPrint(_g, ",");
				_oss_indent(_g, 0);
				ossPrint(_g, "attributeValue ");
				_oss_prt_new_opentype(_g, _tempa->value.u.attributeError->attributeValue.pduNum, *(void **)&_tempa->value.u.attributeError->attributeValue.decoded, &_tempa->value.u.attributeError->attributeValue.encoded);
			    }
			    _oss_indent(_g, -1);
			    ossPrint(_g, "}");
			}
		    break;
		case 2:
		    ossPrint(_g, "attribute : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_tempa->value.u.attribute == NULL)
			ossPrint(_g, "<<<<<<NULL>>>>>>");
		    else
#endif
			_p_Attribute(_g, _tempa->value.u.attribute);
		    break;
		default:
		    ossPrint(_g, "<unknown choice>");
		}
		_tempa = _tempb;
		if (_tempa)
		    ossPrint(_g, ",");
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_SetResult(OssGlobal * _g, _CreateResult * _data_ptr)
{
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "managedObjectClass ");
	    _p_ObjectClass(_g, &_data_ptr->managedObjectClass);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "managedObjectInstance ");
	    _p_ObjectInstance(_g, &_data_ptr->managedObjectInstance);
	    _comma = 1;
	}
	if (_data_ptr->currentTime) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "currentTime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_data_ptr->currentTime == NULL)
		ossPrint(_g, "<<<<<<NULL>>>>>>");
	    else
#endif
		_oss_prt_nchar(_g, (char *)_data_ptr->currentTime);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "attributeList ");
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_data_ptr->attributeList) {
		_setof3 * _tempa = _data_ptr->attributeList;
		_setof3 * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    _p_Attribute(_g, &_tempa->value);
		    _tempa = _tempb;
		    if (_tempa)
			ossPrint(_g, ",");
		}
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	    _comma = 1;
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p__choice1(OssGlobal * _g, _choice1 * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "single-ASN1-type : ");
	_oss_prt_opentype(_g, (OpenType *)&_data_ptr->u.single_ASN1_type);
	break;
    case 2:
	ossPrint(_g, "octet-aligned : ");
	_oss_prt_oct(_g, _data_ptr->u.octet_aligned.value, _data_ptr->u.octet_aligned.length);
	break;
    case 3:
	ossPrint(_g, "arbitrary : ");
	_oss_prt_bit(_g, _data_ptr->u.arbitrary.value, _data_ptr->u.arbitrary.length);
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p_External(OssGlobal * _g, _External * _data_ptr)
{
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "direct-reference ");
	    {
		OssBuf _val;
		OssEncodedOID _e;
		_val.length = 0;
		_val.value = NULL;
		_e.length = (unsigned short)_data_ptr->direct_reference.length;
		_e.value = _data_ptr->direct_reference.value;
		ossEncodedOidToAsnVal(_g, &_e, &_val);
		if (_val.length) {
		    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		    _oss_dec_free(_g, _val.value);
		} else
		    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	    }
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "indirect-reference ");
	    {
		LONG_LONG value = _data_ptr->indirect_reference;

		ossPrint(_g, LLONG_FMT, value);
	    }
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "data-value-descriptor ");
	    _oss_prt_char(_g, (char *)_data_ptr->data_value_descriptor.value, _data_ptr->data_value_descriptor.length);
	    _comma = 1;
	}
	if (_comma) ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "encoding ");
	_p__choice1(_g, &_data_ptr->encoding);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_ActionTypeId(OssGlobal * _g, _ActionTypeId * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "globalForm : ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = NULL;
	    _e.length = (unsigned short)_data_ptr->u.globalForm.length;
	    _e.value = _data_ptr->u.globalForm.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	break;
    case 2:
	ossPrint(_g, "localForm : ");
	{
	    LONG_LONG value = _data_ptr->u.localForm;

	    ossPrint(_g, LLONG_FMT, value);
	}
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p_EventTypeId(OssGlobal * _g, _ActionTypeId * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "globalForm : ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = NULL;
	    _e.length = (unsigned short)_data_ptr->u.globalForm.length;
	    _e.value = _data_ptr->u.globalForm.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	break;
    case 2:
	ossPrint(_g, "localForm : ");
	{
	    LONG_LONG value = _data_ptr->u.localForm;

	    ossPrint(_g, LLONG_FMT, value);
	}
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p__setof2(OssGlobal * _g, _setof1 ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_setof1 * _tempa = *_data_ptr;
	_setof1 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_indent(_g, 0);
	    _p_CMISFilter(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p__setof1(OssGlobal * _g, _setof1 ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_setof1 * _tempa = *_data_ptr;
	_setof1 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_indent(_g, 0);
	    _p_CMISFilter(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p_RealizationParameter(OssGlobal * _g, _RealizationParameter * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "realization-type ");
	{
	    ULONG_LONG value = _data_ptr->realization_type;
	    _oss_prt_enum(_g, value, _ssd[1].sa, (int)_ssd[1].alen);
	}
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "concatenation ");
	    ossPrint(_g, _data_ptr->concatenation ? "TRUE" : "FALSE");
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_ActionInfo(OssGlobal * _g, _ActionInfo * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "actionType ");
	_p_ActionTypeId(_g, &_data_ptr->actionType);
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "actionInfoArg ");
	    _oss_prt_new_opentype(_g, _data_ptr->actionInfoArg.pduNum, *(void **)&_data_ptr->actionInfoArg.decoded, &_data_ptr->actionInfoArg.encoded);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_ActionReply(OssGlobal * _g, _ActionReply * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "actionType ");
	_p_ActionTypeId(_g, &_data_ptr->actionType);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "actionReplyInfo ");
	_oss_prt_new_opentype(_g, _data_ptr->actionReplyInfo.pduNum, *(void **)&_data_ptr->actionReplyInfo.decoded, &_data_ptr->actionReplyInfo.encoded);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p__seqof1(OssGlobal * _g, _seqof1 ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_seqof1 * _tempa = *_data_ptr;
	_seqof1 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_indent(_g, 0);
	    switch (_tempa->value.choice) {
	    case 1:
		ossPrint(_g, "initialString : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
		if (_tempa->value.u.initialString == NULL)
		    ossPrint(_g, "<<<<<<NULL>>>>>>");
		else
#endif
		    _p_Attribute(_g, _tempa->value.u.initialString);
		break;
	    case 2:
		ossPrint(_g, "anyString : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
		if (_tempa->value.u.anyString == NULL)
		    ossPrint(_g, "<<<<<<NULL>>>>>>");
		else
#endif
		    _p_Attribute(_g, _tempa->value.u.anyString);
		break;
	    case 3:
		ossPrint(_g, "finalString : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
		if (_tempa->value.u.finalString == NULL)
		    ossPrint(_g, "<<<<<<NULL>>>>>>");
		else
#endif
		    _p_Attribute(_g, _tempa->value.u.finalString);
		break;
	    default:
		ossPrint(_g, "<unknown choice>");
	    }
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p_FilterItem(OssGlobal * _g, _FilterItem * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "equality : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.equality == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    _p_Attribute(_g, _data_ptr->u.equality);
	break;
    case 2:
	ossPrint(_g, "substrings : ");
	_p__seqof1(_g, &_data_ptr->u.substrings);
	break;
    case 3:
	ossPrint(_g, "greaterOrEqual : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.greaterOrEqual == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    _p_Attribute(_g, _data_ptr->u.greaterOrEqual);
	break;
    case 4:
	ossPrint(_g, "lessOrEqual : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.lessOrEqual == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    _p_Attribute(_g, _data_ptr->u.lessOrEqual);
	break;
    case 5:
	ossPrint(_g, "present : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.present == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    _p_AttributeId(_g, _data_ptr->u.present);
	break;
    case 6:
	ossPrint(_g, "subsetOf : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.subsetOf == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    _p_Attribute(_g, _data_ptr->u.subsetOf);
	break;
    case 7:
	ossPrint(_g, "supersetOf : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.supersetOf == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    _p_Attribute(_g, _data_ptr->u.supersetOf);
	break;
    case 8:
	ossPrint(_g, "nonNullSetIntersection : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.nonNullSetIntersection == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    _p_Attribute(_g, _data_ptr->u.nonNullSetIntersection);
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p__setof6(OssGlobal * _g, _setof6 ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_setof6 * _tempa = *_data_ptr;
	_setof6 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_indent(_g, 0);
	    switch (_tempa->value.choice) {
	    case 1:
		ossPrint(_g, "attributeIdError : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
		if (_tempa->value.u.attributeIdError == NULL)
		    ossPrint(_g, "<<<<<<NULL>>>>>>");
		else
#endif
		    {
			_oss_indent(_g, 1);
			ossPrint(_g, "{");
			_oss_indent(_g, 0);
			ossPrint(_g, "errorStatus ");
			{
			    LONG_LONG value = _tempa->value.u.attributeIdError->errorStatus;
			    _oss_prt_enum(_g, (unsigned)value, _ssd[2].sa, (int)_ssd[2].alen);
			}
			ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "attributeId ");
			_p_AttributeId(_g, &_tempa->value.u.attributeIdError->attributeId);
			_oss_indent(_g, -1);
			ossPrint(_g, "}");
		    }
		break;
	    case 2:
		ossPrint(_g, "attribute : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
		if (_tempa->value.u.attribute == NULL)
		    ossPrint(_g, "<<<<<<NULL>>>>>>");
		else
#endif
		    _p_Attribute(_g, _tempa->value.u.attribute);
		break;
	    default:
		ossPrint(_g, "<unknown choice>");
	    }
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p__setof7(OssGlobal * _g, _setof3 ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_setof3 * _tempa = *_data_ptr;
	_setof3 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _p_Attribute(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p__seq1(OssGlobal * _g, _seq1 * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "eventType ");
	_p_EventTypeId(_g, &_data_ptr->eventType);
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "eventInfo ");
	    _oss_prt_new_opentype(_g, _data_ptr->eventInfo.pduNum, *(void **)&_data_ptr->eventInfo.decoded, &_data_ptr->eventInfo.encoded);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_InvokeId(OssGlobal * _g, _InvokeId * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "present : ");
	{
	    LONG_LONG value = _data_ptr->u.present;

	    ossPrint(_g, LLONG_FMT, value);
	}
	break;
    case 2:
	ossPrint(_g, "absent : ");
	ossPrint(_g, "NULL");
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p_RDNSequence(OssGlobal * _g, _RDNSequence ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_RDNSequence * _tempa = *_data_ptr;
	_RDNSequence * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _p_RelativeDistinguishedName(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p_RelativeDistinguishedName(OssGlobal * _g, _RelativeDistinguishedName ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_RelativeDistinguishedName * _tempa = *_data_ptr;
	_RelativeDistinguishedName * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    {
		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		_oss_indent(_g, 0);
		ossPrint(_g, "id ");
		{
		    OssBuf _val;
		    OssEncodedOID _e;
		    _val.length = 0;
		    _val.value = NULL;
		    _e.length = (unsigned short)_tempa->value.id.length;
		    _e.value = _tempa->value.id.value;
		    ossEncodedOidToAsnVal(_g, &_e, &_val);
		    if (_val.length) {
			ossPrint(_g, "%.*s", (int)_val.length, _val.value);
			_oss_dec_free(_g, _val.value);
		    } else
			_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
		}
		ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "value ");
		_oss_prt_new_opentype(_g, _tempa->value.value.pduNum, *(void **)&_tempa->value.value.decoded, &_tempa->value.value.encoded);
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p_Code(OssGlobal * _g, _Code * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "local : ");
	{
	    LONG_LONG value = _data_ptr->u.local;

	    ossPrint(_g, LLONG_FMT, value);
	}
	break;
    case 2:
	ossPrint(_g, "global : ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = NULL;
	    _e.length = (unsigned short)_data_ptr->u.global.length;
	    _e.value = _data_ptr->u.global.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p_FunctionalUnitPackage(OssGlobal * _g, _FunctionalUnitPackage * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "functionalUnitPackageId ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = NULL;
	    _e.length = (unsigned short)_data_ptr->functionalUnitPackageId.length;
	    _e.value = _data_ptr->functionalUnitPackageId.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "managerRoleFunctionalUnit ");
	    _oss_prt_bit(_g, _data_ptr->managerRoleFunctionalUnit.value, _data_ptr->managerRoleFunctionalUnit.length);
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "agentRoleFunctionalUnit ");
	    _oss_prt_bit(_g, _data_ptr->agentRoleFunctionalUnit.value, _data_ptr->agentRoleFunctionalUnit.length);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static int _pActionArgument(OssGlobal * _g, void * _data)
{
    _ActionArgument	*_data_ptr;
    _data_ptr = (_ActionArgument *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "baseManagedObjectClass ");
	_p_ObjectClass(_g, &_data_ptr->baseManagedObjectClass);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "baseManagedObjectInstance ");
	_p_ObjectInstance(_g, &_data_ptr->baseManagedObjectInstance);
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "accessControl ");
	    _p_External(_g, &_data_ptr->accessControl);
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "synchronization ");
	    {
		ULONG_LONG value = _data_ptr->synchronization;
		_oss_prt_enum(_g, value, _ssd[3].sa, (int)_ssd[3].alen);
	    }
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "scope ");
	    _p_Scope(_g, &_data_ptr->scope);
	}
	if (_data_ptr->bit_mask & 0x10000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "filter ");
	    _p_CMISFilter(_g, &_data_ptr->filter);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "actionInfo ");
	_p_ActionInfo(_g, &_data_ptr->actionInfo);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pActionResult(OssGlobal * _g, void * _data)
{
    _ActionResult	*_data_ptr;
    _data_ptr = (_ActionResult *)_data;
    _p_ActionResult(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pAttribute(OssGlobal * _g, void * _data)
{
    _Attribute	*_data_ptr;
    _data_ptr = (_Attribute *)_data;
    _p_Attribute(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pAttributeId(OssGlobal * _g, void * _data)
{
    _ActionTypeId	*_data_ptr;
    _data_ptr = (_ActionTypeId *)_data;
    _p_AttributeId(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pBaseManagedObjectId(OssGlobal * _g, void * _data)
{
    _BaseManagedObjectId	*_data_ptr;
    _data_ptr = (_BaseManagedObjectId *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "baseManagedObjectClass ");
	_p_ObjectClass(_g, &_data_ptr->baseManagedObjectClass);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "baseManagedObjectInstance ");
	_p_ObjectInstance(_g, &_data_ptr->baseManagedObjectInstance);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pCMISFilter(OssGlobal * _g, void * _data)
{
    _CMISFilter	*_data_ptr;
    _data_ptr = (_CMISFilter *)_data;
    _p_CMISFilter(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pCMISSync(OssGlobal * _g, void * _data)
{
    enum CMISSync	*_data_ptr;
    _data_ptr = (enum CMISSync *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	_oss_prt_enum(_g, value, _ssd[3].sa, (int)_ssd[3].alen);
    }

    return PDU_PRINTED;
}

static int _pComplexityLimitation(OssGlobal * _g, void * _data)
{
    _ComplexityLimitation	*_data_ptr;
    _data_ptr = (_ComplexityLimitation *)_data;
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "scope ");
	    _p_Scope(_g, &_data_ptr->scope);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "filter ");
	    _p_CMISFilter(_g, &_data_ptr->filter);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "sync ");
	    {
		ULONG_LONG value = _data_ptr->sync;
		_oss_prt_enum(_g, value, _ssd[3].sa, (int)_ssd[3].alen);
	    }
	    _comma = 1;
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pCreateArgument(OssGlobal * _g, void * _data)
{
    _CreateArgument	*_data_ptr;
    _data_ptr = (_CreateArgument *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "managedObjectClass ");
	_p_ObjectClass(_g, &_data_ptr->managedObjectClass);
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "managedOrSuperiorObjectInstance ");
	    switch (_data_ptr->managedOrSuperiorObjectInstance.choice) {
	    case 1:
		ossPrint(_g, "managedObjectInstance : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
		if (_data_ptr->managedOrSuperiorObjectInstance.u.managedObjectInstance == NULL)
		    ossPrint(_g, "<<<<<<NULL>>>>>>");
		else
#endif
		    _p_ObjectInstance(_g, _data_ptr->managedOrSuperiorObjectInstance.u.managedObjectInstance);
		break;
	    case 2:
		ossPrint(_g, "superiorObjectInstance : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
		if (_data_ptr->managedOrSuperiorObjectInstance.u.superiorObjectInstance == NULL)
		    ossPrint(_g, "<<<<<<NULL>>>>>>");
		else
#endif
		    _p_ObjectInstance(_g, _data_ptr->managedOrSuperiorObjectInstance.u.superiorObjectInstance);
		break;
	    default:
		ossPrint(_g, "<unknown choice>");
	    }
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "accessControl ");
	    _p_External(_g, &_data_ptr->accessControl);
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "referenceObjectInstance ");
	    _p_ObjectInstance(_g, &_data_ptr->referenceObjectInstance);
	}
	if (_data_ptr->bit_mask & 0x10000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "attributeList ");
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_data_ptr->attributeList) {
		_setof3 * _tempa = _data_ptr->attributeList;
		_setof3 * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    _p_Attribute(_g, &_tempa->value);
		    _tempa = _tempb;
		    if (_tempa)
			ossPrint(_g, ",");
		}
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pCreateResult(OssGlobal * _g, void * _data)
{
    _CreateResult	*_data_ptr;
    _data_ptr = (_CreateResult *)_data;
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "managedObjectClass ");
	    _p_ObjectClass(_g, &_data_ptr->managedObjectClass);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "managedObjectInstance ");
	    _p_ObjectInstance(_g, &_data_ptr->managedObjectInstance);
	    _comma = 1;
	}
	if (_data_ptr->currentTime) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "currentTime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_data_ptr->currentTime == NULL)
		ossPrint(_g, "<<<<<<NULL>>>>>>");
	    else
#endif
		_oss_prt_nchar(_g, (char *)_data_ptr->currentTime);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "attributeList ");
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_data_ptr->attributeList) {
		_setof3 * _tempa = _data_ptr->attributeList;
		_setof3 * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    _p_Attribute(_g, &_tempa->value);
		    _tempa = _tempb;
		    if (_tempa)
			ossPrint(_g, ",");
		}
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	    _comma = 1;
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pDeleteArgument(OssGlobal * _g, void * _data)
{
    _DeleteArgument	*_data_ptr;
    _data_ptr = (_DeleteArgument *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "baseManagedObjectClass ");
	_p_ObjectClass(_g, &_data_ptr->baseManagedObjectClass);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "baseManagedObjectInstance ");
	_p_ObjectInstance(_g, &_data_ptr->baseManagedObjectInstance);
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "accessControl ");
	    _p_External(_g, &_data_ptr->accessControl);
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "synchronization ");
	    {
		ULONG_LONG value = _data_ptr->synchronization;
		_oss_prt_enum(_g, value, _ssd[3].sa, (int)_ssd[3].alen);
	    }
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "scope ");
	    _p_Scope(_g, &_data_ptr->scope);
	}
	if (_data_ptr->bit_mask & 0x10000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "filter ");
	    _p_CMISFilter(_g, &_data_ptr->filter);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pDeleteResult(OssGlobal * _g, void * _data)
{
    _DeleteResult	*_data_ptr;
    _data_ptr = (_DeleteResult *)_data;
    _p_DeleteResult(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pEventReportArgument(OssGlobal * _g, void * _data)
{
    _EventReportArgument	*_data_ptr;
    _data_ptr = (_EventReportArgument *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "managedObjectClass ");
	_p_ObjectClass(_g, &_data_ptr->managedObjectClass);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "managedObjectInstance ");
	_p_ObjectInstance(_g, &_data_ptr->managedObjectInstance);
	if (_data_ptr->eventTime) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "eventTime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_data_ptr->eventTime == NULL)
		ossPrint(_g, "<<<<<<NULL>>>>>>");
	    else
#endif
		_oss_prt_nchar(_g, (char *)_data_ptr->eventTime);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "eventType ");
	_p_EventTypeId(_g, &_data_ptr->eventType);
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "eventInfo ");
	    _oss_prt_new_opentype(_g, _data_ptr->eventInfo.pduNum, *(void **)&_data_ptr->eventInfo.decoded, &_data_ptr->eventInfo.encoded);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pEventReportResult(OssGlobal * _g, void * _data)
{
    _EventReportResult	*_data_ptr;
    _data_ptr = (_EventReportResult *)_data;
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "managedObjectClass ");
	    _p_ObjectClass(_g, &_data_ptr->managedObjectClass);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "managedObjectInstance ");
	    _p_ObjectInstance(_g, &_data_ptr->managedObjectInstance);
	    _comma = 1;
	}
	if (_data_ptr->currentTime) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "currentTime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_data_ptr->currentTime == NULL)
		ossPrint(_g, "<<<<<<NULL>>>>>>");
	    else
#endif
		_oss_prt_nchar(_g, (char *)_data_ptr->currentTime);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "eventReply ");
	    {
		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		_oss_indent(_g, 0);
		ossPrint(_g, "eventType ");
		_p_EventTypeId(_g, &_data_ptr->eventReply.eventType);
		if (_data_ptr->eventReply.bit_mask & 0x80000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "eventReplyInfo ");
		    _oss_prt_new_opentype(_g, _data_ptr->eventReply.eventReplyInfo.pduNum, *(void **)&_data_ptr->eventReply.eventReplyInfo.decoded, &_data_ptr->eventReply.eventReplyInfo.encoded);
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	    _comma = 1;
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pGetArgument(OssGlobal * _g, void * _data)
{
    _GetArgument	*_data_ptr;
    _data_ptr = (_GetArgument *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "baseManagedObjectClass ");
	_p_ObjectClass(_g, &_data_ptr->baseManagedObjectClass);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "baseManagedObjectInstance ");
	_p_ObjectInstance(_g, &_data_ptr->baseManagedObjectInstance);
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "accessControl ");
	    _p_External(_g, &_data_ptr->accessControl);
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "synchronization ");
	    {
		ULONG_LONG value = _data_ptr->synchronization;
		_oss_prt_enum(_g, value, _ssd[3].sa, (int)_ssd[3].alen);
	    }
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "scope ");
	    _p_Scope(_g, &_data_ptr->scope);
	}
	if (_data_ptr->bit_mask & 0x10000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "filter ");
	    _p_CMISFilter(_g, &_data_ptr->filter);
	}
	if (_data_ptr->bit_mask & 0x8000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "attributeIdList ");
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_data_ptr->attributeIdList) {
		_MissingAttributeValue_PARAMETER * _tempa = _data_ptr->attributeIdList;
		_MissingAttributeValue_PARAMETER * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    _oss_indent(_g, 0);
		    _p_AttributeId(_g, &_tempa->value);
		    _tempa = _tempb;
		    if (_tempa)
			ossPrint(_g, ",");
		}
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pGetListError(OssGlobal * _g, void * _data)
{
    _GetListError	*_data_ptr;
    _data_ptr = (_GetListError *)_data;
    _p_GetListError(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pGetResult(OssGlobal * _g, void * _data)
{
    _CreateResult	*_data_ptr;
    _data_ptr = (_CreateResult *)_data;
    _p_GetResult(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pInvalidArgumentValue(OssGlobal * _g, void * _data)
{
    _InvalidArgumentValue	*_data_ptr;
    _data_ptr = (_InvalidArgumentValue *)_data;
    _p_InvalidArgumentValue(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pInvokeIDType(OssGlobal * _g, void * _data)
{
    _InvokeId	*_data_ptr;
    _data_ptr = (_InvokeId *)_data;
    _p_InvokeId(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pLinkedReplyArgument(OssGlobal * _g, void * _data)
{
    _LinkedReplyArgument	*_data_ptr;
    _data_ptr = (_LinkedReplyArgument *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "getResult : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.getResult == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    _p_GetResult(_g, _data_ptr->u.getResult);
	break;
    case 2:
	ossPrint(_g, "getListError : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.getListError == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    _p_GetListError(_g, _data_ptr->u.getListError);
	break;
    case 3:
	ossPrint(_g, "setResult : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.setResult == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    _p_SetResult(_g, _data_ptr->u.setResult);
	break;
    case 4:
	ossPrint(_g, "setListError : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.setListError == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    _p_SetListError(_g, _data_ptr->u.setListError);
	break;
    case 5:
	ossPrint(_g, "actionResult : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.actionResult == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    _p_ActionResult(_g, _data_ptr->u.actionResult);
	break;
    case 6:
	ossPrint(_g, "processingFailure : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.processingFailure == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    _p_ProcessingFailure(_g, _data_ptr->u.processingFailure);
	break;
    case 7:
	ossPrint(_g, "deleteResult : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.deleteResult == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    _p_DeleteResult(_g, _data_ptr->u.deleteResult);
	break;
    case 8:
	ossPrint(_g, "actionError : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.actionError == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    {
		short _comma = 0;

		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		if (_data_ptr->u.actionError->bit_mask & 0x80000000) {
		    _oss_indent(_g, 0);
		    ossPrint(_g, "managedObjectClass ");
		    _p_ObjectClass(_g, &_data_ptr->u.actionError->managedObjectClass);
		    _comma = 1;
		}
		if (_data_ptr->u.actionError->bit_mask & 0x40000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "managedObjectInstance ");
		    _p_ObjectInstance(_g, &_data_ptr->u.actionError->managedObjectInstance);
		    _comma = 1;
		}
		if (_data_ptr->u.actionError->currentTime) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "currentTime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_data_ptr->u.actionError->currentTime == NULL)
			ossPrint(_g, "<<<<<<NULL>>>>>>");
		    else
#endif
			_oss_prt_nchar(_g, (char *)_data_ptr->u.actionError->currentTime);
		    _comma = 1;
		}
		if (_comma) ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "actionErrorInfo ");
		{
		    _oss_indent(_g, 1);
		    ossPrint(_g, "{");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "errorStatus ");
		    {
			LONG_LONG value = _data_ptr->u.actionError->actionErrorInfo.errorStatus;
			_oss_prt_enum(_g, (unsigned)value, _ssd[4].sa, (int)_ssd[4].alen);
		    }
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "errorInfo ");
		    switch (_data_ptr->u.actionError->actionErrorInfo.errorInfo.choice) {
		    case 1:
			ossPrint(_g, "actionArgument : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_data_ptr->u.actionError->actionErrorInfo.errorInfo.u.actionArgument == NULL)
			    ossPrint(_g, "<<<<<<NULL>>>>>>");
			else
#endif
			    _p_NoSuchArgument(_g, _data_ptr->u.actionError->actionErrorInfo.errorInfo.u.actionArgument);
			break;
		    case 2:
			ossPrint(_g, "argumentValue : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_data_ptr->u.actionError->actionErrorInfo.errorInfo.u.argumentValue == NULL)
			    ossPrint(_g, "<<<<<<NULL>>>>>>");
			else
#endif
			    _p_InvalidArgumentValue(_g, _data_ptr->u.actionError->actionErrorInfo.errorInfo.u.argumentValue);
			break;
		    case 3:
			ossPrint(_g, "actionType : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_data_ptr->u.actionError->actionErrorInfo.errorInfo.u.actionType == NULL)
			    ossPrint(_g, "<<<<<<NULL>>>>>>");
			else
#endif
			    _p_ActionTypeId(_g, _data_ptr->u.actionError->actionErrorInfo.errorInfo.u.actionType);
			break;
		    default:
			ossPrint(_g, "<unknown choice>");
		    }
		    _oss_indent(_g, -1);
		    ossPrint(_g, "}");
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	break;
    case 9:
	ossPrint(_g, "deleteError : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.deleteError == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    {
		short _comma = 0;

		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		if (_data_ptr->u.deleteError->bit_mask & 0x80000000) {
		    _oss_indent(_g, 0);
		    ossPrint(_g, "managedObjectClass ");
		    _p_ObjectClass(_g, &_data_ptr->u.deleteError->managedObjectClass);
		    _comma = 1;
		}
		if (_data_ptr->u.deleteError->bit_mask & 0x40000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "managedObjectInstance ");
		    _p_ObjectInstance(_g, &_data_ptr->u.deleteError->managedObjectInstance);
		    _comma = 1;
		}
		if (_data_ptr->u.deleteError->currentTime) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "currentTime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_data_ptr->u.deleteError->currentTime == NULL)
			ossPrint(_g, "<<<<<<NULL>>>>>>");
		    else
#endif
			_oss_prt_nchar(_g, (char *)_data_ptr->u.deleteError->currentTime);
		    _comma = 1;
		}
		if (_comma) ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "deleteErrorInfo ");
		{
		    LONG_LONG value = _data_ptr->u.deleteError->deleteErrorInfo;
		    _oss_prt_enum(_g, (unsigned)value, _ssd[5].sa, (int)_ssd[5].alen);
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

    return PDU_PRINTED;
}

static int _pNoSuchAction(OssGlobal * _g, void * _data)
{
    _NoSuchAction	*_data_ptr;
    _data_ptr = (_NoSuchAction *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "managedObjectClass ");
	_p_ObjectClass(_g, &_data_ptr->managedObjectClass);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "actionType ");
	_p_ActionTypeId(_g, &_data_ptr->actionType);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pNoSuchArgument(OssGlobal * _g, void * _data)
{
    _NoSuchArgument	*_data_ptr;
    _data_ptr = (_NoSuchArgument *)_data;
    _p_NoSuchArgument(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pNoSuchEventType(OssGlobal * _g, void * _data)
{
    _NoSuchEventType	*_data_ptr;
    _data_ptr = (_NoSuchEventType *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "managedObjectClass ");
	_p_ObjectClass(_g, &_data_ptr->managedObjectClass);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "eventType ");
	_p_EventTypeId(_g, &_data_ptr->eventType);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pObjectClass(OssGlobal * _g, void * _data)
{
    _ActionTypeId	*_data_ptr;
    _data_ptr = (_ActionTypeId *)_data;
    _p_ObjectClass(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pObjectInstance(OssGlobal * _g, void * _data)
{
    _ObjectInstance	*_data_ptr;
    _data_ptr = (_ObjectInstance *)_data;
    _p_ObjectInstance(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pProcessingFailure(OssGlobal * _g, void * _data)
{
    _ProcessingFailure	*_data_ptr;
    _data_ptr = (_ProcessingFailure *)_data;
    _p_ProcessingFailure(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pScope(OssGlobal * _g, void * _data)
{
    _Scope	*_data_ptr;
    _data_ptr = (_Scope *)_data;
    _p_Scope(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pSetArgument(OssGlobal * _g, void * _data)
{
    _SetArgument	*_data_ptr;
    _data_ptr = (_SetArgument *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "baseManagedObjectClass ");
	_p_ObjectClass(_g, &_data_ptr->baseManagedObjectClass);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "baseManagedObjectInstance ");
	_p_ObjectInstance(_g, &_data_ptr->baseManagedObjectInstance);
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "accessControl ");
	    _p_External(_g, &_data_ptr->accessControl);
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "synchronization ");
	    {
		ULONG_LONG value = _data_ptr->synchronization;
		_oss_prt_enum(_g, value, _ssd[3].sa, (int)_ssd[3].alen);
	    }
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "scope ");
	    _p_Scope(_g, &_data_ptr->scope);
	}
	if (_data_ptr->bit_mask & 0x10000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "filter ");
	    _p_CMISFilter(_g, &_data_ptr->filter);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "modificationList ");
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->modificationList) {
	    _setof8 * _tempa = _data_ptr->modificationList;
	    _setof8 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		{
		    short _comma = 0;

		    _oss_indent(_g, 1);
		    ossPrint(_g, "{");
		    if (_tempa->value.bit_mask & 0x80000000) {
			_oss_indent(_g, 0);
			ossPrint(_g, "modifyOperator ");
			{
			    LONG_LONG value = _tempa->value.modifyOperator;

			    ossPrint(_g, LLONG_FMT, value);
			}
			_comma = 1;
		    }
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "attributeId ");
		    _p_AttributeId(_g, &_tempa->value.attributeId);
		    if (_tempa->value.bit_mask & 0x40000000) {
			ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "attributeValue ");
			_oss_prt_new_opentype(_g, _tempa->value.attributeValue.pduNum, *(void **)&_tempa->value.attributeValue.decoded, &_tempa->value.attributeValue.encoded);
		    }
		    _oss_indent(_g, -1);
		    ossPrint(_g, "}");
		}
		_tempa = _tempb;
		if (_tempa)
		    ossPrint(_g, ",");
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pSetListError(OssGlobal * _g, void * _data)
{
    _SetListError	*_data_ptr;
    _data_ptr = (_SetListError *)_data;
    _p_SetListError(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pSetResult(OssGlobal * _g, void * _data)
{
    _CreateResult	*_data_ptr;
    _data_ptr = (_CreateResult *)_data;
    _p_SetResult(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pROSEapdus(OssGlobal * _g, void * _data)
{
    _ROSEapdus	*_data_ptr;
    _data_ptr = (_ROSEapdus *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "invoke : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.invoke == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    {
		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		_oss_indent(_g, 0);
		ossPrint(_g, "invokeId ");
		_p_InvokeId(_g, &_data_ptr->u.invoke->invokeId);
		if (_data_ptr->u.invoke->bit_mask & 0x80000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "linkedId ");
		    switch (_data_ptr->u.invoke->linkedId.choice) {
		    case 1:
			ossPrint(_g, "present : ");
			{
			    LONG_LONG value = _data_ptr->u.invoke->linkedId.u.present;

			    ossPrint(_g, LLONG_FMT, value);
			}
			break;
		    case 2:
			ossPrint(_g, "absent : ");
			ossPrint(_g, "NULL");
			break;
		    default:
			ossPrint(_g, "<unknown choice>");
		    }
		}
		ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "opcode ");
		_p_Code(_g, &_data_ptr->u.invoke->opcode);
		if (_data_ptr->u.invoke->bit_mask & 0x40000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "argument ");
		    _oss_prt_new_opentype(_g, _data_ptr->u.invoke->argument.pduNum, *(void **)&_data_ptr->u.invoke->argument.decoded, &_data_ptr->u.invoke->argument.encoded);
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	break;
    case 2:
	ossPrint(_g, "returnResult : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.returnResult == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    {
		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		_oss_indent(_g, 0);
		ossPrint(_g, "invokeId ");
		_p_InvokeId(_g, &_data_ptr->u.returnResult->invokeId);
		if (_data_ptr->u.returnResult->bit_mask & 0x80000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "result ");
		    {
			_oss_indent(_g, 1);
			ossPrint(_g, "{");
			_oss_indent(_g, 0);
			ossPrint(_g, "opcode ");
			_p_Code(_g, &_data_ptr->u.returnResult->result.opcode);
			ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "result ");
			_oss_prt_new_opentype(_g, _data_ptr->u.returnResult->result.result.pduNum, *(void **)&_data_ptr->u.returnResult->result.result.decoded, &_data_ptr->u.returnResult->result.result.encoded);
			_oss_indent(_g, -1);
			ossPrint(_g, "}");
		    }
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	break;
    case 3:
	ossPrint(_g, "returnError : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.returnError == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    {
		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		_oss_indent(_g, 0);
		ossPrint(_g, "invokeId ");
		_p_InvokeId(_g, &_data_ptr->u.returnError->invokeId);
		ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "errcode ");
		_p_Code(_g, &_data_ptr->u.returnError->errcode);
		if (_data_ptr->u.returnError->bit_mask & 0x80000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "parameter ");
		    _oss_prt_new_opentype(_g, _data_ptr->u.returnError->parameter.pduNum, *(void **)&_data_ptr->u.returnError->parameter.decoded, &_data_ptr->u.returnError->parameter.encoded);
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	break;
    case 4:
	ossPrint(_g, "reject : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.reject == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    {
		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		_oss_indent(_g, 0);
		ossPrint(_g, "invokeId ");
		_p_InvokeId(_g, &_data_ptr->u.reject->invokeId);
		ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "problem ");
		switch (_data_ptr->u.reject->problem.choice) {
		case 1:
		    ossPrint(_g, "general : ");
		    {
			LONG_LONG value = _data_ptr->u.reject->problem.u.general;

			ossPrint(_g, LLONG_FMT, value);
		    }
		    break;
		case 2:
		    ossPrint(_g, "invoke : ");
		    {
			LONG_LONG value = _data_ptr->u.reject->problem.u.invoke;

			ossPrint(_g, LLONG_FMT, value);
		    }
		    break;
		case 3:
		    ossPrint(_g, "returnResult : ");
		    {
			LONG_LONG value = _data_ptr->u.reject->problem.u.returnResult;

			ossPrint(_g, LLONG_FMT, value);
		    }
		    break;
		case 4:
		    ossPrint(_g, "returnError : ");
		    {
			LONG_LONG value = _data_ptr->u.reject->problem.u.returnError;

			ossPrint(_g, LLONG_FMT, value);
		    }
		    break;
		default:
		    ossPrint(_g, "<unknown choice>");
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

    return PDU_PRINTED;
}

static int _pCMIPAbortInfo(OssGlobal * _g, void * _data)
{
    _CMIPAbortInfo	*_data_ptr;
    _data_ptr = (_CMIPAbortInfo *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "abortSource ");
	{
	    ULONG_LONG value = _data_ptr->abortSource;
	    _oss_prt_enum(_g, value, _ssd[6].sa, (int)_ssd[6].alen);
	}
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "userInfo ");
	    _p_External(_g, &_data_ptr->userInfo);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pCMIPUserInfo(OssGlobal * _g, void * _data)
{
    _CMIPUserInfo	*_data_ptr;
    _data_ptr = (_CMIPUserInfo *)_data;
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "protocolVersion ");
	    _oss_prt_bit(_g, _data_ptr->protocolVersion.value, _data_ptr->protocolVersion.length);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "functionalUnits ");
	    _oss_prt_bit(_g, _data_ptr->functionalUnits.value, _data_ptr->functionalUnits.length);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "accessControl ");
	    _p_External(_g, &_data_ptr->accessControl);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x10000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "userInfo ");
	    _p_External(_g, &_data_ptr->userInfo);
	    _comma = 1;
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pCmipPduReceivingSupport(OssGlobal * _g, void * _data)
{
    OSSC::COssBitString	*_data_ptr;
    _data_ptr = (OSSC::COssBitString *)_data;
    _oss_prt_bit(_g, _data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pCmipPduSendingSupport(OssGlobal * _g, void * _data)
{
    OSSC::COssBitString	*_data_ptr;
    _data_ptr = (OSSC::COssBitString *)_data;
    _oss_prt_bit(_g, _data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pCmiseFunctionalUnitsSelected(OssGlobal * _g, void * _data)
{
    OSSC::COssBitString	*_data_ptr;
    _data_ptr = (OSSC::COssBitString *)_data;
    _oss_prt_bit(_g, _data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _p0CmiseFunctionalUnitsSupport(OssGlobal * _g, void * _data)
{
    OSSC::COssBitString	*_data_ptr;
    _data_ptr = (OSSC::COssBitString *)_data;
    _oss_prt_bit(_g, _data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pInvokeldsOutstanding(OssGlobal * _g, void * _data)
{
    _InvokeldsOutstanding	**_data_ptr;
    _data_ptr = (_InvokeldsOutstanding **)_data;
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_InvokeldsOutstanding * _tempa = *_data_ptr;
	_InvokeldsOutstanding * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_indent(_g, 0);
	    {
		LONG_LONG value = _tempa->value;

		ossPrint(_g, LLONG_FMT, value);
	    }
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

    return PDU_PRINTED;
}

static int _pInvokeIdsPerforming(OssGlobal * _g, void * _data)
{
    _InvokeldsOutstanding	**_data_ptr;
    _data_ptr = (_InvokeldsOutstanding **)_data;
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_InvokeldsOutstanding * _tempa = *_data_ptr;
	_InvokeldsOutstanding * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_indent(_g, 0);
	    {
		LONG_LONG value = _tempa->value;

		ossPrint(_g, LLONG_FMT, value);
	    }
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

    return PDU_PRINTED;
}

static int _pMaxEncodedCmipPduReceiveSize(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _pProtocolVersionSupported(OssGlobal * _g, void * _data)
{
    OSSC::COssBitString	*_data_ptr;
    _data_ptr = (OSSC::COssBitString *)_data;
    _oss_prt_bit(_g, _data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pSmaseFunctionalUnits(OssGlobal * _g, void * _data)
{
    _SmaseFunctionalUnits	**_data_ptr;
    _data_ptr = (_SmaseFunctionalUnits **)_data;
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_SmaseFunctionalUnits * _tempa = *_data_ptr;
	_SmaseFunctionalUnits * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _p_FunctionalUnitPackage(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

    return PDU_PRINTED;
}

static int _pSmUserInfoSent(OssGlobal * _g, void * _data)
{
    _SmUserInfoSent	*_data_ptr;
    _data_ptr = (_SmUserInfoSent *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "nothingSent : ");
	ossPrint(_g, "NULL");
	break;
    case 2:
	ossPrint(_g, "informationSent : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.informationSent.value, _data_ptr->u.informationSent.length);
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

    return PDU_PRINTED;
}

static int _pSmUserInfoReceived(OssGlobal * _g, void * _data)
{
    _SmUserInfoReceived	*_data_ptr;
    _data_ptr = (_SmUserInfoReceived *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "nothingReceived : ");
	ossPrint(_g, "NULL");
	break;
    case 2:
	ossPrint(_g, "informationReceived : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.informationReceived.value, _data_ptr->u.informationReceived.length);
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

    return PDU_PRINTED;
}

static int _pROSEInvokeIds(OssGlobal * _g, void * _data)
{
    _InvokeId	*_data_ptr;
    _data_ptr = (_InvokeId *)_data;
    _p_InvokeId(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pNoInvokeId(OssGlobal * _g, void * _data)
{
    _InvokeId	*_data_ptr;
    _data_ptr = (_InvokeId *)_data;
    _p_InvokeId(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pSMASEUserData(OssGlobal * _g, void * _data)
{
    _SMASEUserData	*_data_ptr;
    _data_ptr = (_SMASEUserData *)_data;
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "smfuPackages ");
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_data_ptr->smfuPackages) {
		_SmaseFunctionalUnits * _tempa = _data_ptr->smfuPackages;
		_SmaseFunctionalUnits * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    _p_FunctionalUnitPackage(_g, &_tempa->value);
		    _tempa = _tempb;
		    if (_tempa)
			ossPrint(_g, ",");
		}
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "reason ");
	    {
		LONG_LONG value = _data_ptr->reason;

		ossPrint(_g, LLONG_FMT, value);
	    }
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "systemsManagementUserInformation ");
	    _oss_prt_char(_g, (char *)_data_ptr->systemsManagementUserInformation.value, _data_ptr->systemsManagementUserInformation.length);
	    _comma = 1;
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pAccessDenied_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _p1ClassInstanceConflict_PRIOR(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _p2ComplexityLimitation_PRIORI(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _pInvalidScope_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _p3InvalidArgumentValue_PRIORI(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _pInvalidFilter_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _pNoSuchAction_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _pNoSuchArgument_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _pNoSuchObjectClass_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _p4NoSuchObjectInstance_PRIORI(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _pProcessingFailure_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _pSyncNotSupported_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _pMistypedOperation_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _pNoSuchInvokeId_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _p5DuplicateManagedObjectInsta(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _p6InvalidAttributeValue_PRIOR(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _p7InvalidObjectInstance_PRIOR(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _p8MissingAttributeValue_PARAM(OssGlobal * _g, void * _data)
{
    _MissingAttributeValue_PARAMETER	**_data_ptr;
    _data_ptr = (_MissingAttributeValue_PARAMETER **)_data;
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_MissingAttributeValue_PARAMETER * _tempa = *_data_ptr;
	_MissingAttributeValue_PARAMETER * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_indent(_g, 0);
	    _p_AttributeId(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

    return PDU_PRINTED;
}

static int _p9MissingAttributeValue_PRIOR(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _pNoSuchAttribute_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _p10NoSuchReferenceObject_PRIO(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _pNoSuchEventType_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _pGetListError_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _pOperationCancelled_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _pSetListError_PRIORITY(OssGlobal * _g, void * _data)
{
    OSS_UINT32	*_data_ptr;
    _data_ptr = (OSS_UINT32 *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	ossPrint(_g, ULLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _pAcse_RealizationParameter(OssGlobal * _g, void * _data)
{
    _RealizationParameter	*_data_ptr;
    _data_ptr = (_RealizationParameter *)_data;
    _p_RealizationParameter(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _p11Acse_with_concatenation_Re(OssGlobal * _g, void * _data)
{
    _RealizationParameter	*_data_ptr;
    _data_ptr = (_RealizationParameter *)_data;
    _p_RealizationParameter(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _p12Association_by_RTSE_Realiz(OssGlobal * _g, void * _data)
{
    _RealizationParameter	*_data_ptr;
    _data_ptr = (_RealizationParameter *)_data;
    _p_RealizationParameter(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pPData_RealizationParameter(OssGlobal * _g, void * _data)
{
    _RealizationParameter	*_data_ptr;
    _data_ptr = (_RealizationParameter *)_data;
    _p_RealizationParameter(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _p13PData_with_concatenation_R(OssGlobal * _g, void * _data)
{
    _RealizationParameter	*_data_ptr;
    _data_ptr = (_RealizationParameter *)_data;
    _p_RealizationParameter(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _p14Transfer_by_RTSE_Realizati(OssGlobal * _g, void * _data)
{
    _RealizationParameter	*_data_ptr;
    _data_ptr = (_RealizationParameter *)_data;
    _p_RealizationParameter(_g, _data_ptr);

    return PDU_PRINTED;
}

int DLL_ENTRY_FDEF _pmSMASE_A_ASSOCIATE_Informatio(struct ossGlobal * _g, int _pdunum, void * _data)
{
    int _rc = _pdunum < 0;

    if (_rc)
	_pdunum = -_pdunum;
    if (_pdunum < 1 || _pdunum > 78 || !_PrintPDU[_pdunum - 1]._pf)
	return PDU_RANGE;
    else {
	if (_rc) {
	    ossPrint(_g, "%s : ", _PrintPDU[_pdunum - 1]._name);
	    _rc = _PrintPDU[_pdunum - 1]._pf(_g, _data);
	} else {
	    ossPrint(_g, "value %s ::= ", _PrintPDU[_pdunum - 1]._name);
	    _rc = _PrintPDU[_pdunum - 1]._pf(_g, _data);
	    ossPrint(_g, "\n");
	}
    }

    return _rc;
}

#endif

static int _cmAttribute(OssGlobal * _g, _Attribute  * _odata, _Attribute  * _cdata)
{
    int _res = 0;

    _res = _cmAttributeId(_g, &((*_odata).id), &((*_cdata).id));
    if (_res)
	return _res;
    _res = _oss_cmp_new_open_type(_g, ((*_odata).value).pduNum, ((*_cdata).value).pduNum, &(((*_odata).value).encoded), &(((*_cdata).value).encoded), *(void **)&(((*_odata).value).decoded), *(void **)&(((*_cdata).value).decoded));
    if (_res)
	return _res;

    return _res;
}

static int _cmAttributeId(OssGlobal * _g, _ActionTypeId  * _odata, _ActionTypeId  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    if (!((*_cdata).u.globalForm).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*_odata).u.globalForm), &((*_cdata).u.globalForm), sizeof(((*_cdata).u.globalForm).length), sizeof(((*_cdata).u.globalForm).value[0]), (unsigned int)((char *)&((*_odata).u.globalForm).value - (char *)&((*_odata).u.globalForm))))
		return 1;
	}   break;
	case 2: {
	    if ((*_cdata).u.localForm != (*_odata).u.localForm)
		return 1;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}

static int _cmCMISFilter(OssGlobal * _g, _CMISFilter  * _odata, _CMISFilter  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    _res = _cmFilterItem(_g, (*_odata).u.item, (*_cdata).u.item);
	    if (_res)
		return _res;
	}   break;
	case 2: {
	    _res = _cm_setof1(_g, &((*_odata).u.CMISFilter_and), &((*_cdata).u.CMISFilter_and));
	    if (_res)
		return _res;
	}   break;
	case 3: {
	    _res = _cm_setof2(_g, &((*_odata).u.CMISFilter_or), &((*_cdata).u.CMISFilter_or));
	    if (_res)
		return _res;
	}   break;
	case 4: {
	    _res = _cmCMISFilter(_g, (*_odata).u.CMISFilter_not, (*_cdata).u.CMISFilter_not);
	    if (_res)
		return _res;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}

static int _nDCMISFilter(OssGlobal * _g, _CMISFilter  * _odata, _CMISFilter  * _cdata)
{
    int _res = _cmCMISFilter(_g, _odata, _cdata);

    if (_res == -1)
	_oss_enc_error(_g, _type_not_supported_der_toed, 0);
    return _res;
}

static int _cmScope(OssGlobal * _g, _Scope  * _odata, _Scope  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    if ((*_cdata).u.namedNumbers != (*_odata).u.namedNumbers)
		return 1;
	}   break;
	case 2: {
	    if ((*_cdata).u.individualLevels != (*_odata).u.individualLevels)
		return 1;
	}   break;
	case 3: {
	    if ((*_cdata).u.baseToNthLevel != (*_odata).u.baseToNthLevel)
		return 1;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}

static int _nDScope(OssGlobal * _g, _Scope  * _odata, _Scope  * _cdata)
{
    int _res = _cmScope(_g, _odata, _cdata);

    if (_res == -1)
	_oss_enc_error(_g, _type_not_supported_der_toed, 0);
    return _res;
}

static int _cm_setof2(OssGlobal * _g, _setof1 * * _odata, _setof1 * * _cdata)
{
    int _res = 0;

    {
	_setof1 *  _s_1 = *_odata;
	_setof1 *  _d_1 = *_cdata;
	long        *_a, _i, _i_next, _c = 0L;

	while (_s_1 && _d_1) {
	    ++ _c;
	    _s_1 = _s_1->next;
	    _d_1 = _d_1->next;
	}
	if (_s_1 || _d_1)
	    return 1;
	if (_c) {
	    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
	    for (_i = 0; _i < _c; _i ++)
		_a[_i] = _i;
	    _a[_c] = -1L;
	    for (_s_1 = *_odata; _s_1; _s_1 = _s_1->next) {
		_i_next = _a[0]; _res = 1;
		for (_d_1 = *_cdata, _i = 0L; _d_1 && _i_next >= 0L && _a[_i_next] >= 0L; _d_1 = _d_1->next,
			_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
		    if (_i < _i_next)
			continue;
		    _res = _cmCMISFilter(_g, &(_s_1->value), &(_d_1->value));
		    if (_res)
			continue;
		    _res = 0; _a[_i] = _a[_i+1];
		    break;
		}
		if (_res)
		    break;
	    }
	    _oss_dec_freetempmem(_g, _a);
	    if (_res)
		return _res;
	}
    }

    return _res;
}

static int _cm_setof1(OssGlobal * _g, _setof1 * * _odata, _setof1 * * _cdata)
{
    int _res = 0;

    {
	_setof1 *  _s_1 = *_odata;
	_setof1 *  _d_1 = *_cdata;
	long        *_a, _i, _i_next, _c = 0L;

	while (_s_1 && _d_1) {
	    ++ _c;
	    _s_1 = _s_1->next;
	    _d_1 = _d_1->next;
	}
	if (_s_1 || _d_1)
	    return 1;
	if (_c) {
	    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
	    for (_i = 0; _i < _c; _i ++)
		_a[_i] = _i;
	    _a[_c] = -1L;
	    for (_s_1 = *_odata; _s_1; _s_1 = _s_1->next) {
		_i_next = _a[0]; _res = 1;
		for (_d_1 = *_cdata, _i = 0L; _d_1 && _i_next >= 0L && _a[_i_next] >= 0L; _d_1 = _d_1->next,
			_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
		    if (_i < _i_next)
			continue;
		    _res = _cmCMISFilter(_g, &(_s_1->value), &(_d_1->value));
		    if (_res)
			continue;
		    _res = 0; _a[_i] = _a[_i+1];
		    break;
		}
		if (_res)
		    break;
	    }
	    _oss_dec_freetempmem(_g, _a);
	    if (_res)
		return _res;
	}
    }

    return _res;
}

static int _cm_seqof1(OssGlobal * _g, _seqof1 * * _odata, _seqof1 * * _cdata)
{
    int _res = 0;

    {
	_seqof1 *  _s_oss_tmp_1 = *_odata;
	_seqof1 *  _d_oss_tmp_1 = *_cdata;

	while (_s_oss_tmp_1 && _d_oss_tmp_1) {
	    if ((_s_oss_tmp_1->value).choice != (_d_oss_tmp_1->value).choice)
		return 1;
	    switch ((_s_oss_tmp_1->value).choice) {
		case 1: {
		    _res = _cmAttribute(_g, (_s_oss_tmp_1->value).u.initialString, (_d_oss_tmp_1->value).u.initialString);
		    if (_res)
			return _res;
		}   break;
		case 2: {
		    _res = _cmAttribute(_g, (_s_oss_tmp_1->value).u.anyString, (_d_oss_tmp_1->value).u.anyString);
		    if (_res)
			return _res;
		}   break;
		case 3: {
		    _res = _cmAttribute(_g, (_s_oss_tmp_1->value).u.finalString, (_d_oss_tmp_1->value).u.finalString);
		    if (_res)
			return _res;
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	    _s_oss_tmp_1 = _s_oss_tmp_1->next;
	    _d_oss_tmp_1 = _d_oss_tmp_1->next;
	}
	if (_s_oss_tmp_1 || _d_oss_tmp_1)
	    return 1;
    }

    return _res;
}

static int _cmFilterItem(OssGlobal * _g, _FilterItem  * _odata, _FilterItem  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    _res = _cmAttribute(_g, (*_odata).u.equality, (*_cdata).u.equality);
	    if (_res)
		return _res;
	}   break;
	case 2: {
	    _res = _cm_seqof1(_g, &((*_odata).u.substrings), &((*_cdata).u.substrings));
	    if (_res)
		return _res;
	}   break;
	case 3: {
	    _res = _cmAttribute(_g, (*_odata).u.greaterOrEqual, (*_cdata).u.greaterOrEqual);
	    if (_res)
		return _res;
	}   break;
	case 4: {
	    _res = _cmAttribute(_g, (*_odata).u.lessOrEqual, (*_cdata).u.lessOrEqual);
	    if (_res)
		return _res;
	}   break;
	case 5: {
	    _res = _cmAttributeId(_g, (*_odata).u.present, (*_cdata).u.present);
	    if (_res)
		return _res;
	}   break;
	case 6: {
	    _res = _cmAttribute(_g, (*_odata).u.subsetOf, (*_cdata).u.subsetOf);
	    if (_res)
		return _res;
	}   break;
	case 7: {
	    _res = _cmAttribute(_g, (*_odata).u.supersetOf, (*_cdata).u.supersetOf);
	    if (_res)
		return _res;
	}   break;
	case 8: {
	    _res = _cmAttribute(_g, (*_odata).u.nonNullSetIntersection, (*_cdata).u.nonNullSetIntersection);
	    if (_res)
		return _res;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}

#ifdef OSS_COPY_VALUE
#define _oss_c ((_EncDecGlobals*)_g->encDecVar)

static _ActionResult  * _cpActionResult(OssGlobal * _g, _ActionResult  * psVal, _ActionResult  * pdVal)
{
    if (!pdVal) {
	pdVal = (_ActionResult  *)_oss_dec_const_alloc(_g, sizeof(_ActionResult ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    if ((*psVal).bit_mask & 0x80000000) {
	_cpObjectClass(_g, &((*psVal).managedObjectClass), &((*pdVal).managedObjectClass));
    }
    if ((*psVal).bit_mask & 0x40000000) {
	_cpObjectInstance(_g, &((*psVal).managedObjectInstance), &((*pdVal).managedObjectInstance));
    }
    if ((*psVal).currentTime) {
	size_t  len_1 = (size_t)sizeof(char) * (strlen((*psVal).currentTime) + 1);

	(*pdVal).currentTime = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
	strcpy((*pdVal).currentTime, (*psVal).currentTime);
    }
    if ((*psVal).bit_mask & 0x20000000) {
	_cpActionReply(_g, &((*psVal).actionReply), &((*pdVal).actionReply));
    }
    return pdVal;
}


static _Attribute  * _cpAttribute(OssGlobal * _g, _Attribute  * psVal, _Attribute  * pdVal)
{
    if (!pdVal) {
	pdVal = (_Attribute  *)_oss_dec_const_alloc(_g, sizeof(_Attribute ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    {
	_cpAttributeId(_g, &((*psVal).id), &((*pdVal).id));
    }
    {
	int         _pduNum = ((*psVal).value).pduNum;
	_oss_cpy_new_open_type(_g, &_pduNum, &((*psVal).value).encoded, &((*pdVal).value).encoded, *(void **)&((*psVal).value).decoded, (void **)&((*pdVal).value).decoded);
	((*pdVal).value).pduNum = _pduNum;
    }
    return pdVal;
}


static _ActionTypeId  * _cpAttributeId(OssGlobal * _g, _ActionTypeId  * psVal, _ActionTypeId  * pdVal)
{
    if (!pdVal) {
	pdVal = (_ActionTypeId  *)_oss_dec_const_alloc(_g, sizeof(_ActionTypeId ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 1: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.globalForm), &((*pdVal).u.globalForm), sizeof(((*pdVal).u.globalForm).length), sizeof(((*pdVal).u.globalForm).value[0]), (unsigned int)((char *)&((*psVal).u.globalForm).value - (char *)&((*psVal).u.globalForm)));
	}   break;
	default:;
    }
    return pdVal;
}


static _CMISFilter  * _cpCMISFilter(OssGlobal * _g, _CMISFilter  * psVal, _CMISFilter  * pdVal)
{
    if (!pdVal) {
	pdVal = (_CMISFilter  *)_oss_dec_const_alloc(_g, sizeof(_CMISFilter ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 1: {
	    (*pdVal).u.item = NULL;
	    (*pdVal).u.item = _cpFilterItem(_g, (*psVal).u.item, (*pdVal).u.item);
	}   break;
	case 2: {
	    _cp_setof1(_g, &((*psVal).u.CMISFilter_and), &((*pdVal).u.CMISFilter_and));
	}   break;
	case 3: {
	    _cp_setof2(_g, &((*psVal).u.CMISFilter_or), &((*pdVal).u.CMISFilter_or));
	}   break;
	case 4: {
	    (*pdVal).u.CMISFilter_not = NULL;
	    (*pdVal).u.CMISFilter_not = _cpCMISFilter(_g, (*psVal).u.CMISFilter_not, (*pdVal).u.CMISFilter_not);
	}   break;
	default:;
    }
    return pdVal;
}


static _DeleteResult  * _cpDeleteResult(OssGlobal * _g, _DeleteResult  * psVal, _DeleteResult  * pdVal)
{
    if (!pdVal) {
	pdVal = (_DeleteResult  *)_oss_dec_const_alloc(_g, sizeof(_DeleteResult ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    if ((*psVal).bit_mask & 0x80000000) {
	_cpObjectClass(_g, &((*psVal).managedObjectClass), &((*pdVal).managedObjectClass));
    }
    if ((*psVal).bit_mask & 0x40000000) {
	_cpObjectInstance(_g, &((*psVal).managedObjectInstance), &((*pdVal).managedObjectInstance));
    }
    if ((*psVal).currentTime) {
	size_t  len_1 = (size_t)sizeof(char) * (strlen((*psVal).currentTime) + 1);

	(*pdVal).currentTime = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
	strcpy((*pdVal).currentTime, (*psVal).currentTime);
    }
    return pdVal;
}


static _GetListError  * _cpGetListError(OssGlobal * _g, _GetListError  * psVal, _GetListError  * pdVal)
{
    if (!pdVal) {
	pdVal = (_GetListError  *)_oss_dec_const_alloc(_g, sizeof(_GetListError ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    if ((*psVal).bit_mask & 0x80000000) {
	_cpObjectClass(_g, &((*psVal).managedObjectClass), &((*pdVal).managedObjectClass));
    }
    if ((*psVal).bit_mask & 0x40000000) {
	_cpObjectInstance(_g, &((*psVal).managedObjectInstance), &((*pdVal).managedObjectInstance));
    }
    if ((*psVal).currentTime) {
	size_t  len_1 = (size_t)sizeof(char) * (strlen((*psVal).currentTime) + 1);

	(*pdVal).currentTime = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
	strcpy((*pdVal).currentTime, (*psVal).currentTime);
    }
    {
	_cp_setof6(_g, &((*psVal).getInfoList), &((*pdVal).getInfoList));
    }
    return pdVal;
}


static _CreateResult  * _cpGetResult(OssGlobal * _g, _CreateResult  * psVal, _CreateResult  * pdVal)
{
    if (!pdVal) {
	pdVal = (_CreateResult  *)_oss_dec_const_alloc(_g, sizeof(_CreateResult ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    if ((*psVal).bit_mask & 0x80000000) {
	_cpObjectClass(_g, &((*psVal).managedObjectClass), &((*pdVal).managedObjectClass));
    }
    if ((*psVal).bit_mask & 0x40000000) {
	_cpObjectInstance(_g, &((*psVal).managedObjectInstance), &((*pdVal).managedObjectInstance));
    }
    if ((*psVal).currentTime) {
	size_t  len_1 = (size_t)sizeof(char) * (strlen((*psVal).currentTime) + 1);

	(*pdVal).currentTime = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
	strcpy((*pdVal).currentTime, (*psVal).currentTime);
    }
    if ((*psVal).bit_mask & 0x20000000) {
	_cp_setof7(_g, &((*psVal).attributeList), &((*pdVal).attributeList));
    }
    return pdVal;
}


static _InvalidArgumentValue  * _cpInvalidArgumentValue(OssGlobal * _g, _InvalidArgumentValue  * psVal, _InvalidArgumentValue  * pdVal)
{
    if (!pdVal) {
	pdVal = (_InvalidArgumentValue  *)_oss_dec_const_alloc(_g, sizeof(_InvalidArgumentValue ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 1: {
	    (*pdVal).u.actionValue = NULL;
	    (*pdVal).u.actionValue = _cpActionInfo(_g, (*psVal).u.actionValue, (*pdVal).u.actionValue);
	}   break;
	case 2: {
	    _cp_seq1(_g, &((*psVal).u.eventValue), &((*pdVal).u.eventValue));
	}   break;
	default:;
    }
    return pdVal;
}


static _NoSuchArgument  * _cpNoSuchArgument(OssGlobal * _g, _NoSuchArgument  * psVal, _NoSuchArgument  * pdVal)
{
    if (!pdVal) {
	pdVal = (_NoSuchArgument  *)_oss_dec_const_alloc(_g, sizeof(_NoSuchArgument ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 1: {
	    (*pdVal).u.actionId = (_seq2 *)_oss_dec_const_alloc(_g, sizeof(*((*pdVal).u.actionId)));
	    memcpy((*pdVal).u.actionId, (*psVal).u.actionId, sizeof(*(*pdVal).u.actionId));
	    if (((*psVal).u.actionId)->bit_mask & 0x80000000) {
		_cpObjectClass(_g, &(((*psVal).u.actionId)->managedObjectClass), &(((*pdVal).u.actionId)->managedObjectClass));
	    }
	    {
		_cpActionTypeId(_g, &(((*psVal).u.actionId)->actionType), &(((*pdVal).u.actionId)->actionType));
	    }
	}   break;
	case 2: {
	    (*pdVal).u.eventId = (_seq3 *)_oss_dec_const_alloc(_g, sizeof(*((*pdVal).u.eventId)));
	    memcpy((*pdVal).u.eventId, (*psVal).u.eventId, sizeof(*(*pdVal).u.eventId));
	    if (((*psVal).u.eventId)->bit_mask & 0x80000000) {
		_cpObjectClass(_g, &(((*psVal).u.eventId)->managedObjectClass), &(((*pdVal).u.eventId)->managedObjectClass));
	    }
	    {
		_cpEventTypeId(_g, &(((*psVal).u.eventId)->eventType), &(((*pdVal).u.eventId)->eventType));
	    }
	}   break;
	default:;
    }
    return pdVal;
}


static _ActionTypeId  * _cpObjectClass(OssGlobal * _g, _ActionTypeId  * psVal, _ActionTypeId  * pdVal)
{
    if (!pdVal) {
	pdVal = (_ActionTypeId  *)_oss_dec_const_alloc(_g, sizeof(_ActionTypeId ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 1: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.globalForm), &((*pdVal).u.globalForm), sizeof(((*pdVal).u.globalForm).length), sizeof(((*pdVal).u.globalForm).value[0]), (unsigned int)((char *)&((*psVal).u.globalForm).value - (char *)&((*psVal).u.globalForm)));
	}   break;
	default:;
    }
    return pdVal;
}


static _ObjectInstance  * _cpObjectInstance(OssGlobal * _g, _ObjectInstance  * psVal, _ObjectInstance  * pdVal)
{
    if (!pdVal) {
	pdVal = (_ObjectInstance  *)_oss_dec_const_alloc(_g, sizeof(_ObjectInstance ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 1: {
	    _cpRDNSequence(_g, &((*psVal).u.distinguishedName), &((*pdVal).u.distinguishedName));
	}   break;
	case 2: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.nonSpecificForm), &((*pdVal).u.nonSpecificForm), sizeof(((*pdVal).u.nonSpecificForm).length), sizeof(((*pdVal).u.nonSpecificForm).value[0]), (unsigned int)((char *)&((*psVal).u.nonSpecificForm).value - (char *)&((*psVal).u.nonSpecificForm)));
	}   break;
	case 3: {
	    _cpRDNSequence(_g, &((*psVal).u.localDistinguishedName), &((*pdVal).u.localDistinguishedName));
	}   break;
	default:;
    }
    return pdVal;
}


static _ProcessingFailure  * _cpProcessingFailure(OssGlobal * _g, _ProcessingFailure  * psVal, _ProcessingFailure  * pdVal)
{
    if (!pdVal) {
	pdVal = (_ProcessingFailure  *)_oss_dec_const_alloc(_g, sizeof(_ProcessingFailure ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    {
	_cpObjectClass(_g, &((*psVal).managedObjectClass), &((*pdVal).managedObjectClass));
    }
    if ((*psVal).bit_mask & 0x80000000) {
	_cpObjectInstance(_g, &((*psVal).managedObjectInstance), &((*pdVal).managedObjectInstance));
    }
    {
	{
	    _oss_cpy_unbnd_octet_ia(_g, &(((*psVal).specificErrorInfo).errorId), &(((*pdVal).specificErrorInfo).errorId), sizeof((((*pdVal).specificErrorInfo).errorId).length), sizeof((((*pdVal).specificErrorInfo).errorId).value[0]), (unsigned int)((char *)&(((*psVal).specificErrorInfo).errorId).value - (char *)&(((*psVal).specificErrorInfo).errorId)));
	}
	{
	    int         _pduNum = (((*psVal).specificErrorInfo).errorInfo).pduNum;
	    _oss_cpy_new_open_type(_g, &_pduNum, &(((*psVal).specificErrorInfo).errorInfo).encoded, &(((*pdVal).specificErrorInfo).errorInfo).encoded, *(void **)&(((*psVal).specificErrorInfo).errorInfo).decoded, (void **)&(((*pdVal).specificErrorInfo).errorInfo).decoded);
	    (((*pdVal).specificErrorInfo).errorInfo).pduNum = _pduNum;
	}
    }
    return pdVal;
}


static _SetListError  * _cpSetListError(OssGlobal * _g, _SetListError  * psVal, _SetListError  * pdVal)
{
    if (!pdVal) {
	pdVal = (_SetListError  *)_oss_dec_const_alloc(_g, sizeof(_SetListError ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    if ((*psVal).bit_mask & 0x80000000) {
	_cpObjectClass(_g, &((*psVal).managedObjectClass), &((*pdVal).managedObjectClass));
    }
    if ((*psVal).bit_mask & 0x40000000) {
	_cpObjectInstance(_g, &((*psVal).managedObjectInstance), &((*pdVal).managedObjectInstance));
    }
    if ((*psVal).currentTime) {
	size_t  len_1 = (size_t)sizeof(char) * (strlen((*psVal).currentTime) + 1);

	(*pdVal).currentTime = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
	strcpy((*pdVal).currentTime, (*psVal).currentTime);
    }
    {
	(*pdVal).setInfoList = NULL;
	if ((*psVal).setInfoList) {
	    _setof9 *  s_oss_tmp_2 = (*psVal).setInfoList;
	    _setof9 *  d_oss_tmp_2;

	    (*pdVal).setInfoList = d_oss_tmp_2 = (_setof9 *)_oss_dec_getmem_internal(_g, sizeof(_setof9));
	    do {
		memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_setof9));
		{
		    switch ((s_oss_tmp_2->value).choice) {
			case 1: {
			    (d_oss_tmp_2->value).u.attributeError = (_AttributeError  *)_oss_dec_const_alloc(_g, sizeof(_AttributeError ));
			    memcpy((d_oss_tmp_2->value).u.attributeError, (s_oss_tmp_2->value).u.attributeError, sizeof(*(d_oss_tmp_2->value).u.attributeError));
			    {
				_cpAttributeId(_g, &((*(s_oss_tmp_2->value).u.attributeError).attributeId), &((*(d_oss_tmp_2->value).u.attributeError).attributeId));
			    }
			    if ((*(s_oss_tmp_2->value).u.attributeError).bit_mask & 0x40000000) {
				int         _pduNum = ((*(s_oss_tmp_2->value).u.attributeError).attributeValue).pduNum;
				_oss_cpy_new_open_type(_g, &_pduNum, &((*(s_oss_tmp_2->value).u.attributeError).attributeValue).encoded, &((*(d_oss_tmp_2->value).u.attributeError).attributeValue).encoded, *(void **)&((*(s_oss_tmp_2->value).u.attributeError).attributeValue).decoded, (void **)&((*(d_oss_tmp_2->value).u.attributeError).attributeValue).decoded);
				((*(d_oss_tmp_2->value).u.attributeError).attributeValue).pduNum = _pduNum;
			    }
			}   break;
			case 2: {
			    (d_oss_tmp_2->value).u.attribute = NULL;
			    (d_oss_tmp_2->value).u.attribute = _cpAttribute(_g, (s_oss_tmp_2->value).u.attribute, (d_oss_tmp_2->value).u.attribute);
			}   break;
			default:;
		    }
		}
		if (s_oss_tmp_2->next)
		    d_oss_tmp_2->next = (_setof9 *)_oss_dec_getmem_internal(_g, sizeof(_setof9));
		s_oss_tmp_2 = s_oss_tmp_2->next;
		d_oss_tmp_2 = d_oss_tmp_2->next;
	    } while (s_oss_tmp_2);
	}
    }
    return pdVal;
}


static _CreateResult  * _cpSetResult(OssGlobal * _g, _CreateResult  * psVal, _CreateResult  * pdVal)
{
    if (!pdVal) {
	pdVal = (_CreateResult  *)_oss_dec_const_alloc(_g, sizeof(_CreateResult ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    if ((*psVal).bit_mask & 0x80000000) {
	_cpObjectClass(_g, &((*psVal).managedObjectClass), &((*pdVal).managedObjectClass));
    }
    if ((*psVal).bit_mask & 0x40000000) {
	_cpObjectInstance(_g, &((*psVal).managedObjectInstance), &((*pdVal).managedObjectInstance));
    }
    if ((*psVal).currentTime) {
	size_t  len_1 = (size_t)sizeof(char) * (strlen((*psVal).currentTime) + 1);

	(*pdVal).currentTime = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
	strcpy((*pdVal).currentTime, (*psVal).currentTime);
    }
    if ((*psVal).bit_mask & 0x20000000) {
	(*pdVal).attributeList = NULL;
	if ((*psVal).attributeList) {
	    _setof3 *  s_oss_tmp_2 = (*psVal).attributeList;
	    _setof3 *  d_oss_tmp_2;

	    (*pdVal).attributeList = d_oss_tmp_2 = (_setof3 *)_oss_dec_getmem_internal(_g, sizeof(_setof3));
	    do {
		memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_setof3));
		{
		    _cpAttribute(_g, &(s_oss_tmp_2->value), &(d_oss_tmp_2->value));
		}
		if (s_oss_tmp_2->next)
		    d_oss_tmp_2->next = (_setof3 *)_oss_dec_getmem_internal(_g, sizeof(_setof3));
		s_oss_tmp_2 = s_oss_tmp_2->next;
		d_oss_tmp_2 = d_oss_tmp_2->next;
	    } while (s_oss_tmp_2);
	}
    }
    return pdVal;
}


static _choice1  * _cp_choice1(OssGlobal * _g, _choice1  * psVal, _choice1  * pdVal)
{
    if (!pdVal) {
	pdVal = (_choice1  *)_oss_dec_const_alloc(_g, sizeof(_choice1 ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 1: {
	    _oss_cpy_open_type(_g, (OpenType *)&((*psVal).u.single_ASN1_type), (OpenType *)&((*pdVal).u.single_ASN1_type));
	}   break;
	case 2: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.octet_aligned), &((*pdVal).u.octet_aligned), sizeof(((*pdVal).u.octet_aligned).length), sizeof(((*pdVal).u.octet_aligned).value[0]), (unsigned int)((char *)&((*psVal).u.octet_aligned).value - (char *)&((*psVal).u.octet_aligned)));
	}   break;
	case 3: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.arbitrary), &((*pdVal).u.arbitrary), sizeof(((*pdVal).u.arbitrary).length), -1L, (unsigned int)((char *)&((*psVal).u.arbitrary).value - (char *)&((*psVal).u.arbitrary)));
	}   break;
	default:;
    }
    return pdVal;
}


static _External  * _cpExternal(OssGlobal * _g, _External  * psVal, _External  * pdVal)
{
    if (!pdVal) {
	pdVal = (_External  *)_oss_dec_const_alloc(_g, sizeof(_External ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    if ((*psVal).bit_mask & 0x80000000) {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).direct_reference), &((*pdVal).direct_reference), sizeof(((*pdVal).direct_reference).length), sizeof(((*pdVal).direct_reference).value[0]), (unsigned int)((char *)&((*psVal).direct_reference).value - (char *)&((*psVal).direct_reference)));
    }
    if ((*psVal).bit_mask & 0x20000000) {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).data_value_descriptor), &((*pdVal).data_value_descriptor), sizeof(((*pdVal).data_value_descriptor).length), sizeof(((*pdVal).data_value_descriptor).value[0]), (unsigned int)((char *)&((*psVal).data_value_descriptor).value - (char *)&((*psVal).data_value_descriptor)));
    }
    {
	_cp_choice1(_g, &((*psVal).encoding), &((*pdVal).encoding));
    }
    return pdVal;
}


static _ActionTypeId  * _cpActionTypeId(OssGlobal * _g, _ActionTypeId  * psVal, _ActionTypeId  * pdVal)
{
    if (!pdVal) {
	pdVal = (_ActionTypeId  *)_oss_dec_const_alloc(_g, sizeof(_ActionTypeId ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 1: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.globalForm), &((*pdVal).u.globalForm), sizeof(((*pdVal).u.globalForm).length), sizeof(((*pdVal).u.globalForm).value[0]), (unsigned int)((char *)&((*psVal).u.globalForm).value - (char *)&((*psVal).u.globalForm)));
	}   break;
	default:;
    }
    return pdVal;
}


static _ActionTypeId  * _cpEventTypeId(OssGlobal * _g, _ActionTypeId  * psVal, _ActionTypeId  * pdVal)
{
    if (!pdVal) {
	pdVal = (_ActionTypeId  *)_oss_dec_const_alloc(_g, sizeof(_ActionTypeId ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 1: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.globalForm), &((*pdVal).u.globalForm), sizeof(((*pdVal).u.globalForm).length), sizeof(((*pdVal).u.globalForm).value[0]), (unsigned int)((char *)&((*psVal).u.globalForm).value - (char *)&((*psVal).u.globalForm)));
	}   break;
	default:;
    }
    return pdVal;
}


static _setof1 * * _cp_setof2(OssGlobal * _g, _setof1 * * psVal, _setof1 * * pdVal)
{
    if (!pdVal) {
	pdVal = (_setof1 * *)_oss_dec_const_alloc(_g, sizeof(_setof1 *));
    }
    *pdVal = NULL;
    if (*psVal) {
	_setof1 *  s_oss_tmp_1 = *psVal;
	_setof1 *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_setof1 *)_oss_dec_getmem_internal(_g, sizeof(_setof1));
	do {
	    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_setof1));
	    {
		_cpCMISFilter(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_setof1 *)_oss_dec_getmem_internal(_g, sizeof(_setof1));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _setof1 * * _cp_setof1(OssGlobal * _g, _setof1 * * psVal, _setof1 * * pdVal)
{
    if (!pdVal) {
	pdVal = (_setof1 * *)_oss_dec_const_alloc(_g, sizeof(_setof1 *));
    }
    *pdVal = NULL;
    if (*psVal) {
	_setof1 *  s_oss_tmp_1 = *psVal;
	_setof1 *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_setof1 *)_oss_dec_getmem_internal(_g, sizeof(_setof1));
	do {
	    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_setof1));
	    {
		_cpCMISFilter(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_setof1 *)_oss_dec_getmem_internal(_g, sizeof(_setof1));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _ActionInfo  * _cpActionInfo(OssGlobal * _g, _ActionInfo  * psVal, _ActionInfo  * pdVal)
{
    if (!pdVal) {
	pdVal = (_ActionInfo  *)_oss_dec_const_alloc(_g, sizeof(_ActionInfo ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    {
	_cpActionTypeId(_g, &((*psVal).actionType), &((*pdVal).actionType));
    }
    if ((*psVal).bit_mask & 0x80000000) {
	int         _pduNum = ((*psVal).actionInfoArg).pduNum;
	_oss_cpy_new_open_type(_g, &_pduNum, &((*psVal).actionInfoArg).encoded, &((*pdVal).actionInfoArg).encoded, *(void **)&((*psVal).actionInfoArg).decoded, (void **)&((*pdVal).actionInfoArg).decoded);
	((*pdVal).actionInfoArg).pduNum = _pduNum;
    }
    return pdVal;
}


static _ActionReply  * _cpActionReply(OssGlobal * _g, _ActionReply  * psVal, _ActionReply  * pdVal)
{
    if (!pdVal) {
	pdVal = (_ActionReply  *)_oss_dec_const_alloc(_g, sizeof(_ActionReply ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    {
	_cpActionTypeId(_g, &((*psVal).actionType), &((*pdVal).actionType));
    }
    {
	int         _pduNum = ((*psVal).actionReplyInfo).pduNum;
	_oss_cpy_new_open_type(_g, &_pduNum, &((*psVal).actionReplyInfo).encoded, &((*pdVal).actionReplyInfo).encoded, *(void **)&((*psVal).actionReplyInfo).decoded, (void **)&((*pdVal).actionReplyInfo).decoded);
	((*pdVal).actionReplyInfo).pduNum = _pduNum;
    }
    return pdVal;
}


static _seqof1 * * _cp_seqof1(OssGlobal * _g, _seqof1 * * psVal, _seqof1 * * pdVal)
{
    if (!pdVal) {
	pdVal = (_seqof1 * *)_oss_dec_const_alloc(_g, sizeof(_seqof1 *));
    }
    *pdVal = NULL;
    if (*psVal) {
	_seqof1 *  s_oss_tmp_1 = *psVal;
	_seqof1 *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_seqof1 *)_oss_dec_getmem_internal(_g, sizeof(_seqof1));
	do {
	    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_seqof1));
	    {
		switch ((s_oss_tmp_1->value).choice) {
		    case 1: {
			(d_oss_tmp_1->value).u.initialString = NULL;
			(d_oss_tmp_1->value).u.initialString = _cpAttribute(_g, (s_oss_tmp_1->value).u.initialString, (d_oss_tmp_1->value).u.initialString);
		    }   break;
		    case 2: {
			(d_oss_tmp_1->value).u.anyString = NULL;
			(d_oss_tmp_1->value).u.anyString = _cpAttribute(_g, (s_oss_tmp_1->value).u.anyString, (d_oss_tmp_1->value).u.anyString);
		    }   break;
		    case 3: {
			(d_oss_tmp_1->value).u.finalString = NULL;
			(d_oss_tmp_1->value).u.finalString = _cpAttribute(_g, (s_oss_tmp_1->value).u.finalString, (d_oss_tmp_1->value).u.finalString);
		    }   break;
		    default:;
		}
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_seqof1 *)_oss_dec_getmem_internal(_g, sizeof(_seqof1));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _FilterItem  * _cpFilterItem(OssGlobal * _g, _FilterItem  * psVal, _FilterItem  * pdVal)
{
    if (!pdVal) {
	pdVal = (_FilterItem  *)_oss_dec_const_alloc(_g, sizeof(_FilterItem ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 1: {
	    (*pdVal).u.equality = NULL;
	    (*pdVal).u.equality = _cpAttribute(_g, (*psVal).u.equality, (*pdVal).u.equality);
	}   break;
	case 2: {
	    _cp_seqof1(_g, &((*psVal).u.substrings), &((*pdVal).u.substrings));
	}   break;
	case 3: {
	    (*pdVal).u.greaterOrEqual = NULL;
	    (*pdVal).u.greaterOrEqual = _cpAttribute(_g, (*psVal).u.greaterOrEqual, (*pdVal).u.greaterOrEqual);
	}   break;
	case 4: {
	    (*pdVal).u.lessOrEqual = NULL;
	    (*pdVal).u.lessOrEqual = _cpAttribute(_g, (*psVal).u.lessOrEqual, (*pdVal).u.lessOrEqual);
	}   break;
	case 5: {
	    (*pdVal).u.present = NULL;
	    (*pdVal).u.present = _cpAttributeId(_g, (*psVal).u.present, (*pdVal).u.present);
	}   break;
	case 6: {
	    (*pdVal).u.subsetOf = NULL;
	    (*pdVal).u.subsetOf = _cpAttribute(_g, (*psVal).u.subsetOf, (*pdVal).u.subsetOf);
	}   break;
	case 7: {
	    (*pdVal).u.supersetOf = NULL;
	    (*pdVal).u.supersetOf = _cpAttribute(_g, (*psVal).u.supersetOf, (*pdVal).u.supersetOf);
	}   break;
	case 8: {
	    (*pdVal).u.nonNullSetIntersection = NULL;
	    (*pdVal).u.nonNullSetIntersection = _cpAttribute(_g, (*psVal).u.nonNullSetIntersection, (*pdVal).u.nonNullSetIntersection);
	}   break;
	default:;
    }
    return pdVal;
}


static _setof6 * * _cp_setof6(OssGlobal * _g, _setof6 * * psVal, _setof6 * * pdVal)
{
    if (!pdVal) {
	pdVal = (_setof6 * *)_oss_dec_const_alloc(_g, sizeof(_setof6 *));
    }
    *pdVal = NULL;
    if (*psVal) {
	_setof6 *  s_oss_tmp_1 = *psVal;
	_setof6 *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_setof6 *)_oss_dec_getmem_internal(_g, sizeof(_setof6));
	do {
	    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_setof6));
	    {
		switch ((s_oss_tmp_1->value).choice) {
		    case 1: {
			(d_oss_tmp_1->value).u.attributeIdError = (_AttributeIdError  *)_oss_dec_const_alloc(_g, sizeof(_AttributeIdError ));
			memcpy((d_oss_tmp_1->value).u.attributeIdError, (s_oss_tmp_1->value).u.attributeIdError, sizeof(*(d_oss_tmp_1->value).u.attributeIdError));
			{
			    _cpAttributeId(_g, &((*(s_oss_tmp_1->value).u.attributeIdError).attributeId), &((*(d_oss_tmp_1->value).u.attributeIdError).attributeId));
			}
		    }   break;
		    case 2: {
			(d_oss_tmp_1->value).u.attribute = NULL;
			(d_oss_tmp_1->value).u.attribute = _cpAttribute(_g, (s_oss_tmp_1->value).u.attribute, (d_oss_tmp_1->value).u.attribute);
		    }   break;
		    default:;
		}
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_setof6 *)_oss_dec_getmem_internal(_g, sizeof(_setof6));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _setof3 * * _cp_setof7(OssGlobal * _g, _setof3 * * psVal, _setof3 * * pdVal)
{
    if (!pdVal) {
	pdVal = (_setof3 * *)_oss_dec_const_alloc(_g, sizeof(_setof3 *));
    }
    *pdVal = NULL;
    if (*psVal) {
	_setof3 *  s_oss_tmp_1 = *psVal;
	_setof3 *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_setof3 *)_oss_dec_getmem_internal(_g, sizeof(_setof3));
	do {
	    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_setof3));
	    {
		_cpAttribute(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_setof3 *)_oss_dec_getmem_internal(_g, sizeof(_setof3));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _seq1 * * _cp_seq1(OssGlobal * _g, _seq1 * * psVal, _seq1 * * pdVal)
{
    if (!pdVal) {
	pdVal = (_seq1 * *)_oss_dec_const_alloc(_g, sizeof(_seq1 *));
    }
    *pdVal = (_seq1 *)_oss_dec_const_alloc(_g, sizeof(*(*pdVal)));
    memcpy(*pdVal, *psVal, sizeof(**pdVal));
    {
	_cpEventTypeId(_g, &((*psVal)->eventType), &((*pdVal)->eventType));
    }
    if ((*psVal)->bit_mask & 0x80000000) {
	int         _pduNum = ((*psVal)->eventInfo).pduNum;
	_oss_cpy_new_open_type(_g, &_pduNum, &((*psVal)->eventInfo).encoded, &((*pdVal)->eventInfo).encoded, *(void **)&((*psVal)->eventInfo).decoded, (void **)&((*pdVal)->eventInfo).decoded);
	((*pdVal)->eventInfo).pduNum = _pduNum;
    }
    return pdVal;
}


static _RDNSequence * * _cpRDNSequence(OssGlobal * _g, _RDNSequence * * psVal, _RDNSequence * * pdVal)
{
    if (!pdVal) {
	pdVal = (_RDNSequence * *)_oss_dec_const_alloc(_g, sizeof(_RDNSequence *));
    }
    *pdVal = NULL;
    if (*psVal) {
	_RDNSequence *  s_oss_tmp_1 = *psVal;
	_RDNSequence *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_RDNSequence *)_oss_dec_getmem_internal(_g, sizeof(_RDNSequence));
	do {
	    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_RDNSequence));
	    {
		_cpRelativeDistinguishedName(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_RDNSequence *)_oss_dec_getmem_internal(_g, sizeof(_RDNSequence));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _RelativeDistinguishedName * * _cpRelativeDistinguishedName(OssGlobal * _g, _RelativeDistinguishedName * * psVal, _RelativeDistinguishedName * * pdVal)
{
    if (!pdVal) {
	pdVal = (_RelativeDistinguishedName * *)_oss_dec_const_alloc(_g, sizeof(_RelativeDistinguishedName *));
    }
    *pdVal = NULL;
    if (*psVal) {
	_RelativeDistinguishedName *  s_oss_tmp_1 = *psVal;
	_RelativeDistinguishedName *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_RelativeDistinguishedName *)_oss_dec_getmem_internal(_g, sizeof(_RelativeDistinguishedName));
	do {
	    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_RelativeDistinguishedName));
	    {
		{
		    _oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_1->value).id), &((d_oss_tmp_1->value).id), sizeof(((d_oss_tmp_1->value).id).length), sizeof(((d_oss_tmp_1->value).id).value[0]), (unsigned int)((char *)&((s_oss_tmp_1->value).id).value - (char *)&((s_oss_tmp_1->value).id)));
		}
		{
		    int         _pduNum = ((s_oss_tmp_1->value).value).pduNum;
		    _oss_cpy_new_open_type(_g, &_pduNum, &((s_oss_tmp_1->value).value).encoded, &((d_oss_tmp_1->value).value).encoded, *(void **)&((s_oss_tmp_1->value).value).decoded, (void **)&((d_oss_tmp_1->value).value).decoded);
		    ((d_oss_tmp_1->value).value).pduNum = _pduNum;
		}
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_RelativeDistinguishedName *)_oss_dec_getmem_internal(_g, sizeof(_RelativeDistinguishedName));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _Code  * _cpCode(OssGlobal * _g, _Code  * psVal, _Code  * pdVal)
{
    if (!pdVal) {
	pdVal = (_Code  *)_oss_dec_const_alloc(_g, sizeof(_Code ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 2: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.global), &((*pdVal).u.global), sizeof(((*pdVal).u.global).length), sizeof(((*pdVal).u.global).value[0]), (unsigned int)((char *)&((*psVal).u.global).value - (char *)&((*psVal).u.global)));
	}   break;
	default:;
    }
    return pdVal;
}


static _FunctionalUnitPackage  * _cpFunctionalUnitPackage(OssGlobal * _g, _FunctionalUnitPackage  * psVal, _FunctionalUnitPackage  * pdVal)
{
    if (!pdVal) {
	pdVal = (_FunctionalUnitPackage  *)_oss_dec_const_alloc(_g, sizeof(_FunctionalUnitPackage ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).functionalUnitPackageId), &((*pdVal).functionalUnitPackageId), sizeof(((*pdVal).functionalUnitPackageId).length), sizeof(((*pdVal).functionalUnitPackageId).value[0]), (unsigned int)((char *)&((*psVal).functionalUnitPackageId).value - (char *)&((*psVal).functionalUnitPackageId)));
    }
    if ((*psVal).bit_mask & 0x80000000) {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).managerRoleFunctionalUnit), &((*pdVal).managerRoleFunctionalUnit), sizeof(((*pdVal).managerRoleFunctionalUnit).length), -1L, (unsigned int)((char *)&((*psVal).managerRoleFunctionalUnit).value - (char *)&((*psVal).managerRoleFunctionalUnit)));
    }
    if ((*psVal).bit_mask & 0x40000000) {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).agentRoleFunctionalUnit), &((*pdVal).agentRoleFunctionalUnit), sizeof(((*pdVal).agentRoleFunctionalUnit).length), -1L, (unsigned int)((char *)&((*psVal).agentRoleFunctionalUnit).value - (char *)&((*psVal).agentRoleFunctionalUnit)));
    }
    return pdVal;
}


int DLL_ENTRY_FDEF _CPSMASE_A_ASSOCIATE_Informatio(struct ossGlobal * _g, int pduNum, void * src, void ** pdst)
{
    int res = 0;
    void *pdVal = NULL;

    if (pduNum <= 0 || pduNum > 79)
	return PDU_RANGE;
    switch (pduNum) {
	case 1: {
	    pdVal = (_ActionArgument  *)_oss_dec_const_alloc(_g, sizeof(_ActionArgument ));
	    memcpy((_ActionArgument  *)pdVal, (_ActionArgument  *)src, sizeof(*(_ActionArgument  *)pdVal));
	    {
		_cpObjectClass(_g, &((*(_ActionArgument  *)src).baseManagedObjectClass), &((*(_ActionArgument  *)pdVal).baseManagedObjectClass));
	    }
	    {
		_cpObjectInstance(_g, &((*(_ActionArgument  *)src).baseManagedObjectInstance), &((*(_ActionArgument  *)pdVal).baseManagedObjectInstance));
	    }
	    if ((*(_ActionArgument  *)src).bit_mask & 0x80000000) {
		_cpExternal(_g, &((*(_ActionArgument  *)src).accessControl), &((*(_ActionArgument  *)pdVal).accessControl));
	    }
	    if ((*(_ActionArgument  *)src).bit_mask & 0x10000000) {
		_cpCMISFilter(_g, &((*(_ActionArgument  *)src).filter), &((*(_ActionArgument  *)pdVal).filter));
	    }
	    {
		_cpActionInfo(_g, &((*(_ActionArgument  *)src).actionInfo), &((*(_ActionArgument  *)pdVal).actionInfo));
	    }
	} break;
	case 2: {
	    pdVal = _cpActionResult(_g, (_ActionResult  *)src, (_ActionResult  *)pdVal);
	} break;
	case 3: {
	    pdVal = _cpAttribute(_g, (_Attribute  *)src, (_Attribute  *)pdVal);
	} break;
	case 4: {
	    pdVal = _cpAttributeId(_g, (_ActionTypeId  *)src, (_ActionTypeId  *)pdVal);
	} break;
	case 5: {
	    pdVal = (_BaseManagedObjectId  *)_oss_dec_const_alloc(_g, sizeof(_BaseManagedObjectId ));
	    memcpy((_BaseManagedObjectId  *)pdVal, (_BaseManagedObjectId  *)src, sizeof(*(_BaseManagedObjectId  *)pdVal));
	    {
		_cpObjectClass(_g, &((*(_BaseManagedObjectId  *)src).baseManagedObjectClass), &((*(_BaseManagedObjectId  *)pdVal).baseManagedObjectClass));
	    }
	    {
		_cpObjectInstance(_g, &((*(_BaseManagedObjectId  *)src).baseManagedObjectInstance), &((*(_BaseManagedObjectId  *)pdVal).baseManagedObjectInstance));
	    }
	} break;
	case 6: {
	    pdVal = _cpCMISFilter(_g, (_CMISFilter  *)src, (_CMISFilter  *)pdVal);
	} break;
	case 7: {
	    pdVal = (enum CMISSync  *)_oss_dec_const_alloc(_g, sizeof(enum CMISSync ));
	    *(enum CMISSync  *)pdVal = *(enum CMISSync  *)src;
	} break;
	case 8: {
	    pdVal = (_ComplexityLimitation  *)_oss_dec_const_alloc(_g, sizeof(_ComplexityLimitation ));
	    memcpy((_ComplexityLimitation  *)pdVal, (_ComplexityLimitation  *)src, sizeof(*(_ComplexityLimitation  *)pdVal));
	    if ((*(_ComplexityLimitation  *)src).bit_mask & 0x40000000) {
		_cpCMISFilter(_g, &((*(_ComplexityLimitation  *)src).filter), &((*(_ComplexityLimitation  *)pdVal).filter));
	    }
	} break;
	case 9: {
	    pdVal = (_CreateArgument  *)_oss_dec_const_alloc(_g, sizeof(_CreateArgument ));
	    memcpy((_CreateArgument  *)pdVal, (_CreateArgument  *)src, sizeof(*(_CreateArgument  *)pdVal));
	    {
		_cpObjectClass(_g, &((*(_CreateArgument  *)src).managedObjectClass), &((*(_CreateArgument  *)pdVal).managedObjectClass));
	    }
	    if ((*(_CreateArgument  *)src).bit_mask & 0x80000000) {
		switch (((*(_CreateArgument  *)src).managedOrSuperiorObjectInstance).choice) {
		    case 1: {
			((*(_CreateArgument  *)pdVal).managedOrSuperiorObjectInstance).u.managedObjectInstance = NULL;
			((*(_CreateArgument  *)pdVal).managedOrSuperiorObjectInstance).u.managedObjectInstance = _cpObjectInstance(_g, ((*(_CreateArgument  *)src).managedOrSuperiorObjectInstance).u.managedObjectInstance, ((*(_CreateArgument  *)pdVal).managedOrSuperiorObjectInstance).u.managedObjectInstance);
		    }   break;
		    case 2: {
			((*(_CreateArgument  *)pdVal).managedOrSuperiorObjectInstance).u.superiorObjectInstance = NULL;
			((*(_CreateArgument  *)pdVal).managedOrSuperiorObjectInstance).u.superiorObjectInstance = _cpObjectInstance(_g, ((*(_CreateArgument  *)src).managedOrSuperiorObjectInstance).u.superiorObjectInstance, ((*(_CreateArgument  *)pdVal).managedOrSuperiorObjectInstance).u.superiorObjectInstance);
		    }   break;
		    default:;
		}
	    }
	    if ((*(_CreateArgument  *)src).bit_mask & 0x40000000) {
		_cpExternal(_g, &((*(_CreateArgument  *)src).accessControl), &((*(_CreateArgument  *)pdVal).accessControl));
	    }
	    if ((*(_CreateArgument  *)src).bit_mask & 0x20000000) {
		_cpObjectInstance(_g, &((*(_CreateArgument  *)src).referenceObjectInstance), &((*(_CreateArgument  *)pdVal).referenceObjectInstance));
	    }
	    if ((*(_CreateArgument  *)src).bit_mask & 0x10000000) {
		(*(_CreateArgument  *)pdVal).attributeList = NULL;
		if ((*(_CreateArgument  *)src).attributeList) {
		    _setof3 *  s_oss_tmp_2 = (*(_CreateArgument  *)src).attributeList;
		    _setof3 *  d_oss_tmp_2;

		    (*(_CreateArgument  *)pdVal).attributeList = d_oss_tmp_2 = (_setof3 *)_oss_dec_getmem_internal(_g, sizeof(_setof3));
		    do {
			memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_setof3));
			{
			    _cpAttribute(_g, &(s_oss_tmp_2->value), &(d_oss_tmp_2->value));
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_setof3 *)_oss_dec_getmem_internal(_g, sizeof(_setof3));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	} break;
	case 10: {
	    pdVal = (_CreateResult  *)_oss_dec_const_alloc(_g, sizeof(_CreateResult ));
	    memcpy((_CreateResult  *)pdVal, (_CreateResult  *)src, sizeof(*(_CreateResult  *)pdVal));
	    if ((*(_CreateResult  *)src).bit_mask & 0x80000000) {
		_cpObjectClass(_g, &((*(_CreateResult  *)src).managedObjectClass), &((*(_CreateResult  *)pdVal).managedObjectClass));
	    }
	    if ((*(_CreateResult  *)src).bit_mask & 0x40000000) {
		_cpObjectInstance(_g, &((*(_CreateResult  *)src).managedObjectInstance), &((*(_CreateResult  *)pdVal).managedObjectInstance));
	    }
	    if ((*(_CreateResult  *)src).currentTime) {
		size_t  len_1 = (size_t)sizeof(char) * (strlen((*(_CreateResult  *)src).currentTime) + 1);

		(*(_CreateResult  *)pdVal).currentTime = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
		strcpy((*(_CreateResult  *)pdVal).currentTime, (*(_CreateResult  *)src).currentTime);
	    }
	    if ((*(_CreateResult  *)src).bit_mask & 0x20000000) {
		(*(_CreateResult  *)pdVal).attributeList = NULL;
		if ((*(_CreateResult  *)src).attributeList) {
		    _setof3 *  s_oss_tmp_2 = (*(_CreateResult  *)src).attributeList;
		    _setof3 *  d_oss_tmp_2;

		    (*(_CreateResult  *)pdVal).attributeList = d_oss_tmp_2 = (_setof3 *)_oss_dec_getmem_internal(_g, sizeof(_setof3));
		    do {
			memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_setof3));
			{
			    _cpAttribute(_g, &(s_oss_tmp_2->value), &(d_oss_tmp_2->value));
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_setof3 *)_oss_dec_getmem_internal(_g, sizeof(_setof3));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	} break;
	case 11: {
	    pdVal = (_DeleteArgument  *)_oss_dec_const_alloc(_g, sizeof(_DeleteArgument ));
	    memcpy((_DeleteArgument  *)pdVal, (_DeleteArgument  *)src, sizeof(*(_DeleteArgument  *)pdVal));
	    {
		_cpObjectClass(_g, &((*(_DeleteArgument  *)src).baseManagedObjectClass), &((*(_DeleteArgument  *)pdVal).baseManagedObjectClass));
	    }
	    {
		_cpObjectInstance(_g, &((*(_DeleteArgument  *)src).baseManagedObjectInstance), &((*(_DeleteArgument  *)pdVal).baseManagedObjectInstance));
	    }
	    if ((*(_DeleteArgument  *)src).bit_mask & 0x80000000) {
		_cpExternal(_g, &((*(_DeleteArgument  *)src).accessControl), &((*(_DeleteArgument  *)pdVal).accessControl));
	    }
	    if ((*(_DeleteArgument  *)src).bit_mask & 0x10000000) {
		_cpCMISFilter(_g, &((*(_DeleteArgument  *)src).filter), &((*(_DeleteArgument  *)pdVal).filter));
	    }
	} break;
	case 12: {
	    pdVal = _cpDeleteResult(_g, (_DeleteResult  *)src, (_DeleteResult  *)pdVal);
	} break;
	case 13: {
	    pdVal = (_EventReportArgument  *)_oss_dec_const_alloc(_g, sizeof(_EventReportArgument ));
	    memcpy((_EventReportArgument  *)pdVal, (_EventReportArgument  *)src, sizeof(*(_EventReportArgument  *)pdVal));
	    {
		_cpObjectClass(_g, &((*(_EventReportArgument  *)src).managedObjectClass), &((*(_EventReportArgument  *)pdVal).managedObjectClass));
	    }
	    {
		_cpObjectInstance(_g, &((*(_EventReportArgument  *)src).managedObjectInstance), &((*(_EventReportArgument  *)pdVal).managedObjectInstance));
	    }
	    if ((*(_EventReportArgument  *)src).eventTime) {
		size_t  len_1 = (size_t)sizeof(char) * (strlen((*(_EventReportArgument  *)src).eventTime) + 1);

		(*(_EventReportArgument  *)pdVal).eventTime = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
		strcpy((*(_EventReportArgument  *)pdVal).eventTime, (*(_EventReportArgument  *)src).eventTime);
	    }
	    {
		_cpEventTypeId(_g, &((*(_EventReportArgument  *)src).eventType), &((*(_EventReportArgument  *)pdVal).eventType));
	    }
	    if ((*(_EventReportArgument  *)src).bit_mask & 0x80000000) {
		int         _pduNum = ((*(_EventReportArgument  *)src).eventInfo).pduNum;
		_oss_cpy_new_open_type(_g, &_pduNum, &((*(_EventReportArgument  *)src).eventInfo).encoded, &((*(_EventReportArgument  *)pdVal).eventInfo).encoded, *(void **)&((*(_EventReportArgument  *)src).eventInfo).decoded, (void **)&((*(_EventReportArgument  *)pdVal).eventInfo).decoded);
		((*(_EventReportArgument  *)pdVal).eventInfo).pduNum = _pduNum;
	    }
	} break;
	case 14: {
	    pdVal = (_EventReportResult  *)_oss_dec_const_alloc(_g, sizeof(_EventReportResult ));
	    memcpy((_EventReportResult  *)pdVal, (_EventReportResult  *)src, sizeof(*(_EventReportResult  *)pdVal));
	    if ((*(_EventReportResult  *)src).bit_mask & 0x80000000) {
		_cpObjectClass(_g, &((*(_EventReportResult  *)src).managedObjectClass), &((*(_EventReportResult  *)pdVal).managedObjectClass));
	    }
	    if ((*(_EventReportResult  *)src).bit_mask & 0x40000000) {
		_cpObjectInstance(_g, &((*(_EventReportResult  *)src).managedObjectInstance), &((*(_EventReportResult  *)pdVal).managedObjectInstance));
	    }
	    if ((*(_EventReportResult  *)src).currentTime) {
		size_t  len_1 = (size_t)sizeof(char) * (strlen((*(_EventReportResult  *)src).currentTime) + 1);

		(*(_EventReportResult  *)pdVal).currentTime = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
		strcpy((*(_EventReportResult  *)pdVal).currentTime, (*(_EventReportResult  *)src).currentTime);
	    }
	    if ((*(_EventReportResult  *)src).bit_mask & 0x20000000) {
		{
		    _cpEventTypeId(_g, &(((*(_EventReportResult  *)src).eventReply).eventType), &(((*(_EventReportResult  *)pdVal).eventReply).eventType));
		}
		if (((*(_EventReportResult  *)src).eventReply).bit_mask & 0x80000000) {
		    int         _pduNum = (((*(_EventReportResult  *)src).eventReply).eventReplyInfo).pduNum;
		    _oss_cpy_new_open_type(_g, &_pduNum, &(((*(_EventReportResult  *)src).eventReply).eventReplyInfo).encoded, &(((*(_EventReportResult  *)pdVal).eventReply).eventReplyInfo).encoded, *(void **)&(((*(_EventReportResult  *)src).eventReply).eventReplyInfo).decoded, (void **)&(((*(_EventReportResult  *)pdVal).eventReply).eventReplyInfo).decoded);
		    (((*(_EventReportResult  *)pdVal).eventReply).eventReplyInfo).pduNum = _pduNum;
		}
	    }
	} break;
	case 15: {
	    pdVal = (_GetArgument  *)_oss_dec_const_alloc(_g, sizeof(_GetArgument ));
	    memcpy((_GetArgument  *)pdVal, (_GetArgument  *)src, sizeof(*(_GetArgument  *)pdVal));
	    {
		_cpObjectClass(_g, &((*(_GetArgument  *)src).baseManagedObjectClass), &((*(_GetArgument  *)pdVal).baseManagedObjectClass));
	    }
	    {
		_cpObjectInstance(_g, &((*(_GetArgument  *)src).baseManagedObjectInstance), &((*(_GetArgument  *)pdVal).baseManagedObjectInstance));
	    }
	    if ((*(_GetArgument  *)src).bit_mask & 0x80000000) {
		_cpExternal(_g, &((*(_GetArgument  *)src).accessControl), &((*(_GetArgument  *)pdVal).accessControl));
	    }
	    if ((*(_GetArgument  *)src).bit_mask & 0x10000000) {
		_cpCMISFilter(_g, &((*(_GetArgument  *)src).filter), &((*(_GetArgument  *)pdVal).filter));
	    }
	    if ((*(_GetArgument  *)src).bit_mask & 0x8000000) {
		(*(_GetArgument  *)pdVal).attributeIdList = NULL;
		if ((*(_GetArgument  *)src).attributeIdList) {
		    _MissingAttributeValue_PARAMETER *  s_oss_tmp_2 = (*(_GetArgument  *)src).attributeIdList;
		    _MissingAttributeValue_PARAMETER *  d_oss_tmp_2;

		    (*(_GetArgument  *)pdVal).attributeIdList = d_oss_tmp_2 = (_MissingAttributeValue_PARAMETER *)_oss_dec_getmem_internal(_g, sizeof(_MissingAttributeValue_PARAMETER));
		    do {
			memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_MissingAttributeValue_PARAMETER));
			{
			    _cpAttributeId(_g, &(s_oss_tmp_2->value), &(d_oss_tmp_2->value));
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_MissingAttributeValue_PARAMETER *)_oss_dec_getmem_internal(_g, sizeof(_MissingAttributeValue_PARAMETER));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	} break;
	case 16: {
	    pdVal = _cpGetListError(_g, (_GetListError  *)src, (_GetListError  *)pdVal);
	} break;
	case 17: {
	    pdVal = _cpGetResult(_g, (_CreateResult  *)src, (_CreateResult  *)pdVal);
	} break;
	case 18: {
	    pdVal = _cpInvalidArgumentValue(_g, (_InvalidArgumentValue  *)src, (_InvalidArgumentValue  *)pdVal);
	} break;
	case 19: {
	    pdVal = (_InvokeId  *)_oss_dec_const_alloc(_g, sizeof(_InvokeId ));
	    memcpy((_InvokeId  *)pdVal, (_InvokeId  *)src, sizeof(*(_InvokeId  *)pdVal));
	} break;
	case 20: {
	    pdVal = (_LinkedReplyArgument  *)_oss_dec_const_alloc(_g, sizeof(_LinkedReplyArgument ));
	    memcpy((_LinkedReplyArgument  *)pdVal, (_LinkedReplyArgument  *)src, sizeof(*(_LinkedReplyArgument  *)pdVal));
	    switch ((*(_LinkedReplyArgument  *)src).choice) {
		case 1: {
		    (*(_LinkedReplyArgument  *)pdVal).u.getResult = NULL;
		    (*(_LinkedReplyArgument  *)pdVal).u.getResult = _cpGetResult(_g, (*(_LinkedReplyArgument  *)src).u.getResult, (*(_LinkedReplyArgument  *)pdVal).u.getResult);
		}   break;
		case 2: {
		    (*(_LinkedReplyArgument  *)pdVal).u.getListError = NULL;
		    (*(_LinkedReplyArgument  *)pdVal).u.getListError = _cpGetListError(_g, (*(_LinkedReplyArgument  *)src).u.getListError, (*(_LinkedReplyArgument  *)pdVal).u.getListError);
		}   break;
		case 3: {
		    (*(_LinkedReplyArgument  *)pdVal).u.setResult = NULL;
		    (*(_LinkedReplyArgument  *)pdVal).u.setResult = _cpSetResult(_g, (*(_LinkedReplyArgument  *)src).u.setResult, (*(_LinkedReplyArgument  *)pdVal).u.setResult);
		}   break;
		case 4: {
		    (*(_LinkedReplyArgument  *)pdVal).u.setListError = NULL;
		    (*(_LinkedReplyArgument  *)pdVal).u.setListError = _cpSetListError(_g, (*(_LinkedReplyArgument  *)src).u.setListError, (*(_LinkedReplyArgument  *)pdVal).u.setListError);
		}   break;
		case 5: {
		    (*(_LinkedReplyArgument  *)pdVal).u.actionResult = NULL;
		    (*(_LinkedReplyArgument  *)pdVal).u.actionResult = _cpActionResult(_g, (*(_LinkedReplyArgument  *)src).u.actionResult, (*(_LinkedReplyArgument  *)pdVal).u.actionResult);
		}   break;
		case 6: {
		    (*(_LinkedReplyArgument  *)pdVal).u.processingFailure = NULL;
		    (*(_LinkedReplyArgument  *)pdVal).u.processingFailure = _cpProcessingFailure(_g, (*(_LinkedReplyArgument  *)src).u.processingFailure, (*(_LinkedReplyArgument  *)pdVal).u.processingFailure);
		}   break;
		case 7: {
		    (*(_LinkedReplyArgument  *)pdVal).u.deleteResult = NULL;
		    (*(_LinkedReplyArgument  *)pdVal).u.deleteResult = _cpDeleteResult(_g, (*(_LinkedReplyArgument  *)src).u.deleteResult, (*(_LinkedReplyArgument  *)pdVal).u.deleteResult);
		}   break;
		case 8: {
		    (*(_LinkedReplyArgument  *)pdVal).u.actionError = (_ActionError  *)_oss_dec_const_alloc(_g, sizeof(_ActionError ));
		    memcpy((*(_LinkedReplyArgument  *)pdVal).u.actionError, (*(_LinkedReplyArgument  *)src).u.actionError, sizeof(*(*(_LinkedReplyArgument  *)pdVal).u.actionError));
		    if ((*(*(_LinkedReplyArgument  *)src).u.actionError).bit_mask & 0x80000000) {
			_cpObjectClass(_g, &((*(*(_LinkedReplyArgument  *)src).u.actionError).managedObjectClass), &((*(*(_LinkedReplyArgument  *)pdVal).u.actionError).managedObjectClass));
		    }
		    if ((*(*(_LinkedReplyArgument  *)src).u.actionError).bit_mask & 0x40000000) {
			_cpObjectInstance(_g, &((*(*(_LinkedReplyArgument  *)src).u.actionError).managedObjectInstance), &((*(*(_LinkedReplyArgument  *)pdVal).u.actionError).managedObjectInstance));
		    }
		    if ((*(*(_LinkedReplyArgument  *)src).u.actionError).currentTime) {
			size_t  len_2 = (size_t)sizeof(char) * (strlen((*(*(_LinkedReplyArgument  *)src).u.actionError).currentTime) + 1);

			(*(*(_LinkedReplyArgument  *)pdVal).u.actionError).currentTime = (char * )_oss_dec_getmem_internal(_g, (long)len_2);
			strcpy((*(*(_LinkedReplyArgument  *)pdVal).u.actionError).currentTime, (*(*(_LinkedReplyArgument  *)src).u.actionError).currentTime);
		    }
		    {
			{
			    _choice2  * src_3 = &(((*(*(_LinkedReplyArgument  *)src).u.actionError).actionErrorInfo).errorInfo);
			    _choice2  * dst_3 = &(((*(*(_LinkedReplyArgument  *)pdVal).u.actionError).actionErrorInfo).errorInfo);

			    switch ((*src_3).choice) {
				case 1: {
				    (*dst_3).u.actionArgument = NULL;
				    (*dst_3).u.actionArgument = _cpNoSuchArgument(_g, (*src_3).u.actionArgument, (*dst_3).u.actionArgument);
				}   break;
				case 2: {
				    (*dst_3).u.argumentValue = NULL;
				    (*dst_3).u.argumentValue = _cpInvalidArgumentValue(_g, (*src_3).u.argumentValue, (*dst_3).u.argumentValue);
				}   break;
				case 3: {
				    (*dst_3).u.actionType = NULL;
				    (*dst_3).u.actionType = _cpActionTypeId(_g, (*src_3).u.actionType, (*dst_3).u.actionType);
				}   break;
				default:;
			    }
			}
		    }
		}   break;
		case 9: {
		    (*(_LinkedReplyArgument  *)pdVal).u.deleteError = (_DeleteError  *)_oss_dec_const_alloc(_g, sizeof(_DeleteError ));
		    memcpy((*(_LinkedReplyArgument  *)pdVal).u.deleteError, (*(_LinkedReplyArgument  *)src).u.deleteError, sizeof(*(*(_LinkedReplyArgument  *)pdVal).u.deleteError));
		    if ((*(*(_LinkedReplyArgument  *)src).u.deleteError).bit_mask & 0x80000000) {
			_cpObjectClass(_g, &((*(*(_LinkedReplyArgument  *)src).u.deleteError).managedObjectClass), &((*(*(_LinkedReplyArgument  *)pdVal).u.deleteError).managedObjectClass));
		    }
		    if ((*(*(_LinkedReplyArgument  *)src).u.deleteError).bit_mask & 0x40000000) {
			_cpObjectInstance(_g, &((*(*(_LinkedReplyArgument  *)src).u.deleteError).managedObjectInstance), &((*(*(_LinkedReplyArgument  *)pdVal).u.deleteError).managedObjectInstance));
		    }
		    if ((*(*(_LinkedReplyArgument  *)src).u.deleteError).currentTime) {
			size_t  len_2 = (size_t)sizeof(char) * (strlen((*(*(_LinkedReplyArgument  *)src).u.deleteError).currentTime) + 1);

			(*(*(_LinkedReplyArgument  *)pdVal).u.deleteError).currentTime = (char * )_oss_dec_getmem_internal(_g, (long)len_2);
			strcpy((*(*(_LinkedReplyArgument  *)pdVal).u.deleteError).currentTime, (*(*(_LinkedReplyArgument  *)src).u.deleteError).currentTime);
		    }
		}   break;
		default:;
	    }
	} break;
	case 21: {
	    pdVal = (_NoSuchAction  *)_oss_dec_const_alloc(_g, sizeof(_NoSuchAction ));
	    memcpy((_NoSuchAction  *)pdVal, (_NoSuchAction  *)src, sizeof(*(_NoSuchAction  *)pdVal));
	    {
		_cpObjectClass(_g, &((*(_NoSuchAction  *)src).managedObjectClass), &((*(_NoSuchAction  *)pdVal).managedObjectClass));
	    }
	    {
		_cpActionTypeId(_g, &((*(_NoSuchAction  *)src).actionType), &((*(_NoSuchAction  *)pdVal).actionType));
	    }
	} break;
	case 22: {
	    pdVal = _cpNoSuchArgument(_g, (_NoSuchArgument  *)src, (_NoSuchArgument  *)pdVal);
	} break;
	case 23: {
	    pdVal = (_NoSuchEventType  *)_oss_dec_const_alloc(_g, sizeof(_NoSuchEventType ));
	    memcpy((_NoSuchEventType  *)pdVal, (_NoSuchEventType  *)src, sizeof(*(_NoSuchEventType  *)pdVal));
	    {
		_cpObjectClass(_g, &((*(_NoSuchEventType  *)src).managedObjectClass), &((*(_NoSuchEventType  *)pdVal).managedObjectClass));
	    }
	    {
		_cpEventTypeId(_g, &((*(_NoSuchEventType  *)src).eventType), &((*(_NoSuchEventType  *)pdVal).eventType));
	    }
	} break;
	case 24: {
	    pdVal = _cpObjectClass(_g, (_ActionTypeId  *)src, (_ActionTypeId  *)pdVal);
	} break;
	case 25: {
	    pdVal = _cpObjectInstance(_g, (_ObjectInstance  *)src, (_ObjectInstance  *)pdVal);
	} break;
	case 26: {
	    pdVal = _cpProcessingFailure(_g, (_ProcessingFailure  *)src, (_ProcessingFailure  *)pdVal);
	} break;
	case 27: {
	    pdVal = (_Scope  *)_oss_dec_const_alloc(_g, sizeof(_Scope ));
	    memcpy((_Scope  *)pdVal, (_Scope  *)src, sizeof(*(_Scope  *)pdVal));
	} break;
	case 28: {
	    pdVal = (_SetArgument  *)_oss_dec_const_alloc(_g, sizeof(_SetArgument ));
	    memcpy((_SetArgument  *)pdVal, (_SetArgument  *)src, sizeof(*(_SetArgument  *)pdVal));
	    {
		_cpObjectClass(_g, &((*(_SetArgument  *)src).baseManagedObjectClass), &((*(_SetArgument  *)pdVal).baseManagedObjectClass));
	    }
	    {
		_cpObjectInstance(_g, &((*(_SetArgument  *)src).baseManagedObjectInstance), &((*(_SetArgument  *)pdVal).baseManagedObjectInstance));
	    }
	    if ((*(_SetArgument  *)src).bit_mask & 0x80000000) {
		_cpExternal(_g, &((*(_SetArgument  *)src).accessControl), &((*(_SetArgument  *)pdVal).accessControl));
	    }
	    if ((*(_SetArgument  *)src).bit_mask & 0x10000000) {
		_cpCMISFilter(_g, &((*(_SetArgument  *)src).filter), &((*(_SetArgument  *)pdVal).filter));
	    }
	    {
		(*(_SetArgument  *)pdVal).modificationList = NULL;
		if ((*(_SetArgument  *)src).modificationList) {
		    _setof8 *  s_oss_tmp_2 = (*(_SetArgument  *)src).modificationList;
		    _setof8 *  d_oss_tmp_2;

		    (*(_SetArgument  *)pdVal).modificationList = d_oss_tmp_2 = (_setof8 *)_oss_dec_getmem_internal(_g, sizeof(_setof8));
		    do {
			memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_setof8));
			{
			    {
				_cpAttributeId(_g, &((s_oss_tmp_2->value).attributeId), &((d_oss_tmp_2->value).attributeId));
			    }
			    if ((s_oss_tmp_2->value).bit_mask & 0x40000000) {
				int         _pduNum = ((s_oss_tmp_2->value).attributeValue).pduNum;
				_oss_cpy_new_open_type(_g, &_pduNum, &((s_oss_tmp_2->value).attributeValue).encoded, &((d_oss_tmp_2->value).attributeValue).encoded, *(void **)&((s_oss_tmp_2->value).attributeValue).decoded, (void **)&((d_oss_tmp_2->value).attributeValue).decoded);
				((d_oss_tmp_2->value).attributeValue).pduNum = _pduNum;
			    }
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_setof8 *)_oss_dec_getmem_internal(_g, sizeof(_setof8));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	} break;
	case 29: {
	    pdVal = _cpSetListError(_g, (_SetListError  *)src, (_SetListError  *)pdVal);
	} break;
	case 30: {
	    pdVal = _cpSetResult(_g, (_CreateResult  *)src, (_CreateResult  *)pdVal);
	} break;
	case 31: {
	    pdVal = (_ROSEapdus  *)_oss_dec_const_alloc(_g, sizeof(_ROSEapdus ));
	    memcpy((_ROSEapdus  *)pdVal, (_ROSEapdus  *)src, sizeof(*(_ROSEapdus  *)pdVal));
	    switch ((*(_ROSEapdus  *)src).choice) {
		case 1: {
		    (*(_ROSEapdus  *)pdVal).u.invoke = (_seq6 *)_oss_dec_const_alloc(_g, sizeof(*((*(_ROSEapdus  *)pdVal).u.invoke)));
		    memcpy((*(_ROSEapdus  *)pdVal).u.invoke, (*(_ROSEapdus  *)src).u.invoke, sizeof(*(*(_ROSEapdus  *)pdVal).u.invoke));
		    {
			_cpCode(_g, &(((*(_ROSEapdus  *)src).u.invoke)->opcode), &(((*(_ROSEapdus  *)pdVal).u.invoke)->opcode));
		    }
		    if (((*(_ROSEapdus  *)src).u.invoke)->bit_mask & 0x40000000) {
			int         _pduNum = (((*(_ROSEapdus  *)src).u.invoke)->argument).pduNum;
			_oss_cpy_new_open_type(_g, &_pduNum, &(((*(_ROSEapdus  *)src).u.invoke)->argument).encoded, &(((*(_ROSEapdus  *)pdVal).u.invoke)->argument).encoded, *(void **)&(((*(_ROSEapdus  *)src).u.invoke)->argument).decoded, (void **)&(((*(_ROSEapdus  *)pdVal).u.invoke)->argument).decoded);
			(((*(_ROSEapdus  *)pdVal).u.invoke)->argument).pduNum = _pduNum;
		    }
		}   break;
		case 2: {
		    (*(_ROSEapdus  *)pdVal).u.returnResult = (_seq7 *)_oss_dec_const_alloc(_g, sizeof(*((*(_ROSEapdus  *)pdVal).u.returnResult)));
		    memcpy((*(_ROSEapdus  *)pdVal).u.returnResult, (*(_ROSEapdus  *)src).u.returnResult, sizeof(*(*(_ROSEapdus  *)pdVal).u.returnResult));
		    if (((*(_ROSEapdus  *)src).u.returnResult)->bit_mask & 0x80000000) {
			{
			    _cpCode(_g, &((((*(_ROSEapdus  *)src).u.returnResult)->result).opcode), &((((*(_ROSEapdus  *)pdVal).u.returnResult)->result).opcode));
			}
			{
			    int         _pduNum = ((((*(_ROSEapdus  *)src).u.returnResult)->result).result).pduNum;
			    _oss_cpy_new_open_type(_g, &_pduNum, &((((*(_ROSEapdus  *)src).u.returnResult)->result).result).encoded, &((((*(_ROSEapdus  *)pdVal).u.returnResult)->result).result).encoded, *(void **)&((((*(_ROSEapdus  *)src).u.returnResult)->result).result).decoded, (void **)&((((*(_ROSEapdus  *)pdVal).u.returnResult)->result).result).decoded);
			    ((((*(_ROSEapdus  *)pdVal).u.returnResult)->result).result).pduNum = _pduNum;
			}
		    }
		}   break;
		case 3: {
		    (*(_ROSEapdus  *)pdVal).u.returnError = (_seq8 *)_oss_dec_const_alloc(_g, sizeof(*((*(_ROSEapdus  *)pdVal).u.returnError)));
		    memcpy((*(_ROSEapdus  *)pdVal).u.returnError, (*(_ROSEapdus  *)src).u.returnError, sizeof(*(*(_ROSEapdus  *)pdVal).u.returnError));
		    {
			_cpCode(_g, &(((*(_ROSEapdus  *)src).u.returnError)->errcode), &(((*(_ROSEapdus  *)pdVal).u.returnError)->errcode));
		    }
		    if (((*(_ROSEapdus  *)src).u.returnError)->bit_mask & 0x80000000) {
			int         _pduNum = (((*(_ROSEapdus  *)src).u.returnError)->parameter).pduNum;
			_oss_cpy_new_open_type(_g, &_pduNum, &(((*(_ROSEapdus  *)src).u.returnError)->parameter).encoded, &(((*(_ROSEapdus  *)pdVal).u.returnError)->parameter).encoded, *(void **)&(((*(_ROSEapdus  *)src).u.returnError)->parameter).decoded, (void **)&(((*(_ROSEapdus  *)pdVal).u.returnError)->parameter).decoded);
			(((*(_ROSEapdus  *)pdVal).u.returnError)->parameter).pduNum = _pduNum;
		    }
		}   break;
		case 4: {
		    (*(_ROSEapdus  *)pdVal).u.reject = (_Reject  *)_oss_dec_const_alloc(_g, sizeof(_Reject ));
		    memcpy((*(_ROSEapdus  *)pdVal).u.reject, (*(_ROSEapdus  *)src).u.reject, sizeof(*(*(_ROSEapdus  *)pdVal).u.reject));
		}   break;
		default:;
	    }
	} break;
	case 32: {
	    pdVal = (_CMIPAbortInfo  *)_oss_dec_const_alloc(_g, sizeof(_CMIPAbortInfo ));
	    memcpy((_CMIPAbortInfo  *)pdVal, (_CMIPAbortInfo  *)src, sizeof(*(_CMIPAbortInfo  *)pdVal));
	    if ((*(_CMIPAbortInfo  *)src).bit_mask & 0x80000000) {
		_cpExternal(_g, &((*(_CMIPAbortInfo  *)src).userInfo), &((*(_CMIPAbortInfo  *)pdVal).userInfo));
	    }
	} break;
	case 33: {
	    pdVal = (_CMIPUserInfo  *)_oss_dec_const_alloc(_g, sizeof(_CMIPUserInfo ));
	    memcpy((_CMIPUserInfo  *)pdVal, (_CMIPUserInfo  *)src, sizeof(*(_CMIPUserInfo  *)pdVal));
	    if ((*(_CMIPUserInfo  *)src).bit_mask & 0x80000000) {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_CMIPUserInfo  *)src).protocolVersion), &((*(_CMIPUserInfo  *)pdVal).protocolVersion), sizeof(((*(_CMIPUserInfo  *)pdVal).protocolVersion).length), -1L, (unsigned int)((char *)&((*(_CMIPUserInfo  *)src).protocolVersion).value - (char *)&((*(_CMIPUserInfo  *)src).protocolVersion)));
	    }
	    if ((*(_CMIPUserInfo  *)src).bit_mask & 0x40000000) {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_CMIPUserInfo  *)src).functionalUnits), &((*(_CMIPUserInfo  *)pdVal).functionalUnits), sizeof(((*(_CMIPUserInfo  *)pdVal).functionalUnits).length), -1L, (unsigned int)((char *)&((*(_CMIPUserInfo  *)src).functionalUnits).value - (char *)&((*(_CMIPUserInfo  *)src).functionalUnits)));
	    }
	    if ((*(_CMIPUserInfo  *)src).bit_mask & 0x20000000) {
		_cpExternal(_g, &((*(_CMIPUserInfo  *)src).accessControl), &((*(_CMIPUserInfo  *)pdVal).accessControl));
	    }
	    if ((*(_CMIPUserInfo  *)src).bit_mask & 0x10000000) {
		_cpExternal(_g, &((*(_CMIPUserInfo  *)src).userInfo), &((*(_CMIPUserInfo  *)pdVal).userInfo));
	    }
	} break;
	case 34: {
	    pdVal = (OSSC::COssBitString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssBitString  *)src, (OSSC::COssBitString  *)pdVal, sizeof((*(OSSC::COssBitString  *)pdVal).length), -1L, (unsigned int)((char *)&(*(OSSC::COssBitString  *)src).value - (char *)(OSSC::COssBitString  *)src));
	} break;
	case 35: {
	    pdVal = (OSSC::COssBitString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssBitString  *)src, (OSSC::COssBitString  *)pdVal, sizeof((*(OSSC::COssBitString  *)pdVal).length), -1L, (unsigned int)((char *)&(*(OSSC::COssBitString  *)src).value - (char *)(OSSC::COssBitString  *)src));
	} break;
	case 36: {
	    pdVal = (OSSC::COssBitString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssBitString  *)src, (OSSC::COssBitString  *)pdVal, sizeof((*(OSSC::COssBitString  *)pdVal).length), -1L, (unsigned int)((char *)&(*(OSSC::COssBitString  *)src).value - (char *)(OSSC::COssBitString  *)src));
	} break;
	case 37: {
	    pdVal = (OSSC::COssBitString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssBitString  *)src, (OSSC::COssBitString  *)pdVal, sizeof((*(OSSC::COssBitString  *)pdVal).length), -1L, (unsigned int)((char *)&(*(OSSC::COssBitString  *)src).value - (char *)(OSSC::COssBitString  *)src));
	} break;
	case 38: {
	    pdVal = (_InvokeldsOutstanding * *)_oss_cpy_link_obj(_g, (void**)((_InvokeldsOutstanding * *)src), (void**)((_InvokeldsOutstanding * *)pdVal), sizeof(_InvokeldsOutstanding));
	} break;
	case 39: {
	    pdVal = (_InvokeldsOutstanding * *)_oss_cpy_link_obj(_g, (void**)((_InvokeldsOutstanding * *)src), (void**)((_InvokeldsOutstanding * *)pdVal), sizeof(_InvokeldsOutstanding));
	} break;
	case 40: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 41: {
	    pdVal = (OSSC::COssBitString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssBitString  *)src, (OSSC::COssBitString  *)pdVal, sizeof((*(OSSC::COssBitString  *)pdVal).length), -1L, (unsigned int)((char *)&(*(OSSC::COssBitString  *)src).value - (char *)(OSSC::COssBitString  *)src));
	} break;
	case 42: {
	    pdVal = (_SmaseFunctionalUnits * *)_oss_dec_const_alloc(_g, sizeof(_SmaseFunctionalUnits *));
	    *(_SmaseFunctionalUnits * *)pdVal = NULL;
	    if (*(_SmaseFunctionalUnits * *)src) {
		_SmaseFunctionalUnits *  s_oss_tmp_1 = *(_SmaseFunctionalUnits * *)src;
		_SmaseFunctionalUnits *  d_oss_tmp_1;

		*(_SmaseFunctionalUnits * *)pdVal = d_oss_tmp_1 = (_SmaseFunctionalUnits *)_oss_dec_getmem_internal(_g, sizeof(_SmaseFunctionalUnits));
		do {
		    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_SmaseFunctionalUnits));
		    {
			_cpFunctionalUnitPackage(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
		    }
		    if (s_oss_tmp_1->next)
			d_oss_tmp_1->next = (_SmaseFunctionalUnits *)_oss_dec_getmem_internal(_g, sizeof(_SmaseFunctionalUnits));
		    s_oss_tmp_1 = s_oss_tmp_1->next;
		    d_oss_tmp_1 = d_oss_tmp_1->next;
		} while (s_oss_tmp_1);
	    }
	} break;
	case 43: {
	    pdVal = (_SmUserInfoSent  *)_oss_dec_const_alloc(_g, sizeof(_SmUserInfoSent ));
	    memcpy((_SmUserInfoSent  *)pdVal, (_SmUserInfoSent  *)src, sizeof(*(_SmUserInfoSent  *)pdVal));
	    switch ((*(_SmUserInfoSent  *)src).choice) {
		case 2: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_SmUserInfoSent  *)src).u.informationSent), &((*(_SmUserInfoSent  *)pdVal).u.informationSent), sizeof(((*(_SmUserInfoSent  *)pdVal).u.informationSent).length), sizeof(((*(_SmUserInfoSent  *)pdVal).u.informationSent).value[0]), (unsigned int)((char *)&((*(_SmUserInfoSent  *)src).u.informationSent).value - (char *)&((*(_SmUserInfoSent  *)src).u.informationSent)));
		}   break;
		default:;
	    }
	} break;
	case 44: {
	    pdVal = (_SmUserInfoReceived  *)_oss_dec_const_alloc(_g, sizeof(_SmUserInfoReceived ));
	    memcpy((_SmUserInfoReceived  *)pdVal, (_SmUserInfoReceived  *)src, sizeof(*(_SmUserInfoReceived  *)pdVal));
	    switch ((*(_SmUserInfoReceived  *)src).choice) {
		case 2: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_SmUserInfoReceived  *)src).u.informationReceived), &((*(_SmUserInfoReceived  *)pdVal).u.informationReceived), sizeof(((*(_SmUserInfoReceived  *)pdVal).u.informationReceived).length), sizeof(((*(_SmUserInfoReceived  *)pdVal).u.informationReceived).value[0]), (unsigned int)((char *)&((*(_SmUserInfoReceived  *)src).u.informationReceived).value - (char *)&((*(_SmUserInfoReceived  *)src).u.informationReceived)));
		}   break;
		default:;
	    }
	} break;
	case 45: {
	    pdVal = (_InvokeId  *)_oss_dec_const_alloc(_g, sizeof(_InvokeId ));
	    memcpy((_InvokeId  *)pdVal, (_InvokeId  *)src, sizeof(*(_InvokeId  *)pdVal));
	} break;
	case 46: {
	    pdVal = (_InvokeId  *)_oss_dec_const_alloc(_g, sizeof(_InvokeId ));
	    memcpy((_InvokeId  *)pdVal, (_InvokeId  *)src, sizeof(*(_InvokeId  *)pdVal));
	} break;
	case 47: {
	    pdVal = (_SMASEUserData  *)_oss_dec_const_alloc(_g, sizeof(_SMASEUserData ));
	    memcpy((_SMASEUserData  *)pdVal, (_SMASEUserData  *)src, sizeof(*(_SMASEUserData  *)pdVal));
	    if ((*(_SMASEUserData  *)src).bit_mask & 0x80000000) {
		(*(_SMASEUserData  *)pdVal).smfuPackages = NULL;
		if ((*(_SMASEUserData  *)src).smfuPackages) {
		    _SmaseFunctionalUnits *  s_oss_tmp_2 = (*(_SMASEUserData  *)src).smfuPackages;
		    _SmaseFunctionalUnits *  d_oss_tmp_2;

		    (*(_SMASEUserData  *)pdVal).smfuPackages = d_oss_tmp_2 = (_SmaseFunctionalUnits *)_oss_dec_getmem_internal(_g, sizeof(_SmaseFunctionalUnits));
		    do {
			memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_SmaseFunctionalUnits));
			{
			    _cpFunctionalUnitPackage(_g, &(s_oss_tmp_2->value), &(d_oss_tmp_2->value));
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_SmaseFunctionalUnits *)_oss_dec_getmem_internal(_g, sizeof(_SmaseFunctionalUnits));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	    if ((*(_SMASEUserData  *)src).bit_mask & 0x20000000) {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_SMASEUserData  *)src).systemsManagementUserInformation), &((*(_SMASEUserData  *)pdVal).systemsManagementUserInformation), sizeof(((*(_SMASEUserData  *)pdVal).systemsManagementUserInformation).length), sizeof(((*(_SMASEUserData  *)pdVal).systemsManagementUserInformation).value[0]), (unsigned int)((char *)&((*(_SMASEUserData  *)src).systemsManagementUserInformation).value - (char *)&((*(_SMASEUserData  *)src).systemsManagementUserInformation)));
	    }
	} break;
	case 48: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 49: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 50: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 51: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 52: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 53: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 54: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 55: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 56: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 57: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 58: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 59: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 60: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 61: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 62: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 63: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 64: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 65: {
	    pdVal = (_MissingAttributeValue_PARAMETER * *)_oss_dec_const_alloc(_g, sizeof(_MissingAttributeValue_PARAMETER *));
	    *(_MissingAttributeValue_PARAMETER * *)pdVal = NULL;
	    if (*(_MissingAttributeValue_PARAMETER * *)src) {
		_MissingAttributeValue_PARAMETER *  s_oss_tmp_1 = *(_MissingAttributeValue_PARAMETER * *)src;
		_MissingAttributeValue_PARAMETER *  d_oss_tmp_1;

		*(_MissingAttributeValue_PARAMETER * *)pdVal = d_oss_tmp_1 = (_MissingAttributeValue_PARAMETER *)_oss_dec_getmem_internal(_g, sizeof(_MissingAttributeValue_PARAMETER));
		do {
		    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_MissingAttributeValue_PARAMETER));
		    {
			_cpAttributeId(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
		    }
		    if (s_oss_tmp_1->next)
			d_oss_tmp_1->next = (_MissingAttributeValue_PARAMETER *)_oss_dec_getmem_internal(_g, sizeof(_MissingAttributeValue_PARAMETER));
		    s_oss_tmp_1 = s_oss_tmp_1->next;
		    d_oss_tmp_1 = d_oss_tmp_1->next;
		} while (s_oss_tmp_1);
	    }
	} break;
	case 66: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 67: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 68: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 69: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 70: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 71: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 72: {
	    pdVal = (OSS_UINT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_UINT32 ));
	    *(OSS_UINT32  *)pdVal = *(OSS_UINT32  *)src;
	} break;
	case 73: {
	    pdVal = (_RealizationParameter  *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter ));
	    memcpy((_RealizationParameter  *)pdVal, (_RealizationParameter  *)src, sizeof(*(_RealizationParameter  *)pdVal));
	} break;
	case 74: {
	    pdVal = (_RealizationParameter  *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter ));
	    memcpy((_RealizationParameter  *)pdVal, (_RealizationParameter  *)src, sizeof(*(_RealizationParameter  *)pdVal));
	} break;
	case 75: {
	    pdVal = (_RealizationParameter  *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter ));
	    memcpy((_RealizationParameter  *)pdVal, (_RealizationParameter  *)src, sizeof(*(_RealizationParameter  *)pdVal));
	} break;
	case 76: {
	    pdVal = (_RealizationParameter  *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter ));
	    memcpy((_RealizationParameter  *)pdVal, (_RealizationParameter  *)src, sizeof(*(_RealizationParameter  *)pdVal));
	} break;
	case 77: {
	    pdVal = (_RealizationParameter  *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter ));
	    memcpy((_RealizationParameter  *)pdVal, (_RealizationParameter  *)src, sizeof(*(_RealizationParameter  *)pdVal));
	} break;
	case 78: {
	    pdVal = (_RealizationParameter  *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter ));
	    memcpy((_RealizationParameter  *)pdVal, (_RealizationParameter  *)src, sizeof(*(_RealizationParameter  *)pdVal));
	} break;
	default:
	    res = PDU_RANGE;
    }
    *pdst = pdVal;
    return res;
}
#undef _oss_c

void _oss_cpy_new_open_type (OssGlobal *_g, int *_pduNum,
		OssBuf *_obuf, OssBuf *_cbuf, void *_odecoded, void **_cdecoded)
{
    unsigned long   apiFlags = _g->decodingFlags | _g->encodingFlags;

    if (_obuf->length && _obuf->value) {
	if (apiFlags & DONT_DO_ENCODED) {
	    _cbuf->length = 0L;
	    _cbuf->value = NULL;
	} else {
	    _cbuf->value = (unsigned char *)_oss_dec_getmem_internal(_g, _obuf->length);
	    memcpy(_cbuf->value, _obuf->value, _obuf->length);
	    _cbuf->length = _obuf->length;
	}
    } else {
	_cbuf->length = 0L;
	_cbuf->value = NULL;
    }
    if (*_pduNum && _odecoded && !(apiFlags & DONT_DO_DECODED)) {
	_CPSMASE_A_ASSOCIATE_Informatio(_g, *_pduNum, _odecoded, _cdecoded);
    } else {
	*_pduNum = 0;
	*_cdecoded = NULL;
    }
}
#endif /* OSS_COPY_VALUE */

#ifdef OSS_COMPARE_VALUE
static int _cmActionResult(OssGlobal * _g, _ActionResult  * _odata, _ActionResult  * _cdata)
{
    int _res = 0;

    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x80000000)
	return 1;
    if ((*_odata).bit_mask & 0x80000000) {
	_res = _cmObjectClass(_g, &((*_odata).managedObjectClass), &((*_cdata).managedObjectClass));
	if (_res)
	    return _res;
    }
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x40000000)
	return 1;
    if ((*_odata).bit_mask & 0x40000000) {
	_res = _cmObjectInstance(_g, &((*_odata).managedObjectInstance), &((*_cdata).managedObjectInstance));
	if (_res)
	    return _res;
    }
    if (!(*_odata).currentTime != !(*_cdata).currentTime)
	return 1;
    if ((*_odata).currentTime) {
	if (strcmp((*_cdata).currentTime, (*_odata).currentTime))
#ifdef BAD_OID_IRI
	    if (_oss_cmp_str2time((*_cdata).currentTime, (*_odata).currentTime, 0))
#endif
		return 1;
    }
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x20000000)
	return 1;
    if ((*_odata).bit_mask & 0x20000000) {
	_res = _cmActionReply(_g, &((*_odata).actionReply), &((*_cdata).actionReply));
	if (_res)
	    return _res;
    }

    return _res;
}


static int _cmDeleteResult(OssGlobal * _g, _DeleteResult  * _odata, _DeleteResult  * _cdata)
{
    int _res = 0;

    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x80000000)
	return 1;
    if ((*_odata).bit_mask & 0x80000000) {
	_res = _cmObjectClass(_g, &((*_odata).managedObjectClass), &((*_cdata).managedObjectClass));
	if (_res)
	    return _res;
    }
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x40000000)
	return 1;
    if ((*_odata).bit_mask & 0x40000000) {
	_res = _cmObjectInstance(_g, &((*_odata).managedObjectInstance), &((*_cdata).managedObjectInstance));
	if (_res)
	    return _res;
    }
    if (!(*_odata).currentTime != !(*_cdata).currentTime)
	return 1;
    if ((*_odata).currentTime) {
	if (strcmp((*_cdata).currentTime, (*_odata).currentTime))
#ifdef BAD_OID_IRI
	    if (_oss_cmp_str2time((*_cdata).currentTime, (*_odata).currentTime, 0))
#endif
		return 1;
    }

    return _res;
}


static int _cmGetListError(OssGlobal * _g, _GetListError  * _odata, _GetListError  * _cdata)
{
    int _res = 0;

    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x80000000)
	return 1;
    if ((*_odata).bit_mask & 0x80000000) {
	_res = _cmObjectClass(_g, &((*_odata).managedObjectClass), &((*_cdata).managedObjectClass));
	if (_res)
	    return _res;
    }
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x40000000)
	return 1;
    if ((*_odata).bit_mask & 0x40000000) {
	_res = _cmObjectInstance(_g, &((*_odata).managedObjectInstance), &((*_cdata).managedObjectInstance));
	if (_res)
	    return _res;
    }
    if (!(*_odata).currentTime != !(*_cdata).currentTime)
	return 1;
    if ((*_odata).currentTime) {
	if (strcmp((*_cdata).currentTime, (*_odata).currentTime))
#ifdef BAD_OID_IRI
	    if (_oss_cmp_str2time((*_cdata).currentTime, (*_odata).currentTime, 0))
#endif
		return 1;
    }
    _res = _cm_setof6(_g, &((*_odata).getInfoList), &((*_cdata).getInfoList));
    if (_res)
	return _res;

    return _res;
}


static int _cmGetResult(OssGlobal * _g, _CreateResult  * _odata, _CreateResult  * _cdata)
{
    int _res = 0;

    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x80000000)
	return 1;
    if ((*_odata).bit_mask & 0x80000000) {
	_res = _cmObjectClass(_g, &((*_odata).managedObjectClass), &((*_cdata).managedObjectClass));
	if (_res)
	    return _res;
    }
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x40000000)
	return 1;
    if ((*_odata).bit_mask & 0x40000000) {
	_res = _cmObjectInstance(_g, &((*_odata).managedObjectInstance), &((*_cdata).managedObjectInstance));
	if (_res)
	    return _res;
    }
    if (!(*_odata).currentTime != !(*_cdata).currentTime)
	return 1;
    if ((*_odata).currentTime) {
	if (strcmp((*_cdata).currentTime, (*_odata).currentTime))
#ifdef BAD_OID_IRI
	    if (_oss_cmp_str2time((*_cdata).currentTime, (*_odata).currentTime, 0))
#endif
		return 1;
    }
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x20000000)
	return 1;
    if ((*_odata).bit_mask & 0x20000000) {
	_res = _cm_setof7(_g, &((*_odata).attributeList), &((*_cdata).attributeList));
	if (_res)
	    return _res;
    }

    return _res;
}


static int _cmInvalidArgumentValue(OssGlobal * _g, _InvalidArgumentValue  * _odata, _InvalidArgumentValue  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    _res = _cmActionInfo(_g, (*_odata).u.actionValue, (*_cdata).u.actionValue);
	    if (_res)
		return _res;
	}   break;
	case 2: {
	    _res = _cm_seq1(_g, &(*_odata).u.eventValue, &(*_cdata).u.eventValue);
	    if (_res)
		return _res;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}


static int _cmNoSuchArgument(OssGlobal * _g, _NoSuchArgument  * _odata, _NoSuchArgument  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    if ((((*_odata).u.actionId)->bit_mask ^ ((*_cdata).u.actionId)->bit_mask) & 0x80000000)
		return 1;
	    if (((*_odata).u.actionId)->bit_mask & 0x80000000) {
		_res = _cmObjectClass(_g, &(((*_odata).u.actionId)->managedObjectClass), &(((*_cdata).u.actionId)->managedObjectClass));
		if (_res)
		    return _res;
	    }
	    _res = _cmActionTypeId(_g, &(((*_odata).u.actionId)->actionType), &(((*_cdata).u.actionId)->actionType));
	    if (_res)
		return _res;
	}   break;
	case 2: {
	    if ((((*_odata).u.eventId)->bit_mask ^ ((*_cdata).u.eventId)->bit_mask) & 0x80000000)
		return 1;
	    if (((*_odata).u.eventId)->bit_mask & 0x80000000) {
		_res = _cmObjectClass(_g, &(((*_odata).u.eventId)->managedObjectClass), &(((*_cdata).u.eventId)->managedObjectClass));
		if (_res)
		    return _res;
	    }
	    _res = _cmEventTypeId(_g, &(((*_odata).u.eventId)->eventType), &(((*_cdata).u.eventId)->eventType));
	    if (_res)
		return _res;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}


static int _cmObjectClass(OssGlobal * _g, _ActionTypeId  * _odata, _ActionTypeId  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    if (!((*_cdata).u.globalForm).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*_odata).u.globalForm), &((*_cdata).u.globalForm), sizeof(((*_cdata).u.globalForm).length), sizeof(((*_cdata).u.globalForm).value[0]), (unsigned int)((char *)&((*_odata).u.globalForm).value - (char *)&((*_odata).u.globalForm))))
		return 1;
	}   break;
	case 2: {
	    if ((*_cdata).u.localForm != (*_odata).u.localForm)
		return 1;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}


static int _cmObjectInstance(OssGlobal * _g, _ObjectInstance  * _odata, _ObjectInstance  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    _res = _cmRDNSequence(_g, &((*_odata).u.distinguishedName), &((*_cdata).u.distinguishedName));
	    if (_res)
		return _res;
	}   break;
	case 2: {
	    if (_oss_cmp_unbnd_octet_ia(&((*_odata).u.nonSpecificForm), &((*_cdata).u.nonSpecificForm), sizeof(((*_cdata).u.nonSpecificForm).length), sizeof(((*_cdata).u.nonSpecificForm).value[0]), (unsigned int)((char *)&((*_odata).u.nonSpecificForm).value - (char *)&((*_odata).u.nonSpecificForm))))
		return 1;
	}   break;
	case 3: {
	    _res = _cmRDNSequence(_g, &((*_odata).u.localDistinguishedName), &((*_cdata).u.localDistinguishedName));
	    if (_res)
		return _res;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}


static int _cmProcessingFailure(OssGlobal * _g, _ProcessingFailure  * _odata, _ProcessingFailure  * _cdata)
{
    int _res = 0;

    _res = _cmObjectClass(_g, &((*_odata).managedObjectClass), &((*_cdata).managedObjectClass));
    if (_res)
	return _res;
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x80000000)
	return 1;
    if ((*_odata).bit_mask & 0x80000000) {
	_res = _cmObjectInstance(_g, &((*_odata).managedObjectInstance), &((*_cdata).managedObjectInstance));
	if (_res)
	    return _res;
    }
    if (!(((*_cdata).specificErrorInfo).errorId).length)
	return 1;
    if (_oss_cmp_unbnd_octet_ia(&(((*_odata).specificErrorInfo).errorId), &(((*_cdata).specificErrorInfo).errorId), sizeof((((*_cdata).specificErrorInfo).errorId).length), sizeof((((*_cdata).specificErrorInfo).errorId).value[0]), (unsigned int)((char *)&(((*_odata).specificErrorInfo).errorId).value - (char *)&(((*_odata).specificErrorInfo).errorId))))
	return 1;
    _res = _oss_cmp_new_open_type(_g, (((*_odata).specificErrorInfo).errorInfo).pduNum, (((*_cdata).specificErrorInfo).errorInfo).pduNum, &((((*_odata).specificErrorInfo).errorInfo).encoded), &((((*_cdata).specificErrorInfo).errorInfo).encoded), *(void **)&((((*_odata).specificErrorInfo).errorInfo).decoded), *(void **)&((((*_cdata).specificErrorInfo).errorInfo).decoded));
    if (_res)
	return _res;

    return _res;
}


static int _cmSetListError(OssGlobal * _g, _SetListError  * _odata, _SetListError  * _cdata)
{
    int _res = 0;

    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x80000000)
	return 1;
    if ((*_odata).bit_mask & 0x80000000) {
	_res = _cmObjectClass(_g, &((*_odata).managedObjectClass), &((*_cdata).managedObjectClass));
	if (_res)
	    return _res;
    }
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x40000000)
	return 1;
    if ((*_odata).bit_mask & 0x40000000) {
	_res = _cmObjectInstance(_g, &((*_odata).managedObjectInstance), &((*_cdata).managedObjectInstance));
	if (_res)
	    return _res;
    }
    if (!(*_odata).currentTime != !(*_cdata).currentTime)
	return 1;
    if ((*_odata).currentTime) {
	if (strcmp((*_cdata).currentTime, (*_odata).currentTime))
#ifdef BAD_OID_IRI
	    if (_oss_cmp_str2time((*_cdata).currentTime, (*_odata).currentTime, 0))
#endif
		return 1;
    }
    {
	_setof9 *  _s_2 = (*_odata).setInfoList;
	_setof9 *  _d_2 = (*_cdata).setInfoList;
	long        *_a, _i, _i_next, _c = 0L;

	while (_s_2 && _d_2) {
	    ++ _c;
	    _s_2 = _s_2->next;
	    _d_2 = _d_2->next;
	}
	if (_s_2 || _d_2)
	    return 1;
	if (_c) {
	    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
	    for (_i = 0; _i < _c; _i ++)
		_a[_i] = _i;
	    _a[_c] = -1L;
	    for (_s_2 = (*_odata).setInfoList; _s_2; _s_2 = _s_2->next) {
		_i_next = _a[0]; _res = 1;
		for (_d_2 = (*_cdata).setInfoList, _i = 0L; _d_2 && _i_next >= 0L && _a[_i_next] >= 0L; _d_2 = _d_2->next,
			_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
		    if (_i < _i_next)
			continue;
		    if ((_s_2->value).choice != (_d_2->value).choice)
			continue;
		    switch ((_s_2->value).choice) {
			case 1: {
			    if ((*(_d_2->value).u.attributeError).errorStatus != (*(_s_2->value).u.attributeError).errorStatus)
				continue;
			    if (((*(_s_2->value).u.attributeError).bit_mask ^ (*(_d_2->value).u.attributeError).bit_mask) & 0x80000000)
				continue;
			    if ((*(_s_2->value).u.attributeError).bit_mask & 0x80000000) {
				if ((*(_d_2->value).u.attributeError).modifyOperator != (*(_s_2->value).u.attributeError).modifyOperator)
				    continue;
			    }
			    _res = _cmAttributeId(_g, &((*(_s_2->value).u.attributeError).attributeId), &((*(_d_2->value).u.attributeError).attributeId));
			    if (_res)
				continue;
			    if (((*(_s_2->value).u.attributeError).bit_mask ^ (*(_d_2->value).u.attributeError).bit_mask) & 0x40000000)
				continue;
			    if ((*(_s_2->value).u.attributeError).bit_mask & 0x40000000) {
				_res = _oss_cmp_new_open_type(_g, ((*(_s_2->value).u.attributeError).attributeValue).pduNum, ((*(_d_2->value).u.attributeError).attributeValue).pduNum, &(((*(_s_2->value).u.attributeError).attributeValue).encoded), &(((*(_d_2->value).u.attributeError).attributeValue).encoded), *(void **)&(((*(_s_2->value).u.attributeError).attributeValue).decoded), *(void **)&(((*(_d_2->value).u.attributeError).attributeValue).decoded));
				if (_res)
				    continue;
			    }
			}   break;
			case 2: {
			    _res = _cmAttribute(_g, (_s_2->value).u.attribute, (_d_2->value).u.attribute);
			    if (_res)
				continue;
			}   break;
			case 0:
			    break;
			default:
			    continue;
		    }
		    _res = 0; _a[_i] = _a[_i+1];
		    break;
		}
		if (_res)
		    break;
	    }
	    _oss_dec_freetempmem(_g, _a);
	    if (_res)
		return _res;
	}
    }

    return _res;
}


static int _cmSetResult(OssGlobal * _g, _CreateResult  * _odata, _CreateResult  * _cdata)
{
    int _res = 0;

    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x80000000)
	return 1;
    if ((*_odata).bit_mask & 0x80000000) {
	_res = _cmObjectClass(_g, &((*_odata).managedObjectClass), &((*_cdata).managedObjectClass));
	if (_res)
	    return _res;
    }
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x40000000)
	return 1;
    if ((*_odata).bit_mask & 0x40000000) {
	_res = _cmObjectInstance(_g, &((*_odata).managedObjectInstance), &((*_cdata).managedObjectInstance));
	if (_res)
	    return _res;
    }
    if (!(*_odata).currentTime != !(*_cdata).currentTime)
	return 1;
    if ((*_odata).currentTime) {
	if (strcmp((*_cdata).currentTime, (*_odata).currentTime))
#ifdef BAD_OID_IRI
	    if (_oss_cmp_str2time((*_cdata).currentTime, (*_odata).currentTime, 0))
#endif
		return 1;
    }
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x20000000)
	return 1;
    if ((*_odata).bit_mask & 0x20000000) {
	{
	    _setof3 *  _s_2 = (*_odata).attributeList;
	    _setof3 *  _d_2 = (*_cdata).attributeList;
	    long        *_a, _i, _i_next, _c = 0L;

	    while (_s_2 && _d_2) {
		++ _c;
		_s_2 = _s_2->next;
		_d_2 = _d_2->next;
	    }
	    if (_s_2 || _d_2)
		return 1;
	    if (_c) {
		_a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
		for (_i = 0; _i < _c; _i ++)
		    _a[_i] = _i;
		_a[_c] = -1L;
		for (_s_2 = (*_odata).attributeList; _s_2; _s_2 = _s_2->next) {
		    _i_next = _a[0]; _res = 1;
		    for (_d_2 = (*_cdata).attributeList, _i = 0L; _d_2 && _i_next >= 0L && _a[_i_next] >= 0L; _d_2 = _d_2->next,
			    _i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
			if (_i < _i_next)
			    continue;
			_res = _cmAttribute(_g, &(_s_2->value), &(_d_2->value));
			if (_res)
			    continue;
			_res = 0; _a[_i] = _a[_i+1];
			break;
		    }
		    if (_res)
			break;
		}
		_oss_dec_freetempmem(_g, _a);
		if (_res)
		    return _res;
	    }
	}
    }

    return _res;
}


static int _cm_choice1(OssGlobal * _g, _choice1  * _odata, _choice1  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    _res = _oss_cmp_open_type(_g, (OpenType *)&((*_odata).u.single_ASN1_type), (OpenType *)&((*_cdata).u.single_ASN1_type));
	    if (_res)
		return _res;
	}   break;
	case 2: {
	    if (_oss_cmp_unbnd_octet_ia(&((*_odata).u.octet_aligned), &((*_cdata).u.octet_aligned), sizeof(((*_cdata).u.octet_aligned).length), sizeof(((*_cdata).u.octet_aligned).value[0]), (unsigned int)((char *)&((*_odata).u.octet_aligned).value - (char *)&((*_odata).u.octet_aligned))))
		return 1;
	}   break;
	case 3: {
	    if (_oss_cmp_arrbits(((*_odata).u.arbitrary).value, ((*_cdata).u.arbitrary).value, ((*_odata).u.arbitrary).length, ((*_cdata).u.arbitrary).length))
		return 1;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}


static int _cmExternal(OssGlobal * _g, _External  * _odata, _External  * _cdata)
{
    int _res = 0;

    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x80000000)
	return 1;
    if ((*_odata).bit_mask & 0x80000000) {
	if (!((*_cdata).direct_reference).length)
	    return 1;
	if (_oss_cmp_unbnd_octet_ia(&((*_odata).direct_reference), &((*_cdata).direct_reference), sizeof(((*_cdata).direct_reference).length), sizeof(((*_cdata).direct_reference).value[0]), (unsigned int)((char *)&((*_odata).direct_reference).value - (char *)&((*_odata).direct_reference))))
	    return 1;
    }
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x40000000)
	return 1;
    if ((*_odata).bit_mask & 0x40000000) {
	if ((*_cdata).indirect_reference != (*_odata).indirect_reference)
	    return 1;
    }
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x20000000)
	return 1;
    if ((*_odata).bit_mask & 0x20000000) {
	if (_oss_cmp_unbnd_octet_ia(&((*_odata).data_value_descriptor), &((*_cdata).data_value_descriptor), sizeof(((*_cdata).data_value_descriptor).length), sizeof(((*_cdata).data_value_descriptor).value[0]), (unsigned int)((char *)&((*_odata).data_value_descriptor).value - (char *)&((*_odata).data_value_descriptor))))
	    return 1;
    }
    _res = _cm_choice1(_g, &((*_odata).encoding), &((*_cdata).encoding));
    if (_res)
	return _res;

    return _res;
}


static int _cmActionTypeId(OssGlobal * _g, _ActionTypeId  * _odata, _ActionTypeId  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    if (!((*_cdata).u.globalForm).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*_odata).u.globalForm), &((*_cdata).u.globalForm), sizeof(((*_cdata).u.globalForm).length), sizeof(((*_cdata).u.globalForm).value[0]), (unsigned int)((char *)&((*_odata).u.globalForm).value - (char *)&((*_odata).u.globalForm))))
		return 1;
	}   break;
	case 2: {
	    if ((*_cdata).u.localForm != (*_odata).u.localForm)
		return 1;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}


static int _cmEventTypeId(OssGlobal * _g, _ActionTypeId  * _odata, _ActionTypeId  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    if (!((*_cdata).u.globalForm).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*_odata).u.globalForm), &((*_cdata).u.globalForm), sizeof(((*_cdata).u.globalForm).length), sizeof(((*_cdata).u.globalForm).value[0]), (unsigned int)((char *)&((*_odata).u.globalForm).value - (char *)&((*_odata).u.globalForm))))
		return 1;
	}   break;
	case 2: {
	    if ((*_cdata).u.localForm != (*_odata).u.localForm)
		return 1;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}


static int _cmRealizationParameter(OssGlobal * _g, _RealizationParameter  * _odata, _RealizationParameter  * _cdata)
{
    int _res = 0;

    if ((*_cdata).realization_type != (*_odata).realization_type)
	return 1;
    if (((*_odata).bit_mask & (*_cdata).bit_mask) & 0x80000000) {
	if (((*_cdata).concatenation ^ (*_odata).concatenation) & 0x01)
	    return 1;
    } else {
	if ((*_odata).bit_mask & 0x80000000) {
	    if ((__shared8::default_concatenation ^ (*_odata).concatenation) & 0x01)
		return 1;
	}
	if ((*_cdata).bit_mask & 0x80000000) {
	    if (((*_cdata).concatenation ^ __shared8::default_concatenation) & 0x01)
		return 1;
	}
    }

    return _res;
}


static int _cmActionInfo(OssGlobal * _g, _ActionInfo  * _odata, _ActionInfo  * _cdata)
{
    int _res = 0;

    _res = _cmActionTypeId(_g, &((*_odata).actionType), &((*_cdata).actionType));
    if (_res)
	return _res;
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x80000000)
	return 1;
    if ((*_odata).bit_mask & 0x80000000) {
	_res = _oss_cmp_new_open_type(_g, ((*_odata).actionInfoArg).pduNum, ((*_cdata).actionInfoArg).pduNum, &(((*_odata).actionInfoArg).encoded), &(((*_cdata).actionInfoArg).encoded), *(void **)&(((*_odata).actionInfoArg).decoded), *(void **)&(((*_cdata).actionInfoArg).decoded));
	if (_res)
	    return _res;
    }

    return _res;
}


static int _cmActionReply(OssGlobal * _g, _ActionReply  * _odata, _ActionReply  * _cdata)
{
    int _res = 0;

    _res = _cmActionTypeId(_g, &((*_odata).actionType), &((*_cdata).actionType));
    if (_res)
	return _res;
    _res = _oss_cmp_new_open_type(_g, ((*_odata).actionReplyInfo).pduNum, ((*_cdata).actionReplyInfo).pduNum, &(((*_odata).actionReplyInfo).encoded), &(((*_cdata).actionReplyInfo).encoded), *(void **)&(((*_odata).actionReplyInfo).decoded), *(void **)&(((*_cdata).actionReplyInfo).decoded));
    if (_res)
	return _res;

    return _res;
}


static int _cm_setof6(OssGlobal * _g, _setof6 * * _odata, _setof6 * * _cdata)
{
    int _res = 0;

    {
	_setof6 *  _s_1 = *_odata;
	_setof6 *  _d_1 = *_cdata;
	long        *_a, _i, _i_next, _c = 0L;

	while (_s_1 && _d_1) {
	    ++ _c;
	    _s_1 = _s_1->next;
	    _d_1 = _d_1->next;
	}
	if (_s_1 || _d_1)
	    return 1;
	if (_c) {
	    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
	    for (_i = 0; _i < _c; _i ++)
		_a[_i] = _i;
	    _a[_c] = -1L;
	    for (_s_1 = *_odata; _s_1; _s_1 = _s_1->next) {
		_i_next = _a[0]; _res = 1;
		for (_d_1 = *_cdata, _i = 0L; _d_1 && _i_next >= 0L && _a[_i_next] >= 0L; _d_1 = _d_1->next,
			_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
		    if (_i < _i_next)
			continue;
		    if ((_s_1->value).choice != (_d_1->value).choice)
			continue;
		    switch ((_s_1->value).choice) {
			case 1: {
			    if ((*(_d_1->value).u.attributeIdError).errorStatus != (*(_s_1->value).u.attributeIdError).errorStatus)
				continue;
			    _res = _cmAttributeId(_g, &((*(_s_1->value).u.attributeIdError).attributeId), &((*(_d_1->value).u.attributeIdError).attributeId));
			    if (_res)
				continue;
			}   break;
			case 2: {
			    _res = _cmAttribute(_g, (_s_1->value).u.attribute, (_d_1->value).u.attribute);
			    if (_res)
				continue;
			}   break;
			case 0:
			    break;
			default:
			    continue;
		    }
		    _res = 0; _a[_i] = _a[_i+1];
		    break;
		}
		if (_res)
		    break;
	    }
	    _oss_dec_freetempmem(_g, _a);
	    if (_res)
		return _res;
	}
    }

    return _res;
}


static int _cm_setof7(OssGlobal * _g, _setof3 * * _odata, _setof3 * * _cdata)
{
    int _res = 0;

    {
	_setof3 *  _s_1 = *_odata;
	_setof3 *  _d_1 = *_cdata;
	long        *_a, _i, _i_next, _c = 0L;

	while (_s_1 && _d_1) {
	    ++ _c;
	    _s_1 = _s_1->next;
	    _d_1 = _d_1->next;
	}
	if (_s_1 || _d_1)
	    return 1;
	if (_c) {
	    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
	    for (_i = 0; _i < _c; _i ++)
		_a[_i] = _i;
	    _a[_c] = -1L;
	    for (_s_1 = *_odata; _s_1; _s_1 = _s_1->next) {
		_i_next = _a[0]; _res = 1;
		for (_d_1 = *_cdata, _i = 0L; _d_1 && _i_next >= 0L && _a[_i_next] >= 0L; _d_1 = _d_1->next,
			_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
		    if (_i < _i_next)
			continue;
		    _res = _cmAttribute(_g, &(_s_1->value), &(_d_1->value));
		    if (_res)
			continue;
		    _res = 0; _a[_i] = _a[_i+1];
		    break;
		}
		if (_res)
		    break;
	    }
	    _oss_dec_freetempmem(_g, _a);
	    if (_res)
		return _res;
	}
    }

    return _res;
}


static int _cm_seq1(OssGlobal * _g, _seq1 * * _odata, _seq1 * * _cdata)
{
    int _res = 0;

    _res = _cmEventTypeId(_g, &((*_odata)->eventType), &((*_cdata)->eventType));
    if (_res)
	return _res;
    if (((*_odata)->bit_mask ^ (*_cdata)->bit_mask) & 0x80000000)
	return 1;
    if ((*_odata)->bit_mask & 0x80000000) {
	_res = _oss_cmp_new_open_type(_g, ((*_odata)->eventInfo).pduNum, ((*_cdata)->eventInfo).pduNum, &(((*_odata)->eventInfo).encoded), &(((*_cdata)->eventInfo).encoded), *(void **)&(((*_odata)->eventInfo).decoded), *(void **)&(((*_cdata)->eventInfo).decoded));
	if (_res)
	    return _res;
    }

    return _res;
}


static int _cmInvokeId(OssGlobal * _g, _InvokeId  * _odata, _InvokeId  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    if ((*_cdata).u.present != (*_odata).u.present)
		return 1;
	}   break;
	case 2: {
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}


static int _cmRDNSequence(OssGlobal * _g, _RDNSequence * * _odata, _RDNSequence * * _cdata)
{
    int _res = 0;

    {
	_RDNSequence *  _s_oss_tmp_1 = *_odata;
	_RDNSequence *  _d_oss_tmp_1 = *_cdata;

	while (_s_oss_tmp_1 && _d_oss_tmp_1) {
	    _res = _cmRelativeDistinguishedName(_g, &(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value));
	    if (_res)
		return _res;
	    _s_oss_tmp_1 = _s_oss_tmp_1->next;
	    _d_oss_tmp_1 = _d_oss_tmp_1->next;
	}
	if (_s_oss_tmp_1 || _d_oss_tmp_1)
	    return 1;
    }

    return _res;
}


static int _cmRelativeDistinguishedName(OssGlobal * _g, _RelativeDistinguishedName * * _odata, _RelativeDistinguishedName * * _cdata)
{
    int _res = 0;

    {
	_RelativeDistinguishedName *  _s_1 = *_odata;
	_RelativeDistinguishedName *  _d_1 = *_cdata;
	long        *_a, _i, _i_next, _c = 0L;

	while (_s_1 && _d_1) {
	    ++ _c;
	    _s_1 = _s_1->next;
	    _d_1 = _d_1->next;
	}
	if (_s_1 || _d_1)
	    return 1;
	if (_c) {
	    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
	    for (_i = 0; _i < _c; _i ++)
		_a[_i] = _i;
	    _a[_c] = -1L;
	    for (_s_1 = *_odata; _s_1; _s_1 = _s_1->next) {
		_i_next = _a[0]; _res = 1;
		for (_d_1 = *_cdata, _i = 0L; _d_1 && _i_next >= 0L && _a[_i_next] >= 0L; _d_1 = _d_1->next,
			_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
		    if (_i < _i_next)
			continue;
		    if (!((_d_1->value).id).length)
			continue;
		    if (_oss_cmp_unbnd_octet_ia(&((_s_1->value).id), &((_d_1->value).id), sizeof(((_d_1->value).id).length), sizeof(((_d_1->value).id).value[0]), (unsigned int)((char *)&((_s_1->value).id).value - (char *)&((_s_1->value).id))))
			continue;
		    _res = _oss_cmp_new_open_type(_g, ((_s_1->value).value).pduNum, ((_d_1->value).value).pduNum, &(((_s_1->value).value).encoded), &(((_d_1->value).value).encoded), *(void **)&(((_s_1->value).value).decoded), *(void **)&(((_d_1->value).value).decoded));
		    if (_res)
			continue;
		    _res = 0; _a[_i] = _a[_i+1];
		    break;
		}
		if (_res)
		    break;
	    }
	    _oss_dec_freetempmem(_g, _a);
	    if (_res)
		return _res;
	}
    }

    return _res;
}


static int _cmCode(OssGlobal * _g, _Code  * _odata, _Code  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    if ((*_cdata).u.local != (*_odata).u.local)
		return 1;
	}   break;
	case 2: {
	    if (!((*_cdata).u.global).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*_odata).u.global), &((*_cdata).u.global), sizeof(((*_cdata).u.global).length), sizeof(((*_cdata).u.global).value[0]), (unsigned int)((char *)&((*_odata).u.global).value - (char *)&((*_odata).u.global))))
		return 1;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}


static int _cmFunctionalUnitPackage(OssGlobal * _g, _FunctionalUnitPackage  * _odata, _FunctionalUnitPackage  * _cdata)
{
    int _res = 0;

    if (!((*_cdata).functionalUnitPackageId).length)
	return 1;
    if (_oss_cmp_unbnd_octet_ia(&((*_odata).functionalUnitPackageId), &((*_cdata).functionalUnitPackageId), sizeof(((*_cdata).functionalUnitPackageId).length), sizeof(((*_cdata).functionalUnitPackageId).value[0]), (unsigned int)((char *)&((*_odata).functionalUnitPackageId).value - (char *)&((*_odata).functionalUnitPackageId))))
	return 1;
    if (((*_odata).bit_mask & (*_cdata).bit_mask) & 0x80000000) {
	if (_oss_cmp_arrbits(((*_odata).managerRoleFunctionalUnit).value, ((*_cdata).managerRoleFunctionalUnit).value, ((*_odata).managerRoleFunctionalUnit).length, ((*_cdata).managerRoleFunctionalUnit).length))
	    return 1;
    } else {
	if ((*_odata).bit_mask & 0x80000000) {
	    if (_oss_cmp_arrbits(((*_odata).managerRoleFunctionalUnit).value, (_v41).value, ((*_odata).managerRoleFunctionalUnit).length, (_v41).length))
		return 1;
	}
	if ((*_cdata).bit_mask & 0x80000000) {
	    if (_oss_cmp_arrbits((_v41).value, ((*_cdata).managerRoleFunctionalUnit).value, (_v41).length, ((*_cdata).managerRoleFunctionalUnit).length))
		return 1;
	}
    }
    if (((*_odata).bit_mask & (*_cdata).bit_mask) & 0x40000000) {
	if (_oss_cmp_arrbits(((*_odata).agentRoleFunctionalUnit).value, ((*_cdata).agentRoleFunctionalUnit).value, ((*_odata).agentRoleFunctionalUnit).length, ((*_cdata).agentRoleFunctionalUnit).length))
	    return 1;
    } else {
	if ((*_odata).bit_mask & 0x40000000) {
	    if (_oss_cmp_arrbits(((*_odata).agentRoleFunctionalUnit).value, (_v42).value, ((*_odata).agentRoleFunctionalUnit).length, (_v42).length))
		return 1;
	}
	if ((*_cdata).bit_mask & 0x40000000) {
	    if (_oss_cmp_arrbits((_v42).value, ((*_cdata).agentRoleFunctionalUnit).value, (_v42).length, ((*_cdata).agentRoleFunctionalUnit).length))
		return 1;
	}
    }

    return _res;
}


int DLL_ENTRY_FDEF _CMSMASE_A_ASSOCIATE_Informatio(struct ossGlobal * _g, int _pduNum, void * _odata, void * _cdata)
{
    int _res = 0;

    if (_pduNum <= 0 || _pduNum > 79)
	return PDU_RANGE;
    switch (_pduNum) {
	case 1: {
	    _res = _cmObjectClass(_g, &((*(_ActionArgument  *)_odata).baseManagedObjectClass), &((*(_ActionArgument  *)_cdata).baseManagedObjectClass));
	    if (_res)
		return _res;
	    _res = _cmObjectInstance(_g, &((*(_ActionArgument  *)_odata).baseManagedObjectInstance), &((*(_ActionArgument  *)_cdata).baseManagedObjectInstance));
	    if (_res)
		return _res;
	    if (((*(_ActionArgument  *)_odata).bit_mask ^ (*(_ActionArgument  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_ActionArgument  *)_odata).bit_mask & 0x80000000) {
		_res = _cmExternal(_g, &((*(_ActionArgument  *)_odata).accessControl), &((*(_ActionArgument  *)_cdata).accessControl));
		if (_res)
		    return _res;
	    }
	    if (((*(_ActionArgument  *)_odata).bit_mask & (*(_ActionArgument  *)_cdata).bit_mask) & 0x40000000) {
		if ((*(_ActionArgument  *)_cdata).synchronization != (*(_ActionArgument  *)_odata).synchronization)
		    return 1;
	    } else {
		if ((*(_ActionArgument  *)_odata).bit_mask & 0x40000000) {
		    if (ActionArgument::default_synchronization != (*(_ActionArgument  *)_odata).synchronization)
			return 1;
		}
		if ((*(_ActionArgument  *)_cdata).bit_mask & 0x40000000) {
		    if ((*(_ActionArgument  *)_cdata).synchronization != ActionArgument::default_synchronization)
			return 1;
		}
	    }
	    if (((*(_ActionArgument  *)_odata).bit_mask & (*(_ActionArgument  *)_cdata).bit_mask) & 0x20000000) {
		_res = _cmScope(_g, &((*(_ActionArgument  *)_odata).scope), &((*(_ActionArgument  *)_cdata).scope));
		if (_res)
		    return _res;
	    } else {
		if ((*(_ActionArgument  *)_odata).bit_mask & 0x20000000) {
		    {
			_res = _cmScope(_g, &((*(_ActionArgument  *)_odata).scope), (_Scope  *)&_v30);
			if (_res)
			    return _res;
		    }
		}
		if ((*(_ActionArgument  *)_cdata).bit_mask & 0x20000000) {
		    {
			_res = _cmScope(_g, (_Scope  *)&_v30, &((*(_ActionArgument  *)_cdata).scope));
			if (_res)
			    return _res;
		    }
		}
	    }
	    if (((*(_ActionArgument  *)_odata).bit_mask & (*(_ActionArgument  *)_cdata).bit_mask) & 0x10000000) {
		_res = _cmCMISFilter(_g, &((*(_ActionArgument  *)_odata).filter), &((*(_ActionArgument  *)_cdata).filter));
		if (_res)
		    return _res;
	    } else {
		if ((*(_ActionArgument  *)_odata).bit_mask & 0x10000000) {
		    {
			_res = _cmCMISFilter(_g, &((*(_ActionArgument  *)_odata).filter), (_CMISFilter  *)&_v31);
			if (_res)
			    return _res;
		    }
		}
		if ((*(_ActionArgument  *)_cdata).bit_mask & 0x10000000) {
		    {
			_res = _cmCMISFilter(_g, (_CMISFilter  *)&_v31, &((*(_ActionArgument  *)_cdata).filter));
			if (_res)
			    return _res;
		    }
		}
	    }
	    _res = _cmActionInfo(_g, &((*(_ActionArgument  *)_odata).actionInfo), &((*(_ActionArgument  *)_cdata).actionInfo));
	    if (_res)
		return _res;
	} break;
	case 2: {
	    _res = _cmActionResult(_g, (_ActionResult  *)_odata, (_ActionResult  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 3: {
	    _res = _cmAttribute(_g, (_Attribute  *)_odata, (_Attribute  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 4: {
	    _res = _cmAttributeId(_g, (_ActionTypeId  *)_odata, (_ActionTypeId  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 5: {
	    _res = _cmObjectClass(_g, &((*(_BaseManagedObjectId  *)_odata).baseManagedObjectClass), &((*(_BaseManagedObjectId  *)_cdata).baseManagedObjectClass));
	    if (_res)
		return _res;
	    _res = _cmObjectInstance(_g, &((*(_BaseManagedObjectId  *)_odata).baseManagedObjectInstance), &((*(_BaseManagedObjectId  *)_cdata).baseManagedObjectInstance));
	    if (_res)
		return _res;
	} break;
	case 6: {
	    _res = _cmCMISFilter(_g, (_CMISFilter  *)_odata, (_CMISFilter  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 7: {
	    if (*(enum CMISSync  *)_cdata != *(enum CMISSync  *)_odata)
		return 1;
	} break;
	case 8: {
	    if (((*(_ComplexityLimitation  *)_odata).bit_mask ^ (*(_ComplexityLimitation  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_ComplexityLimitation  *)_odata).bit_mask & 0x80000000) {
		_res = _cmScope(_g, &((*(_ComplexityLimitation  *)_odata).scope), &((*(_ComplexityLimitation  *)_cdata).scope));
		if (_res)
		    return _res;
	    }
	    if (((*(_ComplexityLimitation  *)_odata).bit_mask ^ (*(_ComplexityLimitation  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_ComplexityLimitation  *)_odata).bit_mask & 0x40000000) {
		_res = _cmCMISFilter(_g, &((*(_ComplexityLimitation  *)_odata).filter), &((*(_ComplexityLimitation  *)_cdata).filter));
		if (_res)
		    return _res;
	    }
	    if (((*(_ComplexityLimitation  *)_odata).bit_mask ^ (*(_ComplexityLimitation  *)_cdata).bit_mask) & 0x20000000)
		return 1;
	    if ((*(_ComplexityLimitation  *)_odata).bit_mask & 0x20000000) {
		if ((*(_ComplexityLimitation  *)_cdata).sync != (*(_ComplexityLimitation  *)_odata).sync)
		    return 1;
	    }
	} break;
	case 9: {
	    _res = _cmObjectClass(_g, &((*(_CreateArgument  *)_odata).managedObjectClass), &((*(_CreateArgument  *)_cdata).managedObjectClass));
	    if (_res)
		return _res;
	    if (((*(_CreateArgument  *)_odata).bit_mask ^ (*(_CreateArgument  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_CreateArgument  *)_odata).bit_mask & 0x80000000) {
		if (((*(_CreateArgument  *)_odata).managedOrSuperiorObjectInstance).choice != ((*(_CreateArgument  *)_cdata).managedOrSuperiorObjectInstance).choice)
		    return 1;
		switch (((*(_CreateArgument  *)_odata).managedOrSuperiorObjectInstance).choice) {
		    case 1: {
			_res = _cmObjectInstance(_g, ((*(_CreateArgument  *)_odata).managedOrSuperiorObjectInstance).u.managedObjectInstance, ((*(_CreateArgument  *)_cdata).managedOrSuperiorObjectInstance).u.managedObjectInstance);
			if (_res)
			    return _res;
		    }   break;
		    case 2: {
			_res = _cmObjectInstance(_g, ((*(_CreateArgument  *)_odata).managedOrSuperiorObjectInstance).u.superiorObjectInstance, ((*(_CreateArgument  *)_cdata).managedOrSuperiorObjectInstance).u.superiorObjectInstance);
			if (_res)
			    return _res;
		    }   break;
		    case 0:
			break;
		    default:
			return 1;
		}
	    }
	    if (((*(_CreateArgument  *)_odata).bit_mask ^ (*(_CreateArgument  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_CreateArgument  *)_odata).bit_mask & 0x40000000) {
		_res = _cmExternal(_g, &((*(_CreateArgument  *)_odata).accessControl), &((*(_CreateArgument  *)_cdata).accessControl));
		if (_res)
		    return _res;
	    }
	    if (((*(_CreateArgument  *)_odata).bit_mask ^ (*(_CreateArgument  *)_cdata).bit_mask) & 0x20000000)
		return 1;
	    if ((*(_CreateArgument  *)_odata).bit_mask & 0x20000000) {
		_res = _cmObjectInstance(_g, &((*(_CreateArgument  *)_odata).referenceObjectInstance), &((*(_CreateArgument  *)_cdata).referenceObjectInstance));
		if (_res)
		    return _res;
	    }
	    if (((*(_CreateArgument  *)_odata).bit_mask ^ (*(_CreateArgument  *)_cdata).bit_mask) & 0x10000000)
		return 1;
	    if ((*(_CreateArgument  *)_odata).bit_mask & 0x10000000) {
		{
		    _setof3 *  _s_2 = (*(_CreateArgument  *)_odata).attributeList;
		    _setof3 *  _d_2 = (*(_CreateArgument  *)_cdata).attributeList;
		    long        *_a, _i, _i_next, _c = 0L;

		    while (_s_2 && _d_2) {
			++ _c;
			_s_2 = _s_2->next;
			_d_2 = _d_2->next;
		    }
		    if (_s_2 || _d_2)
			return 1;
		    if (_c) {
			_a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
			for (_i = 0; _i < _c; _i ++)
			    _a[_i] = _i;
			_a[_c] = -1L;
			for (_s_2 = (*(_CreateArgument  *)_odata).attributeList; _s_2; _s_2 = _s_2->next) {
			    _i_next = _a[0]; _res = 1;
			    for (_d_2 = (*(_CreateArgument  *)_cdata).attributeList, _i = 0L; _d_2 && _i_next >= 0L && _a[_i_next] >= 0L; _d_2 = _d_2->next,
				    _i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
				if (_i < _i_next)
				    continue;
				_res = _cmAttribute(_g, &(_s_2->value), &(_d_2->value));
				if (_res)
				    continue;
				_res = 0; _a[_i] = _a[_i+1];
				break;
			    }
			    if (_res)
				break;
			}
			_oss_dec_freetempmem(_g, _a);
			if (_res)
			    return _res;
		    }
		}
	    }
	} break;
	case 10: {
	    if (((*(_CreateResult  *)_odata).bit_mask ^ (*(_CreateResult  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_CreateResult  *)_odata).bit_mask & 0x80000000) {
		_res = _cmObjectClass(_g, &((*(_CreateResult  *)_odata).managedObjectClass), &((*(_CreateResult  *)_cdata).managedObjectClass));
		if (_res)
		    return _res;
	    }
	    if (((*(_CreateResult  *)_odata).bit_mask ^ (*(_CreateResult  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_CreateResult  *)_odata).bit_mask & 0x40000000) {
		_res = _cmObjectInstance(_g, &((*(_CreateResult  *)_odata).managedObjectInstance), &((*(_CreateResult  *)_cdata).managedObjectInstance));
		if (_res)
		    return _res;
	    }
	    if (!(*(_CreateResult  *)_odata).currentTime != !(*(_CreateResult  *)_cdata).currentTime)
		return 1;
	    if ((*(_CreateResult  *)_odata).currentTime) {
		if (strcmp((*(_CreateResult  *)_cdata).currentTime, (*(_CreateResult  *)_odata).currentTime))
#ifdef BAD_OID_IRI
		    if (_oss_cmp_str2time((*(_CreateResult  *)_cdata).currentTime, (*(_CreateResult  *)_odata).currentTime, 0))
#endif
			return 1;
	    }
	    if (((*(_CreateResult  *)_odata).bit_mask ^ (*(_CreateResult  *)_cdata).bit_mask) & 0x20000000)
		return 1;
	    if ((*(_CreateResult  *)_odata).bit_mask & 0x20000000) {
		{
		    _setof3 *  _s_2 = (*(_CreateResult  *)_odata).attributeList;
		    _setof3 *  _d_2 = (*(_CreateResult  *)_cdata).attributeList;
		    long        *_a, _i, _i_next, _c = 0L;

		    while (_s_2 && _d_2) {
			++ _c;
			_s_2 = _s_2->next;
			_d_2 = _d_2->next;
		    }
		    if (_s_2 || _d_2)
			return 1;
		    if (_c) {
			_a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
			for (_i = 0; _i < _c; _i ++)
			    _a[_i] = _i;
			_a[_c] = -1L;
			for (_s_2 = (*(_CreateResult  *)_odata).attributeList; _s_2; _s_2 = _s_2->next) {
			    _i_next = _a[0]; _res = 1;
			    for (_d_2 = (*(_CreateResult  *)_cdata).attributeList, _i = 0L; _d_2 && _i_next >= 0L && _a[_i_next] >= 0L; _d_2 = _d_2->next,
				    _i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
				if (_i < _i_next)
				    continue;
				_res = _cmAttribute(_g, &(_s_2->value), &(_d_2->value));
				if (_res)
				    continue;
				_res = 0; _a[_i] = _a[_i+1];
				break;
			    }
			    if (_res)
				break;
			}
			_oss_dec_freetempmem(_g, _a);
			if (_res)
			    return _res;
		    }
		}
	    }
	} break;
	case 11: {
	    _res = _cmObjectClass(_g, &((*(_DeleteArgument  *)_odata).baseManagedObjectClass), &((*(_DeleteArgument  *)_cdata).baseManagedObjectClass));
	    if (_res)
		return _res;
	    _res = _cmObjectInstance(_g, &((*(_DeleteArgument  *)_odata).baseManagedObjectInstance), &((*(_DeleteArgument  *)_cdata).baseManagedObjectInstance));
	    if (_res)
		return _res;
	    if (((*(_DeleteArgument  *)_odata).bit_mask ^ (*(_DeleteArgument  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_DeleteArgument  *)_odata).bit_mask & 0x80000000) {
		_res = _cmExternal(_g, &((*(_DeleteArgument  *)_odata).accessControl), &((*(_DeleteArgument  *)_cdata).accessControl));
		if (_res)
		    return _res;
	    }
	    if (((*(_DeleteArgument  *)_odata).bit_mask & (*(_DeleteArgument  *)_cdata).bit_mask) & 0x40000000) {
		if ((*(_DeleteArgument  *)_cdata).synchronization != (*(_DeleteArgument  *)_odata).synchronization)
		    return 1;
	    } else {
		if ((*(_DeleteArgument  *)_odata).bit_mask & 0x40000000) {
		    if (DeleteArgument::default_synchronization != (*(_DeleteArgument  *)_odata).synchronization)
			return 1;
		}
		if ((*(_DeleteArgument  *)_cdata).bit_mask & 0x40000000) {
		    if ((*(_DeleteArgument  *)_cdata).synchronization != DeleteArgument::default_synchronization)
			return 1;
		}
	    }
	    if (((*(_DeleteArgument  *)_odata).bit_mask & (*(_DeleteArgument  *)_cdata).bit_mask) & 0x20000000) {
		_res = _cmScope(_g, &((*(_DeleteArgument  *)_odata).scope), &((*(_DeleteArgument  *)_cdata).scope));
		if (_res)
		    return _res;
	    } else {
		if ((*(_DeleteArgument  *)_odata).bit_mask & 0x20000000) {
		    {
			_res = _cmScope(_g, &((*(_DeleteArgument  *)_odata).scope), (_Scope  *)&_v32);
			if (_res)
			    return _res;
		    }
		}
		if ((*(_DeleteArgument  *)_cdata).bit_mask & 0x20000000) {
		    {
			_res = _cmScope(_g, (_Scope  *)&_v32, &((*(_DeleteArgument  *)_cdata).scope));
			if (_res)
			    return _res;
		    }
		}
	    }
	    if (((*(_DeleteArgument  *)_odata).bit_mask & (*(_DeleteArgument  *)_cdata).bit_mask) & 0x10000000) {
		_res = _cmCMISFilter(_g, &((*(_DeleteArgument  *)_odata).filter), &((*(_DeleteArgument  *)_cdata).filter));
		if (_res)
		    return _res;
	    } else {
		if ((*(_DeleteArgument  *)_odata).bit_mask & 0x10000000) {
		    {
			_res = _cmCMISFilter(_g, &((*(_DeleteArgument  *)_odata).filter), (_CMISFilter  *)&_v33);
			if (_res)
			    return _res;
		    }
		}
		if ((*(_DeleteArgument  *)_cdata).bit_mask & 0x10000000) {
		    {
			_res = _cmCMISFilter(_g, (_CMISFilter  *)&_v33, &((*(_DeleteArgument  *)_cdata).filter));
			if (_res)
			    return _res;
		    }
		}
	    }
	} break;
	case 12: {
	    _res = _cmDeleteResult(_g, (_DeleteResult  *)_odata, (_DeleteResult  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 13: {
	    _res = _cmObjectClass(_g, &((*(_EventReportArgument  *)_odata).managedObjectClass), &((*(_EventReportArgument  *)_cdata).managedObjectClass));
	    if (_res)
		return _res;
	    _res = _cmObjectInstance(_g, &((*(_EventReportArgument  *)_odata).managedObjectInstance), &((*(_EventReportArgument  *)_cdata).managedObjectInstance));
	    if (_res)
		return _res;
	    if (!(*(_EventReportArgument  *)_odata).eventTime != !(*(_EventReportArgument  *)_cdata).eventTime)
		return 1;
	    if ((*(_EventReportArgument  *)_odata).eventTime) {
		if (strcmp((*(_EventReportArgument  *)_cdata).eventTime, (*(_EventReportArgument  *)_odata).eventTime))
#ifdef BAD_OID_IRI
		    if (_oss_cmp_str2time((*(_EventReportArgument  *)_cdata).eventTime, (*(_EventReportArgument  *)_odata).eventTime, 0))
#endif
			return 1;
	    }
	    _res = _cmEventTypeId(_g, &((*(_EventReportArgument  *)_odata).eventType), &((*(_EventReportArgument  *)_cdata).eventType));
	    if (_res)
		return _res;
	    if (((*(_EventReportArgument  *)_odata).bit_mask ^ (*(_EventReportArgument  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_EventReportArgument  *)_odata).bit_mask & 0x80000000) {
		_res = _oss_cmp_new_open_type(_g, ((*(_EventReportArgument  *)_odata).eventInfo).pduNum, ((*(_EventReportArgument  *)_cdata).eventInfo).pduNum, &(((*(_EventReportArgument  *)_odata).eventInfo).encoded), &(((*(_EventReportArgument  *)_cdata).eventInfo).encoded), *(void **)&(((*(_EventReportArgument  *)_odata).eventInfo).decoded), *(void **)&(((*(_EventReportArgument  *)_cdata).eventInfo).decoded));
		if (_res)
		    return _res;
	    }
	} break;
	case 14: {
	    if (((*(_EventReportResult  *)_odata).bit_mask ^ (*(_EventReportResult  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_EventReportResult  *)_odata).bit_mask & 0x80000000) {
		_res = _cmObjectClass(_g, &((*(_EventReportResult  *)_odata).managedObjectClass), &((*(_EventReportResult  *)_cdata).managedObjectClass));
		if (_res)
		    return _res;
	    }
	    if (((*(_EventReportResult  *)_odata).bit_mask ^ (*(_EventReportResult  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_EventReportResult  *)_odata).bit_mask & 0x40000000) {
		_res = _cmObjectInstance(_g, &((*(_EventReportResult  *)_odata).managedObjectInstance), &((*(_EventReportResult  *)_cdata).managedObjectInstance));
		if (_res)
		    return _res;
	    }
	    if (!(*(_EventReportResult  *)_odata).currentTime != !(*(_EventReportResult  *)_cdata).currentTime)
		return 1;
	    if ((*(_EventReportResult  *)_odata).currentTime) {
		if (strcmp((*(_EventReportResult  *)_cdata).currentTime, (*(_EventReportResult  *)_odata).currentTime))
#ifdef BAD_OID_IRI
		    if (_oss_cmp_str2time((*(_EventReportResult  *)_cdata).currentTime, (*(_EventReportResult  *)_odata).currentTime, 0))
#endif
			return 1;
	    }
	    if (((*(_EventReportResult  *)_odata).bit_mask ^ (*(_EventReportResult  *)_cdata).bit_mask) & 0x20000000)
		return 1;
	    if ((*(_EventReportResult  *)_odata).bit_mask & 0x20000000) {
		_res = _cmEventTypeId(_g, &(((*(_EventReportResult  *)_odata).eventReply).eventType), &(((*(_EventReportResult  *)_cdata).eventReply).eventType));
		if (_res)
		    return _res;
		if ((((*(_EventReportResult  *)_odata).eventReply).bit_mask ^ ((*(_EventReportResult  *)_cdata).eventReply).bit_mask) & 0x80000000)
		    return 1;
		if (((*(_EventReportResult  *)_odata).eventReply).bit_mask & 0x80000000) {
		    _res = _oss_cmp_new_open_type(_g, (((*(_EventReportResult  *)_odata).eventReply).eventReplyInfo).pduNum, (((*(_EventReportResult  *)_cdata).eventReply).eventReplyInfo).pduNum, &((((*(_EventReportResult  *)_odata).eventReply).eventReplyInfo).encoded), &((((*(_EventReportResult  *)_cdata).eventReply).eventReplyInfo).encoded), *(void **)&((((*(_EventReportResult  *)_odata).eventReply).eventReplyInfo).decoded), *(void **)&((((*(_EventReportResult  *)_cdata).eventReply).eventReplyInfo).decoded));
		    if (_res)
			return _res;
		}
	    }
	} break;
	case 15: {
	    _res = _cmObjectClass(_g, &((*(_GetArgument  *)_odata).baseManagedObjectClass), &((*(_GetArgument  *)_cdata).baseManagedObjectClass));
	    if (_res)
		return _res;
	    _res = _cmObjectInstance(_g, &((*(_GetArgument  *)_odata).baseManagedObjectInstance), &((*(_GetArgument  *)_cdata).baseManagedObjectInstance));
	    if (_res)
		return _res;
	    if (((*(_GetArgument  *)_odata).bit_mask ^ (*(_GetArgument  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_GetArgument  *)_odata).bit_mask & 0x80000000) {
		_res = _cmExternal(_g, &((*(_GetArgument  *)_odata).accessControl), &((*(_GetArgument  *)_cdata).accessControl));
		if (_res)
		    return _res;
	    }
	    if (((*(_GetArgument  *)_odata).bit_mask & (*(_GetArgument  *)_cdata).bit_mask) & 0x40000000) {
		if ((*(_GetArgument  *)_cdata).synchronization != (*(_GetArgument  *)_odata).synchronization)
		    return 1;
	    } else {
		if ((*(_GetArgument  *)_odata).bit_mask & 0x40000000) {
		    if (GetArgument::default_synchronization != (*(_GetArgument  *)_odata).synchronization)
			return 1;
		}
		if ((*(_GetArgument  *)_cdata).bit_mask & 0x40000000) {
		    if ((*(_GetArgument  *)_cdata).synchronization != GetArgument::default_synchronization)
			return 1;
		}
	    }
	    if (((*(_GetArgument  *)_odata).bit_mask & (*(_GetArgument  *)_cdata).bit_mask) & 0x20000000) {
		_res = _cmScope(_g, &((*(_GetArgument  *)_odata).scope), &((*(_GetArgument  *)_cdata).scope));
		if (_res)
		    return _res;
	    } else {
		if ((*(_GetArgument  *)_odata).bit_mask & 0x20000000) {
		    {
			_res = _cmScope(_g, &((*(_GetArgument  *)_odata).scope), (_Scope  *)&_v34);
			if (_res)
			    return _res;
		    }
		}
		if ((*(_GetArgument  *)_cdata).bit_mask & 0x20000000) {
		    {
			_res = _cmScope(_g, (_Scope  *)&_v34, &((*(_GetArgument  *)_cdata).scope));
			if (_res)
			    return _res;
		    }
		}
	    }
	    if (((*(_GetArgument  *)_odata).bit_mask & (*(_GetArgument  *)_cdata).bit_mask) & 0x10000000) {
		_res = _cmCMISFilter(_g, &((*(_GetArgument  *)_odata).filter), &((*(_GetArgument  *)_cdata).filter));
		if (_res)
		    return _res;
	    } else {
		if ((*(_GetArgument  *)_odata).bit_mask & 0x10000000) {
		    {
			_res = _cmCMISFilter(_g, &((*(_GetArgument  *)_odata).filter), (_CMISFilter  *)&_v35);
			if (_res)
			    return _res;
		    }
		}
		if ((*(_GetArgument  *)_cdata).bit_mask & 0x10000000) {
		    {
			_res = _cmCMISFilter(_g, (_CMISFilter  *)&_v35, &((*(_GetArgument  *)_cdata).filter));
			if (_res)
			    return _res;
		    }
		}
	    }
	    if (((*(_GetArgument  *)_odata).bit_mask ^ (*(_GetArgument  *)_cdata).bit_mask) & 0x8000000)
		return 1;
	    if ((*(_GetArgument  *)_odata).bit_mask & 0x8000000) {
		{
		    _MissingAttributeValue_PARAMETER *  _s_2 = (*(_GetArgument  *)_odata).attributeIdList;
		    _MissingAttributeValue_PARAMETER *  _d_2 = (*(_GetArgument  *)_cdata).attributeIdList;
		    long        *_a, _i, _i_next, _c = 0L;

		    while (_s_2 && _d_2) {
			++ _c;
			_s_2 = _s_2->next;
			_d_2 = _d_2->next;
		    }
		    if (_s_2 || _d_2)
			return 1;
		    if (_c) {
			_a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
			for (_i = 0; _i < _c; _i ++)
			    _a[_i] = _i;
			_a[_c] = -1L;
			for (_s_2 = (*(_GetArgument  *)_odata).attributeIdList; _s_2; _s_2 = _s_2->next) {
			    _i_next = _a[0]; _res = 1;
			    for (_d_2 = (*(_GetArgument  *)_cdata).attributeIdList, _i = 0L; _d_2 && _i_next >= 0L && _a[_i_next] >= 0L; _d_2 = _d_2->next,
				    _i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
				if (_i < _i_next)
				    continue;
				_res = _cmAttributeId(_g, &(_s_2->value), &(_d_2->value));
				if (_res)
				    continue;
				_res = 0; _a[_i] = _a[_i+1];
				break;
			    }
			    if (_res)
				break;
			}
			_oss_dec_freetempmem(_g, _a);
			if (_res)
			    return _res;
		    }
		}
	    }
	} break;
	case 16: {
	    _res = _cmGetListError(_g, (_GetListError  *)_odata, (_GetListError  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 17: {
	    _res = _cmGetResult(_g, (_CreateResult  *)_odata, (_CreateResult  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 18: {
	    _res = _cmInvalidArgumentValue(_g, (_InvalidArgumentValue  *)_odata, (_InvalidArgumentValue  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 19: {
	    _res = _cmInvokeId(_g, (_InvokeId  *)_odata, (_InvokeId  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 20: {
	    if ((*(_LinkedReplyArgument  *)_odata).choice != (*(_LinkedReplyArgument  *)_cdata).choice)
		return 1;
	    switch ((*(_LinkedReplyArgument  *)_odata).choice) {
		case 1: {
		    _res = _cmGetResult(_g, (*(_LinkedReplyArgument  *)_odata).u.getResult, (*(_LinkedReplyArgument  *)_cdata).u.getResult);
		    if (_res)
			return _res;
		}   break;
		case 2: {
		    _res = _cmGetListError(_g, (*(_LinkedReplyArgument  *)_odata).u.getListError, (*(_LinkedReplyArgument  *)_cdata).u.getListError);
		    if (_res)
			return _res;
		}   break;
		case 3: {
		    _res = _cmSetResult(_g, (*(_LinkedReplyArgument  *)_odata).u.setResult, (*(_LinkedReplyArgument  *)_cdata).u.setResult);
		    if (_res)
			return _res;
		}   break;
		case 4: {
		    _res = _cmSetListError(_g, (*(_LinkedReplyArgument  *)_odata).u.setListError, (*(_LinkedReplyArgument  *)_cdata).u.setListError);
		    if (_res)
			return _res;
		}   break;
		case 5: {
		    _res = _cmActionResult(_g, (*(_LinkedReplyArgument  *)_odata).u.actionResult, (*(_LinkedReplyArgument  *)_cdata).u.actionResult);
		    if (_res)
			return _res;
		}   break;
		case 6: {
		    _res = _cmProcessingFailure(_g, (*(_LinkedReplyArgument  *)_odata).u.processingFailure, (*(_LinkedReplyArgument  *)_cdata).u.processingFailure);
		    if (_res)
			return _res;
		}   break;
		case 7: {
		    _res = _cmDeleteResult(_g, (*(_LinkedReplyArgument  *)_odata).u.deleteResult, (*(_LinkedReplyArgument  *)_cdata).u.deleteResult);
		    if (_res)
			return _res;
		}   break;
		case 8: {
		    if (((*(*(_LinkedReplyArgument  *)_odata).u.actionError).bit_mask ^ (*(*(_LinkedReplyArgument  *)_cdata).u.actionError).bit_mask) & 0x80000000)
			return 1;
		    if ((*(*(_LinkedReplyArgument  *)_odata).u.actionError).bit_mask & 0x80000000) {
			_res = _cmObjectClass(_g, &((*(*(_LinkedReplyArgument  *)_odata).u.actionError).managedObjectClass), &((*(*(_LinkedReplyArgument  *)_cdata).u.actionError).managedObjectClass));
			if (_res)
			    return _res;
		    }
		    if (((*(*(_LinkedReplyArgument  *)_odata).u.actionError).bit_mask ^ (*(*(_LinkedReplyArgument  *)_cdata).u.actionError).bit_mask) & 0x40000000)
			return 1;
		    if ((*(*(_LinkedReplyArgument  *)_odata).u.actionError).bit_mask & 0x40000000) {
			_res = _cmObjectInstance(_g, &((*(*(_LinkedReplyArgument  *)_odata).u.actionError).managedObjectInstance), &((*(*(_LinkedReplyArgument  *)_cdata).u.actionError).managedObjectInstance));
			if (_res)
			    return _res;
		    }
		    if (!(*(*(_LinkedReplyArgument  *)_odata).u.actionError).currentTime != !(*(*(_LinkedReplyArgument  *)_cdata).u.actionError).currentTime)
			return 1;
		    if ((*(*(_LinkedReplyArgument  *)_odata).u.actionError).currentTime) {
			if (strcmp((*(*(_LinkedReplyArgument  *)_cdata).u.actionError).currentTime, (*(*(_LinkedReplyArgument  *)_odata).u.actionError).currentTime))
#ifdef BAD_OID_IRI
			    if (_oss_cmp_str2time((*(*(_LinkedReplyArgument  *)_cdata).u.actionError).currentTime, (*(*(_LinkedReplyArgument  *)_odata).u.actionError).currentTime, 0))
#endif
				return 1;
		    }
		    if (((*(*(_LinkedReplyArgument  *)_cdata).u.actionError).actionErrorInfo).errorStatus != ((*(*(_LinkedReplyArgument  *)_odata).u.actionError).actionErrorInfo).errorStatus)
			return 1;
		    {
			_choice2  * _odata_3 = &(((*(*(_LinkedReplyArgument  *)_odata).u.actionError).actionErrorInfo).errorInfo);
			_choice2  * _cdata_3 = &(((*(*(_LinkedReplyArgument  *)_cdata).u.actionError).actionErrorInfo).errorInfo);

			if ((*_odata_3).choice != (*_cdata_3).choice)
			    return 1;
			switch ((*_odata_3).choice) {
			    case 1: {
				_res = _cmNoSuchArgument(_g, (*_odata_3).u.actionArgument, (*_cdata_3).u.actionArgument);
				if (_res)
				    return _res;
			    }   break;
			    case 2: {
				_res = _cmInvalidArgumentValue(_g, (*_odata_3).u.argumentValue, (*_cdata_3).u.argumentValue);
				if (_res)
				    return _res;
			    }   break;
			    case 3: {
				_res = _cmActionTypeId(_g, (*_odata_3).u.actionType, (*_cdata_3).u.actionType);
				if (_res)
				    return _res;
			    }   break;
			    case 0:
				break;
			    default:
				return 1;
			}
		    }
		}   break;
		case 9: {
		    if (((*(*(_LinkedReplyArgument  *)_odata).u.deleteError).bit_mask ^ (*(*(_LinkedReplyArgument  *)_cdata).u.deleteError).bit_mask) & 0x80000000)
			return 1;
		    if ((*(*(_LinkedReplyArgument  *)_odata).u.deleteError).bit_mask & 0x80000000) {
			_res = _cmObjectClass(_g, &((*(*(_LinkedReplyArgument  *)_odata).u.deleteError).managedObjectClass), &((*(*(_LinkedReplyArgument  *)_cdata).u.deleteError).managedObjectClass));
			if (_res)
			    return _res;
		    }
		    if (((*(*(_LinkedReplyArgument  *)_odata).u.deleteError).bit_mask ^ (*(*(_LinkedReplyArgument  *)_cdata).u.deleteError).bit_mask) & 0x40000000)
			return 1;
		    if ((*(*(_LinkedReplyArgument  *)_odata).u.deleteError).bit_mask & 0x40000000) {
			_res = _cmObjectInstance(_g, &((*(*(_LinkedReplyArgument  *)_odata).u.deleteError).managedObjectInstance), &((*(*(_LinkedReplyArgument  *)_cdata).u.deleteError).managedObjectInstance));
			if (_res)
			    return _res;
		    }
		    if (!(*(*(_LinkedReplyArgument  *)_odata).u.deleteError).currentTime != !(*(*(_LinkedReplyArgument  *)_cdata).u.deleteError).currentTime)
			return 1;
		    if ((*(*(_LinkedReplyArgument  *)_odata).u.deleteError).currentTime) {
			if (strcmp((*(*(_LinkedReplyArgument  *)_cdata).u.deleteError).currentTime, (*(*(_LinkedReplyArgument  *)_odata).u.deleteError).currentTime))
#ifdef BAD_OID_IRI
			    if (_oss_cmp_str2time((*(*(_LinkedReplyArgument  *)_cdata).u.deleteError).currentTime, (*(*(_LinkedReplyArgument  *)_odata).u.deleteError).currentTime, 0))
#endif
				return 1;
		    }
		    if ((*(*(_LinkedReplyArgument  *)_cdata).u.deleteError).deleteErrorInfo != (*(*(_LinkedReplyArgument  *)_odata).u.deleteError).deleteErrorInfo)
			return 1;
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 21: {
	    _res = _cmObjectClass(_g, &((*(_NoSuchAction  *)_odata).managedObjectClass), &((*(_NoSuchAction  *)_cdata).managedObjectClass));
	    if (_res)
		return _res;
	    _res = _cmActionTypeId(_g, &((*(_NoSuchAction  *)_odata).actionType), &((*(_NoSuchAction  *)_cdata).actionType));
	    if (_res)
		return _res;
	} break;
	case 22: {
	    _res = _cmNoSuchArgument(_g, (_NoSuchArgument  *)_odata, (_NoSuchArgument  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 23: {
	    _res = _cmObjectClass(_g, &((*(_NoSuchEventType  *)_odata).managedObjectClass), &((*(_NoSuchEventType  *)_cdata).managedObjectClass));
	    if (_res)
		return _res;
	    _res = _cmEventTypeId(_g, &((*(_NoSuchEventType  *)_odata).eventType), &((*(_NoSuchEventType  *)_cdata).eventType));
	    if (_res)
		return _res;
	} break;
	case 24: {
	    _res = _cmObjectClass(_g, (_ActionTypeId  *)_odata, (_ActionTypeId  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 25: {
	    _res = _cmObjectInstance(_g, (_ObjectInstance  *)_odata, (_ObjectInstance  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 26: {
	    _res = _cmProcessingFailure(_g, (_ProcessingFailure  *)_odata, (_ProcessingFailure  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 27: {
	    _res = _cmScope(_g, (_Scope  *)_odata, (_Scope  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 28: {
	    _res = _cmObjectClass(_g, &((*(_SetArgument  *)_odata).baseManagedObjectClass), &((*(_SetArgument  *)_cdata).baseManagedObjectClass));
	    if (_res)
		return _res;
	    _res = _cmObjectInstance(_g, &((*(_SetArgument  *)_odata).baseManagedObjectInstance), &((*(_SetArgument  *)_cdata).baseManagedObjectInstance));
	    if (_res)
		return _res;
	    if (((*(_SetArgument  *)_odata).bit_mask ^ (*(_SetArgument  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_SetArgument  *)_odata).bit_mask & 0x80000000) {
		_res = _cmExternal(_g, &((*(_SetArgument  *)_odata).accessControl), &((*(_SetArgument  *)_cdata).accessControl));
		if (_res)
		    return _res;
	    }
	    if (((*(_SetArgument  *)_odata).bit_mask & (*(_SetArgument  *)_cdata).bit_mask) & 0x40000000) {
		if ((*(_SetArgument  *)_cdata).synchronization != (*(_SetArgument  *)_odata).synchronization)
		    return 1;
	    } else {
		if ((*(_SetArgument  *)_odata).bit_mask & 0x40000000) {
		    if (SetArgument::default_synchronization != (*(_SetArgument  *)_odata).synchronization)
			return 1;
		}
		if ((*(_SetArgument  *)_cdata).bit_mask & 0x40000000) {
		    if ((*(_SetArgument  *)_cdata).synchronization != SetArgument::default_synchronization)
			return 1;
		}
	    }
	    if (((*(_SetArgument  *)_odata).bit_mask & (*(_SetArgument  *)_cdata).bit_mask) & 0x20000000) {
		_res = _cmScope(_g, &((*(_SetArgument  *)_odata).scope), &((*(_SetArgument  *)_cdata).scope));
		if (_res)
		    return _res;
	    } else {
		if ((*(_SetArgument  *)_odata).bit_mask & 0x20000000) {
		    {
			_res = _cmScope(_g, &((*(_SetArgument  *)_odata).scope), (_Scope  *)&_v36);
			if (_res)
			    return _res;
		    }
		}
		if ((*(_SetArgument  *)_cdata).bit_mask & 0x20000000) {
		    {
			_res = _cmScope(_g, (_Scope  *)&_v36, &((*(_SetArgument  *)_cdata).scope));
			if (_res)
			    return _res;
		    }
		}
	    }
	    if (((*(_SetArgument  *)_odata).bit_mask & (*(_SetArgument  *)_cdata).bit_mask) & 0x10000000) {
		_res = _cmCMISFilter(_g, &((*(_SetArgument  *)_odata).filter), &((*(_SetArgument  *)_cdata).filter));
		if (_res)
		    return _res;
	    } else {
		if ((*(_SetArgument  *)_odata).bit_mask & 0x10000000) {
		    {
			_res = _cmCMISFilter(_g, &((*(_SetArgument  *)_odata).filter), (_CMISFilter  *)&_v37);
			if (_res)
			    return _res;
		    }
		}
		if ((*(_SetArgument  *)_cdata).bit_mask & 0x10000000) {
		    {
			_res = _cmCMISFilter(_g, (_CMISFilter  *)&_v37, &((*(_SetArgument  *)_cdata).filter));
			if (_res)
			    return _res;
		    }
		}
	    }
	    {
		_setof8 *  _s_2 = (*(_SetArgument  *)_odata).modificationList;
		_setof8 *  _d_2 = (*(_SetArgument  *)_cdata).modificationList;
		long        *_a, _i, _i_next, _c = 0L;

		while (_s_2 && _d_2) {
		    ++ _c;
		    _s_2 = _s_2->next;
		    _d_2 = _d_2->next;
		}
		if (_s_2 || _d_2)
		    return 1;
		if (_c) {
		    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
		    for (_i = 0; _i < _c; _i ++)
			_a[_i] = _i;
		    _a[_c] = -1L;
		    for (_s_2 = (*(_SetArgument  *)_odata).modificationList; _s_2; _s_2 = _s_2->next) {
			_i_next = _a[0]; _res = 1;
			for (_d_2 = (*(_SetArgument  *)_cdata).modificationList, _i = 0L; _d_2 && _i_next >= 0L && _a[_i_next] >= 0L; _d_2 = _d_2->next,
				_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
			    if (_i < _i_next)
				continue;
			    if (((_s_2->value).bit_mask & (_d_2->value).bit_mask) & 0x80000000) {
				if ((_d_2->value).modifyOperator != (_s_2->value).modifyOperator)
				    continue;
			    } else {
				if ((_s_2->value).bit_mask & 0x80000000) {
				    if (__seq4::default_modifyOperator != (_s_2->value).modifyOperator)
					continue;
				}
				if ((_d_2->value).bit_mask & 0x80000000) {
				    if ((_d_2->value).modifyOperator != __seq4::default_modifyOperator)
					continue;
				}
			    }
			    _res = _cmAttributeId(_g, &((_s_2->value).attributeId), &((_d_2->value).attributeId));
			    if (_res)
				continue;
			    if (((_s_2->value).bit_mask ^ (_d_2->value).bit_mask) & 0x40000000)
				continue;
			    if ((_s_2->value).bit_mask & 0x40000000) {
				_res = _oss_cmp_new_open_type(_g, ((_s_2->value).attributeValue).pduNum, ((_d_2->value).attributeValue).pduNum, &(((_s_2->value).attributeValue).encoded), &(((_d_2->value).attributeValue).encoded), *(void **)&(((_s_2->value).attributeValue).decoded), *(void **)&(((_d_2->value).attributeValue).decoded));
				if (_res)
				    continue;
			    }
			    _res = 0; _a[_i] = _a[_i+1];
			    break;
			}
			if (_res)
			    break;
		    }
		    _oss_dec_freetempmem(_g, _a);
		    if (_res)
			return _res;
		}
	    }
	} break;
	case 29: {
	    _res = _cmSetListError(_g, (_SetListError  *)_odata, (_SetListError  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 30: {
	    _res = _cmSetResult(_g, (_CreateResult  *)_odata, (_CreateResult  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 31: {
	    if ((*(_ROSEapdus  *)_odata).choice != (*(_ROSEapdus  *)_cdata).choice)
		return 1;
	    switch ((*(_ROSEapdus  *)_odata).choice) {
		case 1: {
		    _res = _cmInvokeId(_g, &(((*(_ROSEapdus  *)_odata).u.invoke)->invokeId), &(((*(_ROSEapdus  *)_cdata).u.invoke)->invokeId));
		    if (_res)
			return _res;
		    if ((((*(_ROSEapdus  *)_odata).u.invoke)->bit_mask ^ ((*(_ROSEapdus  *)_cdata).u.invoke)->bit_mask) & 0x80000000)
			return 1;
		    if (((*(_ROSEapdus  *)_odata).u.invoke)->bit_mask & 0x80000000) {
			if ((((*(_ROSEapdus  *)_odata).u.invoke)->linkedId).choice != (((*(_ROSEapdus  *)_cdata).u.invoke)->linkedId).choice)
			    return 1;
			switch ((((*(_ROSEapdus  *)_odata).u.invoke)->linkedId).choice) {
			    case 1: {
				if ((((*(_ROSEapdus  *)_cdata).u.invoke)->linkedId).u.present != (((*(_ROSEapdus  *)_odata).u.invoke)->linkedId).u.present)
				    return 1;
			    }   break;
			    case 2: {
			    }   break;
			    case 0:
				break;
			    default:
				return 1;
			}
		    }
		    _res = _cmCode(_g, &(((*(_ROSEapdus  *)_odata).u.invoke)->opcode), &(((*(_ROSEapdus  *)_cdata).u.invoke)->opcode));
		    if (_res)
			return _res;
		    if ((((*(_ROSEapdus  *)_odata).u.invoke)->bit_mask ^ ((*(_ROSEapdus  *)_cdata).u.invoke)->bit_mask) & 0x40000000)
			return 1;
		    if (((*(_ROSEapdus  *)_odata).u.invoke)->bit_mask & 0x40000000) {
			_res = _oss_cmp_new_open_type(_g, (((*(_ROSEapdus  *)_odata).u.invoke)->argument).pduNum, (((*(_ROSEapdus  *)_cdata).u.invoke)->argument).pduNum, &((((*(_ROSEapdus  *)_odata).u.invoke)->argument).encoded), &((((*(_ROSEapdus  *)_cdata).u.invoke)->argument).encoded), *(void **)&((((*(_ROSEapdus  *)_odata).u.invoke)->argument).decoded), *(void **)&((((*(_ROSEapdus  *)_cdata).u.invoke)->argument).decoded));
			if (_res)
			    return _res;
		    }
		}   break;
		case 2: {
		    _res = _cmInvokeId(_g, &(((*(_ROSEapdus  *)_odata).u.returnResult)->invokeId), &(((*(_ROSEapdus  *)_cdata).u.returnResult)->invokeId));
		    if (_res)
			return _res;
		    if ((((*(_ROSEapdus  *)_odata).u.returnResult)->bit_mask ^ ((*(_ROSEapdus  *)_cdata).u.returnResult)->bit_mask) & 0x80000000)
			return 1;
		    if (((*(_ROSEapdus  *)_odata).u.returnResult)->bit_mask & 0x80000000) {
			_res = _cmCode(_g, &((((*(_ROSEapdus  *)_odata).u.returnResult)->result).opcode), &((((*(_ROSEapdus  *)_cdata).u.returnResult)->result).opcode));
			if (_res)
			    return _res;
			_res = _oss_cmp_new_open_type(_g, ((((*(_ROSEapdus  *)_odata).u.returnResult)->result).result).pduNum, ((((*(_ROSEapdus  *)_cdata).u.returnResult)->result).result).pduNum, &(((((*(_ROSEapdus  *)_odata).u.returnResult)->result).result).encoded), &(((((*(_ROSEapdus  *)_cdata).u.returnResult)->result).result).encoded), *(void **)&(((((*(_ROSEapdus  *)_odata).u.returnResult)->result).result).decoded), *(void **)&(((((*(_ROSEapdus  *)_cdata).u.returnResult)->result).result).decoded));
			if (_res)
			    return _res;
		    }
		}   break;
		case 3: {
		    _res = _cmInvokeId(_g, &(((*(_ROSEapdus  *)_odata).u.returnError)->invokeId), &(((*(_ROSEapdus  *)_cdata).u.returnError)->invokeId));
		    if (_res)
			return _res;
		    _res = _cmCode(_g, &(((*(_ROSEapdus  *)_odata).u.returnError)->errcode), &(((*(_ROSEapdus  *)_cdata).u.returnError)->errcode));
		    if (_res)
			return _res;
		    if ((((*(_ROSEapdus  *)_odata).u.returnError)->bit_mask ^ ((*(_ROSEapdus  *)_cdata).u.returnError)->bit_mask) & 0x80000000)
			return 1;
		    if (((*(_ROSEapdus  *)_odata).u.returnError)->bit_mask & 0x80000000) {
			_res = _oss_cmp_new_open_type(_g, (((*(_ROSEapdus  *)_odata).u.returnError)->parameter).pduNum, (((*(_ROSEapdus  *)_cdata).u.returnError)->parameter).pduNum, &((((*(_ROSEapdus  *)_odata).u.returnError)->parameter).encoded), &((((*(_ROSEapdus  *)_cdata).u.returnError)->parameter).encoded), *(void **)&((((*(_ROSEapdus  *)_odata).u.returnError)->parameter).decoded), *(void **)&((((*(_ROSEapdus  *)_cdata).u.returnError)->parameter).decoded));
			if (_res)
			    return _res;
		    }
		}   break;
		case 4: {
		    _res = _cmInvokeId(_g, &((*(*(_ROSEapdus  *)_odata).u.reject).invokeId), &((*(*(_ROSEapdus  *)_cdata).u.reject).invokeId));
		    if (_res)
			return _res;
		    if (((*(*(_ROSEapdus  *)_odata).u.reject).problem).choice != ((*(*(_ROSEapdus  *)_cdata).u.reject).problem).choice)
			return 1;
		    switch (((*(*(_ROSEapdus  *)_odata).u.reject).problem).choice) {
			case 1: {
			    if (((*(*(_ROSEapdus  *)_cdata).u.reject).problem).u.general != ((*(*(_ROSEapdus  *)_odata).u.reject).problem).u.general)
				return 1;
			}   break;
			case 2: {
			    if (((*(*(_ROSEapdus  *)_cdata).u.reject).problem).u.invoke != ((*(*(_ROSEapdus  *)_odata).u.reject).problem).u.invoke)
				return 1;
			}   break;
			case 3: {
			    if (((*(*(_ROSEapdus  *)_cdata).u.reject).problem).u.returnResult != ((*(*(_ROSEapdus  *)_odata).u.reject).problem).u.returnResult)
				return 1;
			}   break;
			case 4: {
			    if (((*(*(_ROSEapdus  *)_cdata).u.reject).problem).u.returnError != ((*(*(_ROSEapdus  *)_odata).u.reject).problem).u.returnError)
				return 1;
			}   break;
			case 0:
			    break;
			default:
			    return 1;
		    }
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 32: {
	    if ((*(_CMIPAbortInfo  *)_cdata).abortSource != (*(_CMIPAbortInfo  *)_odata).abortSource)
		return 1;
	    if (((*(_CMIPAbortInfo  *)_odata).bit_mask ^ (*(_CMIPAbortInfo  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_CMIPAbortInfo  *)_odata).bit_mask & 0x80000000) {
		_res = _cmExternal(_g, &((*(_CMIPAbortInfo  *)_odata).userInfo), &((*(_CMIPAbortInfo  *)_cdata).userInfo));
		if (_res)
		    return _res;
	    }
	} break;
	case 33: {
	    if (((*(_CMIPUserInfo  *)_odata).bit_mask & (*(_CMIPUserInfo  *)_cdata).bit_mask) & 0x80000000) {
		if (_oss_cmp_arrbits(((*(_CMIPUserInfo  *)_odata).protocolVersion).value, ((*(_CMIPUserInfo  *)_cdata).protocolVersion).value, ((*(_CMIPUserInfo  *)_odata).protocolVersion).length, ((*(_CMIPUserInfo  *)_cdata).protocolVersion).length))
		    return 1;
	    } else {
		if ((*(_CMIPUserInfo  *)_odata).bit_mask & 0x80000000) {
		    if (_oss_cmp_arrbits(((*(_CMIPUserInfo  *)_odata).protocolVersion).value, (_v38).value, ((*(_CMIPUserInfo  *)_odata).protocolVersion).length, (_v38).length))
			return 1;
		}
		if ((*(_CMIPUserInfo  *)_cdata).bit_mask & 0x80000000) {
		    if (_oss_cmp_arrbits((_v38).value, ((*(_CMIPUserInfo  *)_cdata).protocolVersion).value, (_v38).length, ((*(_CMIPUserInfo  *)_cdata).protocolVersion).length))
			return 1;
		}
	    }
	    if (((*(_CMIPUserInfo  *)_odata).bit_mask & (*(_CMIPUserInfo  *)_cdata).bit_mask) & 0x40000000) {
		if (_oss_cmp_arrbits(((*(_CMIPUserInfo  *)_odata).functionalUnits).value, ((*(_CMIPUserInfo  *)_cdata).functionalUnits).value, ((*(_CMIPUserInfo  *)_odata).functionalUnits).length, ((*(_CMIPUserInfo  *)_cdata).functionalUnits).length))
		    return 1;
	    } else {
		if ((*(_CMIPUserInfo  *)_odata).bit_mask & 0x40000000) {
		    if (_oss_cmp_arrbits(((*(_CMIPUserInfo  *)_odata).functionalUnits).value, (_v40).value, ((*(_CMIPUserInfo  *)_odata).functionalUnits).length, (_v40).length))
			return 1;
		}
		if ((*(_CMIPUserInfo  *)_cdata).bit_mask & 0x40000000) {
		    if (_oss_cmp_arrbits((_v40).value, ((*(_CMIPUserInfo  *)_cdata).functionalUnits).value, (_v40).length, ((*(_CMIPUserInfo  *)_cdata).functionalUnits).length))
			return 1;
		}
	    }
	    if (((*(_CMIPUserInfo  *)_odata).bit_mask ^ (*(_CMIPUserInfo  *)_cdata).bit_mask) & 0x20000000)
		return 1;
	    if ((*(_CMIPUserInfo  *)_odata).bit_mask & 0x20000000) {
		_res = _cmExternal(_g, &((*(_CMIPUserInfo  *)_odata).accessControl), &((*(_CMIPUserInfo  *)_cdata).accessControl));
		if (_res)
		    return _res;
	    }
	    if (((*(_CMIPUserInfo  *)_odata).bit_mask ^ (*(_CMIPUserInfo  *)_cdata).bit_mask) & 0x10000000)
		return 1;
	    if ((*(_CMIPUserInfo  *)_odata).bit_mask & 0x10000000) {
		_res = _cmExternal(_g, &((*(_CMIPUserInfo  *)_odata).userInfo), &((*(_CMIPUserInfo  *)_cdata).userInfo));
		if (_res)
		    return _res;
	    }
	} break;
	case 34: {
	    if (_oss_cmp_arrbits((*(OSSC::COssBitString  *)_odata).value, (*(OSSC::COssBitString  *)_cdata).value, (*(OSSC::COssBitString  *)_odata).length, (*(OSSC::COssBitString  *)_cdata).length))
		return 1;
	} break;
	case 35: {
	    if (_oss_cmp_arrbits((*(OSSC::COssBitString  *)_odata).value, (*(OSSC::COssBitString  *)_cdata).value, (*(OSSC::COssBitString  *)_odata).length, (*(OSSC::COssBitString  *)_cdata).length))
		return 1;
	} break;
	case 36: {
	    if (_oss_cmp_arrbits((*(OSSC::COssBitString  *)_odata).value, (*(OSSC::COssBitString  *)_cdata).value, (*(OSSC::COssBitString  *)_odata).length, (*(OSSC::COssBitString  *)_cdata).length))
		return 1;
	} break;
	case 37: {
	    if (_oss_cmp_arrbits((*(OSSC::COssBitString  *)_odata).value, (*(OSSC::COssBitString  *)_cdata).value, (*(OSSC::COssBitString  *)_odata).length, (*(OSSC::COssBitString  *)_cdata).length))
		return 1;
	} break;
	case 38: {
	    {
		_InvokeldsOutstanding *  _s_1 = *(_InvokeldsOutstanding * *)_odata;
		_InvokeldsOutstanding *  _d_1 = *(_InvokeldsOutstanding * *)_cdata;
		long        *_a, _i, _i_next, _c = 0L;

		while (_s_1 && _d_1) {
		    ++ _c;
		    _s_1 = _s_1->next;
		    _d_1 = _d_1->next;
		}
		if (_s_1 || _d_1)
		    return 1;
		if (_c) {
		    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
		    for (_i = 0; _i < _c; _i ++)
			_a[_i] = _i;
		    _a[_c] = -1L;
		    for (_s_1 = *(_InvokeldsOutstanding * *)_odata; _s_1; _s_1 = _s_1->next) {
			_i_next = _a[0]; _res = 1;
			for (_d_1 = *(_InvokeldsOutstanding * *)_cdata, _i = 0L; _d_1 && _i_next >= 0L && _a[_i_next] >= 0L; _d_1 = _d_1->next,
				_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
			    if (_i < _i_next)
				continue;
			    if (_d_1->value != _s_1->value)
				continue;
			    _res = 0; _a[_i] = _a[_i+1];
			    break;
			}
			if (_res)
			    break;
		    }
		    _oss_dec_freetempmem(_g, _a);
		    if (_res)
			return _res;
		}
	    }
	} break;
	case 39: {
	    {
		_InvokeldsOutstanding *  _s_1 = *(_InvokeldsOutstanding * *)_odata;
		_InvokeldsOutstanding *  _d_1 = *(_InvokeldsOutstanding * *)_cdata;
		long        *_a, _i, _i_next, _c = 0L;

		while (_s_1 && _d_1) {
		    ++ _c;
		    _s_1 = _s_1->next;
		    _d_1 = _d_1->next;
		}
		if (_s_1 || _d_1)
		    return 1;
		if (_c) {
		    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
		    for (_i = 0; _i < _c; _i ++)
			_a[_i] = _i;
		    _a[_c] = -1L;
		    for (_s_1 = *(_InvokeldsOutstanding * *)_odata; _s_1; _s_1 = _s_1->next) {
			_i_next = _a[0]; _res = 1;
			for (_d_1 = *(_InvokeldsOutstanding * *)_cdata, _i = 0L; _d_1 && _i_next >= 0L && _a[_i_next] >= 0L; _d_1 = _d_1->next,
				_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
			    if (_i < _i_next)
				continue;
			    if (_d_1->value != _s_1->value)
				continue;
			    _res = 0; _a[_i] = _a[_i+1];
			    break;
			}
			if (_res)
			    break;
		    }
		    _oss_dec_freetempmem(_g, _a);
		    if (_res)
			return _res;
		}
	    }
	} break;
	case 40: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 41: {
	    if (_oss_cmp_arrbits((*(OSSC::COssBitString  *)_odata).value, (*(OSSC::COssBitString  *)_cdata).value, (*(OSSC::COssBitString  *)_odata).length, (*(OSSC::COssBitString  *)_cdata).length))
		return 1;
	} break;
	case 42: {
	    {
		_SmaseFunctionalUnits *  _s_1 = *(_SmaseFunctionalUnits * *)_odata;
		_SmaseFunctionalUnits *  _d_1 = *(_SmaseFunctionalUnits * *)_cdata;
		long        *_a, _i, _i_next, _c = 0L;

		while (_s_1 && _d_1) {
		    ++ _c;
		    _s_1 = _s_1->next;
		    _d_1 = _d_1->next;
		}
		if (_s_1 || _d_1)
		    return 1;
		if (_c) {
		    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
		    for (_i = 0; _i < _c; _i ++)
			_a[_i] = _i;
		    _a[_c] = -1L;
		    for (_s_1 = *(_SmaseFunctionalUnits * *)_odata; _s_1; _s_1 = _s_1->next) {
			_i_next = _a[0]; _res = 1;
			for (_d_1 = *(_SmaseFunctionalUnits * *)_cdata, _i = 0L; _d_1 && _i_next >= 0L && _a[_i_next] >= 0L; _d_1 = _d_1->next,
				_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
			    if (_i < _i_next)
				continue;
			    _res = _cmFunctionalUnitPackage(_g, &(_s_1->value), &(_d_1->value));
			    if (_res)
				continue;
			    _res = 0; _a[_i] = _a[_i+1];
			    break;
			}
			if (_res)
			    break;
		    }
		    _oss_dec_freetempmem(_g, _a);
		    if (_res)
			return _res;
		}
	    }
	} break;
	case 43: {
	    if ((*(_SmUserInfoSent  *)_odata).choice != (*(_SmUserInfoSent  *)_cdata).choice)
		return 1;
	    switch ((*(_SmUserInfoSent  *)_odata).choice) {
		case 1: {
		}   break;
		case 2: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_SmUserInfoSent  *)_odata).u.informationSent), &((*(_SmUserInfoSent  *)_cdata).u.informationSent), sizeof(((*(_SmUserInfoSent  *)_cdata).u.informationSent).length), sizeof(((*(_SmUserInfoSent  *)_cdata).u.informationSent).value[0]), (unsigned int)((char *)&((*(_SmUserInfoSent  *)_odata).u.informationSent).value - (char *)&((*(_SmUserInfoSent  *)_odata).u.informationSent))))
			return 1;
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 44: {
	    if ((*(_SmUserInfoReceived  *)_odata).choice != (*(_SmUserInfoReceived  *)_cdata).choice)
		return 1;
	    switch ((*(_SmUserInfoReceived  *)_odata).choice) {
		case 1: {
		}   break;
		case 2: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_SmUserInfoReceived  *)_odata).u.informationReceived), &((*(_SmUserInfoReceived  *)_cdata).u.informationReceived), sizeof(((*(_SmUserInfoReceived  *)_cdata).u.informationReceived).length), sizeof(((*(_SmUserInfoReceived  *)_cdata).u.informationReceived).value[0]), (unsigned int)((char *)&((*(_SmUserInfoReceived  *)_odata).u.informationReceived).value - (char *)&((*(_SmUserInfoReceived  *)_odata).u.informationReceived))))
			return 1;
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 45: {
	    _res = _cmInvokeId(_g, (_InvokeId  *)_odata, (_InvokeId  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 46: {
	    _res = _cmInvokeId(_g, (_InvokeId  *)_odata, (_InvokeId  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 47: {
	    if (((*(_SMASEUserData  *)_odata).bit_mask ^ (*(_SMASEUserData  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_SMASEUserData  *)_odata).bit_mask & 0x80000000) {
		{
		    _SmaseFunctionalUnits *  _s_2 = (*(_SMASEUserData  *)_odata).smfuPackages;
		    _SmaseFunctionalUnits *  _d_2 = (*(_SMASEUserData  *)_cdata).smfuPackages;
		    long        *_a, _i, _i_next, _c = 0L;

		    while (_s_2 && _d_2) {
			++ _c;
			_s_2 = _s_2->next;
			_d_2 = _d_2->next;
		    }
		    if (_s_2 || _d_2)
			return 1;
		    if (_c) {
			_a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
			for (_i = 0; _i < _c; _i ++)
			    _a[_i] = _i;
			_a[_c] = -1L;
			for (_s_2 = (*(_SMASEUserData  *)_odata).smfuPackages; _s_2; _s_2 = _s_2->next) {
			    _i_next = _a[0]; _res = 1;
			    for (_d_2 = (*(_SMASEUserData  *)_cdata).smfuPackages, _i = 0L; _d_2 && _i_next >= 0L && _a[_i_next] >= 0L; _d_2 = _d_2->next,
				    _i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
				if (_i < _i_next)
				    continue;
				_res = _cmFunctionalUnitPackage(_g, &(_s_2->value), &(_d_2->value));
				if (_res)
				    continue;
				_res = 0; _a[_i] = _a[_i+1];
				break;
			    }
			    if (_res)
				break;
			}
			_oss_dec_freetempmem(_g, _a);
			if (_res)
			    return _res;
		    }
		}
	    }
	    if (((*(_SMASEUserData  *)_odata).bit_mask ^ (*(_SMASEUserData  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_SMASEUserData  *)_odata).bit_mask & 0x40000000) {
		if ((*(_SMASEUserData  *)_cdata).reason != (*(_SMASEUserData  *)_odata).reason)
		    return 1;
	    }
	    if (((*(_SMASEUserData  *)_odata).bit_mask ^ (*(_SMASEUserData  *)_cdata).bit_mask) & 0x20000000)
		return 1;
	    if ((*(_SMASEUserData  *)_odata).bit_mask & 0x20000000) {
		if (_oss_cmp_unbnd_octet_ia(&((*(_SMASEUserData  *)_odata).systemsManagementUserInformation), &((*(_SMASEUserData  *)_cdata).systemsManagementUserInformation), sizeof(((*(_SMASEUserData  *)_cdata).systemsManagementUserInformation).length), sizeof(((*(_SMASEUserData  *)_cdata).systemsManagementUserInformation).value[0]), (unsigned int)((char *)&((*(_SMASEUserData  *)_odata).systemsManagementUserInformation).value - (char *)&((*(_SMASEUserData  *)_odata).systemsManagementUserInformation))))
		    return 1;
	    }
	} break;
	case 48: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 49: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 50: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 51: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 52: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 53: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 54: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 55: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 56: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 57: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 58: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 59: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 60: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 61: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 62: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 63: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 64: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 65: {
	    {
		_MissingAttributeValue_PARAMETER *  _s_1 = *(_MissingAttributeValue_PARAMETER * *)_odata;
		_MissingAttributeValue_PARAMETER *  _d_1 = *(_MissingAttributeValue_PARAMETER * *)_cdata;
		long        *_a, _i, _i_next, _c = 0L;

		while (_s_1 && _d_1) {
		    ++ _c;
		    _s_1 = _s_1->next;
		    _d_1 = _d_1->next;
		}
		if (_s_1 || _d_1)
		    return 1;
		if (_c) {
		    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
		    for (_i = 0; _i < _c; _i ++)
			_a[_i] = _i;
		    _a[_c] = -1L;
		    for (_s_1 = *(_MissingAttributeValue_PARAMETER * *)_odata; _s_1; _s_1 = _s_1->next) {
			_i_next = _a[0]; _res = 1;
			for (_d_1 = *(_MissingAttributeValue_PARAMETER * *)_cdata, _i = 0L; _d_1 && _i_next >= 0L && _a[_i_next] >= 0L; _d_1 = _d_1->next,
				_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
			    if (_i < _i_next)
				continue;
			    _res = _cmAttributeId(_g, &(_s_1->value), &(_d_1->value));
			    if (_res)
				continue;
			    _res = 0; _a[_i] = _a[_i+1];
			    break;
			}
			if (_res)
			    break;
		    }
		    _oss_dec_freetempmem(_g, _a);
		    if (_res)
			return _res;
		}
	    }
	} break;
	case 66: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 67: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 68: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 69: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 70: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 71: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 72: {
	    if (*(OSS_UINT32  *)_cdata != *(OSS_UINT32  *)_odata)
		return 1;
	} break;
	case 73: {
	    _res = _cmRealizationParameter(_g, (_RealizationParameter  *)_odata, (_RealizationParameter  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 74: {
	    _res = _cmRealizationParameter(_g, (_RealizationParameter  *)_odata, (_RealizationParameter  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 75: {
	    _res = _cmRealizationParameter(_g, (_RealizationParameter  *)_odata, (_RealizationParameter  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 76: {
	    _res = _cmRealizationParameter(_g, (_RealizationParameter  *)_odata, (_RealizationParameter  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 77: {
	    _res = _cmRealizationParameter(_g, (_RealizationParameter  *)_odata, (_RealizationParameter  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 78: {
	    _res = _cmRealizationParameter(_g, (_RealizationParameter  *)_odata, (_RealizationParameter  *)_cdata);
	    if (_res)
		return _res;
	} break;
	default:
	    return PDU_RANGE;
    }
    return _res;
}
#endif /* OSS_COMPARE_VALUE */

int _oss_cmp_new_open_type (OssGlobal *_g, int _pduNum1, int _pduNum2,
		OssBuf *_obuf1, OssBuf *_obuf2, void *_decoded1, void *_decoded2)
{
    unsigned long   apiFlags = _g->decodingFlags | _g->encodingFlags;

    if (!(apiFlags & DONT_DO_DECODED) && (_decoded1 || _decoded2)) {
	if (!_decoded1 || !_decoded2 || _pduNum1 != _pduNum2 || _pduNum1 == 0)
	    return VALUES_NOT_EQUAL;
#ifdef OSS_COMPARE_VALUE
	if (_CMSMASE_A_ASSOCIATE_Informatio(_g, _pduNum1, _decoded1, _decoded2))
	    return VALUES_NOT_EQUAL;
#else
	_oss_toed_error(_g, _cmp_code_not_linked, NULL);
#endif
    } else if (!(apiFlags & DONT_DO_ENCODED) && (_obuf1->value || _obuf2->value)) {
	if (!_obuf1->value || !_obuf2->value || _obuf1->length != _obuf2->length ||
		memcmp(_obuf1->value, _obuf2->value, _obuf1->length))
	    return VALUES_NOT_EQUAL;
    }

    return VALUES_EQUAL;
}
/* Entry points */
static const _entry_point_struct _entry_points = {_ossinit_SMASE_A_ASSOCIATE_Information, _emSMASE_A_ASSOCIATE_Informatio, _dmSMASE_A_ASSOCIATE_Informatio, 
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
_fmSMASE_A_ASSOCIATE_Informatio,
#else
NULL, 
#endif
117,
_peSMASE_A_ASSOCIATE_Informatio, _pdSMASE_A_ASSOCIATE_Informatio, 116, 0, NULL,
#ifdef OSSPRINT
_pmSMASE_A_ASSOCIATE_Informatio
#else
NULL
#endif
};
static void _oss_post_init(struct ossGlobal *world) {
    static const unsigned char _oss_typeinfo[] = {
        0x00, 0x4d, 0x34, 0x09, 0x80, 0xab, 0x48, 0x10, 0xda, 0x78,
        0x64, 0x12, 0xda, 0x7b, 0x64, 0x9e, 0x0e, 0x7d, 0xd8, 0x36,
        0x8d, 0xe3, 0x71, 0xf1, 0x70, 0x60, 0x57, 0xf5, 0x3c, 0x1e,
        0x30, 0x88, 0x1b, 0xfb, 0xeb, 0x95, 0x69, 0xb1, 0xb6, 0x9e,
        0xd6, 0xc4, 0x5b, 0x84, 0xb4, 0x29, 0x08, 0x56, 0xb7, 0x5b,
        0xd3, 0x6a, 0x11, 0x97, 0x9f, 0x41, 0x51, 0x62, 0xc5, 0x0d,
        0x2b, 0x00, 0xb8, 0x2c, 0x62, 0xf2, 0xcf, 0xf0, 0x62, 0x9a,
        0x9c, 0xd6, 0x5d, 0x58, 0x84, 0x71, 0xde, 0xab, 0x5a
    };
    ossInitRootContext1(world, (unsigned char *)_oss_typeinfo);
}

} /* extern "C" */

void *SMASE_A_ASSOCIATE_Information_TableType::internal = (void *)&_entry_points;
} // namespace CMIP
