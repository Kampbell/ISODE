/*************************************************************/
/* Copyright (C) 2015 OSS Nokalva, Inc.  All rights reserved.*/
/*************************************************************/

/* THIS FILE IS PROPRIETARY MATERIAL OF OSS NOKALVA, INC.
 * AND MAY BE USED ONLY BY DIRECT LICENSEES OF OSS NOKALVA, INC.
 * THIS FILE MAY NOT BE DISTRIBUTED. */

/* This file was generated by a TRIAL version of the OSS ASN.1 Tools.
 * Applications built using this file can be executed only on the machine
 * on which you run the OSS ASN.1 compiler. */

/* Generated for: Kampbell (Trial), License: 70040Z. */
/* Abstract syntax: UpperBounds */
/* Created: Sat Jan 03 14:51:23 2015 */
/* ASN.1/C++ compiler version: 6.0 */
/* Code generated for runtime version 6.0 or later */
/* Compiler operating system: Windows */
/* Compiler machine type: Intel x86 */
/* Target operating system: Windows */
/* Target machine type: Intel x86 */
/* C++ compiler options required: -Zp8 (Microsoft) */
/* ASN.1 compiler options and file names specified:
 * -output Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/csn\ASN -modlistingfile
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/csn\ASN.lst -gendirectives
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/csn\ASN.gen -warningmessages
 * -informatorymessages -2008 -per -ber -der -root -messageFormat msvc
 * -namespace ASN -allow universaltags
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/asn/ACSE-1.asn
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/asn/ISO8823-PRESENTATION.asn
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/asn/Reliable-Transfer-APDU.asn
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/asn/Remote-Operations-Abstract-Syntaxes.asn
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/asn/Remote-Operations-Generic-ROS-PDUs.asn
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/asn/Remote-Operations-Information-Objects.asn
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/asn/Remote-Operations-Information-Objects-extensions.asn
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/asn/Remote-Operations-Realizations.asn
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/asn/Remote-Operations-Useful-Definitions.asn
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/asn/SelectedAttributeTypes.asn
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/asn/UsefulDefinitions.asn
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/asn/InformationFramework.asn
 * Z:/git/ISO.ITU.OSI/cpp/src/iso/itu/osi/asn1/asn/UpperBounds.asn
 */

#define OSS_COMPILER_API_LEVEL 31
#define _OSS_CODE_FILE
#define OSS_TOED_BER
#define OSS_TOED_PER
#include "ASN.h"
#include "string.h"

#include "osstype.h"

#if OSSDEBUG > 1
#define OSS_CNTX_INIT _Context_Element _element;  _element._occurrence = 0;
#define OSS_CNTX_INITZERO _Context_Element _element = {nullptr, nullptr, 0};
#define OSS_CNTX_ZEROOCC  _element._occurrence = 0;
#define OSS_CNTX_INCOCC  _element._occurrence++;
#define OSS_CNTX_SETOCC(OCC) _element._occurrence = OCC;
#define OSS_CNTX_DEF _Context_Element _element;
#define OSS_CNTX_POP(OSSCNAME) OSSCNAME->_oss_context_anchor._last = _element._parent;
#define OSS_CNTX_PUSH(OSSCNAME,CNTXID) _element._id = (_Context_Id *)&_context_id[CNTXID];\
    _element._parent = OSSCNAME->_oss_context_anchor._last;\
    OSSCNAME->_oss_context_anchor._last = &_element;
#define OSS_CNTX_SET(CNTXID) _element._id = (_Context_Id *)&_context_id[CNTXID];
#define OSS_CNTX_NEW(OSSCNAME,CNTXID) _Context_Element _element;\
    _element._occurrence = 0;\
    _element._id = (_Context_Id *)&_context_id[CNTXID];\
    _element._parent = OSSCNAME->_oss_context_anchor._last;\
    OSSCNAME->_oss_context_anchor._last = &_element;
#define OSS_CNTX_ANCHOR_SET(PDU,CNTXID) \
    _element._parent = _oss_c->_oss_context_anchor._last;\
    _element._id = (_Context_Id *)&_context_id[CNTXID];\
    _oss_c->_oss_context_anchor._last = &_element;\
    if (!_oss_c->_oss_context_anchor._pdu_number) {\
        _oss_c->_oss_context_anchor._pdu_number = PDU;\
        _oss_c->_oss_context_anchor._pdu_id = _element._id;\
    }
#define OSS_CNTX_OSSC_DEF _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#else
#define OSS_CNTX_INIT
#define OSS_CNTX_INITZERO
#define OSS_CNTX_ZEROOCC
#define OSS_CNTX_INCOCC
#define OSS_CNTX_SETOCC(OCC)
#define OSS_CNTX_DEF
#define OSS_CNTX_POP(OSSCNAME)
#define OSS_CNTX_PUSH(OSSCNAME,CNTXID)
#define OSS_CNTX_SET(CNTXID)
#define OSS_CNTX_NEW(OSSCNAME,CNTXID)
#define OSS_CNTX_ANCHOR_SET(PDU,CNTXID) _oss_c->_oss_context_anchor._pdu_number = 0;
#endif
using namespace ASN;
namespace ASN {

/* Control table object */

class UpperBounds_TableType : public OssControlTable {
public:
    static void *internal;
    UpperBounds_TableType();
    int destroy(void *data, OssTypeIndex typeindex);
    int copy(void *src, void **dst, OssTypeIndex typeindex);
    int equal(void *data1, void *data2, OssTypeIndex typeindex);
};

UpperBounds_TableType::UpperBounds_TableType() : OssControlTable(internal) {
}

int UpperBounds_TableType::destroy(void *data, OssTypeIndex typeindex) {
    switch (typeindex) {
	case 1:
	    delete (OssEncOID *)data;
	    break;
	case 2:
	    delete (ACSE_apdu *)data;
	    break;
	case 3:
	    delete (AE_title *)data;
	    break;
	case 4:
	    delete (CP_type *)data;
	    break;
	case 5:
	    delete (CPC_type *)data;
	    break;
	case 6:
	    delete (CPA_PPDU *)data;
	    break;
	case 7:
	    delete (CPR_PPDU *)data;
	    break;
	case 8:
	    delete (Abort_type *)data;
	    break;
	case 9:
	    delete (Typed_data_type *)data;
	    break;
	case 10:
	    delete (RS_PPDU *)data;
	    break;
	case 11:
	    delete (RSA_PPDU *)data;
	    break;
	case 12:
	    delete (Reliable_Transfer_APDU_RTSE_apdus *)data;
	    break;
	case 13:
	    delete (Remote_Operations_Abstract_Syntaxes_RTSE_apdus *)data;
	    break;
	case 14:
	    delete (ROSEInvokeIds *)data;
	    break;
	case 15:
	    delete (Reject *)data;
	    break;
	case 16:
	    delete (NoInvokeId *)data;
	    break;
	case 17:
	    delete (UnboundedDirectoryString *)data;
	    break;
	case 18:
	    delete (UniqueIdentifier *)data;
	    break;
	case 19:
	    delete (UUIDPair *)data;
	    break;
	case 20:
	    delete (CountryName *)data;
	    break;
	case 21:
	    delete (Guide *)data;
	    break;
	case 22:
	    delete (EnhancedGuide *)data;
	    break;
	case 23:
	    delete (PostalAddress *)data;
	    break;
	case 24:
	    delete (TelephoneNumber *)data;
	    break;
	case 25:
	    delete (TelexNumber *)data;
	    break;
	case 26:
	    delete (X121Address *)data;
	    break;
	case 27:
	    delete (InternationalISDNNumber *)data;
	    break;
	case 28:
	    delete (DestinationIndicator *)data;
	    break;
	case 29:
	    delete (CommunicationsService *)data;
	    break;
	case 30:
	    delete (CommunicationsNetwork *)data;
	    break;
	case 31:
	    delete (PreferredDeliveryMethod *)data;
	    break;
	case 32:
	    delete (PresentationAddress *)data;
	    break;
	case 33:
	    delete (ProtocolInformation *)data;
	    break;
	case 34:
	    delete (NameAndOptionalUID *)data;
	    break;
	case 35:
	    delete (MultipleMatchingLocalities *)data;
	    break;
	case 36:
	    delete (SubstringAssertion *)data;
	    break;
	case 37:
	    delete (CaseIgnoreList *)data;
	    break;
	case 38:
	    delete (OctetSubstringAssertion *)data;
	    break;
	case 39:
	    asn1Free(data);
	    break;
	case 40:
	    asn1Free(data);
	    break;
	case 41:
	    asn1Free(data);
	    break;
	case 42:
	    delete (LanguageContextSyntax *)data;
	    break;
	case 43:
	    delete (TimeSpecification *)data;
	    break;
	case 44:
	    delete (TimeAssertion *)data;
	    break;
	case 45:
	    delete (LocaleContextSyntax *)data;
	    break;
	case 46:
	    delete (AttributeOptionList *)data;
	    break;
	case 47:
	    delete (ID *)data;
	    break;
	case 48:
	    delete (AttributeValue *)data;
	    break;
	case 49:
	    delete (ContextAssertion *)data;
	    break;
	case 50:
	    delete (AttributeTypeAssertion *)data;
	    break;
	case 51:
	    delete (DistinguishedName *)data;
	    break;
	case 52:
	    delete (SubtreeSpecification *)data;
	    break;
	case 53:
	    delete (DITStructureRule *)data;
	    break;
	case 54:
	    delete (DITContentRule *)data;
	    break;
	case 55:
	    delete (DITContextUse *)data;
	    break;
	case 56:
	    asn1Free(data);
	    break;
	case 57:
	    asn1Free(data);
	    break;
	case 58:
	    delete (Acse_RealizationParameter *)data;
	    break;
	case 59:
	    delete (Acse_with_concatenation_RealizationParameter *)data;
	    break;
	case 60:
	    delete (Association_by_RTSE_RealizationParameter *)data;
	    break;
	case 61:
	    delete (PData_RealizationParameter *)data;
	    break;
	case 62:
	    delete (PData_with_concatenation_RealizationParameter *)data;
	    break;
	case 63:
	    delete (Transfer_by_RTSE_RealizationParameter *)data;
	    break;
	case 64:
	    delete (BitStringMatch_SYNTAX *)data;
	    break;
	case 65:
	    delete (DnQualifier_WITH_SYNTAX *)data;
	    break;
	case 66:
	    delete (SerialNumber_WITH_SYNTAX *)data;
	    break;
	case 67:
	    delete (NumericStringMatch_SYNTAX *)data;
	    break;
	case 68:
	    delete (ProtocolInformationMatch_SYNTAX *)data;
	    break;
	case 69:
	    delete (UiiInUrn_WITH_SYNTAX *)data;
	    break;
	case 70:
	    delete (NumericStringOrderingMatch_SYNTAX *)data;
	    break;
	case 71:
	    asn1Free(data);
	    break;
	case 72:
	    asn1Free(data);
	    break;
	case 73:
	    asn1Free(data);
	    break;
	case 74:
	    delete (OctetStringMatch_SYNTAX *)data;
	    break;
	case 75:
	    delete (OctetStringOrderingMatch_SYNTAX *)data;
	    break;
	case 76:
	    delete (UTCTimeMatch_SYNTAX *)data;
	    break;
	case 77:
	    delete (UTCTimeOrderingMatch_SYNTAX *)data;
	    break;
	case 78:
	    delete (GeneralizedTimeMatch_SYNTAX *)data;
	    break;
	case 79:
	    delete (GeneralizedTimeOrderingMatch_SYNTAX *)data;
	    break;
	case 80:
	    asn1Free(data);
	    break;
	case 81:
	    delete (AdministrativeRole_WITH_SYNTAX *)data;
	    break;
	case 82:
	    delete (CreateTimestamp_WITH_SYNTAX *)data;
	    break;
	case 83:
	    delete (ModifyTimestamp_WITH_SYNTAX *)data;
	    break;
	case 84:
	    delete (SubschemaTimestamp_WITH_SYNTAX *)data;
	    break;
	case 85:
	    asn1Free(data);
	    break;
	default:
	    return oss_call_error(OSS_UNKNOWN_TYPE);
    }
    return 0;
}

int UpperBounds_TableType::copy(void *src, void **dst, OssTypeIndex typeindex) {
    switch (typeindex) {
	case 1:
	    *dst = new OssEncOID(*(OssEncOID *)src);
	    break;
	case 2:
	    *dst = new ACSE_apdu(*(ACSE_apdu *)src);
	    break;
	case 3:
	    *dst = new AE_title(*(AE_title *)src);
	    break;
	case 4:
	    *dst = new CP_type(*(CP_type *)src);
	    break;
	case 5:
	    *dst = new CPC_type(*(CPC_type *)src);
	    break;
	case 6:
	    *dst = new CPA_PPDU(*(CPA_PPDU *)src);
	    break;
	case 7:
	    *dst = new CPR_PPDU(*(CPR_PPDU *)src);
	    break;
	case 8:
	    *dst = new Abort_type(*(Abort_type *)src);
	    break;
	case 9:
	    *dst = new Typed_data_type(*(Typed_data_type *)src);
	    break;
	case 10:
	    *dst = new RS_PPDU(*(RS_PPDU *)src);
	    break;
	case 11:
	    *dst = new RSA_PPDU(*(RSA_PPDU *)src);
	    break;
	case 12:
	    *dst = new Reliable_Transfer_APDU_RTSE_apdus(*(Reliable_Transfer_APDU_RTSE_apdus *)src);
	    break;
	case 13:
	    *dst = new Remote_Operations_Abstract_Syntaxes_RTSE_apdus(*(Remote_Operations_Abstract_Syntaxes_RTSE_apdus *)src);
	    break;
	case 14:
	    *dst = new ROSEInvokeIds(*(ROSEInvokeIds *)src);
	    break;
	case 15:
	    *dst = new Reject(*(Reject *)src);
	    break;
	case 16:
	    *dst = new NoInvokeId(*(NoInvokeId *)src);
	    break;
	case 17:
	    *dst = new UnboundedDirectoryString(*(UnboundedDirectoryString *)src);
	    break;
	case 18:
	    *dst = new UniqueIdentifier(*(UniqueIdentifier *)src);
	    break;
	case 19:
	    *dst = new UUIDPair(*(UUIDPair *)src);
	    break;
	case 20:
	    *dst = new CountryName(*(CountryName *)src);
	    break;
	case 21:
	    *dst = new Guide(*(Guide *)src);
	    break;
	case 22:
	    *dst = new EnhancedGuide(*(EnhancedGuide *)src);
	    break;
	case 23:
	    *dst = new PostalAddress(*(PostalAddress *)src);
	    break;
	case 24:
	    *dst = new TelephoneNumber(*(TelephoneNumber *)src);
	    break;
	case 25:
	    *dst = new TelexNumber(*(TelexNumber *)src);
	    break;
	case 26:
	    *dst = new X121Address(*(X121Address *)src);
	    break;
	case 27:
	    *dst = new InternationalISDNNumber(*(InternationalISDNNumber *)src);
	    break;
	case 28:
	    *dst = new DestinationIndicator(*(DestinationIndicator *)src);
	    break;
	case 29:
	    *dst = new CommunicationsService(*(CommunicationsService *)src);
	    break;
	case 30:
	    *dst = new CommunicationsNetwork(*(CommunicationsNetwork *)src);
	    break;
	case 31:
	    *dst = new PreferredDeliveryMethod(*(PreferredDeliveryMethod *)src);
	    break;
	case 32:
	    *dst = new PresentationAddress(*(PresentationAddress *)src);
	    break;
	case 33:
	    *dst = new ProtocolInformation(*(ProtocolInformation *)src);
	    break;
	case 34:
	    *dst = new NameAndOptionalUID(*(NameAndOptionalUID *)src);
	    break;
	case 35:
	    *dst = new MultipleMatchingLocalities(*(MultipleMatchingLocalities *)src);
	    break;
	case 36:
	    *dst = new SubstringAssertion(*(SubstringAssertion *)src);
	    break;
	case 37:
	    *dst = new CaseIgnoreList(*(CaseIgnoreList *)src);
	    break;
	case 38:
	    *dst = new OctetSubstringAssertion(*(OctetSubstringAssertion *)src);
	    break;
	case 39:
	    *dst = osscppMalloc(sizeof(SequenceMatchType));
	    if (*dst)
		**(SequenceMatchType **)dst = *(SequenceMatchType *)src;
	    break;
	case 40:
	    *dst = osscppMalloc(sizeof(WordMatchTypes));
	    if (*dst)
		**(WordMatchTypes **)dst = *(WordMatchTypes *)src;
	    break;
	case 41:
	    *dst = osscppMalloc(sizeof(CharacterMatchTypes));
	    if (*dst)
		**(CharacterMatchTypes **)dst = *(CharacterMatchTypes *)src;
	    break;
	case 42:
	    *dst = new LanguageContextSyntax(*(LanguageContextSyntax *)src);
	    break;
	case 43:
	    *dst = new TimeSpecification(*(TimeSpecification *)src);
	    break;
	case 44:
	    *dst = new TimeAssertion(*(TimeAssertion *)src);
	    break;
	case 45:
	    *dst = new LocaleContextSyntax(*(LocaleContextSyntax *)src);
	    break;
	case 46:
	    *dst = new AttributeOptionList(*(AttributeOptionList *)src);
	    break;
	case 47:
	    *dst = new ID(*(ID *)src);
	    break;
	case 48:
	    *dst = new AttributeValue(*(AttributeValue *)src);
	    break;
	case 49:
	    *dst = new ContextAssertion(*(ContextAssertion *)src);
	    break;
	case 50:
	    *dst = new AttributeTypeAssertion(*(AttributeTypeAssertion *)src);
	    break;
	case 51:
	    *dst = new DistinguishedName(*(DistinguishedName *)src);
	    break;
	case 52:
	    *dst = new SubtreeSpecification(*(SubtreeSpecification *)src);
	    break;
	case 53:
	    *dst = new DITStructureRule(*(DITStructureRule *)src);
	    break;
	case 54:
	    *dst = new DITContentRule(*(DITContentRule *)src);
	    break;
	case 55:
	    *dst = new DITContextUse(*(DITContextUse *)src);
	    break;
	case 56:
	    *dst = osscppMalloc(sizeof(HierarchyLevel));
	    if (*dst)
		**(HierarchyLevel **)dst = *(HierarchyLevel *)src;
	    break;
	case 57:
	    *dst = osscppMalloc(sizeof(HierarchyBelow));
	    if (*dst)
		**(HierarchyBelow **)dst = *(HierarchyBelow *)src;
	    break;
	case 58:
	    *dst = new Acse_RealizationParameter(*(Acse_RealizationParameter *)src);
	    break;
	case 59:
	    *dst = new Acse_with_concatenation_RealizationParameter(*(Acse_with_concatenation_RealizationParameter *)src);
	    break;
	case 60:
	    *dst = new Association_by_RTSE_RealizationParameter(*(Association_by_RTSE_RealizationParameter *)src);
	    break;
	case 61:
	    *dst = new PData_RealizationParameter(*(PData_RealizationParameter *)src);
	    break;
	case 62:
	    *dst = new PData_with_concatenation_RealizationParameter(*(PData_with_concatenation_RealizationParameter *)src);
	    break;
	case 63:
	    *dst = new Transfer_by_RTSE_RealizationParameter(*(Transfer_by_RTSE_RealizationParameter *)src);
	    break;
	case 64:
	    *dst = new BitStringMatch_SYNTAX(*(BitStringMatch_SYNTAX *)src);
	    break;
	case 65:
	    *dst = new DnQualifier_WITH_SYNTAX(*(DnQualifier_WITH_SYNTAX *)src);
	    break;
	case 66:
	    *dst = new SerialNumber_WITH_SYNTAX(*(SerialNumber_WITH_SYNTAX *)src);
	    break;
	case 67:
	    *dst = new NumericStringMatch_SYNTAX(*(NumericStringMatch_SYNTAX *)src);
	    break;
	case 68:
	    *dst = new ProtocolInformationMatch_SYNTAX(*(ProtocolInformationMatch_SYNTAX *)src);
	    break;
	case 69:
	    *dst = new UiiInUrn_WITH_SYNTAX(*(UiiInUrn_WITH_SYNTAX *)src);
	    break;
	case 70:
	    *dst = new NumericStringOrderingMatch_SYNTAX(*(NumericStringOrderingMatch_SYNTAX *)src);
	    break;
	case 71:
	    *dst = osscppMalloc(sizeof(BooleanMatch_SYNTAX));
	    if (*dst)
		**(BooleanMatch_SYNTAX **)dst = *(BooleanMatch_SYNTAX *)src;
	    break;
	case 72:
	    *dst = osscppMalloc(sizeof(IntegerMatch_SYNTAX));
	    if (*dst)
		**(IntegerMatch_SYNTAX **)dst = *(IntegerMatch_SYNTAX *)src;
	    break;
	case 73:
	    *dst = osscppMalloc(sizeof(IntegerOrderingMatch_SYNTAX));
	    if (*dst)
		**(IntegerOrderingMatch_SYNTAX **)dst = *(IntegerOrderingMatch_SYNTAX *)src;
	    break;
	case 74:
	    *dst = new OctetStringMatch_SYNTAX(*(OctetStringMatch_SYNTAX *)src);
	    break;
	case 75:
	    *dst = new OctetStringOrderingMatch_SYNTAX(*(OctetStringOrderingMatch_SYNTAX *)src);
	    break;
	case 76:
	    *dst = new UTCTimeMatch_SYNTAX(*(UTCTimeMatch_SYNTAX *)src);
	    break;
	case 77:
	    *dst = new UTCTimeOrderingMatch_SYNTAX(*(UTCTimeOrderingMatch_SYNTAX *)src);
	    break;
	case 78:
	    *dst = new GeneralizedTimeMatch_SYNTAX(*(GeneralizedTimeMatch_SYNTAX *)src);
	    break;
	case 79:
	    *dst = new GeneralizedTimeOrderingMatch_SYNTAX(*(GeneralizedTimeOrderingMatch_SYNTAX *)src);
	    break;
	case 80:
	    *dst = osscppMalloc(sizeof(IntegerFirstComponentMatch_SYNTAX));
	    if (*dst)
		**(IntegerFirstComponentMatch_SYNTAX **)dst = *(IntegerFirstComponentMatch_SYNTAX *)src;
	    break;
	case 81:
	    *dst = new AdministrativeRole_WITH_SYNTAX(*(AdministrativeRole_WITH_SYNTAX *)src);
	    break;
	case 82:
	    *dst = new CreateTimestamp_WITH_SYNTAX(*(CreateTimestamp_WITH_SYNTAX *)src);
	    break;
	case 83:
	    *dst = new ModifyTimestamp_WITH_SYNTAX(*(ModifyTimestamp_WITH_SYNTAX *)src);
	    break;
	case 84:
	    *dst = new SubschemaTimestamp_WITH_SYNTAX(*(SubschemaTimestamp_WITH_SYNTAX *)src);
	    break;
	case 85:
	    *dst = osscppMalloc(sizeof(HasSubordinates_WITH_SYNTAX));
	    if (*dst)
		**(HasSubordinates_WITH_SYNTAX **)dst = *(HasSubordinates_WITH_SYNTAX *)src;
	    break;
	default:
	    return oss_call_error(OSS_UNKNOWN_TYPE);
    }
    if (*dst == 0)
	return OSS_NO_MEMORY;
    return 0;
}

int UpperBounds_TableType::equal(void *data1, void *data2, OssTypeIndex typeindex) {
    switch (typeindex) {
	case 1:
	    return *(OssEncOID *)data1 == *(OssEncOID *)data2;
	case 2:
	    return *(ACSE_apdu *)data1 == *(ACSE_apdu *)data2;
	case 3:
	    return *(AE_title *)data1 == *(AE_title *)data2;
	case 4:
	    return *(CP_type *)data1 == *(CP_type *)data2;
	case 5:
	    return *(CPC_type *)data1 == *(CPC_type *)data2;
	case 6:
	    return *(CPA_PPDU *)data1 == *(CPA_PPDU *)data2;
	case 7:
	    return *(CPR_PPDU *)data1 == *(CPR_PPDU *)data2;
	case 8:
	    return *(Abort_type *)data1 == *(Abort_type *)data2;
	case 9:
	    return *(Typed_data_type *)data1 == *(Typed_data_type *)data2;
	case 10:
	    return *(RS_PPDU *)data1 == *(RS_PPDU *)data2;
	case 11:
	    return *(RSA_PPDU *)data1 == *(RSA_PPDU *)data2;
	case 12:
	    return *(Reliable_Transfer_APDU_RTSE_apdus *)data1 == *(Reliable_Transfer_APDU_RTSE_apdus *)data2;
	case 13:
	    return *(Remote_Operations_Abstract_Syntaxes_RTSE_apdus *)data1 == *(Remote_Operations_Abstract_Syntaxes_RTSE_apdus *)data2;
	case 14:
	    return *(ROSEInvokeIds *)data1 == *(ROSEInvokeIds *)data2;
	case 15:
	    return *(Reject *)data1 == *(Reject *)data2;
	case 16:
	    return *(NoInvokeId *)data1 == *(NoInvokeId *)data2;
	case 17:
	    return *(UnboundedDirectoryString *)data1 == *(UnboundedDirectoryString *)data2;
	case 18:
	    return *(UniqueIdentifier *)data1 == *(UniqueIdentifier *)data2;
	case 19:
	    return *(UUIDPair *)data1 == *(UUIDPair *)data2;
	case 20:
	    return *(CountryName *)data1 == *(CountryName *)data2;
	case 21:
	    return *(Guide *)data1 == *(Guide *)data2;
	case 22:
	    return *(EnhancedGuide *)data1 == *(EnhancedGuide *)data2;
	case 23:
	    return *(PostalAddress *)data1 == *(PostalAddress *)data2;
	case 24:
	    return *(TelephoneNumber *)data1 == *(TelephoneNumber *)data2;
	case 25:
	    return *(TelexNumber *)data1 == *(TelexNumber *)data2;
	case 26:
	    return *(X121Address *)data1 == *(X121Address *)data2;
	case 27:
	    return *(InternationalISDNNumber *)data1 == *(InternationalISDNNumber *)data2;
	case 28:
	    return *(DestinationIndicator *)data1 == *(DestinationIndicator *)data2;
	case 29:
	    return *(CommunicationsService *)data1 == *(CommunicationsService *)data2;
	case 30:
	    return *(CommunicationsNetwork *)data1 == *(CommunicationsNetwork *)data2;
	case 31:
	    return *(PreferredDeliveryMethod *)data1 == *(PreferredDeliveryMethod *)data2;
	case 32:
	    return *(PresentationAddress *)data1 == *(PresentationAddress *)data2;
	case 33:
	    return *(ProtocolInformation *)data1 == *(ProtocolInformation *)data2;
	case 34:
	    return *(NameAndOptionalUID *)data1 == *(NameAndOptionalUID *)data2;
	case 35:
	    return *(MultipleMatchingLocalities *)data1 == *(MultipleMatchingLocalities *)data2;
	case 36:
	    return *(SubstringAssertion *)data1 == *(SubstringAssertion *)data2;
	case 37:
	    return *(CaseIgnoreList *)data1 == *(CaseIgnoreList *)data2;
	case 38:
	    return *(OctetSubstringAssertion *)data1 == *(OctetSubstringAssertion *)data2;
	case 39:
	    return *(SequenceMatchType *)data1 == *(SequenceMatchType *)data2;
	case 40:
	    return *(WordMatchTypes *)data1 == *(WordMatchTypes *)data2;
	case 41:
	    return *(CharacterMatchTypes *)data1 == *(CharacterMatchTypes *)data2;
	case 42:
	    return *(LanguageContextSyntax *)data1 == *(LanguageContextSyntax *)data2;
	case 43:
	    return *(TimeSpecification *)data1 == *(TimeSpecification *)data2;
	case 44:
	    return *(TimeAssertion *)data1 == *(TimeAssertion *)data2;
	case 45:
	    return *(LocaleContextSyntax *)data1 == *(LocaleContextSyntax *)data2;
	case 46:
	    return *(AttributeOptionList *)data1 == *(AttributeOptionList *)data2;
	case 47:
	    return *(ID *)data1 == *(ID *)data2;
	case 48:
	    return *(AttributeValue *)data1 == *(AttributeValue *)data2;
	case 49:
	    return *(ContextAssertion *)data1 == *(ContextAssertion *)data2;
	case 50:
	    return *(AttributeTypeAssertion *)data1 == *(AttributeTypeAssertion *)data2;
	case 51:
	    return *(DistinguishedName *)data1 == *(DistinguishedName *)data2;
	case 52:
	    return *(SubtreeSpecification *)data1 == *(SubtreeSpecification *)data2;
	case 53:
	    return *(DITStructureRule *)data1 == *(DITStructureRule *)data2;
	case 54:
	    return *(DITContentRule *)data1 == *(DITContentRule *)data2;
	case 55:
	    return *(DITContextUse *)data1 == *(DITContextUse *)data2;
	case 56:
	    return *(HierarchyLevel *)data1 == *(HierarchyLevel *)data2;
	case 57:
	    return *(HierarchyBelow *)data1 == *(HierarchyBelow *)data2;
	case 58:
	    return *(Acse_RealizationParameter *)data1 == *(Acse_RealizationParameter *)data2;
	case 59:
	    return *(Acse_with_concatenation_RealizationParameter *)data1 == *(Acse_with_concatenation_RealizationParameter *)data2;
	case 60:
	    return *(Association_by_RTSE_RealizationParameter *)data1 == *(Association_by_RTSE_RealizationParameter *)data2;
	case 61:
	    return *(PData_RealizationParameter *)data1 == *(PData_RealizationParameter *)data2;
	case 62:
	    return *(PData_with_concatenation_RealizationParameter *)data1 == *(PData_with_concatenation_RealizationParameter *)data2;
	case 63:
	    return *(Transfer_by_RTSE_RealizationParameter *)data1 == *(Transfer_by_RTSE_RealizationParameter *)data2;
	case 64:
	    return *(BitStringMatch_SYNTAX *)data1 == *(BitStringMatch_SYNTAX *)data2;
	case 65:
	    return *(DnQualifier_WITH_SYNTAX *)data1 == *(DnQualifier_WITH_SYNTAX *)data2;
	case 66:
	    return *(SerialNumber_WITH_SYNTAX *)data1 == *(SerialNumber_WITH_SYNTAX *)data2;
	case 67:
	    return *(NumericStringMatch_SYNTAX *)data1 == *(NumericStringMatch_SYNTAX *)data2;
	case 68:
	    return *(ProtocolInformationMatch_SYNTAX *)data1 == *(ProtocolInformationMatch_SYNTAX *)data2;
	case 69:
	    return *(UiiInUrn_WITH_SYNTAX *)data1 == *(UiiInUrn_WITH_SYNTAX *)data2;
	case 70:
	    return *(NumericStringOrderingMatch_SYNTAX *)data1 == *(NumericStringOrderingMatch_SYNTAX *)data2;
	case 71:
	    return *(BooleanMatch_SYNTAX *)data1 == *(BooleanMatch_SYNTAX *)data2;
	case 72:
	    return *(IntegerMatch_SYNTAX *)data1 == *(IntegerMatch_SYNTAX *)data2;
	case 73:
	    return *(IntegerOrderingMatch_SYNTAX *)data1 == *(IntegerOrderingMatch_SYNTAX *)data2;
	case 74:
	    return *(OctetStringMatch_SYNTAX *)data1 == *(OctetStringMatch_SYNTAX *)data2;
	case 75:
	    return *(OctetStringOrderingMatch_SYNTAX *)data1 == *(OctetStringOrderingMatch_SYNTAX *)data2;
	case 76:
	    return *(UTCTimeMatch_SYNTAX *)data1 == *(UTCTimeMatch_SYNTAX *)data2;
	case 77:
	    return *(UTCTimeOrderingMatch_SYNTAX *)data1 == *(UTCTimeOrderingMatch_SYNTAX *)data2;
	case 78:
	    return *(GeneralizedTimeMatch_SYNTAX *)data1 == *(GeneralizedTimeMatch_SYNTAX *)data2;
	case 79:
	    return *(GeneralizedTimeOrderingMatch_SYNTAX *)data1 == *(GeneralizedTimeOrderingMatch_SYNTAX *)data2;
	case 80:
	    return *(IntegerFirstComponentMatch_SYNTAX *)data1 == *(IntegerFirstComponentMatch_SYNTAX *)data2;
	case 81:
	    return *(AdministrativeRole_WITH_SYNTAX *)data1 == *(AdministrativeRole_WITH_SYNTAX *)data2;
	case 82:
	    return *(CreateTimestamp_WITH_SYNTAX *)data1 == *(CreateTimestamp_WITH_SYNTAX *)data2;
	case 83:
	    return *(ModifyTimestamp_WITH_SYNTAX *)data1 == *(ModifyTimestamp_WITH_SYNTAX *)data2;
	case 84:
	    return *(SubschemaTimestamp_WITH_SYNTAX *)data1 == *(SubschemaTimestamp_WITH_SYNTAX *)data2;
	case 85:
	    return *(HasSubordinates_WITH_SYNTAX *)data1 == *(HasSubordinates_WITH_SYNTAX *)data2;
    }
    return 0;
}

static UpperBounds_TableType UpperBounds_Table;

/* Representation types */

__shared2::__shared2() {
    memset(this, 0, sizeof(__shared2));
}

__shared2::__shared2(const __shared2 & that) {
    memset(this, 0, sizeof(__shared2));
    operator =(that);
}

__shared2::~__shared2() {
    cleanup();
}

__shared2 & __shared2::operator = (const __shared2 & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case single_ASN1_type_chosen:
	    *(single_ASN1_type *)&single_ASN1_type_field = *(single_ASN1_type *)&that.single_ASN1_type_field;
	    break;
	case octet_aligned_chosen:
	    *(octet_aligned *)&octet_aligned_field = *(octet_aligned *)&that.octet_aligned_field;
	    break;
	case arbitrary_chosen:
	    *(arbitrary *)&arbitrary_field = *(arbitrary *)&that.arbitrary_field;
	    break;
    }
    return *this;
}

int __shared2::operator == (const __shared2 & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case single_ASN1_type_chosen:
	    return *(single_ASN1_type *)&single_ASN1_type_field == *(single_ASN1_type *)&that.single_ASN1_type_field;
	case octet_aligned_chosen:
	    return *(octet_aligned *)&octet_aligned_field == *(octet_aligned *)&that.octet_aligned_field;
	case arbitrary_chosen:
	    return *(arbitrary *)&arbitrary_field == *(arbitrary *)&that.arbitrary_field;
    }

    return 1;
}

int __shared2::operator != (const __shared2 & that) const {
    return !(operator ==(that));
}

__shared2::single_ASN1_type *__shared2::get_single_ASN1_type() {
    if (_choice == single_ASN1_type_chosen)
	return (single_ASN1_type *)&single_ASN1_type_field;
    else
	return 0;
}

const __shared2::single_ASN1_type *__shared2::get_single_ASN1_type() const {
    if (_choice == single_ASN1_type_chosen)
	return (const single_ASN1_type *)&single_ASN1_type_field;
    else
	return 0;
}

void __shared2::set_single_ASN1_type(const single_ASN1_type & single_ASN1_type_val) {
    cleanup();
    *(single_ASN1_type *)&single_ASN1_type_field = single_ASN1_type_val;
    _choice = single_ASN1_type_chosen;
}

__shared2::octet_aligned *__shared2::get_octet_aligned() {
    if (_choice == octet_aligned_chosen)
	return (octet_aligned *)&octet_aligned_field;
    else
	return 0;
}

const __shared2::octet_aligned *__shared2::get_octet_aligned() const {
    if (_choice == octet_aligned_chosen)
	return (const octet_aligned *)&octet_aligned_field;
    else
	return 0;
}

void __shared2::set_octet_aligned(const octet_aligned & octet_aligned_val) {
    cleanup();
    *(octet_aligned *)&octet_aligned_field = octet_aligned_val;
    _choice = octet_aligned_chosen;
}

__shared2::arbitrary *__shared2::get_arbitrary() {
    if (_choice == arbitrary_chosen)
	return (arbitrary *)&arbitrary_field;
    else
	return 0;
}

const __shared2::arbitrary *__shared2::get_arbitrary() const {
    if (_choice == arbitrary_chosen)
	return (const arbitrary *)&arbitrary_field;
    else
	return 0;
}

void __shared2::set_arbitrary(const arbitrary & arbitrary_val) {
    cleanup();
    *(arbitrary *)&arbitrary_field = arbitrary_val;
    _choice = arbitrary_chosen;
}

void __shared2::cleanup() {
    switch (_choice) {
	case single_ASN1_type_chosen:
	    ((single_ASN1_type *)&single_ASN1_type_field)->~OssOpen();
	    break;
	case octet_aligned_chosen:
	    ((octet_aligned *)&octet_aligned_field)->~OssString();
	    break;
	case arbitrary_chosen:
	    ((arbitrary *)&arbitrary_field)->~OssBitString();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

void *External::operator new(size_t size) {
    return ossNewFunc(size);
}

void External::operator delete(void *ptr) {
    asn1Free(ptr);
}

External::External() {
    memset(this, 0, sizeof(External));
}

External::External(const External & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	direct_reference_field = that.direct_reference_field;
	indirect_reference_field = that.indirect_reference_field;
	data_value_descriptor_field = that.data_value_descriptor_field;
	encoding_field = that.encoding_field;
    } OSSCLEAN(External)
}

External::External(const direct_reference & direct_reference_val, indirect_reference indirect_reference_val, 
    const data_value_descriptor & data_value_descriptor_val, const encoding & encoding_val) {
    OSSTRY {
	bit_mask = 0xe0000000;
	direct_reference_field = direct_reference_val;
	indirect_reference_field = indirect_reference_val;
	data_value_descriptor_field = data_value_descriptor_val;
	encoding_field = encoding_val;
    } OSSCLEAN(External)
}

External::External(const encoding & encoding_val) {
    OSSTRY {
	bit_mask = 0;
	encoding_field = encoding_val;
    } OSSCLEAN(External)
}

External & External::operator = (const External & that) {
    if (this == &that)
	return *this;
    this->~External();
    bit_mask = that.bit_mask;
    direct_reference_field = that.direct_reference_field;
    indirect_reference_field = that.indirect_reference_field;
    data_value_descriptor_field = that.data_value_descriptor_field;
    encoding_field = that.encoding_field;
    return *this;
}

int External::operator == (const External & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (direct_reference_field != that.direct_reference_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (indirect_reference_field != that.indirect_reference_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (data_value_descriptor_field != that.data_value_descriptor_field)
	    return 0;
    }
    if (encoding_field != that.encoding_field)
	return 0;
    return 1;
}

int External::operator != (const External & that) const {
    return !(operator ==(that));
}

External::direct_reference *External::get_direct_reference() {
    if (bit_mask & 0x80000000)
	return &direct_reference_field;
    else
	return 0;
}

const External::direct_reference *External::get_direct_reference() const {
    if (bit_mask & 0x80000000)
	return &direct_reference_field;
    else
	return 0;
}

void External::set_direct_reference(const direct_reference & direct_reference_val) {
    bit_mask |= 0x80000000;
    direct_reference_field = direct_reference_val;
}

int External::direct_reference_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void External::omit_direct_reference() {
    direct_reference_field.~OssEncOID();
    bit_mask &= ~0x80000000;
}

External::indirect_reference *External::get_indirect_reference() {
    if (bit_mask & 0x40000000)
	return &indirect_reference_field;
    else
	return 0;
}

const External::indirect_reference *External::get_indirect_reference() const {
    if (bit_mask & 0x40000000)
	return &indirect_reference_field;
    else
	return 0;
}

void External::set_indirect_reference(indirect_reference indirect_reference_val) {
    bit_mask |= 0x40000000;
    indirect_reference_field = indirect_reference_val;
}

int External::indirect_reference_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void External::omit_indirect_reference() {
    bit_mask &= ~0x40000000;
}

External::data_value_descriptor *External::get_data_value_descriptor() {
    if (bit_mask & 0x20000000)
	return &data_value_descriptor_field;
    else
	return 0;
}

const External::data_value_descriptor *External::get_data_value_descriptor() const {
    if (bit_mask & 0x20000000)
	return &data_value_descriptor_field;
    else
	return 0;
}

void External::set_data_value_descriptor(const data_value_descriptor & data_value_descriptor_val) {
    bit_mask |= 0x20000000;
    data_value_descriptor_field = data_value_descriptor_val;
}

int External::data_value_descriptor_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void External::omit_data_value_descriptor() {
    data_value_descriptor_field.~OssString();
    bit_mask &= ~0x20000000;
}

External::encoding & External::get_encoding() {
    return encoding_field;
}

const External::encoding & External::get_encoding() const {
    return encoding_field;
}

void External::set_encoding(const encoding & encoding_val) {
    encoding_field = encoding_val;
}

/* Auxiliary data structures and functions for class __shared6 */

class __shared6_member {
public:
    __shared6_member *next;
    __shared6::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared6_member();
    __shared6_member(const __shared6::component & val);
};

void *__shared6_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared6_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared6_member::__shared6_member() {
}

__shared6_member::__shared6_member(const __shared6::component & val) {
    value = val;
}

static void *__shared6_copy(void *that) {
    return new __shared6_member(((__shared6_member *)that)->value);
}

static void __shared6_destroy(void *that) {
    delete (__shared6_member *)that;
}

static int __shared6_compare(void *val1, void *val2) {
    return (((__shared6_member *)val1)->value == ((__shared6_member *)val2)->value);
}

/* Constructors */

__shared6::__shared6() {
}

__shared6::__shared6(const __shared6 & that) {
    OSSTRY {
	do_copy(that, &__shared6_copy);
    } OSSCLEAN(__shared6)
}

/* Destructor */

__shared6::~__shared6() {
    do_destroy(&__shared6_destroy);
}

/* Operators: assignment, equality, inequality */

__shared6 & __shared6::operator = (const __shared6 & that) {
    do_destroy(&__shared6_destroy);
    do_copy(that, &__shared6_copy);
    return *this;
}

int __shared6::operator == (const __shared6 & that) const {
    return do_compare(that, &__shared6_compare);
}

int __shared6::operator != (const __shared6 & that) const {
    return !do_compare(that, &__shared6_compare);
}

/* Locate ("At" etc) methods */

__shared6::component *__shared6::at(OssIndex pos) {
    return &((__shared6_member *)pos)->value;
}

const __shared6::component *__shared6::at(OssIndex pos) const {
    return &((__shared6_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared6::prepend(const component & val) {
    __shared6_member *newrec = new __shared6_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared6::prepend(__shared6 *seq) {
    return do_prepend(seq);
}

OssIndex __shared6::insert_after(OssIndex pos, const component & val) {
    __shared6_member *newrec = new __shared6_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared6::insert_after(OssIndex pos, __shared6 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared6::remove_front() {
    __shared6_member *extr = (__shared6_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared6_destroy(extr);
    return 0;
}

int __shared6::remove_after(OssIndex pos) {
    __shared6_member *extr = (__shared6_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared6_destroy(extr);
    return 0;
}

/* Extract methods */

__shared6 *__shared6::extract_after(OssIndex begin, OssIndex end) {
    return (__shared6 *)do_extract_after(begin, end);
}

__shared7::__shared7() {
    memset(this, 0, sizeof(__shared7));
}

__shared7::__shared7(const __shared7 & that) {
    memset(this, 0, sizeof(__shared7));
    operator =(that);
}

__shared7::~__shared7() {
    cleanup();
}

__shared7 & __shared7::operator = (const __shared7 & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case rdnSequence_chosen:
	    *(rdnSequence *)&rdnSequence_field = *(rdnSequence *)&that.rdnSequence_field;
	    break;
    }
    return *this;
}

int __shared7::operator == (const __shared7 & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case rdnSequence_chosen:
	    return *(rdnSequence *)&rdnSequence_field == *(rdnSequence *)&that.rdnSequence_field;
    }

    return 1;
}

int __shared7::operator != (const __shared7 & that) const {
    return !(operator ==(that));
}

__shared7::rdnSequence *__shared7::get_rdnSequence() {
    if (_choice == rdnSequence_chosen)
	return (rdnSequence *)&rdnSequence_field;
    else
	return 0;
}

const __shared7::rdnSequence *__shared7::get_rdnSequence() const {
    if (_choice == rdnSequence_chosen)
	return (const rdnSequence *)&rdnSequence_field;
    else
	return 0;
}

void __shared7::set_rdnSequence(const rdnSequence & rdnSequence_val) {
    cleanup();
    *(rdnSequence *)&rdnSequence_field = rdnSequence_val;
    _choice = rdnSequence_chosen;
}

void __shared7::cleanup() {
    switch (_choice) {
	case rdnSequence_chosen:
	    ((rdnSequence *)&rdnSequence_field)->~__shared6();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

AP_title::AP_title() {
    memset(this, 0, sizeof(AP_title));
}

AP_title::AP_title(const AP_title & that) {
    memset(this, 0, sizeof(AP_title));
    operator =(that);
}

AP_title::~AP_title() {
    cleanup();
}

AP_title & AP_title::operator = (const AP_title & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case ap_title_form1_chosen:
	    if (that.ap_title_form1_field)
		ap_title_form1_field = new ap_title_form1(*that.ap_title_form1_field);
	    break;
	case ap_title_form2_chosen:
	    *(ap_title_form2 *)&ap_title_form2_field = *(ap_title_form2 *)&that.ap_title_form2_field;
	    break;
    }
    return *this;
}

int AP_title::operator == (const AP_title & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case ap_title_form1_chosen:
	    if ((ap_title_form1_field) && (that.ap_title_form1_field))
		return (*ap_title_form1_field == *(that.ap_title_form1_field));
	    else if (!((!ap_title_form1_field) && (!that.ap_title_form1_field)))
		return 0;
	    break;
	case ap_title_form2_chosen:
	    return *(ap_title_form2 *)&ap_title_form2_field == *(ap_title_form2 *)&that.ap_title_form2_field;
    }

    return 1;
}

int AP_title::operator != (const AP_title & that) const {
    return !(operator ==(that));
}

AP_title::ap_title_form1 *AP_title::get_ap_title_form1() {
    if (_choice == ap_title_form1_chosen)
	return (ap_title_form1 *)ap_title_form1_field;
    else
	return 0;
}

const AP_title::ap_title_form1 *AP_title::get_ap_title_form1() const {
    if (_choice == ap_title_form1_chosen)
	return (const ap_title_form1 *)ap_title_form1_field;
    else
	return 0;
}

void AP_title::set_ap_title_form1(const ap_title_form1 & ap_title_form1_val) {
    cleanup();
    ap_title_form1_field = new ap_title_form1(ap_title_form1_val);
    _choice = ap_title_form1_chosen;
}

AP_title::ap_title_form2 *AP_title::get_ap_title_form2() {
    if (_choice == ap_title_form2_chosen)
	return (ap_title_form2 *)&ap_title_form2_field;
    else
	return 0;
}

const AP_title::ap_title_form2 *AP_title::get_ap_title_form2() const {
    if (_choice == ap_title_form2_chosen)
	return (const ap_title_form2 *)&ap_title_form2_field;
    else
	return 0;
}

void AP_title::set_ap_title_form2(const ap_title_form2 & ap_title_form2_val) {
    cleanup();
    *(ap_title_form2 *)&ap_title_form2_field = ap_title_form2_val;
    _choice = ap_title_form2_chosen;
}

void AP_title::cleanup() {
    switch (_choice) {
	case ap_title_form1_chosen:
	    if (ap_title_form1_field)
		delete ap_title_form1_field;
	    break;
	case ap_title_form2_chosen:
	    ((ap_title_form2 *)&ap_title_form2_field)->~OssEncOID();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

/* Auxiliary data structures and functions for class __shared5 */

class __shared5_member {
public:
    __shared5_member *next;
    __shared5::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared5_member();
    __shared5_member(const __shared5::component & val);
};

void *__shared5_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared5_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared5_member::__shared5_member() {
}

__shared5_member::__shared5_member(const __shared5::component & val) {
    value = val;
}

static void *__shared5_copy(void *that) {
    return new __shared5_member(((__shared5_member *)that)->value);
}

static void __shared5_destroy(void *that) {
    delete (__shared5_member *)that;
}

static int __shared5_compare(void *val1, void *val2) {
    return (((__shared5_member *)val1)->value == ((__shared5_member *)val2)->value);
}

/* Constructors */

__shared5::__shared5() {
}

__shared5::__shared5(const __shared5 & that) {
    OSSTRY {
	do_copy(that, &__shared5_copy);
    } OSSCLEAN(__shared5)
}

/* Destructor */

__shared5::~__shared5() {
    do_destroy(&__shared5_destroy);
}

/* Operators: assignment, equality, inequality */

__shared5 & __shared5::operator = (const __shared5 & that) {
    do_destroy(&__shared5_destroy);
    do_copy(that, &__shared5_copy);
    return *this;
}

int __shared5::operator == (const __shared5 & that) const {
    return do_compare(that, &__shared5_compare);
}

int __shared5::operator != (const __shared5 & that) const {
    return !do_compare(that, &__shared5_compare);
}

/* Locate ("At" etc) methods */

__shared5::component *__shared5::at(OssIndex pos) {
    return &((__shared5_member *)pos)->value;
}

const __shared5::component *__shared5::at(OssIndex pos) const {
    return &((__shared5_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared5::prepend(const component & val) {
    __shared5_member *newrec = new __shared5_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared5::prepend(__shared5 *seq) {
    return do_prepend(seq);
}

OssIndex __shared5::insert_after(OssIndex pos, const component & val) {
    __shared5_member *newrec = new __shared5_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared5::insert_after(OssIndex pos, __shared5 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared5::remove_front() {
    __shared5_member *extr = (__shared5_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared5_destroy(extr);
    return 0;
}

int __shared5::remove_after(OssIndex pos) {
    __shared5_member *extr = (__shared5_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared5_destroy(extr);
    return 0;
}

/* Extract methods */

__shared5 *__shared5::extract_after(OssIndex begin, OssIndex end) {
    return (__shared5 *)do_extract_after(begin, end);
}

AE_qualifier::AE_qualifier() {
    memset(this, 0, sizeof(AE_qualifier));
}

AE_qualifier::AE_qualifier(const AE_qualifier & that) {
    memset(this, 0, sizeof(AE_qualifier));
    operator =(that);
}

AE_qualifier::~AE_qualifier() {
    cleanup();
}

AE_qualifier & AE_qualifier::operator = (const AE_qualifier & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case ae_qualifier_form1_chosen:
	    *(ae_qualifier_form1 *)&ae_qualifier_form1_field = *(ae_qualifier_form1 *)&that.ae_qualifier_form1_field;
	    break;
	case ae_qualifier_form2_chosen:
	    *(ae_qualifier_form2 *)&ae_qualifier_form2_field = *(ae_qualifier_form2 *)&that.ae_qualifier_form2_field;
	    break;
    }
    return *this;
}

int AE_qualifier::operator == (const AE_qualifier & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case ae_qualifier_form1_chosen:
	    return *(ae_qualifier_form1 *)&ae_qualifier_form1_field == *(ae_qualifier_form1 *)&that.ae_qualifier_form1_field;
	case ae_qualifier_form2_chosen:
	    return *(ae_qualifier_form2 *)&ae_qualifier_form2_field == *(ae_qualifier_form2 *)&that.ae_qualifier_form2_field;
    }

    return 1;
}

int AE_qualifier::operator != (const AE_qualifier & that) const {
    return !(operator ==(that));
}

AE_qualifier::ae_qualifier_form1 *AE_qualifier::get_ae_qualifier_form1() {
    if (_choice == ae_qualifier_form1_chosen)
	return (ae_qualifier_form1 *)&ae_qualifier_form1_field;
    else
	return 0;
}

const AE_qualifier::ae_qualifier_form1 *AE_qualifier::get_ae_qualifier_form1() const {
    if (_choice == ae_qualifier_form1_chosen)
	return (const ae_qualifier_form1 *)&ae_qualifier_form1_field;
    else
	return 0;
}

void AE_qualifier::set_ae_qualifier_form1(const ae_qualifier_form1 & ae_qualifier_form1_val) {
    cleanup();
    *(ae_qualifier_form1 *)&ae_qualifier_form1_field = ae_qualifier_form1_val;
    _choice = ae_qualifier_form1_chosen;
}

AE_qualifier::ae_qualifier_form2 *AE_qualifier::get_ae_qualifier_form2() {
    if (_choice == ae_qualifier_form2_chosen)
	return (ae_qualifier_form2 *)&ae_qualifier_form2_field;
    else
	return 0;
}

const AE_qualifier::ae_qualifier_form2 *AE_qualifier::get_ae_qualifier_form2() const {
    if (_choice == ae_qualifier_form2_chosen)
	return (const ae_qualifier_form2 *)&ae_qualifier_form2_field;
    else
	return 0;
}

void AE_qualifier::set_ae_qualifier_form2(ae_qualifier_form2 ae_qualifier_form2_val) {
    cleanup();
    *(ae_qualifier_form2 *)&ae_qualifier_form2_field = ae_qualifier_form2_val;
    _choice = ae_qualifier_form2_chosen;
}

void AE_qualifier::cleanup() {
    switch (_choice) {
	case ae_qualifier_form1_chosen:
	    ((ae_qualifier_form1 *)&ae_qualifier_form1_field)->~__shared5();
	    break;
	case ae_qualifier_form2_chosen:
	    break;
    }
    memset(this, 0, sizeof(*this));
}

SupportedContexts_Type::SupportedContexts_Type()
{
}

SupportedContexts_Type::SupportedContexts_Type(const SupportedContexts_Type & that)
{
    operator =(that);
}

SupportedContexts_Type::~SupportedContexts_Type()
{
    cleanup_decoded();
}

SupportedContexts_Type & SupportedContexts_Type::operator = (const SupportedContexts_Type & that)
{
    int result;
    void *copy = nullptr;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = UpperBounds_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int SupportedContexts_Type::operator == (const SupportedContexts_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return UpperBounds_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int SupportedContexts_Type::operator != (const SupportedContexts_Type & that) const
{
    return !(operator ==(that));
}

int SupportedContexts_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = UpperBounds_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int SupportedContexts_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int SupportedContexts_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int SupportedContexts_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int SupportedContexts_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

void SupportedContexts_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	UpperBounds_Table.destroy(decoded, pdunum);
	decoded = nullptr;
	pdunum = 0;
    }
}

void *__seq1::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq1::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq1::__seq1() {
    memset(this, 0, sizeof(__seq1));
}

__seq1::__seq1(const __seq1 & that) {
    OSSTRY {
	other_mechanism_name_field = that.other_mechanism_name_field;
	other_mechanism_value_field = that.other_mechanism_value_field;
    } OSSCLEAN(__seq1)
}

__seq1::__seq1(const other_mechanism_name & other_mechanism_name_val, const other_mechanism_value & other_mechanism_value_val) {
    OSSTRY {
	other_mechanism_name_field = other_mechanism_name_val;
	other_mechanism_value_field = other_mechanism_value_val;
    } OSSCLEAN(__seq1)
}

__seq1 & __seq1::operator = (const __seq1 & that) {
    if (this == &that)
	return *this;
    other_mechanism_name_field = that.other_mechanism_name_field;
    other_mechanism_value_field = that.other_mechanism_value_field;
    return *this;
}

int __seq1::operator == (const __seq1 & that) const {
    if (other_mechanism_name_field != that.other_mechanism_name_field)
	return 0;
    if (other_mechanism_value_field != that.other_mechanism_value_field)
	return 0;
    return 1;
}

int __seq1::operator != (const __seq1 & that) const {
    return !(operator ==(that));
}

__seq1::other_mechanism_name & __seq1::get_other_mechanism_name() {
    return other_mechanism_name_field;
}

const __seq1::other_mechanism_name & __seq1::get_other_mechanism_name() const {
    return other_mechanism_name_field;
}

void __seq1::set_other_mechanism_name(const other_mechanism_name & other_mechanism_name_val) {
    other_mechanism_name_field = other_mechanism_name_val;
}

__seq1::other_mechanism_value & __seq1::get_other_mechanism_value() {
    return other_mechanism_value_field;
}

const __seq1::other_mechanism_value & __seq1::get_other_mechanism_value() const {
    return other_mechanism_value_field;
}

void __seq1::set_other_mechanism_value(const other_mechanism_value & other_mechanism_value_val) {
    other_mechanism_value_field = other_mechanism_value_val;
}

Authentication_value::Authentication_value() {
    memset(this, 0, sizeof(Authentication_value));
}

Authentication_value::Authentication_value(const Authentication_value & that) {
    memset(this, 0, sizeof(Authentication_value));
    operator =(that);
}

Authentication_value::~Authentication_value() {
    cleanup();
}

Authentication_value & Authentication_value::operator = (const Authentication_value & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case charstring_chosen:
	    *(charstring *)&charstring_field = *(charstring *)&that.charstring_field;
	    break;
	case bitstring_chosen:
	    *(bitstring *)&bitstring_field = *(bitstring *)&that.bitstring_field;
	    break;
	case external_chosen:
	    if (that.external_field)
		external_field = new external(*that.external_field);
	    break;
	case other_chosen:
	    if (that.other_field)
		other_field = new other(*that.other_field);
	    break;
    }
    return *this;
}

int Authentication_value::operator == (const Authentication_value & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case charstring_chosen:
	    return *(charstring *)&charstring_field == *(charstring *)&that.charstring_field;
	case bitstring_chosen:
	    return *(bitstring *)&bitstring_field == *(bitstring *)&that.bitstring_field;
	case external_chosen:
	    if ((external_field) && (that.external_field))
		return (*external_field == *(that.external_field));
	    else if (!((!external_field) && (!that.external_field)))
		return 0;
	    break;
	case other_chosen:
	    if ((other_field) && (that.other_field))
		return (*other_field == *(that.other_field));
	    else if (!((!other_field) && (!that.other_field)))
		return 0;
	    break;
    }

    return 1;
}

int Authentication_value::operator != (const Authentication_value & that) const {
    return !(operator ==(that));
}

Authentication_value::charstring *Authentication_value::get_charstring() {
    if (_choice == charstring_chosen)
	return (charstring *)&charstring_field;
    else
	return 0;
}

const Authentication_value::charstring *Authentication_value::get_charstring() const {
    if (_choice == charstring_chosen)
	return (const charstring *)&charstring_field;
    else
	return 0;
}

void Authentication_value::set_charstring(const charstring & charstring_val) {
    cleanup();
    *(charstring *)&charstring_field = charstring_val;
    _choice = charstring_chosen;
}

Authentication_value::bitstring *Authentication_value::get_bitstring() {
    if (_choice == bitstring_chosen)
	return (bitstring *)&bitstring_field;
    else
	return 0;
}

const Authentication_value::bitstring *Authentication_value::get_bitstring() const {
    if (_choice == bitstring_chosen)
	return (const bitstring *)&bitstring_field;
    else
	return 0;
}

void Authentication_value::set_bitstring(const bitstring & bitstring_val) {
    cleanup();
    *(bitstring *)&bitstring_field = bitstring_val;
    _choice = bitstring_chosen;
}

Authentication_value::external *Authentication_value::get_external() {
    if (_choice == external_chosen)
	return (external *)external_field;
    else
	return 0;
}

const Authentication_value::external *Authentication_value::get_external() const {
    if (_choice == external_chosen)
	return (const external *)external_field;
    else
	return 0;
}

void Authentication_value::set_external(const external & external_val) {
    cleanup();
    external_field = new external(external_val);
    _choice = external_chosen;
}

Authentication_value::other *Authentication_value::get_other() {
    if (_choice == other_chosen)
	return (other *)other_field;
    else
	return 0;
}

const Authentication_value::other *Authentication_value::get_other() const {
    if (_choice == other_chosen)
	return (const other *)other_field;
    else
	return 0;
}

void Authentication_value::set_other(const other & other_val) {
    cleanup();
    other_field = new other(other_val);
    _choice = other_chosen;
}

void Authentication_value::cleanup() {
    switch (_choice) {
	case charstring_chosen:
	    ((charstring *)&charstring_field)->~OssString();
	    break;
	case bitstring_chosen:
	    ((bitstring *)&bitstring_field)->~OssBitString();
	    break;
	case external_chosen:
	    if (external_field)
		delete external_field;
	    break;
	case other_chosen:
	    if (other_field)
		delete other_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

/* Auxiliary data structures and functions for class __shared8 */

class __shared8_member {
public:
    __shared8_member *next;
    __shared8::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared8_member();
    __shared8_member(const __shared8::component & val);
};

void *__shared8_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared8_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared8_member::__shared8_member() {
}

__shared8_member::__shared8_member(const __shared8::component & val) {
    value = val;
}

static void *__shared8_copy(void *that) {
    return new __shared8_member(((__shared8_member *)that)->value);
}

static void __shared8_destroy(void *that) {
    delete (__shared8_member *)that;
}

static int __shared8_compare(void *val1, void *val2) {
    return (((__shared8_member *)val1)->value == ((__shared8_member *)val2)->value);
}

/* Constructors */

__shared8::__shared8() {
}

__shared8::__shared8(const __shared8 & that) {
    OSSTRY {
	do_copy(that, &__shared8_copy);
    } OSSCLEAN(__shared8)
}

/* Destructor */

__shared8::~__shared8() {
    do_destroy(&__shared8_destroy);
}

/* Operators: assignment, equality, inequality */

__shared8 & __shared8::operator = (const __shared8 & that) {
    do_destroy(&__shared8_destroy);
    do_copy(that, &__shared8_copy);
    return *this;
}

int __shared8::operator == (const __shared8 & that) const {
    return do_compare(that, &__shared8_compare);
}

int __shared8::operator != (const __shared8 & that) const {
    return !do_compare(that, &__shared8_compare);
}

/* Locate ("At" etc) methods */

__shared8::component *__shared8::at(OssIndex pos) {
    return &((__shared8_member *)pos)->value;
}

const __shared8::component *__shared8::at(OssIndex pos) const {
    return &((__shared8_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared8::prepend(const component & val) {
    __shared8_member *newrec = new __shared8_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared8::prepend(__shared8 *seq) {
    return do_prepend(seq);
}

OssIndex __shared8::insert_after(OssIndex pos, const component & val) {
    __shared8_member *newrec = new __shared8_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared8::insert_after(OssIndex pos, __shared8 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared8::remove_front() {
    __shared8_member *extr = (__shared8_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared8_destroy(extr);
    return 0;
}

int __shared8::remove_after(OssIndex pos) {
    __shared8_member *extr = (__shared8_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared8_destroy(extr);
    return 0;
}

/* Extract methods */

__shared8 *__shared8::extract_after(OssIndex begin, OssIndex end) {
    return (__shared8 *)do_extract_after(begin, end);
}

/* Auxiliary data structures and functions for class __shared9 */

class __shared9_member {
public:
    __shared9_member *next;
    __shared9::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared9_member();
    __shared9_member(const __shared9::component & val);
};

void *__shared9_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared9_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared9_member::__shared9_member() {
}

__shared9_member::__shared9_member(const __shared9::component & val) {
    value = val;
}

static void *__shared9_copy(void *that) {
    return new __shared9_member(((__shared9_member *)that)->value);
}

static void __shared9_destroy(void *that) {
    delete (__shared9_member *)that;
}

static int __shared9_compare(void *val1, void *val2) {
    return (((__shared9_member *)val1)->value == ((__shared9_member *)val2)->value);
}

/* Constructors */

__shared9::__shared9() {
}

__shared9::__shared9(const __shared9 & that) {
    OSSTRY {
	do_copy(that, &__shared9_copy);
    } OSSCLEAN(__shared9)
}

/* Destructor */

__shared9::~__shared9() {
    do_destroy(&__shared9_destroy);
}

/* Operators: assignment, equality, inequality */

__shared9 & __shared9::operator = (const __shared9 & that) {
    do_destroy(&__shared9_destroy);
    do_copy(that, &__shared9_copy);
    return *this;
}

int __shared9::operator == (const __shared9 & that) const {
    return do_compare(that, &__shared9_compare);
}

int __shared9::operator != (const __shared9 & that) const {
    return !do_compare(that, &__shared9_compare);
}

/* Locate ("At" etc) methods */

__shared9::component *__shared9::at(OssIndex pos) {
    return &((__shared9_member *)pos)->value;
}

const __shared9::component *__shared9::at(OssIndex pos) const {
    return &((__shared9_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared9::prepend(const component & val) {
    __shared9_member *newrec = new __shared9_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared9::prepend(__shared9 *seq) {
    return do_prepend(seq);
}

OssIndex __shared9::insert_after(OssIndex pos, const component & val) {
    __shared9_member *newrec = new __shared9_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared9::insert_after(OssIndex pos, __shared9 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared9::remove_front() {
    __shared9_member *extr = (__shared9_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared9_destroy(extr);
    return 0;
}

int __shared9::remove_after(OssIndex pos) {
    __shared9_member *extr = (__shared9_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared9_destroy(extr);
    return 0;
}

/* Extract methods */

__shared9 *__shared9::extract_after(OssIndex begin, OssIndex end) {
    return (__shared9 *)do_extract_after(begin, end);
}

void *AARQ_apdu::operator new(size_t size) {
    return ossNewFunc(size);
}

void AARQ_apdu::operator delete(void *ptr) {
    asn1Free(ptr);
}

const OssBitString& AARQ_apdu::get_default_protocol_version() {
    return AARQ_apdu::default_protocol_version;
}

AARQ_apdu::AARQ_apdu() {
    memset(this, 0, sizeof(AARQ_apdu));
}

AARQ_apdu::AARQ_apdu(const AARQ_apdu & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	if (bit_mask & 0x80000000)
	    protocol_version_field = that.protocol_version_field;
	application_context_name_field = that.application_context_name_field;
	called_AP_title_field = that.called_AP_title_field;
	called_AE_qualifier_field = that.called_AE_qualifier_field;
	called_AP_invocation_identifier_field = that.called_AP_invocation_identifier_field;
	called_AE_invocation_identifier_field = that.called_AE_invocation_identifier_field;
	calling_AP_title_field = that.calling_AP_title_field;
	calling_AE_qualifier_field = that.calling_AE_qualifier_field;
	calling_AP_invocation_identifier_field = that.calling_AP_invocation_identifier_field;
	calling_AE_invocation_identifier_field = that.calling_AE_invocation_identifier_field;
	sender_acse_requirements_field = that.sender_acse_requirements_field;
	mechanism_name_field = that.mechanism_name_field;
	calling_authentication_value_field = that.calling_authentication_value_field;
	application_context_name_list_field = that.application_context_name_list_field;
	implementation_information_field = that.implementation_information_field;
	user_information_field = that.user_information_field;
    } OSSCLEAN(AARQ_apdu)
}

AARQ_apdu::AARQ_apdu(const protocol_version & protocol_version_val, const application_context_name & application_context_name_val, 
    const called_AP_title & called_AP_title_val, const called_AE_qualifier & called_AE_qualifier_val, 
    called_AP_invocation_identifier called_AP_invocation_identifier_val, called_AE_invocation_identifier called_AE_invocation_identifier_val, 
    const calling_AP_title & calling_AP_title_val, const calling_AE_qualifier & calling_AE_qualifier_val, 
    calling_AP_invocation_identifier calling_AP_invocation_identifier_val, calling_AE_invocation_identifier calling_AE_invocation_identifier_val, 
    const sender_acse_requirements & sender_acse_requirements_val, const mechanism_name & mechanism_name_val, 
    const calling_authentication_value & calling_authentication_value_val, const application_context_name_list & application_context_name_list_val, 
    const implementation_information & implementation_information_val, const user_information & user_information_val) {
    OSSTRY {
	bit_mask = 0xfffe0000;
	protocol_version_field = protocol_version_val;
	application_context_name_field = application_context_name_val;
	called_AP_title_field = called_AP_title_val;
	called_AE_qualifier_field = called_AE_qualifier_val;
	called_AP_invocation_identifier_field = called_AP_invocation_identifier_val;
	called_AE_invocation_identifier_field = called_AE_invocation_identifier_val;
	calling_AP_title_field = calling_AP_title_val;
	calling_AE_qualifier_field = calling_AE_qualifier_val;
	calling_AP_invocation_identifier_field = calling_AP_invocation_identifier_val;
	calling_AE_invocation_identifier_field = calling_AE_invocation_identifier_val;
	sender_acse_requirements_field = sender_acse_requirements_val;
	mechanism_name_field = mechanism_name_val;
	calling_authentication_value_field = calling_authentication_value_val;
	application_context_name_list_field = application_context_name_list_val;
	implementation_information_field = implementation_information_val;
	user_information_field = user_information_val;
    } OSSCLEAN(AARQ_apdu)
}

AARQ_apdu::AARQ_apdu(const application_context_name & application_context_name_val) {
    OSSTRY {
	bit_mask = 0;
	application_context_name_field = application_context_name_val;
    } OSSCLEAN(AARQ_apdu)
}

AARQ_apdu::~AARQ_apdu() {
    if (!(bit_mask & 0x80000000))
	memset(&protocol_version_field, 0, sizeof(protocol_version));
}

AARQ_apdu & AARQ_apdu::operator = (const AARQ_apdu & that) {
    if (this == &that)
	return *this;
    this->~AARQ_apdu();
    bit_mask = that.bit_mask;
    if (bit_mask & 0x80000000)
	protocol_version_field = that.protocol_version_field;
    application_context_name_field = that.application_context_name_field;
    called_AP_title_field = that.called_AP_title_field;
    called_AE_qualifier_field = that.called_AE_qualifier_field;
    called_AP_invocation_identifier_field = that.called_AP_invocation_identifier_field;
    called_AE_invocation_identifier_field = that.called_AE_invocation_identifier_field;
    calling_AP_title_field = that.calling_AP_title_field;
    calling_AE_qualifier_field = that.calling_AE_qualifier_field;
    calling_AP_invocation_identifier_field = that.calling_AP_invocation_identifier_field;
    calling_AE_invocation_identifier_field = that.calling_AE_invocation_identifier_field;
    sender_acse_requirements_field = that.sender_acse_requirements_field;
    mechanism_name_field = that.mechanism_name_field;
    calling_authentication_value_field = that.calling_authentication_value_field;
    application_context_name_list_field = that.application_context_name_list_field;
    implementation_information_field = that.implementation_information_field;
    user_information_field = that.user_information_field;
    return *this;
}

int AARQ_apdu::operator == (const AARQ_apdu & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (protocol_version_field != that.protocol_version_field)
	    return 0;
    }
    if (application_context_name_field != that.application_context_name_field)
	return 0;
    if (bit_mask & 0x40000000) {
	if (called_AP_title_field != that.called_AP_title_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (called_AE_qualifier_field != that.called_AE_qualifier_field)
	    return 0;
    }
    if (bit_mask & 0x10000000) {
	if (called_AP_invocation_identifier_field != that.called_AP_invocation_identifier_field)
	    return 0;
    }
    if (bit_mask & 0x8000000) {
	if (called_AE_invocation_identifier_field != that.called_AE_invocation_identifier_field)
	    return 0;
    }
    if (bit_mask & 0x4000000) {
	if (calling_AP_title_field != that.calling_AP_title_field)
	    return 0;
    }
    if (bit_mask & 0x2000000) {
	if (calling_AE_qualifier_field != that.calling_AE_qualifier_field)
	    return 0;
    }
    if (bit_mask & 0x1000000) {
	if (calling_AP_invocation_identifier_field != that.calling_AP_invocation_identifier_field)
	    return 0;
    }
    if (bit_mask & 0x800000) {
	if (calling_AE_invocation_identifier_field != that.calling_AE_invocation_identifier_field)
	    return 0;
    }
    if (bit_mask & 0x400000) {
	if (sender_acse_requirements_field != that.sender_acse_requirements_field)
	    return 0;
    }
    if (bit_mask & 0x200000) {
	if (mechanism_name_field != that.mechanism_name_field)
	    return 0;
    }
    if (bit_mask & 0x100000) {
	if (calling_authentication_value_field != that.calling_authentication_value_field)
	    return 0;
    }
    if (bit_mask & 0x80000) {
	if (application_context_name_list_field != that.application_context_name_list_field)
	    return 0;
    }
    if (bit_mask & 0x40000) {
	if (implementation_information_field != that.implementation_information_field)
	    return 0;
    }
    if (bit_mask & 0x20000) {
	if (user_information_field != that.user_information_field)
	    return 0;
    }
    return 1;
}

int AARQ_apdu::operator != (const AARQ_apdu & that) const {
    return !(operator ==(that));
}

AARQ_apdu::protocol_version *AARQ_apdu::get_protocol_version() {
    if (bit_mask & 0x80000000)
	return &protocol_version_field;
    else
	return 0;
}

const AARQ_apdu::protocol_version *AARQ_apdu::get_protocol_version() const {
    if (bit_mask & 0x80000000)
	return &protocol_version_field;
    else
	return 0;
}

void AARQ_apdu::set_protocol_version(const protocol_version & protocol_version_val) {
    if (!(bit_mask & 0x80000000)) {
	memset(&protocol_version_field, 0, sizeof(protocol_version));
	bit_mask |= 0x80000000;
    }
    protocol_version_field = protocol_version_val;
}

int AARQ_apdu::protocol_version_is_default() const {
    return !(bit_mask & 0x80000000);
}

void AARQ_apdu::set_default_protocol_version() {
    if (bit_mask & 0x80000000) {
	protocol_version_field.~OssBitString();
	bit_mask &= ~0x80000000;
    }
}

AARQ_apdu::application_context_name & AARQ_apdu::get_application_context_name() {
    return application_context_name_field;
}

const AARQ_apdu::application_context_name & AARQ_apdu::get_application_context_name() const {
    return application_context_name_field;
}

void AARQ_apdu::set_application_context_name(const application_context_name & application_context_name_val) {
    application_context_name_field = application_context_name_val;
}

AARQ_apdu::called_AP_title *AARQ_apdu::get_called_AP_title() {
    if (bit_mask & 0x40000000)
	return &called_AP_title_field;
    else
	return 0;
}

const AARQ_apdu::called_AP_title *AARQ_apdu::get_called_AP_title() const {
    if (bit_mask & 0x40000000)
	return &called_AP_title_field;
    else
	return 0;
}

void AARQ_apdu::set_called_AP_title(const called_AP_title & called_AP_title_val) {
    bit_mask |= 0x40000000;
    called_AP_title_field = called_AP_title_val;
}

int AARQ_apdu::called_AP_title_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void AARQ_apdu::omit_called_AP_title() {
    called_AP_title_field.~AP_title();
    bit_mask &= ~0x40000000;
}

AARQ_apdu::called_AE_qualifier *AARQ_apdu::get_called_AE_qualifier() {
    if (bit_mask & 0x20000000)
	return &called_AE_qualifier_field;
    else
	return 0;
}

const AARQ_apdu::called_AE_qualifier *AARQ_apdu::get_called_AE_qualifier() const {
    if (bit_mask & 0x20000000)
	return &called_AE_qualifier_field;
    else
	return 0;
}

void AARQ_apdu::set_called_AE_qualifier(const called_AE_qualifier & called_AE_qualifier_val) {
    bit_mask |= 0x20000000;
    called_AE_qualifier_field = called_AE_qualifier_val;
}

int AARQ_apdu::called_AE_qualifier_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void AARQ_apdu::omit_called_AE_qualifier() {
    called_AE_qualifier_field.~AE_qualifier();
    bit_mask &= ~0x20000000;
}

AARQ_apdu::called_AP_invocation_identifier *AARQ_apdu::get_called_AP_invocation_identifier() {
    if (bit_mask & 0x10000000)
	return &called_AP_invocation_identifier_field;
    else
	return 0;
}

const AARQ_apdu::called_AP_invocation_identifier *AARQ_apdu::get_called_AP_invocation_identifier() const {
    if (bit_mask & 0x10000000)
	return &called_AP_invocation_identifier_field;
    else
	return 0;
}

void AARQ_apdu::set_called_AP_invocation_identifier(called_AP_invocation_identifier called_AP_invocation_identifier_val) {
    bit_mask |= 0x10000000;
    called_AP_invocation_identifier_field = called_AP_invocation_identifier_val;
}

int AARQ_apdu::called_AP_invocation_identifier_is_present() const {
    return !!(bit_mask & 0x10000000);
}

void AARQ_apdu::omit_called_AP_invocation_identifier() {
    bit_mask &= ~0x10000000;
}

AARQ_apdu::called_AE_invocation_identifier *AARQ_apdu::get_called_AE_invocation_identifier() {
    if (bit_mask & 0x8000000)
	return &called_AE_invocation_identifier_field;
    else
	return 0;
}

const AARQ_apdu::called_AE_invocation_identifier *AARQ_apdu::get_called_AE_invocation_identifier() const {
    if (bit_mask & 0x8000000)
	return &called_AE_invocation_identifier_field;
    else
	return 0;
}

void AARQ_apdu::set_called_AE_invocation_identifier(called_AE_invocation_identifier called_AE_invocation_identifier_val) {
    bit_mask |= 0x8000000;
    called_AE_invocation_identifier_field = called_AE_invocation_identifier_val;
}

int AARQ_apdu::called_AE_invocation_identifier_is_present() const {
    return !!(bit_mask & 0x8000000);
}

void AARQ_apdu::omit_called_AE_invocation_identifier() {
    bit_mask &= ~0x8000000;
}

AARQ_apdu::calling_AP_title *AARQ_apdu::get_calling_AP_title() {
    if (bit_mask & 0x4000000)
	return &calling_AP_title_field;
    else
	return 0;
}

const AARQ_apdu::calling_AP_title *AARQ_apdu::get_calling_AP_title() const {
    if (bit_mask & 0x4000000)
	return &calling_AP_title_field;
    else
	return 0;
}

void AARQ_apdu::set_calling_AP_title(const calling_AP_title & calling_AP_title_val) {
    bit_mask |= 0x4000000;
    calling_AP_title_field = calling_AP_title_val;
}

int AARQ_apdu::calling_AP_title_is_present() const {
    return !!(bit_mask & 0x4000000);
}

void AARQ_apdu::omit_calling_AP_title() {
    calling_AP_title_field.~AP_title();
    bit_mask &= ~0x4000000;
}

AARQ_apdu::calling_AE_qualifier *AARQ_apdu::get_calling_AE_qualifier() {
    if (bit_mask & 0x2000000)
	return &calling_AE_qualifier_field;
    else
	return 0;
}

const AARQ_apdu::calling_AE_qualifier *AARQ_apdu::get_calling_AE_qualifier() const {
    if (bit_mask & 0x2000000)
	return &calling_AE_qualifier_field;
    else
	return 0;
}

void AARQ_apdu::set_calling_AE_qualifier(const calling_AE_qualifier & calling_AE_qualifier_val) {
    bit_mask |= 0x2000000;
    calling_AE_qualifier_field = calling_AE_qualifier_val;
}

int AARQ_apdu::calling_AE_qualifier_is_present() const {
    return !!(bit_mask & 0x2000000);
}

void AARQ_apdu::omit_calling_AE_qualifier() {
    calling_AE_qualifier_field.~AE_qualifier();
    bit_mask &= ~0x2000000;
}

AARQ_apdu::calling_AP_invocation_identifier *AARQ_apdu::get_calling_AP_invocation_identifier() {
    if (bit_mask & 0x1000000)
	return &calling_AP_invocation_identifier_field;
    else
	return 0;
}

const AARQ_apdu::calling_AP_invocation_identifier *AARQ_apdu::get_calling_AP_invocation_identifier() const {
    if (bit_mask & 0x1000000)
	return &calling_AP_invocation_identifier_field;
    else
	return 0;
}

void AARQ_apdu::set_calling_AP_invocation_identifier(calling_AP_invocation_identifier calling_AP_invocation_identifier_val) {
    bit_mask |= 0x1000000;
    calling_AP_invocation_identifier_field = calling_AP_invocation_identifier_val;
}

int AARQ_apdu::calling_AP_invocation_identifier_is_present() const {
    return !!(bit_mask & 0x1000000);
}

void AARQ_apdu::omit_calling_AP_invocation_identifier() {
    bit_mask &= ~0x1000000;
}

AARQ_apdu::calling_AE_invocation_identifier *AARQ_apdu::get_calling_AE_invocation_identifier() {
    if (bit_mask & 0x800000)
	return &calling_AE_invocation_identifier_field;
    else
	return 0;
}

const AARQ_apdu::calling_AE_invocation_identifier *AARQ_apdu::get_calling_AE_invocation_identifier() const {
    if (bit_mask & 0x800000)
	return &calling_AE_invocation_identifier_field;
    else
	return 0;
}

void AARQ_apdu::set_calling_AE_invocation_identifier(calling_AE_invocation_identifier calling_AE_invocation_identifier_val) {
    bit_mask |= 0x800000;
    calling_AE_invocation_identifier_field = calling_AE_invocation_identifier_val;
}

int AARQ_apdu::calling_AE_invocation_identifier_is_present() const {
    return !!(bit_mask & 0x800000);
}

void AARQ_apdu::omit_calling_AE_invocation_identifier() {
    bit_mask &= ~0x800000;
}

AARQ_apdu::sender_acse_requirements *AARQ_apdu::get_sender_acse_requirements() {
    if (bit_mask & 0x400000)
	return &sender_acse_requirements_field;
    else
	return 0;
}

const AARQ_apdu::sender_acse_requirements *AARQ_apdu::get_sender_acse_requirements() const {
    if (bit_mask & 0x400000)
	return &sender_acse_requirements_field;
    else
	return 0;
}

void AARQ_apdu::set_sender_acse_requirements(const sender_acse_requirements & sender_acse_requirements_val) {
    bit_mask |= 0x400000;
    sender_acse_requirements_field = sender_acse_requirements_val;
}

int AARQ_apdu::sender_acse_requirements_is_present() const {
    return !!(bit_mask & 0x400000);
}

void AARQ_apdu::omit_sender_acse_requirements() {
    sender_acse_requirements_field.~OssBitString();
    bit_mask &= ~0x400000;
}

AARQ_apdu::mechanism_name *AARQ_apdu::get_mechanism_name() {
    if (bit_mask & 0x200000)
	return &mechanism_name_field;
    else
	return 0;
}

const AARQ_apdu::mechanism_name *AARQ_apdu::get_mechanism_name() const {
    if (bit_mask & 0x200000)
	return &mechanism_name_field;
    else
	return 0;
}

void AARQ_apdu::set_mechanism_name(const mechanism_name & mechanism_name_val) {
    bit_mask |= 0x200000;
    mechanism_name_field = mechanism_name_val;
}

int AARQ_apdu::mechanism_name_is_present() const {
    return !!(bit_mask & 0x200000);
}

void AARQ_apdu::omit_mechanism_name() {
    mechanism_name_field.~OssEncOID();
    bit_mask &= ~0x200000;
}

AARQ_apdu::calling_authentication_value *AARQ_apdu::get_calling_authentication_value() {
    if (bit_mask & 0x100000)
	return &calling_authentication_value_field;
    else
	return 0;
}

const AARQ_apdu::calling_authentication_value *AARQ_apdu::get_calling_authentication_value() const {
    if (bit_mask & 0x100000)
	return &calling_authentication_value_field;
    else
	return 0;
}

void AARQ_apdu::set_calling_authentication_value(const calling_authentication_value & calling_authentication_value_val) {
    bit_mask |= 0x100000;
    calling_authentication_value_field = calling_authentication_value_val;
}

int AARQ_apdu::calling_authentication_value_is_present() const {
    return !!(bit_mask & 0x100000);
}

void AARQ_apdu::omit_calling_authentication_value() {
    calling_authentication_value_field.~Authentication_value();
    bit_mask &= ~0x100000;
}

AARQ_apdu::application_context_name_list *AARQ_apdu::get_application_context_name_list() {
    if (bit_mask & 0x80000)
	return &application_context_name_list_field;
    else
	return 0;
}

const AARQ_apdu::application_context_name_list *AARQ_apdu::get_application_context_name_list() const {
    if (bit_mask & 0x80000)
	return &application_context_name_list_field;
    else
	return 0;
}

void AARQ_apdu::set_application_context_name_list(const application_context_name_list & application_context_name_list_val) {
    bit_mask |= 0x80000;
    application_context_name_list_field = application_context_name_list_val;
}

int AARQ_apdu::application_context_name_list_is_present() const {
    return !!(bit_mask & 0x80000);
}

void AARQ_apdu::omit_application_context_name_list() {
    application_context_name_list_field.~__shared8();
    bit_mask &= ~0x80000;
}

AARQ_apdu::implementation_information *AARQ_apdu::get_implementation_information() {
    if (bit_mask & 0x40000)
	return &implementation_information_field;
    else
	return 0;
}

const AARQ_apdu::implementation_information *AARQ_apdu::get_implementation_information() const {
    if (bit_mask & 0x40000)
	return &implementation_information_field;
    else
	return 0;
}

void AARQ_apdu::set_implementation_information(const implementation_information & implementation_information_val) {
    bit_mask |= 0x40000;
    implementation_information_field = implementation_information_val;
}

int AARQ_apdu::implementation_information_is_present() const {
    return !!(bit_mask & 0x40000);
}

void AARQ_apdu::omit_implementation_information() {
    implementation_information_field.~OssString();
    bit_mask &= ~0x40000;
}

AARQ_apdu::user_information *AARQ_apdu::get_user_information() {
    if (bit_mask & 0x20000)
	return &user_information_field;
    else
	return 0;
}

const AARQ_apdu::user_information *AARQ_apdu::get_user_information() const {
    if (bit_mask & 0x20000)
	return &user_information_field;
    else
	return 0;
}

void AARQ_apdu::set_user_information(const user_information & user_information_val) {
    bit_mask |= 0x20000;
    user_information_field = user_information_val;
}

int AARQ_apdu::user_information_is_present() const {
    return !!(bit_mask & 0x20000);
}

void AARQ_apdu::omit_user_information() {
    user_information_field.~__shared9();
    bit_mask &= ~0x20000;
}

Associate_source_diagnostic::Associate_source_diagnostic() {
    memset(this, 0, sizeof(Associate_source_diagnostic));
}

Associate_source_diagnostic::Associate_source_diagnostic(const Associate_source_diagnostic & that) {
    memset(this, 0, sizeof(Associate_source_diagnostic));
    operator =(that);
}

Associate_source_diagnostic & Associate_source_diagnostic::operator = (const Associate_source_diagnostic & that) {
    if (this == &that)
	return *this;
    _choice = that._choice;
    switch (_choice) {
	case acse_service_user_chosen:
	    *(acse_service_user *)&acse_service_user_field = *(acse_service_user *)&that.acse_service_user_field;
	    break;
	case acse_service_provider_chosen:
	    *(acse_service_provider *)&acse_service_provider_field = *(acse_service_provider *)&that.acse_service_provider_field;
	    break;
    }
    return *this;
}

int Associate_source_diagnostic::operator == (const Associate_source_diagnostic & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case acse_service_user_chosen:
	    return *(acse_service_user *)&acse_service_user_field == *(acse_service_user *)&that.acse_service_user_field;
	case acse_service_provider_chosen:
	    return *(acse_service_provider *)&acse_service_provider_field == *(acse_service_provider *)&that.acse_service_provider_field;
    }

    return 1;
}

int Associate_source_diagnostic::operator != (const Associate_source_diagnostic & that) const {
    return !(operator ==(that));
}

Associate_source_diagnostic::acse_service_user *Associate_source_diagnostic::get_acse_service_user() {
    if (_choice == acse_service_user_chosen)
	return (acse_service_user *)&acse_service_user_field;
    else
	return 0;
}

const Associate_source_diagnostic::acse_service_user *Associate_source_diagnostic::get_acse_service_user() const {
    if (_choice == acse_service_user_chosen)
	return (const acse_service_user *)&acse_service_user_field;
    else
	return 0;
}

void Associate_source_diagnostic::set_acse_service_user(acse_service_user acse_service_user_val) {
    *(acse_service_user *)&acse_service_user_field = acse_service_user_val;
    _choice = acse_service_user_chosen;
}

Associate_source_diagnostic::acse_service_provider *Associate_source_diagnostic::get_acse_service_provider() {
    if (_choice == acse_service_provider_chosen)
	return (acse_service_provider *)&acse_service_provider_field;
    else
	return 0;
}

const Associate_source_diagnostic::acse_service_provider *Associate_source_diagnostic::get_acse_service_provider() const {
    if (_choice == acse_service_provider_chosen)
	return (const acse_service_provider *)&acse_service_provider_field;
    else
	return 0;
}

void Associate_source_diagnostic::set_acse_service_provider(acse_service_provider acse_service_provider_val) {
    *(acse_service_provider *)&acse_service_provider_field = acse_service_provider_val;
    _choice = acse_service_provider_chosen;
}

void *AARE_apdu::operator new(size_t size) {
    return ossNewFunc(size);
}

void AARE_apdu::operator delete(void *ptr) {
    asn1Free(ptr);
}

const OssBitString& AARE_apdu::get_default_protocol_version() {
    return AARE_apdu::default_protocol_version;
}

AARE_apdu::AARE_apdu() {
    memset(this, 0, sizeof(AARE_apdu));
}

AARE_apdu::AARE_apdu(const AARE_apdu & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	if (bit_mask & 0x80000000)
	    protocol_version_field = that.protocol_version_field;
	application_context_name_field = that.application_context_name_field;
	result_field = that.result_field;
	result_source_diagnostic_field = that.result_source_diagnostic_field;
	responding_AP_title_field = that.responding_AP_title_field;
	responding_AE_qualifier_field = that.responding_AE_qualifier_field;
	responding_AP_invocation_identifier_field = that.responding_AP_invocation_identifier_field;
	responding_AE_invocation_identifier_field = that.responding_AE_invocation_identifier_field;
	responder_acse_requirements_field = that.responder_acse_requirements_field;
	mechanism_name_field = that.mechanism_name_field;
	responding_authentication_value_field = that.responding_authentication_value_field;
	application_context_name_list_field = that.application_context_name_list_field;
	implementation_information_field = that.implementation_information_field;
	user_information_field = that.user_information_field;
    } OSSCLEAN(AARE_apdu)
}

AARE_apdu::AARE_apdu(const protocol_version & protocol_version_val, const application_context_name & application_context_name_val, 
    result result_val, const result_source_diagnostic & result_source_diagnostic_val, 
    const responding_AP_title & responding_AP_title_val, const responding_AE_qualifier & responding_AE_qualifier_val, 
    responding_AP_invocation_identifier responding_AP_invocation_identifier_val, responding_AE_invocation_identifier responding_AE_invocation_identifier_val, 
    const responder_acse_requirements & responder_acse_requirements_val, const mechanism_name & mechanism_name_val, 
    const responding_authentication_value & responding_authentication_value_val, const application_context_name_list & application_context_name_list_val, 
    const implementation_information & implementation_information_val, const user_information & user_information_val) {
    OSSTRY {
	bit_mask = 0xffe00000;
	protocol_version_field = protocol_version_val;
	application_context_name_field = application_context_name_val;
	result_field = result_val;
	result_source_diagnostic_field = result_source_diagnostic_val;
	responding_AP_title_field = responding_AP_title_val;
	responding_AE_qualifier_field = responding_AE_qualifier_val;
	responding_AP_invocation_identifier_field = responding_AP_invocation_identifier_val;
	responding_AE_invocation_identifier_field = responding_AE_invocation_identifier_val;
	responder_acse_requirements_field = responder_acse_requirements_val;
	mechanism_name_field = mechanism_name_val;
	responding_authentication_value_field = responding_authentication_value_val;
	application_context_name_list_field = application_context_name_list_val;
	implementation_information_field = implementation_information_val;
	user_information_field = user_information_val;
    } OSSCLEAN(AARE_apdu)
}

AARE_apdu::AARE_apdu(const application_context_name & application_context_name_val, 
    result result_val, const result_source_diagnostic & result_source_diagnostic_val) {
    OSSTRY {
	bit_mask = 0;
	application_context_name_field = application_context_name_val;
	result_field = result_val;
	result_source_diagnostic_field = result_source_diagnostic_val;
    } OSSCLEAN(AARE_apdu)
}

AARE_apdu::~AARE_apdu() {
    if (!(bit_mask & 0x80000000))
	memset(&protocol_version_field, 0, sizeof(protocol_version));
}

AARE_apdu & AARE_apdu::operator = (const AARE_apdu & that) {
    if (this == &that)
	return *this;
    this->~AARE_apdu();
    bit_mask = that.bit_mask;
    if (bit_mask & 0x80000000)
	protocol_version_field = that.protocol_version_field;
    application_context_name_field = that.application_context_name_field;
    result_field = that.result_field;
    result_source_diagnostic_field = that.result_source_diagnostic_field;
    responding_AP_title_field = that.responding_AP_title_field;
    responding_AE_qualifier_field = that.responding_AE_qualifier_field;
    responding_AP_invocation_identifier_field = that.responding_AP_invocation_identifier_field;
    responding_AE_invocation_identifier_field = that.responding_AE_invocation_identifier_field;
    responder_acse_requirements_field = that.responder_acse_requirements_field;
    mechanism_name_field = that.mechanism_name_field;
    responding_authentication_value_field = that.responding_authentication_value_field;
    application_context_name_list_field = that.application_context_name_list_field;
    implementation_information_field = that.implementation_information_field;
    user_information_field = that.user_information_field;
    return *this;
}

int AARE_apdu::operator == (const AARE_apdu & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (protocol_version_field != that.protocol_version_field)
	    return 0;
    }
    if (application_context_name_field != that.application_context_name_field)
	return 0;
    if (result_field != that.result_field)
	return 0;
    if (result_source_diagnostic_field != that.result_source_diagnostic_field)
	return 0;
    if (bit_mask & 0x40000000) {
	if (responding_AP_title_field != that.responding_AP_title_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (responding_AE_qualifier_field != that.responding_AE_qualifier_field)
	    return 0;
    }
    if (bit_mask & 0x10000000) {
	if (responding_AP_invocation_identifier_field != that.responding_AP_invocation_identifier_field)
	    return 0;
    }
    if (bit_mask & 0x8000000) {
	if (responding_AE_invocation_identifier_field != that.responding_AE_invocation_identifier_field)
	    return 0;
    }
    if (bit_mask & 0x4000000) {
	if (responder_acse_requirements_field != that.responder_acse_requirements_field)
	    return 0;
    }
    if (bit_mask & 0x2000000) {
	if (mechanism_name_field != that.mechanism_name_field)
	    return 0;
    }
    if (bit_mask & 0x1000000) {
	if (responding_authentication_value_field != that.responding_authentication_value_field)
	    return 0;
    }
    if (bit_mask & 0x800000) {
	if (application_context_name_list_field != that.application_context_name_list_field)
	    return 0;
    }
    if (bit_mask & 0x400000) {
	if (implementation_information_field != that.implementation_information_field)
	    return 0;
    }
    if (bit_mask & 0x200000) {
	if (user_information_field != that.user_information_field)
	    return 0;
    }
    return 1;
}

int AARE_apdu::operator != (const AARE_apdu & that) const {
    return !(operator ==(that));
}

AARE_apdu::protocol_version *AARE_apdu::get_protocol_version() {
    if (bit_mask & 0x80000000)
	return &protocol_version_field;
    else
	return 0;
}

const AARE_apdu::protocol_version *AARE_apdu::get_protocol_version() const {
    if (bit_mask & 0x80000000)
	return &protocol_version_field;
    else
	return 0;
}

void AARE_apdu::set_protocol_version(const protocol_version & protocol_version_val) {
    if (!(bit_mask & 0x80000000)) {
	memset(&protocol_version_field, 0, sizeof(protocol_version));
	bit_mask |= 0x80000000;
    }
    protocol_version_field = protocol_version_val;
}

int AARE_apdu::protocol_version_is_default() const {
    return !(bit_mask & 0x80000000);
}

void AARE_apdu::set_default_protocol_version() {
    if (bit_mask & 0x80000000) {
	protocol_version_field.~OssBitString();
	bit_mask &= ~0x80000000;
    }
}

AARE_apdu::application_context_name & AARE_apdu::get_application_context_name() {
    return application_context_name_field;
}

const AARE_apdu::application_context_name & AARE_apdu::get_application_context_name() const {
    return application_context_name_field;
}

void AARE_apdu::set_application_context_name(const application_context_name & application_context_name_val) {
    application_context_name_field = application_context_name_val;
}

AARE_apdu::result & AARE_apdu::get_result() {
    return result_field;
}

AARE_apdu::result AARE_apdu::get_result() const {
    return result_field;
}

void AARE_apdu::set_result(result result_val) {
    result_field = result_val;
}

AARE_apdu::result_source_diagnostic & AARE_apdu::get_result_source_diagnostic() {
    return result_source_diagnostic_field;
}

const AARE_apdu::result_source_diagnostic & AARE_apdu::get_result_source_diagnostic() const {
    return result_source_diagnostic_field;
}

void AARE_apdu::set_result_source_diagnostic(const result_source_diagnostic & result_source_diagnostic_val) {
    result_source_diagnostic_field = result_source_diagnostic_val;
}

AARE_apdu::responding_AP_title *AARE_apdu::get_responding_AP_title() {
    if (bit_mask & 0x40000000)
	return &responding_AP_title_field;
    else
	return 0;
}

const AARE_apdu::responding_AP_title *AARE_apdu::get_responding_AP_title() const {
    if (bit_mask & 0x40000000)
	return &responding_AP_title_field;
    else
	return 0;
}

void AARE_apdu::set_responding_AP_title(const responding_AP_title & responding_AP_title_val) {
    bit_mask |= 0x40000000;
    responding_AP_title_field = responding_AP_title_val;
}

int AARE_apdu::responding_AP_title_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void AARE_apdu::omit_responding_AP_title() {
    responding_AP_title_field.~AP_title();
    bit_mask &= ~0x40000000;
}

AARE_apdu::responding_AE_qualifier *AARE_apdu::get_responding_AE_qualifier() {
    if (bit_mask & 0x20000000)
	return &responding_AE_qualifier_field;
    else
	return 0;
}

const AARE_apdu::responding_AE_qualifier *AARE_apdu::get_responding_AE_qualifier() const {
    if (bit_mask & 0x20000000)
	return &responding_AE_qualifier_field;
    else
	return 0;
}

void AARE_apdu::set_responding_AE_qualifier(const responding_AE_qualifier & responding_AE_qualifier_val) {
    bit_mask |= 0x20000000;
    responding_AE_qualifier_field = responding_AE_qualifier_val;
}

int AARE_apdu::responding_AE_qualifier_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void AARE_apdu::omit_responding_AE_qualifier() {
    responding_AE_qualifier_field.~AE_qualifier();
    bit_mask &= ~0x20000000;
}

AARE_apdu::responding_AP_invocation_identifier *AARE_apdu::get_responding_AP_invocation_identifier() {
    if (bit_mask & 0x10000000)
	return &responding_AP_invocation_identifier_field;
    else
	return 0;
}

const AARE_apdu::responding_AP_invocation_identifier *AARE_apdu::get_responding_AP_invocation_identifier() const {
    if (bit_mask & 0x10000000)
	return &responding_AP_invocation_identifier_field;
    else
	return 0;
}

void AARE_apdu::set_responding_AP_invocation_identifier(responding_AP_invocation_identifier responding_AP_invocation_identifier_val) {
    bit_mask |= 0x10000000;
    responding_AP_invocation_identifier_field = responding_AP_invocation_identifier_val;
}

int AARE_apdu::responding_AP_invocation_identifier_is_present() const {
    return !!(bit_mask & 0x10000000);
}

void AARE_apdu::omit_responding_AP_invocation_identifier() {
    bit_mask &= ~0x10000000;
}

AARE_apdu::responding_AE_invocation_identifier *AARE_apdu::get_responding_AE_invocation_identifier() {
    if (bit_mask & 0x8000000)
	return &responding_AE_invocation_identifier_field;
    else
	return 0;
}

const AARE_apdu::responding_AE_invocation_identifier *AARE_apdu::get_responding_AE_invocation_identifier() const {
    if (bit_mask & 0x8000000)
	return &responding_AE_invocation_identifier_field;
    else
	return 0;
}

void AARE_apdu::set_responding_AE_invocation_identifier(responding_AE_invocation_identifier responding_AE_invocation_identifier_val) {
    bit_mask |= 0x8000000;
    responding_AE_invocation_identifier_field = responding_AE_invocation_identifier_val;
}

int AARE_apdu::responding_AE_invocation_identifier_is_present() const {
    return !!(bit_mask & 0x8000000);
}

void AARE_apdu::omit_responding_AE_invocation_identifier() {
    bit_mask &= ~0x8000000;
}

AARE_apdu::responder_acse_requirements *AARE_apdu::get_responder_acse_requirements() {
    if (bit_mask & 0x4000000)
	return &responder_acse_requirements_field;
    else
	return 0;
}

const AARE_apdu::responder_acse_requirements *AARE_apdu::get_responder_acse_requirements() const {
    if (bit_mask & 0x4000000)
	return &responder_acse_requirements_field;
    else
	return 0;
}

void AARE_apdu::set_responder_acse_requirements(const responder_acse_requirements & responder_acse_requirements_val) {
    bit_mask |= 0x4000000;
    responder_acse_requirements_field = responder_acse_requirements_val;
}

int AARE_apdu::responder_acse_requirements_is_present() const {
    return !!(bit_mask & 0x4000000);
}

void AARE_apdu::omit_responder_acse_requirements() {
    responder_acse_requirements_field.~OssBitString();
    bit_mask &= ~0x4000000;
}

AARE_apdu::mechanism_name *AARE_apdu::get_mechanism_name() {
    if (bit_mask & 0x2000000)
	return &mechanism_name_field;
    else
	return 0;
}

const AARE_apdu::mechanism_name *AARE_apdu::get_mechanism_name() const {
    if (bit_mask & 0x2000000)
	return &mechanism_name_field;
    else
	return 0;
}

void AARE_apdu::set_mechanism_name(const mechanism_name & mechanism_name_val) {
    bit_mask |= 0x2000000;
    mechanism_name_field = mechanism_name_val;
}

int AARE_apdu::mechanism_name_is_present() const {
    return !!(bit_mask & 0x2000000);
}

void AARE_apdu::omit_mechanism_name() {
    mechanism_name_field.~OssEncOID();
    bit_mask &= ~0x2000000;
}

AARE_apdu::responding_authentication_value *AARE_apdu::get_responding_authentication_value() {
    if (bit_mask & 0x1000000)
	return &responding_authentication_value_field;
    else
	return 0;
}

const AARE_apdu::responding_authentication_value *AARE_apdu::get_responding_authentication_value() const {
    if (bit_mask & 0x1000000)
	return &responding_authentication_value_field;
    else
	return 0;
}

void AARE_apdu::set_responding_authentication_value(const responding_authentication_value & responding_authentication_value_val) {
    bit_mask |= 0x1000000;
    responding_authentication_value_field = responding_authentication_value_val;
}

int AARE_apdu::responding_authentication_value_is_present() const {
    return !!(bit_mask & 0x1000000);
}

void AARE_apdu::omit_responding_authentication_value() {
    responding_authentication_value_field.~Authentication_value();
    bit_mask &= ~0x1000000;
}

AARE_apdu::application_context_name_list *AARE_apdu::get_application_context_name_list() {
    if (bit_mask & 0x800000)
	return &application_context_name_list_field;
    else
	return 0;
}

const AARE_apdu::application_context_name_list *AARE_apdu::get_application_context_name_list() const {
    if (bit_mask & 0x800000)
	return &application_context_name_list_field;
    else
	return 0;
}

void AARE_apdu::set_application_context_name_list(const application_context_name_list & application_context_name_list_val) {
    bit_mask |= 0x800000;
    application_context_name_list_field = application_context_name_list_val;
}

int AARE_apdu::application_context_name_list_is_present() const {
    return !!(bit_mask & 0x800000);
}

void AARE_apdu::omit_application_context_name_list() {
    application_context_name_list_field.~__shared8();
    bit_mask &= ~0x800000;
}

AARE_apdu::implementation_information *AARE_apdu::get_implementation_information() {
    if (bit_mask & 0x400000)
	return &implementation_information_field;
    else
	return 0;
}

const AARE_apdu::implementation_information *AARE_apdu::get_implementation_information() const {
    if (bit_mask & 0x400000)
	return &implementation_information_field;
    else
	return 0;
}

void AARE_apdu::set_implementation_information(const implementation_information & implementation_information_val) {
    bit_mask |= 0x400000;
    implementation_information_field = implementation_information_val;
}

int AARE_apdu::implementation_information_is_present() const {
    return !!(bit_mask & 0x400000);
}

void AARE_apdu::omit_implementation_information() {
    implementation_information_field.~OssString();
    bit_mask &= ~0x400000;
}

AARE_apdu::user_information *AARE_apdu::get_user_information() {
    if (bit_mask & 0x200000)
	return &user_information_field;
    else
	return 0;
}

const AARE_apdu::user_information *AARE_apdu::get_user_information() const {
    if (bit_mask & 0x200000)
	return &user_information_field;
    else
	return 0;
}

void AARE_apdu::set_user_information(const user_information & user_information_val) {
    bit_mask |= 0x200000;
    user_information_field = user_information_val;
}

int AARE_apdu::user_information_is_present() const {
    return !!(bit_mask & 0x200000);
}

void AARE_apdu::omit_user_information() {
    user_information_field.~__shared9();
    bit_mask &= ~0x200000;
}

void *__shared10::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared10::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared10::__shared10() {
    memset(this, 0, sizeof(__shared10));
}

__shared10::__shared10(const __shared10 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	reason_field = that.reason_field;
	user_information_field = that.user_information_field;
    } OSSCLEAN(__shared10)
}

__shared10::__shared10(reason reason_val, const user_information & user_information_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	reason_field = reason_val;
	user_information_field = user_information_val;
    } OSSCLEAN(__shared10)
}

__shared10 & __shared10::operator = (const __shared10 & that) {
    if (this == &that)
	return *this;
    this->~__shared10();
    bit_mask = that.bit_mask;
    reason_field = that.reason_field;
    user_information_field = that.user_information_field;
    return *this;
}

int __shared10::operator == (const __shared10 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (reason_field != that.reason_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (user_information_field != that.user_information_field)
	    return 0;
    }
    return 1;
}

int __shared10::operator != (const __shared10 & that) const {
    return !(operator ==(that));
}

__shared10::reason *__shared10::get_reason() {
    if (bit_mask & 0x80000000)
	return &reason_field;
    else
	return 0;
}

const __shared10::reason *__shared10::get_reason() const {
    if (bit_mask & 0x80000000)
	return &reason_field;
    else
	return 0;
}

void __shared10::set_reason(reason reason_val) {
    bit_mask |= 0x80000000;
    reason_field = reason_val;
}

int __shared10::reason_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void __shared10::omit_reason() {
    bit_mask &= ~0x80000000;
}

__shared10::user_information *__shared10::get_user_information() {
    if (bit_mask & 0x40000000)
	return &user_information_field;
    else
	return 0;
}

const __shared10::user_information *__shared10::get_user_information() const {
    if (bit_mask & 0x40000000)
	return &user_information_field;
    else
	return 0;
}

void __shared10::set_user_information(const user_information & user_information_val) {
    bit_mask |= 0x40000000;
    user_information_field = user_information_val;
}

int __shared10::user_information_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void __shared10::omit_user_information() {
    user_information_field.~__shared9();
    bit_mask &= ~0x40000000;
}

void *ABRT_apdu::operator new(size_t size) {
    return ossNewFunc(size);
}

void ABRT_apdu::operator delete(void *ptr) {
    asn1Free(ptr);
}

ABRT_apdu::ABRT_apdu() {
    memset(this, 0, sizeof(ABRT_apdu));
}

ABRT_apdu::ABRT_apdu(const ABRT_apdu & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	abort_source_field = that.abort_source_field;
	abort_diagnostic_field = that.abort_diagnostic_field;
	user_information_field = that.user_information_field;
    } OSSCLEAN(ABRT_apdu)
}

ABRT_apdu::ABRT_apdu(abort_source abort_source_val, abort_diagnostic abort_diagnostic_val, 
    const user_information & user_information_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	abort_source_field = abort_source_val;
	abort_diagnostic_field = abort_diagnostic_val;
	user_information_field = user_information_val;
    } OSSCLEAN(ABRT_apdu)
}

ABRT_apdu::ABRT_apdu(abort_source abort_source_val) {
    OSSTRY {
	bit_mask = 0;
	abort_source_field = abort_source_val;
    } OSSCLEAN(ABRT_apdu)
}

ABRT_apdu & ABRT_apdu::operator = (const ABRT_apdu & that) {
    if (this == &that)
	return *this;
    this->~ABRT_apdu();
    bit_mask = that.bit_mask;
    abort_source_field = that.abort_source_field;
    abort_diagnostic_field = that.abort_diagnostic_field;
    user_information_field = that.user_information_field;
    return *this;
}

int ABRT_apdu::operator == (const ABRT_apdu & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (abort_source_field != that.abort_source_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (abort_diagnostic_field != that.abort_diagnostic_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (user_information_field != that.user_information_field)
	    return 0;
    }
    return 1;
}

int ABRT_apdu::operator != (const ABRT_apdu & that) const {
    return !(operator ==(that));
}

ABRT_apdu::abort_source & ABRT_apdu::get_abort_source() {
    return abort_source_field;
}

ABRT_apdu::abort_source ABRT_apdu::get_abort_source() const {
    return abort_source_field;
}

void ABRT_apdu::set_abort_source(abort_source abort_source_val) {
    abort_source_field = abort_source_val;
}

ABRT_apdu::abort_diagnostic *ABRT_apdu::get_abort_diagnostic() {
    if (bit_mask & 0x80000000)
	return &abort_diagnostic_field;
    else
	return 0;
}

const ABRT_apdu::abort_diagnostic *ABRT_apdu::get_abort_diagnostic() const {
    if (bit_mask & 0x80000000)
	return &abort_diagnostic_field;
    else
	return 0;
}

void ABRT_apdu::set_abort_diagnostic(abort_diagnostic abort_diagnostic_val) {
    bit_mask |= 0x80000000;
    abort_diagnostic_field = abort_diagnostic_val;
}

int ABRT_apdu::abort_diagnostic_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void ABRT_apdu::omit_abort_diagnostic() {
    bit_mask &= ~0x80000000;
}

ABRT_apdu::user_information *ABRT_apdu::get_user_information() {
    if (bit_mask & 0x40000000)
	return &user_information_field;
    else
	return 0;
}

const ABRT_apdu::user_information *ABRT_apdu::get_user_information() const {
    if (bit_mask & 0x40000000)
	return &user_information_field;
    else
	return 0;
}

void ABRT_apdu::set_user_information(const user_information & user_information_val) {
    bit_mask |= 0x40000000;
    user_information_field = user_information_val;
}

int ABRT_apdu::user_information_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void ABRT_apdu::omit_user_information() {
    user_information_field.~__shared9();
    bit_mask &= ~0x40000000;
}

ACSE_apdu::ACSE_apdu() {
    memset(this, 0, sizeof(ACSE_apdu));
}

ACSE_apdu::ACSE_apdu(const ACSE_apdu & that) {
    memset(this, 0, sizeof(ACSE_apdu));
    operator =(that);
}

ACSE_apdu::~ACSE_apdu() {
    cleanup();
}

ACSE_apdu & ACSE_apdu::operator = (const ACSE_apdu & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case aarq_chosen:
	    if (that.aarq_field)
		aarq_field = new aarq(*that.aarq_field);
	    break;
	case aare_chosen:
	    if (that.aare_field)
		aare_field = new aare(*that.aare_field);
	    break;
	case rlrq_chosen:
	    if (that.rlrq_field)
		rlrq_field = new rlrq(*that.rlrq_field);
	    break;
	case rlre_chosen:
	    if (that.rlre_field)
		rlre_field = new rlre(*that.rlre_field);
	    break;
	case abrt_chosen:
	    if (that.abrt_field)
		abrt_field = new abrt(*that.abrt_field);
	    break;
    }
    return *this;
}

int ACSE_apdu::operator == (const ACSE_apdu & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case aarq_chosen:
	    if ((aarq_field) && (that.aarq_field))
		return (*aarq_field == *(that.aarq_field));
	    else if (!((!aarq_field) && (!that.aarq_field)))
		return 0;
	    break;
	case aare_chosen:
	    if ((aare_field) && (that.aare_field))
		return (*aare_field == *(that.aare_field));
	    else if (!((!aare_field) && (!that.aare_field)))
		return 0;
	    break;
	case rlrq_chosen:
	    if ((rlrq_field) && (that.rlrq_field))
		return (*rlrq_field == *(that.rlrq_field));
	    else if (!((!rlrq_field) && (!that.rlrq_field)))
		return 0;
	    break;
	case rlre_chosen:
	    if ((rlre_field) && (that.rlre_field))
		return (*rlre_field == *(that.rlre_field));
	    else if (!((!rlre_field) && (!that.rlre_field)))
		return 0;
	    break;
	case abrt_chosen:
	    if ((abrt_field) && (that.abrt_field))
		return (*abrt_field == *(that.abrt_field));
	    else if (!((!abrt_field) && (!that.abrt_field)))
		return 0;
	    break;
    }

    return 1;
}

int ACSE_apdu::operator != (const ACSE_apdu & that) const {
    return !(operator ==(that));
}

ACSE_apdu::aarq *ACSE_apdu::get_aarq() {
    if (_choice == aarq_chosen)
	return (aarq *)aarq_field;
    else
	return 0;
}

const ACSE_apdu::aarq *ACSE_apdu::get_aarq() const {
    if (_choice == aarq_chosen)
	return (const aarq *)aarq_field;
    else
	return 0;
}

void ACSE_apdu::set_aarq(const aarq & aarq_val) {
    cleanup();
    aarq_field = new aarq(aarq_val);
    _choice = aarq_chosen;
}

ACSE_apdu::aare *ACSE_apdu::get_aare() {
    if (_choice == aare_chosen)
	return (aare *)aare_field;
    else
	return 0;
}

const ACSE_apdu::aare *ACSE_apdu::get_aare() const {
    if (_choice == aare_chosen)
	return (const aare *)aare_field;
    else
	return 0;
}

void ACSE_apdu::set_aare(const aare & aare_val) {
    cleanup();
    aare_field = new aare(aare_val);
    _choice = aare_chosen;
}

ACSE_apdu::rlrq *ACSE_apdu::get_rlrq() {
    if (_choice == rlrq_chosen)
	return (rlrq *)rlrq_field;
    else
	return 0;
}

const ACSE_apdu::rlrq *ACSE_apdu::get_rlrq() const {
    if (_choice == rlrq_chosen)
	return (const rlrq *)rlrq_field;
    else
	return 0;
}

void ACSE_apdu::set_rlrq(const rlrq & rlrq_val) {
    cleanup();
    rlrq_field = new rlrq(rlrq_val);
    _choice = rlrq_chosen;
}

ACSE_apdu::rlre *ACSE_apdu::get_rlre() {
    if (_choice == rlre_chosen)
	return (rlre *)rlre_field;
    else
	return 0;
}

const ACSE_apdu::rlre *ACSE_apdu::get_rlre() const {
    if (_choice == rlre_chosen)
	return (const rlre *)rlre_field;
    else
	return 0;
}

void ACSE_apdu::set_rlre(const rlre & rlre_val) {
    cleanup();
    rlre_field = new rlre(rlre_val);
    _choice = rlre_chosen;
}

ACSE_apdu::abrt *ACSE_apdu::get_abrt() {
    if (_choice == abrt_chosen)
	return (abrt *)abrt_field;
    else
	return 0;
}

const ACSE_apdu::abrt *ACSE_apdu::get_abrt() const {
    if (_choice == abrt_chosen)
	return (const abrt *)abrt_field;
    else
	return 0;
}

void ACSE_apdu::set_abrt(const abrt & abrt_val) {
    cleanup();
    abrt_field = new abrt(abrt_val);
    _choice = abrt_chosen;
}

void ACSE_apdu::cleanup() {
    switch (_choice) {
	case aarq_chosen:
	    if (aarq_field)
		delete aarq_field;
	    break;
	case aare_chosen:
	    if (aare_field)
		delete aare_field;
	    break;
	case rlrq_chosen:
	    if (rlrq_field)
		delete rlrq_field;
	    break;
	case rlre_chosen:
	    if (rlre_field)
		delete rlre_field;
	    break;
	case abrt_chosen:
	    if (abrt_field)
		delete abrt_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

void *__shared11::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared11::operator delete(void *ptr) {
    asn1Free(ptr);
}

ossBoolean __shared11::get_default_concatenation() {
    return __shared11::default_concatenation;
}

__shared11::__shared11() {
    memset(this, 0, sizeof(__shared11));
}

__shared11::__shared11(const __shared11 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	realization_type_field = that.realization_type_field;
	concatenation_field = that.concatenation_field;
    } OSSCLEAN(__shared11)
}

__shared11::__shared11(realization_type realization_type_val, concatenation concatenation_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	realization_type_field = realization_type_val;
	concatenation_field = concatenation_val;
    } OSSCLEAN(__shared11)
}

__shared11::__shared11(realization_type realization_type_val) {
    OSSTRY {
	bit_mask = 0;
	realization_type_field = realization_type_val;
    } OSSCLEAN(__shared11)
}

__shared11 & __shared11::operator = (const __shared11 & that) {
    if (this == &that)
	return *this;
    this->~__shared11();
    bit_mask = that.bit_mask;
    realization_type_field = that.realization_type_field;
    concatenation_field = that.concatenation_field;
    return *this;
}

int __shared11::operator == (const __shared11 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (realization_type_field != that.realization_type_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (concatenation_field != that.concatenation_field)
	    return 0;
    }
    return 1;
}

int __shared11::operator != (const __shared11 & that) const {
    return !(operator ==(that));
}

__shared11::realization_type & __shared11::get_realization_type() {
    return realization_type_field;
}

__shared11::realization_type __shared11::get_realization_type() const {
    return realization_type_field;
}

void __shared11::set_realization_type(realization_type realization_type_val) {
    realization_type_field = realization_type_val;
}

__shared11::concatenation *__shared11::get_concatenation() {
    if (bit_mask & 0x80000000)
	return &concatenation_field;
    else
	return 0;
}

const __shared11::concatenation *__shared11::get_concatenation() const {
    if (bit_mask & 0x80000000)
	return &concatenation_field;
    else
	return 0;
}

void __shared11::set_concatenation(concatenation concatenation_val) {
    bit_mask |= 0x80000000;
    concatenation_field = concatenation_val;
}

int __shared11::concatenation_is_default() const {
    return !(bit_mask & 0x80000000);
}

void __shared11::set_default_concatenation() {
    bit_mask &= ~0x80000000;
}

AE_title::AE_title() {
    memset(this, 0, sizeof(AE_title));
}

AE_title::AE_title(const AE_title & that) {
    memset(this, 0, sizeof(AE_title));
    operator =(that);
}

AE_title::~AE_title() {
    cleanup();
}

AE_title & AE_title::operator = (const AE_title & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case ae_title_form1_chosen:
	    if (that.ae_title_form1_field)
		ae_title_form1_field = new ae_title_form1(*that.ae_title_form1_field);
	    break;
	case ae_title_form2_chosen:
	    *(ae_title_form2 *)&ae_title_form2_field = *(ae_title_form2 *)&that.ae_title_form2_field;
	    break;
    }
    return *this;
}

int AE_title::operator == (const AE_title & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case ae_title_form1_chosen:
	    if ((ae_title_form1_field) && (that.ae_title_form1_field))
		return (*ae_title_form1_field == *(that.ae_title_form1_field));
	    else if (!((!ae_title_form1_field) && (!that.ae_title_form1_field)))
		return 0;
	    break;
	case ae_title_form2_chosen:
	    return *(ae_title_form2 *)&ae_title_form2_field == *(ae_title_form2 *)&that.ae_title_form2_field;
    }

    return 1;
}

int AE_title::operator != (const AE_title & that) const {
    return !(operator ==(that));
}

AE_title::ae_title_form1 *AE_title::get_ae_title_form1() {
    if (_choice == ae_title_form1_chosen)
	return (ae_title_form1 *)ae_title_form1_field;
    else
	return 0;
}

const AE_title::ae_title_form1 *AE_title::get_ae_title_form1() const {
    if (_choice == ae_title_form1_chosen)
	return (const ae_title_form1 *)ae_title_form1_field;
    else
	return 0;
}

void AE_title::set_ae_title_form1(const ae_title_form1 & ae_title_form1_val) {
    cleanup();
    ae_title_form1_field = new ae_title_form1(ae_title_form1_val);
    _choice = ae_title_form1_chosen;
}

AE_title::ae_title_form2 *AE_title::get_ae_title_form2() {
    if (_choice == ae_title_form2_chosen)
	return (ae_title_form2 *)&ae_title_form2_field;
    else
	return 0;
}

const AE_title::ae_title_form2 *AE_title::get_ae_title_form2() const {
    if (_choice == ae_title_form2_chosen)
	return (const ae_title_form2 *)&ae_title_form2_field;
    else
	return 0;
}

void AE_title::set_ae_title_form2(const ae_title_form2 & ae_title_form2_val) {
    cleanup();
    *(ae_title_form2 *)&ae_title_form2_field = ae_title_form2_val;
    _choice = ae_title_form2_chosen;
}

void AE_title::cleanup() {
    switch (_choice) {
	case ae_title_form1_chosen:
	    if (ae_title_form1_field)
		delete ae_title_form1_field;
	    break;
	case ae_title_form2_chosen:
	    ((ae_title_form2 *)&ae_title_form2_field)->~OssEncOID();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

void *Mode_selector::operator new(size_t size) {
    return ossNewFunc(size);
}

void Mode_selector::operator delete(void *ptr) {
    asn1Free(ptr);
}

Mode_selector::Mode_selector() {
    memset(this, 0, sizeof(Mode_selector));
}

Mode_selector::Mode_selector(const Mode_selector & that) {
    OSSTRY {
	mode_value_field = that.mode_value_field;
    } OSSCLEAN(Mode_selector)
}

Mode_selector::Mode_selector(mode_value mode_value_val) {
    OSSTRY {
	mode_value_field = mode_value_val;
    } OSSCLEAN(Mode_selector)
}

Mode_selector & Mode_selector::operator = (const Mode_selector & that) {
    if (this == &that)
	return *this;
    mode_value_field = that.mode_value_field;
    return *this;
}

int Mode_selector::operator == (const Mode_selector & that) const {
    if (mode_value_field != that.mode_value_field)
	return 0;
    return 1;
}

int Mode_selector::operator != (const Mode_selector & that) const {
    return !(operator ==(that));
}

Mode_selector::mode_value & Mode_selector::get_mode_value() {
    return mode_value_field;
}

Mode_selector::mode_value Mode_selector::get_mode_value() const {
    return mode_value_field;
}

void Mode_selector::set_mode_value(mode_value mode_value_val) {
    mode_value_field = mode_value_val;
}

CallingSSuserReference::CallingSSuserReference() {
    memset(this, 0, sizeof(CallingSSuserReference));
}

CallingSSuserReference::CallingSSuserReference(const CallingSSuserReference & that) {
    memset(this, 0, sizeof(CallingSSuserReference));
    operator =(that);
}

CallingSSuserReference::~CallingSSuserReference() {
    cleanup();
}

CallingSSuserReference & CallingSSuserReference::operator = (const CallingSSuserReference & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case t61String_chosen:
	    *(t61String *)&t61String_field = *(t61String *)&that.t61String_field;
	    break;
	case octetString_chosen:
	    *(octetString *)&octetString_field = *(octetString *)&that.octetString_field;
	    break;
    }
    return *this;
}

int CallingSSuserReference::operator == (const CallingSSuserReference & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case t61String_chosen:
	    return *(t61String *)&t61String_field == *(t61String *)&that.t61String_field;
	case octetString_chosen:
	    return *(octetString *)&octetString_field == *(octetString *)&that.octetString_field;
    }

    return 1;
}

int CallingSSuserReference::operator != (const CallingSSuserReference & that) const {
    return !(operator ==(that));
}

CallingSSuserReference::t61String *CallingSSuserReference::get_t61String() {
    if (_choice == t61String_chosen)
	return (t61String *)&t61String_field;
    else
	return 0;
}

const CallingSSuserReference::t61String *CallingSSuserReference::get_t61String() const {
    if (_choice == t61String_chosen)
	return (const t61String *)&t61String_field;
    else
	return 0;
}

void CallingSSuserReference::set_t61String(const t61String & t61String_val) {
    cleanup();
    *(t61String *)&t61String_field = t61String_val;
    _choice = t61String_chosen;
}

CallingSSuserReference::octetString *CallingSSuserReference::get_octetString() {
    if (_choice == octetString_chosen)
	return (octetString *)&octetString_field;
    else
	return 0;
}

const CallingSSuserReference::octetString *CallingSSuserReference::get_octetString() const {
    if (_choice == octetString_chosen)
	return (const octetString *)&octetString_field;
    else
	return 0;
}

void CallingSSuserReference::set_octetString(const octetString & octetString_val) {
    cleanup();
    *(octetString *)&octetString_field = octetString_val;
    _choice = octetString_chosen;
}

void CallingSSuserReference::cleanup() {
    switch (_choice) {
	case t61String_chosen:
	    ((t61String *)&t61String_field)->~OssString();
	    break;
	case octetString_chosen:
	    ((octetString *)&octetString_field)->~OssString();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

void *SessionConnectionIdentifier::operator new(size_t size) {
    return ossNewFunc(size);
}

void SessionConnectionIdentifier::operator delete(void *ptr) {
    asn1Free(ptr);
}

SessionConnectionIdentifier::SessionConnectionIdentifier() {
    memset(this, 0, sizeof(SessionConnectionIdentifier));
}

SessionConnectionIdentifier::SessionConnectionIdentifier(const SessionConnectionIdentifier & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	callingSSuserReference_field = that.callingSSuserReference_field;
	commonReference_field = that.commonReference_field;
	additionalReferenceInformation_field = that.additionalReferenceInformation_field;
    } OSSCLEAN(SessionConnectionIdentifier)
}

SessionConnectionIdentifier::SessionConnectionIdentifier(const callingSSuserReference & callingSSuserReference_val, 
    const commonReference & commonReference_val, const additionalReferenceInformation & additionalReferenceInformation_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	callingSSuserReference_field = callingSSuserReference_val;
	commonReference_field = commonReference_val;
	additionalReferenceInformation_field = additionalReferenceInformation_val;
    } OSSCLEAN(SessionConnectionIdentifier)
}

SessionConnectionIdentifier::SessionConnectionIdentifier(const callingSSuserReference & callingSSuserReference_val, 
    const commonReference & commonReference_val) {
    OSSTRY {
	bit_mask = 0;
	callingSSuserReference_field = callingSSuserReference_val;
	commonReference_field = commonReference_val;
    } OSSCLEAN(SessionConnectionIdentifier)
}

SessionConnectionIdentifier & SessionConnectionIdentifier::operator = (const SessionConnectionIdentifier & that) {
    if (this == &that)
	return *this;
    this->~SessionConnectionIdentifier();
    bit_mask = that.bit_mask;
    callingSSuserReference_field = that.callingSSuserReference_field;
    commonReference_field = that.commonReference_field;
    additionalReferenceInformation_field = that.additionalReferenceInformation_field;
    return *this;
}

int SessionConnectionIdentifier::operator == (const SessionConnectionIdentifier & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (callingSSuserReference_field != that.callingSSuserReference_field)
	return 0;
    if (commonReference_field != that.commonReference_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (additionalReferenceInformation_field != that.additionalReferenceInformation_field)
	    return 0;
    }
    return 1;
}

int SessionConnectionIdentifier::operator != (const SessionConnectionIdentifier & that) const {
    return !(operator ==(that));
}

SessionConnectionIdentifier::callingSSuserReference & SessionConnectionIdentifier::get_callingSSuserReference() {
    return callingSSuserReference_field;
}

const SessionConnectionIdentifier::callingSSuserReference & SessionConnectionIdentifier::get_callingSSuserReference() const {
    return callingSSuserReference_field;
}

void SessionConnectionIdentifier::set_callingSSuserReference(const callingSSuserReference & callingSSuserReference_val) {
    callingSSuserReference_field = callingSSuserReference_val;
}

SessionConnectionIdentifier::commonReference & SessionConnectionIdentifier::get_commonReference() {
    return commonReference_field;
}

const SessionConnectionIdentifier::commonReference & SessionConnectionIdentifier::get_commonReference() const {
    return commonReference_field;
}

void SessionConnectionIdentifier::set_commonReference(const commonReference & commonReference_val) {
    commonReference_field = commonReference_val;
}

SessionConnectionIdentifier::additionalReferenceInformation *SessionConnectionIdentifier::get_additionalReferenceInformation() {
    if (bit_mask & 0x80000000)
	return &additionalReferenceInformation_field;
    else
	return 0;
}

const SessionConnectionIdentifier::additionalReferenceInformation *SessionConnectionIdentifier::get_additionalReferenceInformation() const {
    if (bit_mask & 0x80000000)
	return &additionalReferenceInformation_field;
    else
	return 0;
}

void SessionConnectionIdentifier::set_additionalReferenceInformation(const additionalReferenceInformation & additionalReferenceInformation_val) {
    bit_mask |= 0x80000000;
    additionalReferenceInformation_field = additionalReferenceInformation_val;
}

int SessionConnectionIdentifier::additionalReferenceInformation_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void SessionConnectionIdentifier::omit_additionalReferenceInformation() {
    additionalReferenceInformation_field.~OssString();
    bit_mask &= ~0x80000000;
}

ConnectionData::ConnectionData() {
    memset(this, 0, sizeof(ConnectionData));
}

ConnectionData::ConnectionData(const ConnectionData & that) {
    memset(this, 0, sizeof(ConnectionData));
    operator =(that);
}

ConnectionData::~ConnectionData() {
    cleanup();
}

ConnectionData & ConnectionData::operator = (const ConnectionData & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case open_chosen:
	    *(open *)&open_field = *(open *)&that.open_field;
	    break;
	case recover_chosen:
	    if (that.recover_field)
		recover_field = new recover(*that.recover_field);
	    break;
    }
    return *this;
}

int ConnectionData::operator == (const ConnectionData & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case open_chosen:
	    return *(open *)&open_field == *(open *)&that.open_field;
	case recover_chosen:
	    if ((recover_field) && (that.recover_field))
		return (*recover_field == *(that.recover_field));
	    else if (!((!recover_field) && (!that.recover_field)))
		return 0;
	    break;
    }

    return 1;
}

int ConnectionData::operator != (const ConnectionData & that) const {
    return !(operator ==(that));
}

ConnectionData::open *ConnectionData::get_open() {
    if (_choice == open_chosen)
	return (open *)&open_field;
    else
	return 0;
}

const ConnectionData::open *ConnectionData::get_open() const {
    if (_choice == open_chosen)
	return (const open *)&open_field;
    else
	return 0;
}

void ConnectionData::set_open(const open & open_val) {
    cleanup();
    *(open *)&open_field = open_val;
    _choice = open_chosen;
}

ConnectionData::recover *ConnectionData::get_recover() {
    if (_choice == recover_chosen)
	return (recover *)recover_field;
    else
	return 0;
}

const ConnectionData::recover *ConnectionData::get_recover() const {
    if (_choice == recover_chosen)
	return (const recover *)recover_field;
    else
	return 0;
}

void ConnectionData::set_recover(const recover & recover_val) {
    cleanup();
    recover_field = new recover(recover_val);
    _choice = recover_chosen;
}

void ConnectionData::cleanup() {
    switch (_choice) {
	case open_chosen:
	    ((open *)&open_field)->~OssOpen();
	    break;
	case recover_chosen:
	    if (recover_field)
		delete recover_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

/* Auxiliary data structures and functions for class __shared12 */

class __shared12_member {
public:
    __shared12_member *next;
    __shared12::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared12_member();
    __shared12_member(const __shared12::component & val);
};

void *__shared12_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared12_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared12_member::__shared12_member() {
}

__shared12_member::__shared12_member(const __shared12::component & val) {
    value = val;
}

static void *__shared12_copy(void *that) {
    return new __shared12_member(((__shared12_member *)that)->value);
}

static void __shared12_destroy(void *that) {
    delete (__shared12_member *)that;
}

static int __shared12_compare(void *val1, void *val2) {
    return (((__shared12_member *)val1)->value == ((__shared12_member *)val2)->value);
}

/* Constructors */

__shared12::__shared12() {
}

__shared12::__shared12(const __shared12 & that) {
    OSSTRY {
	do_copy(that, &__shared12_copy);
    } OSSCLEAN(__shared12)
}

/* Destructor */

__shared12::~__shared12() {
    do_destroy(&__shared12_destroy);
}

/* Operators: assignment, equality, inequality */

__shared12 & __shared12::operator = (const __shared12 & that) {
    do_destroy(&__shared12_destroy);
    do_copy(that, &__shared12_copy);
    return *this;
}

int __shared12::operator == (const __shared12 & that) const {
    return do_compare(that, &__shared12_compare);
}

int __shared12::operator != (const __shared12 & that) const {
    return !do_compare(that, &__shared12_compare);
}

/* Locate ("At" etc) methods */

__shared12::component *__shared12::at(OssIndex pos) {
    return &((__shared12_member *)pos)->value;
}

const __shared12::component *__shared12::at(OssIndex pos) const {
    return &((__shared12_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared12::prepend(const component & val) {
    __shared12_member *newrec = new __shared12_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared12::prepend(__shared12 *seq) {
    return do_prepend(seq);
}

OssIndex __shared12::insert_after(OssIndex pos, const component & val) {
    __shared12_member *newrec = new __shared12_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared12::insert_after(OssIndex pos, __shared12 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared12::remove_front() {
    __shared12_member *extr = (__shared12_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared12_destroy(extr);
    return 0;
}

int __shared12::remove_after(OssIndex pos) {
    __shared12_member *extr = (__shared12_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared12_destroy(extr);
    return 0;
}

/* Extract methods */

__shared12 *__shared12::extract_after(OssIndex begin, OssIndex end) {
    return (__shared12 *)do_extract_after(begin, end);
}

void *Default_context_name::operator new(size_t size) {
    return ossNewFunc(size);
}

void Default_context_name::operator delete(void *ptr) {
    asn1Free(ptr);
}

Default_context_name::Default_context_name() {
    memset(this, 0, sizeof(Default_context_name));
}

Default_context_name::Default_context_name(const Default_context_name & that) {
    OSSTRY {
	abstract_syntax_name_field = that.abstract_syntax_name_field;
	transfer_syntax_name_field = that.transfer_syntax_name_field;
    } OSSCLEAN(Default_context_name)
}

Default_context_name::Default_context_name(const abstract_syntax_name & abstract_syntax_name_val, 
    const transfer_syntax_name & transfer_syntax_name_val) {
    OSSTRY {
	abstract_syntax_name_field = abstract_syntax_name_val;
	transfer_syntax_name_field = transfer_syntax_name_val;
    } OSSCLEAN(Default_context_name)
}

Default_context_name & Default_context_name::operator = (const Default_context_name & that) {
    if (this == &that)
	return *this;
    abstract_syntax_name_field = that.abstract_syntax_name_field;
    transfer_syntax_name_field = that.transfer_syntax_name_field;
    return *this;
}

int Default_context_name::operator == (const Default_context_name & that) const {
    if (abstract_syntax_name_field != that.abstract_syntax_name_field)
	return 0;
    if (transfer_syntax_name_field != that.transfer_syntax_name_field)
	return 0;
    return 1;
}

int Default_context_name::operator != (const Default_context_name & that) const {
    return !(operator ==(that));
}

Default_context_name::abstract_syntax_name & Default_context_name::get_abstract_syntax_name() {
    return abstract_syntax_name_field;
}

const Default_context_name::abstract_syntax_name & Default_context_name::get_abstract_syntax_name() const {
    return abstract_syntax_name_field;
}

void Default_context_name::set_abstract_syntax_name(const abstract_syntax_name & abstract_syntax_name_val) {
    abstract_syntax_name_field = abstract_syntax_name_val;
}

Default_context_name::transfer_syntax_name & Default_context_name::get_transfer_syntax_name() {
    return transfer_syntax_name_field;
}

const Default_context_name::transfer_syntax_name & Default_context_name::get_transfer_syntax_name() const {
    return transfer_syntax_name_field;
}

void Default_context_name::set_transfer_syntax_name(const transfer_syntax_name & transfer_syntax_name_val) {
    transfer_syntax_name_field = transfer_syntax_name_val;
}

/* Auxiliary data structures and functions for class __shared13 */

class __shared13_member {
public:
    __shared13_member *next;
    __shared13::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared13_member();
    __shared13_member(const __shared13::component & val);
};

void *__shared13_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared13_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared13_member::__shared13_member() {
}

__shared13_member::__shared13_member(const __shared13::component & val) {
    value = val;
}

static void *__shared13_copy(void *that) {
    return new __shared13_member(((__shared13_member *)that)->value);
}

static void __shared13_destroy(void *that) {
    delete (__shared13_member *)that;
}

static int __shared13_compare(void *val1, void *val2) {
    return (((__shared13_member *)val1)->value == ((__shared13_member *)val2)->value);
}

/* Constructors */

__shared13::__shared13() {
}

__shared13::__shared13(const __shared13 & that) {
    OSSTRY {
	do_copy(that, &__shared13_copy);
    } OSSCLEAN(__shared13)
}

/* Destructor */

__shared13::~__shared13() {
    do_destroy(&__shared13_destroy);
}

/* Operators: assignment, equality, inequality */

__shared13 & __shared13::operator = (const __shared13 & that) {
    do_destroy(&__shared13_destroy);
    do_copy(that, &__shared13_copy);
    return *this;
}

int __shared13::operator == (const __shared13 & that) const {
    return do_compare(that, &__shared13_compare);
}

int __shared13::operator != (const __shared13 & that) const {
    return !do_compare(that, &__shared13_compare);
}

/* Locate ("At" etc) methods */

__shared13::component *__shared13::at(OssIndex pos) {
    return &((__shared13_member *)pos)->value;
}

const __shared13::component *__shared13::at(OssIndex pos) const {
    return &((__shared13_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared13::prepend(const component & val) {
    __shared13_member *newrec = new __shared13_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared13::prepend(__shared13 *seq) {
    return do_prepend(seq);
}

OssIndex __shared13::insert_after(OssIndex pos, const component & val) {
    __shared13_member *newrec = new __shared13_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared13::insert_after(OssIndex pos, __shared13 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared13::remove_front() {
    __shared13_member *extr = (__shared13_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared13_destroy(extr);
    return 0;
}

int __shared13::remove_after(OssIndex pos) {
    __shared13_member *extr = (__shared13_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared13_destroy(extr);
    return 0;
}

/* Extract methods */

__shared13 *__shared13::extract_after(OssIndex begin, OssIndex end) {
    return (__shared13 *)do_extract_after(begin, end);
}

__shared14::__shared14() {
    memset(this, 0, sizeof(__shared14));
}

__shared14::__shared14(const __shared14 & that) {
    memset(this, 0, sizeof(__shared14));
    operator =(that);
}

__shared14::~__shared14() {
    cleanup();
}

__shared14 & __shared14::operator = (const __shared14 & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case simply_encoded_data_chosen:
	    *(simply_encoded_data *)&simply_encoded_data_field = *(simply_encoded_data *)&that.simply_encoded_data_field;
	    break;
	case fully_encoded_data_chosen:
	    *(fully_encoded_data *)&fully_encoded_data_field = *(fully_encoded_data *)&that.fully_encoded_data_field;
	    break;
    }
    return *this;
}

int __shared14::operator == (const __shared14 & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case simply_encoded_data_chosen:
	    return *(simply_encoded_data *)&simply_encoded_data_field == *(simply_encoded_data *)&that.simply_encoded_data_field;
	case fully_encoded_data_chosen:
	    return *(fully_encoded_data *)&fully_encoded_data_field == *(fully_encoded_data *)&that.fully_encoded_data_field;
    }

    return 1;
}

int __shared14::operator != (const __shared14 & that) const {
    return !(operator ==(that));
}

__shared14::simply_encoded_data *__shared14::get_simply_encoded_data() {
    if (_choice == simply_encoded_data_chosen)
	return (simply_encoded_data *)&simply_encoded_data_field;
    else
	return 0;
}

const __shared14::simply_encoded_data *__shared14::get_simply_encoded_data() const {
    if (_choice == simply_encoded_data_chosen)
	return (const simply_encoded_data *)&simply_encoded_data_field;
    else
	return 0;
}

void __shared14::set_simply_encoded_data(const simply_encoded_data & simply_encoded_data_val) {
    cleanup();
    *(simply_encoded_data *)&simply_encoded_data_field = simply_encoded_data_val;
    _choice = simply_encoded_data_chosen;
}

__shared14::fully_encoded_data *__shared14::get_fully_encoded_data() {
    if (_choice == fully_encoded_data_chosen)
	return (fully_encoded_data *)&fully_encoded_data_field;
    else
	return 0;
}

const __shared14::fully_encoded_data *__shared14::get_fully_encoded_data() const {
    if (_choice == fully_encoded_data_chosen)
	return (const fully_encoded_data *)&fully_encoded_data_field;
    else
	return 0;
}

void __shared14::set_fully_encoded_data(const fully_encoded_data & fully_encoded_data_val) {
    cleanup();
    *(fully_encoded_data *)&fully_encoded_data_field = fully_encoded_data_val;
    _choice = fully_encoded_data_chosen;
}

void __shared14::cleanup() {
    switch (_choice) {
	case simply_encoded_data_chosen:
	    ((simply_encoded_data *)&simply_encoded_data_field)->~OssString();
	    break;
	case fully_encoded_data_chosen:
	    ((fully_encoded_data *)&fully_encoded_data_field)->~__shared13();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

void *__shared15::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared15::operator delete(void *ptr) {
    asn1Free(ptr);
}

OSS_INT32 __shared15::get_default_checkpointSize() {
    return __shared15::default_checkpointSize;
}

OSS_INT32 __shared15::get_default_windowSize() {
    return __shared15::default_windowSize;
}

OSS_INT32 __shared15::get_default_dialogueMode() {
    return __shared15::default_dialogueMode;
}

__shared15::__shared15() {
    memset(this, 0, sizeof(__shared15));
}

__shared15::__shared15(const __shared15 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	checkpointSize_field = that.checkpointSize_field;
	windowSize_field = that.windowSize_field;
	dialogueMode_field = that.dialogueMode_field;
	connectionDataRQ_field = that.connectionDataRQ_field;
	applicationProtocol_field = that.applicationProtocol_field;
    } OSSCLEAN(__shared15)
}

__shared15::__shared15(checkpointSize checkpointSize_val, windowSize windowSize_val, 
    dialogueMode dialogueMode_val, const connectionDataRQ & connectionDataRQ_val, applicationProtocol applicationProtocol_val) {
    OSSTRY {
	bit_mask = 0xf0000000;
	checkpointSize_field = checkpointSize_val;
	windowSize_field = windowSize_val;
	dialogueMode_field = dialogueMode_val;
	connectionDataRQ_field = connectionDataRQ_val;
	applicationProtocol_field = applicationProtocol_val;
    } OSSCLEAN(__shared15)
}

__shared15::__shared15(const connectionDataRQ & connectionDataRQ_val) {
    OSSTRY {
	bit_mask = 0;
	connectionDataRQ_field = connectionDataRQ_val;
    } OSSCLEAN(__shared15)
}

__shared15 & __shared15::operator = (const __shared15 & that) {
    if (this == &that)
	return *this;
    this->~__shared15();
    bit_mask = that.bit_mask;
    checkpointSize_field = that.checkpointSize_field;
    windowSize_field = that.windowSize_field;
    dialogueMode_field = that.dialogueMode_field;
    connectionDataRQ_field = that.connectionDataRQ_field;
    applicationProtocol_field = that.applicationProtocol_field;
    return *this;
}

int __shared15::operator == (const __shared15 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (checkpointSize_field != that.checkpointSize_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (windowSize_field != that.windowSize_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (dialogueMode_field != that.dialogueMode_field)
	    return 0;
    }
    if (connectionDataRQ_field != that.connectionDataRQ_field)
	return 0;
    if (bit_mask & 0x10000000) {
	if (applicationProtocol_field != that.applicationProtocol_field)
	    return 0;
    }
    return 1;
}

int __shared15::operator != (const __shared15 & that) const {
    return !(operator ==(that));
}

__shared15::checkpointSize *__shared15::get_checkpointSize() {
    if (bit_mask & 0x80000000)
	return &checkpointSize_field;
    else
	return 0;
}

const __shared15::checkpointSize *__shared15::get_checkpointSize() const {
    if (bit_mask & 0x80000000)
	return &checkpointSize_field;
    else
	return 0;
}

void __shared15::set_checkpointSize(checkpointSize checkpointSize_val) {
    bit_mask |= 0x80000000;
    checkpointSize_field = checkpointSize_val;
}

int __shared15::checkpointSize_is_default() const {
    return !(bit_mask & 0x80000000);
}

void __shared15::set_default_checkpointSize() {
    bit_mask &= ~0x80000000;
}

__shared15::windowSize *__shared15::get_windowSize() {
    if (bit_mask & 0x40000000)
	return &windowSize_field;
    else
	return 0;
}

const __shared15::windowSize *__shared15::get_windowSize() const {
    if (bit_mask & 0x40000000)
	return &windowSize_field;
    else
	return 0;
}

void __shared15::set_windowSize(windowSize windowSize_val) {
    bit_mask |= 0x40000000;
    windowSize_field = windowSize_val;
}

int __shared15::windowSize_is_default() const {
    return !(bit_mask & 0x40000000);
}

void __shared15::set_default_windowSize() {
    bit_mask &= ~0x40000000;
}

__shared15::dialogueMode *__shared15::get_dialogueMode() {
    if (bit_mask & 0x20000000)
	return &dialogueMode_field;
    else
	return 0;
}

const __shared15::dialogueMode *__shared15::get_dialogueMode() const {
    if (bit_mask & 0x20000000)
	return &dialogueMode_field;
    else
	return 0;
}

void __shared15::set_dialogueMode(dialogueMode dialogueMode_val) {
    bit_mask |= 0x20000000;
    dialogueMode_field = dialogueMode_val;
}

int __shared15::dialogueMode_is_default() const {
    return !(bit_mask & 0x20000000);
}

void __shared15::set_default_dialogueMode() {
    bit_mask &= ~0x20000000;
}

__shared15::connectionDataRQ & __shared15::get_connectionDataRQ() {
    return connectionDataRQ_field;
}

const __shared15::connectionDataRQ & __shared15::get_connectionDataRQ() const {
    return connectionDataRQ_field;
}

void __shared15::set_connectionDataRQ(const connectionDataRQ & connectionDataRQ_val) {
    connectionDataRQ_field = connectionDataRQ_val;
}

__shared15::applicationProtocol *__shared15::get_applicationProtocol() {
    if (bit_mask & 0x10000000)
	return &applicationProtocol_field;
    else
	return 0;
}

const __shared15::applicationProtocol *__shared15::get_applicationProtocol() const {
    if (bit_mask & 0x10000000)
	return &applicationProtocol_field;
    else
	return 0;
}

void __shared15::set_applicationProtocol(applicationProtocol applicationProtocol_val) {
    bit_mask |= 0x10000000;
    applicationProtocol_field = applicationProtocol_val;
}

int __shared15::applicationProtocol_is_present() const {
    return !!(bit_mask & 0x10000000);
}

void __shared15::omit_applicationProtocol() {
    bit_mask &= ~0x10000000;
}

void *__seq2::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq2::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq2::__seq2() {
    memset(this, 0, sizeof(__seq2));
}

__seq2::__seq2(const __seq2 &) {
    OSSTRY {
    } OSSCLEAN(__seq2)
}

__seq2 & __seq2::operator = (const __seq2 & that) {
    if (this == &that)
	return *this;
    return *this;
}

int __seq2::operator == (const __seq2 &) const {
    return 1;
}

int __seq2::operator != (const __seq2 & that) const {
    return !(operator ==(that));
}

void *__seq3::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq3::operator delete(void *ptr) {
    asn1Free(ptr);
}

const OssBitString& __seq3::get_default_protocol_version() {
    return __seq3::default_protocol_version;
}

const OssBitString& __seq3::get_default_protocol_options() {
    return __seq3::default_protocol_options;
}

__seq3::__seq3() {
    memset(this, 0, sizeof(__seq3));
}

__seq3::__seq3(const __seq3 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	if (bit_mask & 0x80000000)
	    protocol_version_field = that.protocol_version_field;
	calling_presentation_selector_field = that.calling_presentation_selector_field;
	called_presentation_selector_field = that.called_presentation_selector_field;
	presentation_context_definition_list_field = that.presentation_context_definition_list_field;
	default_context_name_field = that.default_context_name_field;
	presentation_requirements_field = that.presentation_requirements_field;
	user_session_requirements_field = that.user_session_requirements_field;
	if (bit_mask & 0x1000000)
	    protocol_options_field = that.protocol_options_field;
	initiators_nominated_context_field = that.initiators_nominated_context_field;
	extensions_field = that.extensions_field;
	user_data_field = that.user_data_field;
    } OSSCLEAN(__seq3)
}

__seq3::__seq3(const protocol_version & protocol_version_val, const calling_presentation_selector & calling_presentation_selector_val, 
    const called_presentation_selector & called_presentation_selector_val, const presentation_context_definition_list & presentation_context_definition_list_val, 
    const default_context_name & default_context_name_val, const presentation_requirements & presentation_requirements_val, 
    const user_session_requirements & user_session_requirements_val, const protocol_options & protocol_options_val, 
    initiators_nominated_context initiators_nominated_context_val, const extensions & extensions_val, 
    const user_data & user_data_val) {
    OSSTRY {
	bit_mask = 0xffe00000;
	protocol_version_field = protocol_version_val;
	calling_presentation_selector_field = calling_presentation_selector_val;
	called_presentation_selector_field = called_presentation_selector_val;
	presentation_context_definition_list_field = presentation_context_definition_list_val;
	default_context_name_field = default_context_name_val;
	presentation_requirements_field = presentation_requirements_val;
	user_session_requirements_field = user_session_requirements_val;
	protocol_options_field = protocol_options_val;
	initiators_nominated_context_field = initiators_nominated_context_val;
	extensions_field = extensions_val;
	user_data_field = user_data_val;
    } OSSCLEAN(__seq3)
}

__seq3::~__seq3() {
    if (!(bit_mask & 0x80000000))
	memset(&protocol_version_field, 0, sizeof(protocol_version));
    if (!(bit_mask & 0x1000000))
	memset(&protocol_options_field, 0, sizeof(protocol_options));
}

__seq3 & __seq3::operator = (const __seq3 & that) {
    if (this == &that)
	return *this;
    this->~__seq3();
    bit_mask = that.bit_mask;
    if (bit_mask & 0x80000000)
	protocol_version_field = that.protocol_version_field;
    calling_presentation_selector_field = that.calling_presentation_selector_field;
    called_presentation_selector_field = that.called_presentation_selector_field;
    presentation_context_definition_list_field = that.presentation_context_definition_list_field;
    default_context_name_field = that.default_context_name_field;
    presentation_requirements_field = that.presentation_requirements_field;
    user_session_requirements_field = that.user_session_requirements_field;
    if (bit_mask & 0x1000000)
	protocol_options_field = that.protocol_options_field;
    initiators_nominated_context_field = that.initiators_nominated_context_field;
    extensions_field = that.extensions_field;
    user_data_field = that.user_data_field;
    return *this;
}

int __seq3::operator == (const __seq3 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (protocol_version_field != that.protocol_version_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (calling_presentation_selector_field != that.calling_presentation_selector_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (called_presentation_selector_field != that.called_presentation_selector_field)
	    return 0;
    }
    if (bit_mask & 0x10000000) {
	if (presentation_context_definition_list_field != that.presentation_context_definition_list_field)
	    return 0;
    }
    if (bit_mask & 0x8000000) {
	if (default_context_name_field != that.default_context_name_field)
	    return 0;
    }
    if (bit_mask & 0x4000000) {
	if (presentation_requirements_field != that.presentation_requirements_field)
	    return 0;
    }
    if (bit_mask & 0x2000000) {
	if (user_session_requirements_field != that.user_session_requirements_field)
	    return 0;
    }
    if (bit_mask & 0x1000000) {
	if (protocol_options_field != that.protocol_options_field)
	    return 0;
    }
    if (bit_mask & 0x800000) {
	if (initiators_nominated_context_field != that.initiators_nominated_context_field)
	    return 0;
    }
    if (bit_mask & 0x400000) {
	if (extensions_field != that.extensions_field)
	    return 0;
    }
    if (bit_mask & 0x200000) {
	if (user_data_field != that.user_data_field)
	    return 0;
    }
    return 1;
}

int __seq3::operator != (const __seq3 & that) const {
    return !(operator ==(that));
}

__seq3::protocol_version *__seq3::get_protocol_version() {
    if (bit_mask & 0x80000000)
	return &protocol_version_field;
    else
	return 0;
}

const __seq3::protocol_version *__seq3::get_protocol_version() const {
    if (bit_mask & 0x80000000)
	return &protocol_version_field;
    else
	return 0;
}

void __seq3::set_protocol_version(const protocol_version & protocol_version_val) {
    if (!(bit_mask & 0x80000000)) {
	memset(&protocol_version_field, 0, sizeof(protocol_version));
	bit_mask |= 0x80000000;
    }
    protocol_version_field = protocol_version_val;
}

int __seq3::protocol_version_is_default() const {
    return !(bit_mask & 0x80000000);
}

void __seq3::set_default_protocol_version() {
    if (bit_mask & 0x80000000) {
	protocol_version_field.~OssBitString();
	bit_mask &= ~0x80000000;
    }
}

__seq3::calling_presentation_selector *__seq3::get_calling_presentation_selector() {
    if (bit_mask & 0x40000000)
	return &calling_presentation_selector_field;
    else
	return 0;
}

const __seq3::calling_presentation_selector *__seq3::get_calling_presentation_selector() const {
    if (bit_mask & 0x40000000)
	return &calling_presentation_selector_field;
    else
	return 0;
}

void __seq3::set_calling_presentation_selector(const calling_presentation_selector & calling_presentation_selector_val) {
    bit_mask |= 0x40000000;
    calling_presentation_selector_field = calling_presentation_selector_val;
}

int __seq3::calling_presentation_selector_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void __seq3::omit_calling_presentation_selector() {
    calling_presentation_selector_field.~OssString();
    bit_mask &= ~0x40000000;
}

__seq3::called_presentation_selector *__seq3::get_called_presentation_selector() {
    if (bit_mask & 0x20000000)
	return &called_presentation_selector_field;
    else
	return 0;
}

const __seq3::called_presentation_selector *__seq3::get_called_presentation_selector() const {
    if (bit_mask & 0x20000000)
	return &called_presentation_selector_field;
    else
	return 0;
}

void __seq3::set_called_presentation_selector(const called_presentation_selector & called_presentation_selector_val) {
    bit_mask |= 0x20000000;
    called_presentation_selector_field = called_presentation_selector_val;
}

int __seq3::called_presentation_selector_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void __seq3::omit_called_presentation_selector() {
    called_presentation_selector_field.~OssString();
    bit_mask &= ~0x20000000;
}

__seq3::presentation_context_definition_list *__seq3::get_presentation_context_definition_list() {
    if (bit_mask & 0x10000000)
	return &presentation_context_definition_list_field;
    else
	return 0;
}

const __seq3::presentation_context_definition_list *__seq3::get_presentation_context_definition_list() const {
    if (bit_mask & 0x10000000)
	return &presentation_context_definition_list_field;
    else
	return 0;
}

void __seq3::set_presentation_context_definition_list(const presentation_context_definition_list & presentation_context_definition_list_val) {
    bit_mask |= 0x10000000;
    presentation_context_definition_list_field = presentation_context_definition_list_val;
}

int __seq3::presentation_context_definition_list_is_present() const {
    return !!(bit_mask & 0x10000000);
}

void __seq3::omit_presentation_context_definition_list() {
    presentation_context_definition_list_field.~__shared12();
    bit_mask &= ~0x10000000;
}

__seq3::default_context_name *__seq3::get_default_context_name() {
    if (bit_mask & 0x8000000)
	return &default_context_name_field;
    else
	return 0;
}

const __seq3::default_context_name *__seq3::get_default_context_name() const {
    if (bit_mask & 0x8000000)
	return &default_context_name_field;
    else
	return 0;
}

void __seq3::set_default_context_name(const default_context_name & default_context_name_val) {
    bit_mask |= 0x8000000;
    default_context_name_field = default_context_name_val;
}

int __seq3::default_context_name_is_present() const {
    return !!(bit_mask & 0x8000000);
}

void __seq3::omit_default_context_name() {
    default_context_name_field.~Default_context_name();
    bit_mask &= ~0x8000000;
}

__seq3::presentation_requirements *__seq3::get_presentation_requirements() {
    if (bit_mask & 0x4000000)
	return &presentation_requirements_field;
    else
	return 0;
}

const __seq3::presentation_requirements *__seq3::get_presentation_requirements() const {
    if (bit_mask & 0x4000000)
	return &presentation_requirements_field;
    else
	return 0;
}

void __seq3::set_presentation_requirements(const presentation_requirements & presentation_requirements_val) {
    bit_mask |= 0x4000000;
    presentation_requirements_field = presentation_requirements_val;
}

int __seq3::presentation_requirements_is_present() const {
    return !!(bit_mask & 0x4000000);
}

void __seq3::omit_presentation_requirements() {
    presentation_requirements_field.~OssBitString();
    bit_mask &= ~0x4000000;
}

__seq3::user_session_requirements *__seq3::get_user_session_requirements() {
    if (bit_mask & 0x2000000)
	return &user_session_requirements_field;
    else
	return 0;
}

const __seq3::user_session_requirements *__seq3::get_user_session_requirements() const {
    if (bit_mask & 0x2000000)
	return &user_session_requirements_field;
    else
	return 0;
}

void __seq3::set_user_session_requirements(const user_session_requirements & user_session_requirements_val) {
    bit_mask |= 0x2000000;
    user_session_requirements_field = user_session_requirements_val;
}

int __seq3::user_session_requirements_is_present() const {
    return !!(bit_mask & 0x2000000);
}

void __seq3::omit_user_session_requirements() {
    user_session_requirements_field.~OssBitString();
    bit_mask &= ~0x2000000;
}

__seq3::protocol_options *__seq3::get_protocol_options() {
    if (bit_mask & 0x1000000)
	return &protocol_options_field;
    else
	return 0;
}

const __seq3::protocol_options *__seq3::get_protocol_options() const {
    if (bit_mask & 0x1000000)
	return &protocol_options_field;
    else
	return 0;
}

void __seq3::set_protocol_options(const protocol_options & protocol_options_val) {
    if (!(bit_mask & 0x1000000)) {
	memset(&protocol_options_field, 0, sizeof(protocol_options));
	bit_mask |= 0x1000000;
    }
    protocol_options_field = protocol_options_val;
}

int __seq3::protocol_options_is_default() const {
    return !(bit_mask & 0x1000000);
}

void __seq3::set_default_protocol_options() {
    if (bit_mask & 0x1000000) {
	protocol_options_field.~OssBitString();
	bit_mask &= ~0x1000000;
    }
}

__seq3::initiators_nominated_context *__seq3::get_initiators_nominated_context() {
    if (bit_mask & 0x800000)
	return &initiators_nominated_context_field;
    else
	return 0;
}

const __seq3::initiators_nominated_context *__seq3::get_initiators_nominated_context() const {
    if (bit_mask & 0x800000)
	return &initiators_nominated_context_field;
    else
	return 0;
}

void __seq3::set_initiators_nominated_context(initiators_nominated_context initiators_nominated_context_val) {
    bit_mask |= 0x800000;
    initiators_nominated_context_field = initiators_nominated_context_val;
}

int __seq3::initiators_nominated_context_is_present() const {
    return !!(bit_mask & 0x800000);
}

void __seq3::omit_initiators_nominated_context() {
    bit_mask &= ~0x800000;
}

__seq3::extensions *__seq3::get_extensions() {
    if (bit_mask & 0x400000)
	return &extensions_field;
    else
	return 0;
}

const __seq3::extensions *__seq3::get_extensions() const {
    if (bit_mask & 0x400000)
	return &extensions_field;
    else
	return 0;
}

void __seq3::set_extensions(const extensions & extensions_val) {
    bit_mask |= 0x400000;
    extensions_field = extensions_val;
}

int __seq3::extensions_is_present() const {
    return !!(bit_mask & 0x400000);
}

void __seq3::omit_extensions() {
    extensions_field.~__seq2();
    bit_mask &= ~0x400000;
}

__seq3::user_data *__seq3::get_user_data() {
    if (bit_mask & 0x200000)
	return &user_data_field;
    else
	return 0;
}

const __seq3::user_data *__seq3::get_user_data() const {
    if (bit_mask & 0x200000)
	return &user_data_field;
    else
	return 0;
}

void __seq3::set_user_data(const user_data & user_data_val) {
    bit_mask |= 0x200000;
    user_data_field = user_data_val;
}

int __seq3::user_data_is_present() const {
    return !!(bit_mask & 0x200000);
}

void __seq3::omit_user_data() {
    user_data_field.~__shared14();
    bit_mask &= ~0x200000;
}

void *CP_type::operator new(size_t size) {
    return ossNewFunc(size);
}

void CP_type::operator delete(void *ptr) {
    asn1Free(ptr);
}

CP_type::CP_type() {
    memset(this, 0, sizeof(CP_type));
}

CP_type::CP_type(const CP_type & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	mode_selector_field = that.mode_selector_field;
	x410_mode_parameters_field = that.x410_mode_parameters_field;
	normal_mode_parameters_field = that.normal_mode_parameters_field;
    } OSSCLEAN(CP_type)
}

CP_type::CP_type(const mode_selector & mode_selector_val, const x410_mode_parameters & x410_mode_parameters_val, 
    const normal_mode_parameters & normal_mode_parameters_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	mode_selector_field = mode_selector_val;
	x410_mode_parameters_field = x410_mode_parameters_val;
	normal_mode_parameters_field = normal_mode_parameters_val;
    } OSSCLEAN(CP_type)
}

CP_type::CP_type(const mode_selector & mode_selector_val) {
    OSSTRY {
	bit_mask = 0;
	mode_selector_field = mode_selector_val;
    } OSSCLEAN(CP_type)
}

CP_type & CP_type::operator = (const CP_type & that) {
    if (this == &that)
	return *this;
    this->~CP_type();
    bit_mask = that.bit_mask;
    mode_selector_field = that.mode_selector_field;
    x410_mode_parameters_field = that.x410_mode_parameters_field;
    normal_mode_parameters_field = that.normal_mode_parameters_field;
    return *this;
}

int CP_type::operator == (const CP_type & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (mode_selector_field != that.mode_selector_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (x410_mode_parameters_field != that.x410_mode_parameters_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (normal_mode_parameters_field != that.normal_mode_parameters_field)
	    return 0;
    }
    return 1;
}

int CP_type::operator != (const CP_type & that) const {
    return !(operator ==(that));
}

CP_type::mode_selector & CP_type::get_mode_selector() {
    return mode_selector_field;
}

const CP_type::mode_selector & CP_type::get_mode_selector() const {
    return mode_selector_field;
}

void CP_type::set_mode_selector(const mode_selector & mode_selector_val) {
    mode_selector_field = mode_selector_val;
}

CP_type::x410_mode_parameters *CP_type::get_x410_mode_parameters() {
    if (bit_mask & 0x80000000)
	return &x410_mode_parameters_field;
    else
	return 0;
}

const CP_type::x410_mode_parameters *CP_type::get_x410_mode_parameters() const {
    if (bit_mask & 0x80000000)
	return &x410_mode_parameters_field;
    else
	return 0;
}

void CP_type::set_x410_mode_parameters(const x410_mode_parameters & x410_mode_parameters_val) {
    bit_mask |= 0x80000000;
    x410_mode_parameters_field = x410_mode_parameters_val;
}

int CP_type::x410_mode_parameters_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void CP_type::omit_x410_mode_parameters() {
    x410_mode_parameters_field.~__shared15();
    bit_mask &= ~0x80000000;
}

CP_type::normal_mode_parameters *CP_type::get_normal_mode_parameters() {
    if (bit_mask & 0x40000000)
	return &normal_mode_parameters_field;
    else
	return 0;
}

const CP_type::normal_mode_parameters *CP_type::get_normal_mode_parameters() const {
    if (bit_mask & 0x40000000)
	return &normal_mode_parameters_field;
    else
	return 0;
}

void CP_type::set_normal_mode_parameters(const normal_mode_parameters & normal_mode_parameters_val) {
    bit_mask |= 0x40000000;
    normal_mode_parameters_field = normal_mode_parameters_val;
}

int CP_type::normal_mode_parameters_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void CP_type::omit_normal_mode_parameters() {
    normal_mode_parameters_field.~__seq3();
    bit_mask &= ~0x40000000;
}

/* Auxiliary data structures and functions for class __shared16 */

class __shared16_member {
public:
    __shared16_member *next;
    __shared16::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared16_member();
    __shared16_member(const __shared16::component & val);
};

void *__shared16_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared16_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared16_member::__shared16_member() {
}

__shared16_member::__shared16_member(const __shared16::component & val) {
    value = val;
}

static void *__shared16_copy(void *that) {
    return new __shared16_member(((__shared16_member *)that)->value);
}

static void __shared16_destroy(void *that) {
    delete (__shared16_member *)that;
}

static int __shared16_compare(void *val1, void *val2) {
    return (((__shared16_member *)val1)->value == ((__shared16_member *)val2)->value);
}

/* Constructors */

__shared16::__shared16() {
}

__shared16::__shared16(const __shared16 & that) {
    OSSTRY {
	do_copy(that, &__shared16_copy);
    } OSSCLEAN(__shared16)
}

/* Destructor */

__shared16::~__shared16() {
    do_destroy(&__shared16_destroy);
}

/* Operators: assignment, equality, inequality */

__shared16 & __shared16::operator = (const __shared16 & that) {
    do_destroy(&__shared16_destroy);
    do_copy(that, &__shared16_copy);
    return *this;
}

int __shared16::operator == (const __shared16 & that) const {
    return do_compare(that, &__shared16_compare);
}

int __shared16::operator != (const __shared16 & that) const {
    return !do_compare(that, &__shared16_compare);
}

/* Locate ("At" etc) methods */

__shared16::component *__shared16::at(OssIndex pos) {
    return &((__shared16_member *)pos)->value;
}

const __shared16::component *__shared16::at(OssIndex pos) const {
    return &((__shared16_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared16::prepend(const component & val) {
    __shared16_member *newrec = new __shared16_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared16::prepend(__shared16 *seq) {
    return do_prepend(seq);
}

OssIndex __shared16::insert_after(OssIndex pos, const component & val) {
    __shared16_member *newrec = new __shared16_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared16::insert_after(OssIndex pos, __shared16 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared16::remove_front() {
    __shared16_member *extr = (__shared16_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared16_destroy(extr);
    return 0;
}

int __shared16::remove_after(OssIndex pos) {
    __shared16_member *extr = (__shared16_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared16_destroy(extr);
    return 0;
}

/* Extract methods */

__shared16 *__shared16::extract_after(OssIndex begin, OssIndex end) {
    return (__shared16 *)do_extract_after(begin, end);
}

void *__shared17::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared17::operator delete(void *ptr) {
    asn1Free(ptr);
}

OSS_INT32 __shared17::get_default_checkpointSize() {
    return __shared17::default_checkpointSize;
}

OSS_INT32 __shared17::get_default_windowSize() {
    return __shared17::default_windowSize;
}

__shared17::__shared17() {
    memset(this, 0, sizeof(__shared17));
}

__shared17::__shared17(const __shared17 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	checkpointSize_field = that.checkpointSize_field;
	windowSize_field = that.windowSize_field;
	connectionDataAC_field = that.connectionDataAC_field;
    } OSSCLEAN(__shared17)
}

__shared17::__shared17(checkpointSize checkpointSize_val, windowSize windowSize_val, 
    const connectionDataAC & connectionDataAC_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	checkpointSize_field = checkpointSize_val;
	windowSize_field = windowSize_val;
	connectionDataAC_field = connectionDataAC_val;
    } OSSCLEAN(__shared17)
}

__shared17::__shared17(const connectionDataAC & connectionDataAC_val) {
    OSSTRY {
	bit_mask = 0;
	connectionDataAC_field = connectionDataAC_val;
    } OSSCLEAN(__shared17)
}

__shared17 & __shared17::operator = (const __shared17 & that) {
    if (this == &that)
	return *this;
    this->~__shared17();
    bit_mask = that.bit_mask;
    checkpointSize_field = that.checkpointSize_field;
    windowSize_field = that.windowSize_field;
    connectionDataAC_field = that.connectionDataAC_field;
    return *this;
}

int __shared17::operator == (const __shared17 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (checkpointSize_field != that.checkpointSize_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (windowSize_field != that.windowSize_field)
	    return 0;
    }
    if (connectionDataAC_field != that.connectionDataAC_field)
	return 0;
    return 1;
}

int __shared17::operator != (const __shared17 & that) const {
    return !(operator ==(that));
}

__shared17::checkpointSize *__shared17::get_checkpointSize() {
    if (bit_mask & 0x80000000)
	return &checkpointSize_field;
    else
	return 0;
}

const __shared17::checkpointSize *__shared17::get_checkpointSize() const {
    if (bit_mask & 0x80000000)
	return &checkpointSize_field;
    else
	return 0;
}

void __shared17::set_checkpointSize(checkpointSize checkpointSize_val) {
    bit_mask |= 0x80000000;
    checkpointSize_field = checkpointSize_val;
}

int __shared17::checkpointSize_is_default() const {
    return !(bit_mask & 0x80000000);
}

void __shared17::set_default_checkpointSize() {
    bit_mask &= ~0x80000000;
}

__shared17::windowSize *__shared17::get_windowSize() {
    if (bit_mask & 0x40000000)
	return &windowSize_field;
    else
	return 0;
}

const __shared17::windowSize *__shared17::get_windowSize() const {
    if (bit_mask & 0x40000000)
	return &windowSize_field;
    else
	return 0;
}

void __shared17::set_windowSize(windowSize windowSize_val) {
    bit_mask |= 0x40000000;
    windowSize_field = windowSize_val;
}

int __shared17::windowSize_is_default() const {
    return !(bit_mask & 0x40000000);
}

void __shared17::set_default_windowSize() {
    bit_mask &= ~0x40000000;
}

__shared17::connectionDataAC & __shared17::get_connectionDataAC() {
    return connectionDataAC_field;
}

const __shared17::connectionDataAC & __shared17::get_connectionDataAC() const {
    return connectionDataAC_field;
}

void __shared17::set_connectionDataAC(const connectionDataAC & connectionDataAC_val) {
    connectionDataAC_field = connectionDataAC_val;
}

void *__seq4::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq4::operator delete(void *ptr) {
    asn1Free(ptr);
}

const OssBitString& __seq4::get_default_protocol_version() {
    return __seq4::default_protocol_version;
}

const OssBitString& __seq4::get_default_protocol_options() {
    return __seq4::default_protocol_options;
}

__seq4::__seq4() {
    memset(this, 0, sizeof(__seq4));
}

__seq4::__seq4(const __seq4 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	if (bit_mask & 0x80000000)
	    protocol_version_field = that.protocol_version_field;
	responding_presentation_selector_field = that.responding_presentation_selector_field;
	presentation_context_definition_result_list_field = that.presentation_context_definition_result_list_field;
	presentation_requirements_field = that.presentation_requirements_field;
	user_session_requirements_field = that.user_session_requirements_field;
	if (bit_mask & 0x4000000)
	    protocol_options_field = that.protocol_options_field;
	responders_nominated_context_field = that.responders_nominated_context_field;
	user_data_field = that.user_data_field;
    } OSSCLEAN(__seq4)
}

__seq4::__seq4(const protocol_version & protocol_version_val, const responding_presentation_selector & responding_presentation_selector_val, 
    const presentation_context_definition_result_list & presentation_context_definition_result_list_val, 
    const presentation_requirements & presentation_requirements_val, const user_session_requirements & user_session_requirements_val, 
    const protocol_options & protocol_options_val, responders_nominated_context responders_nominated_context_val, 
    const user_data & user_data_val) {
    OSSTRY {
	bit_mask = 0xff000000;
	protocol_version_field = protocol_version_val;
	responding_presentation_selector_field = responding_presentation_selector_val;
	presentation_context_definition_result_list_field = presentation_context_definition_result_list_val;
	presentation_requirements_field = presentation_requirements_val;
	user_session_requirements_field = user_session_requirements_val;
	protocol_options_field = protocol_options_val;
	responders_nominated_context_field = responders_nominated_context_val;
	user_data_field = user_data_val;
    } OSSCLEAN(__seq4)
}

__seq4::~__seq4() {
    if (!(bit_mask & 0x80000000))
	memset(&protocol_version_field, 0, sizeof(protocol_version));
    if (!(bit_mask & 0x4000000))
	memset(&protocol_options_field, 0, sizeof(protocol_options));
}

__seq4 & __seq4::operator = (const __seq4 & that) {
    if (this == &that)
	return *this;
    this->~__seq4();
    bit_mask = that.bit_mask;
    if (bit_mask & 0x80000000)
	protocol_version_field = that.protocol_version_field;
    responding_presentation_selector_field = that.responding_presentation_selector_field;
    presentation_context_definition_result_list_field = that.presentation_context_definition_result_list_field;
    presentation_requirements_field = that.presentation_requirements_field;
    user_session_requirements_field = that.user_session_requirements_field;
    if (bit_mask & 0x4000000)
	protocol_options_field = that.protocol_options_field;
    responders_nominated_context_field = that.responders_nominated_context_field;
    user_data_field = that.user_data_field;
    return *this;
}

int __seq4::operator == (const __seq4 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (protocol_version_field != that.protocol_version_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (responding_presentation_selector_field != that.responding_presentation_selector_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (presentation_context_definition_result_list_field != that.presentation_context_definition_result_list_field)
	    return 0;
    }
    if (bit_mask & 0x10000000) {
	if (presentation_requirements_field != that.presentation_requirements_field)
	    return 0;
    }
    if (bit_mask & 0x8000000) {
	if (user_session_requirements_field != that.user_session_requirements_field)
	    return 0;
    }
    if (bit_mask & 0x4000000) {
	if (protocol_options_field != that.protocol_options_field)
	    return 0;
    }
    if (bit_mask & 0x2000000) {
	if (responders_nominated_context_field != that.responders_nominated_context_field)
	    return 0;
    }
    if (bit_mask & 0x1000000) {
	if (user_data_field != that.user_data_field)
	    return 0;
    }
    return 1;
}

int __seq4::operator != (const __seq4 & that) const {
    return !(operator ==(that));
}

__seq4::protocol_version *__seq4::get_protocol_version() {
    if (bit_mask & 0x80000000)
	return &protocol_version_field;
    else
	return 0;
}

const __seq4::protocol_version *__seq4::get_protocol_version() const {
    if (bit_mask & 0x80000000)
	return &protocol_version_field;
    else
	return 0;
}

void __seq4::set_protocol_version(const protocol_version & protocol_version_val) {
    if (!(bit_mask & 0x80000000)) {
	memset(&protocol_version_field, 0, sizeof(protocol_version));
	bit_mask |= 0x80000000;
    }
    protocol_version_field = protocol_version_val;
}

int __seq4::protocol_version_is_default() const {
    return !(bit_mask & 0x80000000);
}

void __seq4::set_default_protocol_version() {
    if (bit_mask & 0x80000000) {
	protocol_version_field.~OssBitString();
	bit_mask &= ~0x80000000;
    }
}

__seq4::responding_presentation_selector *__seq4::get_responding_presentation_selector() {
    if (bit_mask & 0x40000000)
	return &responding_presentation_selector_field;
    else
	return 0;
}

const __seq4::responding_presentation_selector *__seq4::get_responding_presentation_selector() const {
    if (bit_mask & 0x40000000)
	return &responding_presentation_selector_field;
    else
	return 0;
}

void __seq4::set_responding_presentation_selector(const responding_presentation_selector & responding_presentation_selector_val) {
    bit_mask |= 0x40000000;
    responding_presentation_selector_field = responding_presentation_selector_val;
}

int __seq4::responding_presentation_selector_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void __seq4::omit_responding_presentation_selector() {
    responding_presentation_selector_field.~OssString();
    bit_mask &= ~0x40000000;
}

__seq4::presentation_context_definition_result_list *__seq4::get_presentation_context_definition_result_list() {
    if (bit_mask & 0x20000000)
	return &presentation_context_definition_result_list_field;
    else
	return 0;
}

const __seq4::presentation_context_definition_result_list *__seq4::get_presentation_context_definition_result_list() const {
    if (bit_mask & 0x20000000)
	return &presentation_context_definition_result_list_field;
    else
	return 0;
}

void __seq4::set_presentation_context_definition_result_list(const presentation_context_definition_result_list & presentation_context_definition_result_list_val) {
    bit_mask |= 0x20000000;
    presentation_context_definition_result_list_field = presentation_context_definition_result_list_val;
}

int __seq4::presentation_context_definition_result_list_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void __seq4::omit_presentation_context_definition_result_list() {
    presentation_context_definition_result_list_field.~__shared16();
    bit_mask &= ~0x20000000;
}

__seq4::presentation_requirements *__seq4::get_presentation_requirements() {
    if (bit_mask & 0x10000000)
	return &presentation_requirements_field;
    else
	return 0;
}

const __seq4::presentation_requirements *__seq4::get_presentation_requirements() const {
    if (bit_mask & 0x10000000)
	return &presentation_requirements_field;
    else
	return 0;
}

void __seq4::set_presentation_requirements(const presentation_requirements & presentation_requirements_val) {
    bit_mask |= 0x10000000;
    presentation_requirements_field = presentation_requirements_val;
}

int __seq4::presentation_requirements_is_present() const {
    return !!(bit_mask & 0x10000000);
}

void __seq4::omit_presentation_requirements() {
    presentation_requirements_field.~OssBitString();
    bit_mask &= ~0x10000000;
}

__seq4::user_session_requirements *__seq4::get_user_session_requirements() {
    if (bit_mask & 0x8000000)
	return &user_session_requirements_field;
    else
	return 0;
}

const __seq4::user_session_requirements *__seq4::get_user_session_requirements() const {
    if (bit_mask & 0x8000000)
	return &user_session_requirements_field;
    else
	return 0;
}

void __seq4::set_user_session_requirements(const user_session_requirements & user_session_requirements_val) {
    bit_mask |= 0x8000000;
    user_session_requirements_field = user_session_requirements_val;
}

int __seq4::user_session_requirements_is_present() const {
    return !!(bit_mask & 0x8000000);
}

void __seq4::omit_user_session_requirements() {
    user_session_requirements_field.~OssBitString();
    bit_mask &= ~0x8000000;
}

__seq4::protocol_options *__seq4::get_protocol_options() {
    if (bit_mask & 0x4000000)
	return &protocol_options_field;
    else
	return 0;
}

const __seq4::protocol_options *__seq4::get_protocol_options() const {
    if (bit_mask & 0x4000000)
	return &protocol_options_field;
    else
	return 0;
}

void __seq4::set_protocol_options(const protocol_options & protocol_options_val) {
    if (!(bit_mask & 0x4000000)) {
	memset(&protocol_options_field, 0, sizeof(protocol_options));
	bit_mask |= 0x4000000;
    }
    protocol_options_field = protocol_options_val;
}

int __seq4::protocol_options_is_default() const {
    return !(bit_mask & 0x4000000);
}

void __seq4::set_default_protocol_options() {
    if (bit_mask & 0x4000000) {
	protocol_options_field.~OssBitString();
	bit_mask &= ~0x4000000;
    }
}

__seq4::responders_nominated_context *__seq4::get_responders_nominated_context() {
    if (bit_mask & 0x2000000)
	return &responders_nominated_context_field;
    else
	return 0;
}

const __seq4::responders_nominated_context *__seq4::get_responders_nominated_context() const {
    if (bit_mask & 0x2000000)
	return &responders_nominated_context_field;
    else
	return 0;
}

void __seq4::set_responders_nominated_context(responders_nominated_context responders_nominated_context_val) {
    bit_mask |= 0x2000000;
    responders_nominated_context_field = responders_nominated_context_val;
}

int __seq4::responders_nominated_context_is_present() const {
    return !!(bit_mask & 0x2000000);
}

void __seq4::omit_responders_nominated_context() {
    bit_mask &= ~0x2000000;
}

__seq4::user_data *__seq4::get_user_data() {
    if (bit_mask & 0x1000000)
	return &user_data_field;
    else
	return 0;
}

const __seq4::user_data *__seq4::get_user_data() const {
    if (bit_mask & 0x1000000)
	return &user_data_field;
    else
	return 0;
}

void __seq4::set_user_data(const user_data & user_data_val) {
    bit_mask |= 0x1000000;
    user_data_field = user_data_val;
}

int __seq4::user_data_is_present() const {
    return !!(bit_mask & 0x1000000);
}

void __seq4::omit_user_data() {
    user_data_field.~__shared14();
    bit_mask &= ~0x1000000;
}

void *CPA_PPDU::operator new(size_t size) {
    return ossNewFunc(size);
}

void CPA_PPDU::operator delete(void *ptr) {
    asn1Free(ptr);
}

CPA_PPDU::CPA_PPDU() {
    memset(this, 0, sizeof(CPA_PPDU));
}

CPA_PPDU::CPA_PPDU(const CPA_PPDU & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	mode_selector_field = that.mode_selector_field;
	x410_mode_parameters_field = that.x410_mode_parameters_field;
	normal_mode_parameters_field = that.normal_mode_parameters_field;
    } OSSCLEAN(CPA_PPDU)
}

CPA_PPDU::CPA_PPDU(const mode_selector & mode_selector_val, const x410_mode_parameters & x410_mode_parameters_val, 
    const normal_mode_parameters & normal_mode_parameters_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	mode_selector_field = mode_selector_val;
	x410_mode_parameters_field = x410_mode_parameters_val;
	normal_mode_parameters_field = normal_mode_parameters_val;
    } OSSCLEAN(CPA_PPDU)
}

CPA_PPDU::CPA_PPDU(const mode_selector & mode_selector_val) {
    OSSTRY {
	bit_mask = 0;
	mode_selector_field = mode_selector_val;
    } OSSCLEAN(CPA_PPDU)
}

CPA_PPDU & CPA_PPDU::operator = (const CPA_PPDU & that) {
    if (this == &that)
	return *this;
    this->~CPA_PPDU();
    bit_mask = that.bit_mask;
    mode_selector_field = that.mode_selector_field;
    x410_mode_parameters_field = that.x410_mode_parameters_field;
    normal_mode_parameters_field = that.normal_mode_parameters_field;
    return *this;
}

int CPA_PPDU::operator == (const CPA_PPDU & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (mode_selector_field != that.mode_selector_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (x410_mode_parameters_field != that.x410_mode_parameters_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (normal_mode_parameters_field != that.normal_mode_parameters_field)
	    return 0;
    }
    return 1;
}

int CPA_PPDU::operator != (const CPA_PPDU & that) const {
    return !(operator ==(that));
}

CPA_PPDU::mode_selector & CPA_PPDU::get_mode_selector() {
    return mode_selector_field;
}

const CPA_PPDU::mode_selector & CPA_PPDU::get_mode_selector() const {
    return mode_selector_field;
}

void CPA_PPDU::set_mode_selector(const mode_selector & mode_selector_val) {
    mode_selector_field = mode_selector_val;
}

CPA_PPDU::x410_mode_parameters *CPA_PPDU::get_x410_mode_parameters() {
    if (bit_mask & 0x80000000)
	return &x410_mode_parameters_field;
    else
	return 0;
}

const CPA_PPDU::x410_mode_parameters *CPA_PPDU::get_x410_mode_parameters() const {
    if (bit_mask & 0x80000000)
	return &x410_mode_parameters_field;
    else
	return 0;
}

void CPA_PPDU::set_x410_mode_parameters(const x410_mode_parameters & x410_mode_parameters_val) {
    bit_mask |= 0x80000000;
    x410_mode_parameters_field = x410_mode_parameters_val;
}

int CPA_PPDU::x410_mode_parameters_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void CPA_PPDU::omit_x410_mode_parameters() {
    x410_mode_parameters_field.~__shared17();
    bit_mask &= ~0x80000000;
}

CPA_PPDU::normal_mode_parameters *CPA_PPDU::get_normal_mode_parameters() {
    if (bit_mask & 0x40000000)
	return &normal_mode_parameters_field;
    else
	return 0;
}

const CPA_PPDU::normal_mode_parameters *CPA_PPDU::get_normal_mode_parameters() const {
    if (bit_mask & 0x40000000)
	return &normal_mode_parameters_field;
    else
	return 0;
}

void CPA_PPDU::set_normal_mode_parameters(const normal_mode_parameters & normal_mode_parameters_val) {
    bit_mask |= 0x40000000;
    normal_mode_parameters_field = normal_mode_parameters_val;
}

int CPA_PPDU::normal_mode_parameters_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void CPA_PPDU::omit_normal_mode_parameters() {
    normal_mode_parameters_field.~__seq4();
    bit_mask &= ~0x40000000;
}

void *__shared18::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared18::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared18::__shared18() {
    memset(this, 0, sizeof(__shared18));
}

__shared18::__shared18(const __shared18 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	refuseReason_field = that.refuseReason_field;
	userDataRJ_field = that.userDataRJ_field;
    } OSSCLEAN(__shared18)
}

__shared18::__shared18(refuseReason refuseReason_val, const userDataRJ & userDataRJ_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	refuseReason_field = refuseReason_val;
	userDataRJ_field = userDataRJ_val;
    } OSSCLEAN(__shared18)
}

__shared18 & __shared18::operator = (const __shared18 & that) {
    if (this == &that)
	return *this;
    this->~__shared18();
    bit_mask = that.bit_mask;
    refuseReason_field = that.refuseReason_field;
    userDataRJ_field = that.userDataRJ_field;
    return *this;
}

int __shared18::operator == (const __shared18 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (refuseReason_field != that.refuseReason_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (userDataRJ_field != that.userDataRJ_field)
	    return 0;
    }
    return 1;
}

int __shared18::operator != (const __shared18 & that) const {
    return !(operator ==(that));
}

__shared18::refuseReason *__shared18::get_refuseReason() {
    if (bit_mask & 0x80000000)
	return &refuseReason_field;
    else
	return 0;
}

const __shared18::refuseReason *__shared18::get_refuseReason() const {
    if (bit_mask & 0x80000000)
	return &refuseReason_field;
    else
	return 0;
}

void __shared18::set_refuseReason(refuseReason refuseReason_val) {
    bit_mask |= 0x80000000;
    refuseReason_field = refuseReason_val;
}

int __shared18::refuseReason_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void __shared18::omit_refuseReason() {
    bit_mask &= ~0x80000000;
}

__shared18::userDataRJ *__shared18::get_userDataRJ() {
    if (bit_mask & 0x40000000)
	return &userDataRJ_field;
    else
	return 0;
}

const __shared18::userDataRJ *__shared18::get_userDataRJ() const {
    if (bit_mask & 0x40000000)
	return &userDataRJ_field;
    else
	return 0;
}

void __shared18::set_userDataRJ(const userDataRJ & userDataRJ_val) {
    bit_mask |= 0x40000000;
    userDataRJ_field = userDataRJ_val;
}

int __shared18::userDataRJ_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void __shared18::omit_userDataRJ() {
    userDataRJ_field.~OssOpen();
    bit_mask &= ~0x40000000;
}

void *__seq5::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq5::operator delete(void *ptr) {
    asn1Free(ptr);
}

const OssBitString& __seq5::get_default_protocol_version() {
    return __seq5::default_protocol_version;
}

__seq5::__seq5() {
    memset(this, 0, sizeof(__seq5));
}

__seq5::__seq5(const __seq5 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	if (bit_mask & 0x80000000)
	    protocol_version_field = that.protocol_version_field;
	responding_presentation_selector_field = that.responding_presentation_selector_field;
	presentation_context_definition_result_list_field = that.presentation_context_definition_result_list_field;
	default_context_result_field = that.default_context_result_field;
	provider_reason_field = that.provider_reason_field;
	user_data_field = that.user_data_field;
    } OSSCLEAN(__seq5)
}

__seq5::__seq5(const protocol_version & protocol_version_val, const responding_presentation_selector & responding_presentation_selector_val, 
    const presentation_context_definition_result_list & presentation_context_definition_result_list_val, 
    default_context_result default_context_result_val, provider_reason provider_reason_val, 
    const user_data & user_data_val) {
    OSSTRY {
	bit_mask = 0xfc000000;
	protocol_version_field = protocol_version_val;
	responding_presentation_selector_field = responding_presentation_selector_val;
	presentation_context_definition_result_list_field = presentation_context_definition_result_list_val;
	default_context_result_field = default_context_result_val;
	provider_reason_field = provider_reason_val;
	user_data_field = user_data_val;
    } OSSCLEAN(__seq5)
}

__seq5::~__seq5() {
    if (!(bit_mask & 0x80000000))
	memset(&protocol_version_field, 0, sizeof(protocol_version));
}

__seq5 & __seq5::operator = (const __seq5 & that) {
    if (this == &that)
	return *this;
    this->~__seq5();
    bit_mask = that.bit_mask;
    if (bit_mask & 0x80000000)
	protocol_version_field = that.protocol_version_field;
    responding_presentation_selector_field = that.responding_presentation_selector_field;
    presentation_context_definition_result_list_field = that.presentation_context_definition_result_list_field;
    default_context_result_field = that.default_context_result_field;
    provider_reason_field = that.provider_reason_field;
    user_data_field = that.user_data_field;
    return *this;
}

int __seq5::operator == (const __seq5 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (protocol_version_field != that.protocol_version_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (responding_presentation_selector_field != that.responding_presentation_selector_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (presentation_context_definition_result_list_field != that.presentation_context_definition_result_list_field)
	    return 0;
    }
    if (bit_mask & 0x10000000) {
	if (default_context_result_field != that.default_context_result_field)
	    return 0;
    }
    if (bit_mask & 0x8000000) {
	if (provider_reason_field != that.provider_reason_field)
	    return 0;
    }
    if (bit_mask & 0x4000000) {
	if (user_data_field != that.user_data_field)
	    return 0;
    }
    return 1;
}

int __seq5::operator != (const __seq5 & that) const {
    return !(operator ==(that));
}

__seq5::protocol_version *__seq5::get_protocol_version() {
    if (bit_mask & 0x80000000)
	return &protocol_version_field;
    else
	return 0;
}

const __seq5::protocol_version *__seq5::get_protocol_version() const {
    if (bit_mask & 0x80000000)
	return &protocol_version_field;
    else
	return 0;
}

void __seq5::set_protocol_version(const protocol_version & protocol_version_val) {
    if (!(bit_mask & 0x80000000)) {
	memset(&protocol_version_field, 0, sizeof(protocol_version));
	bit_mask |= 0x80000000;
    }
    protocol_version_field = protocol_version_val;
}

int __seq5::protocol_version_is_default() const {
    return !(bit_mask & 0x80000000);
}

void __seq5::set_default_protocol_version() {
    if (bit_mask & 0x80000000) {
	protocol_version_field.~OssBitString();
	bit_mask &= ~0x80000000;
    }
}

__seq5::responding_presentation_selector *__seq5::get_responding_presentation_selector() {
    if (bit_mask & 0x40000000)
	return &responding_presentation_selector_field;
    else
	return 0;
}

const __seq5::responding_presentation_selector *__seq5::get_responding_presentation_selector() const {
    if (bit_mask & 0x40000000)
	return &responding_presentation_selector_field;
    else
	return 0;
}

void __seq5::set_responding_presentation_selector(const responding_presentation_selector & responding_presentation_selector_val) {
    bit_mask |= 0x40000000;
    responding_presentation_selector_field = responding_presentation_selector_val;
}

int __seq5::responding_presentation_selector_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void __seq5::omit_responding_presentation_selector() {
    responding_presentation_selector_field.~OssString();
    bit_mask &= ~0x40000000;
}

__seq5::presentation_context_definition_result_list *__seq5::get_presentation_context_definition_result_list() {
    if (bit_mask & 0x20000000)
	return &presentation_context_definition_result_list_field;
    else
	return 0;
}

const __seq5::presentation_context_definition_result_list *__seq5::get_presentation_context_definition_result_list() const {
    if (bit_mask & 0x20000000)
	return &presentation_context_definition_result_list_field;
    else
	return 0;
}

void __seq5::set_presentation_context_definition_result_list(const presentation_context_definition_result_list & presentation_context_definition_result_list_val) {
    bit_mask |= 0x20000000;
    presentation_context_definition_result_list_field = presentation_context_definition_result_list_val;
}

int __seq5::presentation_context_definition_result_list_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void __seq5::omit_presentation_context_definition_result_list() {
    presentation_context_definition_result_list_field.~__shared16();
    bit_mask &= ~0x20000000;
}

__seq5::default_context_result *__seq5::get_default_context_result() {
    if (bit_mask & 0x10000000)
	return &default_context_result_field;
    else
	return 0;
}

const __seq5::default_context_result *__seq5::get_default_context_result() const {
    if (bit_mask & 0x10000000)
	return &default_context_result_field;
    else
	return 0;
}

void __seq5::set_default_context_result(default_context_result default_context_result_val) {
    bit_mask |= 0x10000000;
    default_context_result_field = default_context_result_val;
}

int __seq5::default_context_result_is_present() const {
    return !!(bit_mask & 0x10000000);
}

void __seq5::omit_default_context_result() {
    bit_mask &= ~0x10000000;
}

__seq5::provider_reason *__seq5::get_provider_reason() {
    if (bit_mask & 0x8000000)
	return &provider_reason_field;
    else
	return 0;
}

const __seq5::provider_reason *__seq5::get_provider_reason() const {
    if (bit_mask & 0x8000000)
	return &provider_reason_field;
    else
	return 0;
}

void __seq5::set_provider_reason(provider_reason provider_reason_val) {
    bit_mask |= 0x8000000;
    provider_reason_field = provider_reason_val;
}

int __seq5::provider_reason_is_present() const {
    return !!(bit_mask & 0x8000000);
}

void __seq5::omit_provider_reason() {
    bit_mask &= ~0x8000000;
}

__seq5::user_data *__seq5::get_user_data() {
    if (bit_mask & 0x4000000)
	return &user_data_field;
    else
	return 0;
}

const __seq5::user_data *__seq5::get_user_data() const {
    if (bit_mask & 0x4000000)
	return &user_data_field;
    else
	return 0;
}

void __seq5::set_user_data(const user_data & user_data_val) {
    bit_mask |= 0x4000000;
    user_data_field = user_data_val;
}

int __seq5::user_data_is_present() const {
    return !!(bit_mask & 0x4000000);
}

void __seq5::omit_user_data() {
    user_data_field.~__shared14();
    bit_mask &= ~0x4000000;
}

CPR_PPDU::CPR_PPDU() {
    memset(this, 0, sizeof(CPR_PPDU));
}

CPR_PPDU::CPR_PPDU(const CPR_PPDU & that) {
    memset(this, 0, sizeof(CPR_PPDU));
    operator =(that);
}

CPR_PPDU::~CPR_PPDU() {
    cleanup();
}

CPR_PPDU & CPR_PPDU::operator = (const CPR_PPDU & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case x400_mode_parameters_chosen:
	    if (that.x400_mode_parameters_field)
		x400_mode_parameters_field = new x400_mode_parameters(*that.x400_mode_parameters_field);
	    break;
	case normal_mode_parameters_chosen:
	    if (that.normal_mode_parameters_field)
		normal_mode_parameters_field = new normal_mode_parameters(*that.normal_mode_parameters_field);
	    break;
    }
    return *this;
}

int CPR_PPDU::operator == (const CPR_PPDU & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case x400_mode_parameters_chosen:
	    if ((x400_mode_parameters_field) && (that.x400_mode_parameters_field))
		return (*x400_mode_parameters_field == *(that.x400_mode_parameters_field));
	    else if (!((!x400_mode_parameters_field) && (!that.x400_mode_parameters_field)))
		return 0;
	    break;
	case normal_mode_parameters_chosen:
	    if ((normal_mode_parameters_field) && (that.normal_mode_parameters_field))
		return (*normal_mode_parameters_field == *(that.normal_mode_parameters_field));
	    else if (!((!normal_mode_parameters_field) && (!that.normal_mode_parameters_field)))
		return 0;
	    break;
    }

    return 1;
}

int CPR_PPDU::operator != (const CPR_PPDU & that) const {
    return !(operator ==(that));
}

CPR_PPDU::x400_mode_parameters *CPR_PPDU::get_x400_mode_parameters() {
    if (_choice == x400_mode_parameters_chosen)
	return (x400_mode_parameters *)x400_mode_parameters_field;
    else
	return 0;
}

const CPR_PPDU::x400_mode_parameters *CPR_PPDU::get_x400_mode_parameters() const {
    if (_choice == x400_mode_parameters_chosen)
	return (const x400_mode_parameters *)x400_mode_parameters_field;
    else
	return 0;
}

void CPR_PPDU::set_x400_mode_parameters(const x400_mode_parameters & x400_mode_parameters_val) {
    cleanup();
    x400_mode_parameters_field = new x400_mode_parameters(x400_mode_parameters_val);
    _choice = x400_mode_parameters_chosen;
}

CPR_PPDU::normal_mode_parameters *CPR_PPDU::get_normal_mode_parameters() {
    if (_choice == normal_mode_parameters_chosen)
	return (normal_mode_parameters *)normal_mode_parameters_field;
    else
	return 0;
}

const CPR_PPDU::normal_mode_parameters *CPR_PPDU::get_normal_mode_parameters() const {
    if (_choice == normal_mode_parameters_chosen)
	return (const normal_mode_parameters *)normal_mode_parameters_field;
    else
	return 0;
}

void CPR_PPDU::set_normal_mode_parameters(const normal_mode_parameters & normal_mode_parameters_val) {
    cleanup();
    normal_mode_parameters_field = new normal_mode_parameters(normal_mode_parameters_val);
    _choice = normal_mode_parameters_chosen;
}

void CPR_PPDU::cleanup() {
    switch (_choice) {
	case x400_mode_parameters_chosen:
	    if (x400_mode_parameters_field)
		delete x400_mode_parameters_field;
	    break;
	case normal_mode_parameters_chosen:
	    if (normal_mode_parameters_field)
		delete normal_mode_parameters_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

void *__shared19::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared19::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared19::__shared19() {
    memset(this, 0, sizeof(__shared19));
}

__shared19::__shared19(const __shared19 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	abortReason_field = that.abortReason_field;
	reflectedParameter_field = that.reflectedParameter_field;
	userdataAB_field = that.userdataAB_field;
    } OSSCLEAN(__shared19)
}

__shared19::__shared19(abortReason abortReason_val, const reflectedParameter & reflectedParameter_val, 
    const userdataAB & userdataAB_val) {
    OSSTRY {
	bit_mask = 0xe0000000;
	abortReason_field = abortReason_val;
	reflectedParameter_field = reflectedParameter_val;
	userdataAB_field = userdataAB_val;
    } OSSCLEAN(__shared19)
}

__shared19 & __shared19::operator = (const __shared19 & that) {
    if (this == &that)
	return *this;
    this->~__shared19();
    bit_mask = that.bit_mask;
    abortReason_field = that.abortReason_field;
    reflectedParameter_field = that.reflectedParameter_field;
    userdataAB_field = that.userdataAB_field;
    return *this;
}

int __shared19::operator == (const __shared19 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (abortReason_field != that.abortReason_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (reflectedParameter_field != that.reflectedParameter_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (userdataAB_field != that.userdataAB_field)
	    return 0;
    }
    return 1;
}

int __shared19::operator != (const __shared19 & that) const {
    return !(operator ==(that));
}

__shared19::abortReason *__shared19::get_abortReason() {
    if (bit_mask & 0x80000000)
	return &abortReason_field;
    else
	return 0;
}

const __shared19::abortReason *__shared19::get_abortReason() const {
    if (bit_mask & 0x80000000)
	return &abortReason_field;
    else
	return 0;
}

void __shared19::set_abortReason(abortReason abortReason_val) {
    bit_mask |= 0x80000000;
    abortReason_field = abortReason_val;
}

int __shared19::abortReason_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void __shared19::omit_abortReason() {
    bit_mask &= ~0x80000000;
}

__shared19::reflectedParameter *__shared19::get_reflectedParameter() {
    if (bit_mask & 0x40000000)
	return &reflectedParameter_field;
    else
	return 0;
}

const __shared19::reflectedParameter *__shared19::get_reflectedParameter() const {
    if (bit_mask & 0x40000000)
	return &reflectedParameter_field;
    else
	return 0;
}

void __shared19::set_reflectedParameter(const reflectedParameter & reflectedParameter_val) {
    bit_mask |= 0x40000000;
    reflectedParameter_field = reflectedParameter_val;
}

int __shared19::reflectedParameter_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void __shared19::omit_reflectedParameter() {
    reflectedParameter_field.~OssBitString();
    bit_mask &= ~0x40000000;
}

__shared19::userdataAB *__shared19::get_userdataAB() {
    if (bit_mask & 0x20000000)
	return &userdataAB_field;
    else
	return 0;
}

const __shared19::userdataAB *__shared19::get_userdataAB() const {
    if (bit_mask & 0x20000000)
	return &userdataAB_field;
    else
	return 0;
}

void __shared19::set_userdataAB(const userdataAB & userdataAB_val) {
    bit_mask |= 0x20000000;
    userdataAB_field = userdataAB_val;
}

int __shared19::userdataAB_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void __shared19::omit_userdataAB() {
    userdataAB_field.~OssOpen();
    bit_mask &= ~0x20000000;
}

/* Auxiliary data structures and functions for class __shared20 */

class __shared20_member {
public:
    __shared20_member *next;
    __shared20::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared20_member();
    __shared20_member(const __shared20::component & val);
};

void *__shared20_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared20_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared20_member::__shared20_member() {
}

__shared20_member::__shared20_member(const __shared20::component & val) {
    value = val;
}

static void *__shared20_copy(void *that) {
    return new __shared20_member(((__shared20_member *)that)->value);
}

static void __shared20_destroy(void *that) {
    delete (__shared20_member *)that;
}

static int __shared20_compare(void *val1, void *val2) {
    return (((__shared20_member *)val1)->value == ((__shared20_member *)val2)->value);
}

/* Constructors */

__shared20::__shared20() {
}

__shared20::__shared20(const __shared20 & that) {
    OSSTRY {
	do_copy(that, &__shared20_copy);
    } OSSCLEAN(__shared20)
}

/* Destructor */

__shared20::~__shared20() {
    do_destroy(&__shared20_destroy);
}

/* Operators: assignment, equality, inequality */

__shared20 & __shared20::operator = (const __shared20 & that) {
    do_destroy(&__shared20_destroy);
    do_copy(that, &__shared20_copy);
    return *this;
}

int __shared20::operator == (const __shared20 & that) const {
    return do_compare(that, &__shared20_compare);
}

int __shared20::operator != (const __shared20 & that) const {
    return !do_compare(that, &__shared20_compare);
}

/* Locate ("At" etc) methods */

__shared20::component *__shared20::at(OssIndex pos) {
    return &((__shared20_member *)pos)->value;
}

const __shared20::component *__shared20::at(OssIndex pos) const {
    return &((__shared20_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared20::prepend(const component & val) {
    __shared20_member *newrec = new __shared20_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared20::prepend(__shared20 *seq) {
    return do_prepend(seq);
}

OssIndex __shared20::insert_after(OssIndex pos, const component & val) {
    __shared20_member *newrec = new __shared20_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared20::insert_after(OssIndex pos, __shared20 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared20::remove_front() {
    __shared20_member *extr = (__shared20_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared20_destroy(extr);
    return 0;
}

int __shared20::remove_after(OssIndex pos) {
    __shared20_member *extr = (__shared20_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared20_destroy(extr);
    return 0;
}

/* Extract methods */

__shared20 *__shared20::extract_after(OssIndex begin, OssIndex end) {
    return (__shared20 *)do_extract_after(begin, end);
}

void *__shared21::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared21::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared21::__shared21() {
    memset(this, 0, sizeof(__shared21));
}

__shared21::__shared21(const __shared21 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	presentation_context_identifier_list_field = that.presentation_context_identifier_list_field;
	user_data_field = that.user_data_field;
    } OSSCLEAN(__shared21)
}

__shared21::__shared21(const presentation_context_identifier_list & presentation_context_identifier_list_val, 
    const user_data & user_data_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	presentation_context_identifier_list_field = presentation_context_identifier_list_val;
	user_data_field = user_data_val;
    } OSSCLEAN(__shared21)
}

__shared21 & __shared21::operator = (const __shared21 & that) {
    if (this == &that)
	return *this;
    this->~__shared21();
    bit_mask = that.bit_mask;
    presentation_context_identifier_list_field = that.presentation_context_identifier_list_field;
    user_data_field = that.user_data_field;
    return *this;
}

int __shared21::operator == (const __shared21 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (presentation_context_identifier_list_field != that.presentation_context_identifier_list_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (user_data_field != that.user_data_field)
	    return 0;
    }
    return 1;
}

int __shared21::operator != (const __shared21 & that) const {
    return !(operator ==(that));
}

__shared21::presentation_context_identifier_list *__shared21::get_presentation_context_identifier_list() {
    if (bit_mask & 0x80000000)
	return &presentation_context_identifier_list_field;
    else
	return 0;
}

const __shared21::presentation_context_identifier_list *__shared21::get_presentation_context_identifier_list() const {
    if (bit_mask & 0x80000000)
	return &presentation_context_identifier_list_field;
    else
	return 0;
}

void __shared21::set_presentation_context_identifier_list(const presentation_context_identifier_list & presentation_context_identifier_list_val) {
    bit_mask |= 0x80000000;
    presentation_context_identifier_list_field = presentation_context_identifier_list_val;
}

int __shared21::presentation_context_identifier_list_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void __shared21::omit_presentation_context_identifier_list() {
    presentation_context_identifier_list_field.~__shared20();
    bit_mask &= ~0x80000000;
}

__shared21::user_data *__shared21::get_user_data() {
    if (bit_mask & 0x40000000)
	return &user_data_field;
    else
	return 0;
}

const __shared21::user_data *__shared21::get_user_data() const {
    if (bit_mask & 0x40000000)
	return &user_data_field;
    else
	return 0;
}

void __shared21::set_user_data(const user_data & user_data_val) {
    bit_mask |= 0x40000000;
    user_data_field = user_data_val;
}

int __shared21::user_data_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void __shared21::omit_user_data() {
    user_data_field.~__shared14();
    bit_mask &= ~0x40000000;
}

ARU_PPDU::ARU_PPDU() {
    memset(this, 0, sizeof(ARU_PPDU));
}

ARU_PPDU::ARU_PPDU(const ARU_PPDU & that) {
    memset(this, 0, sizeof(ARU_PPDU));
    operator =(that);
}

ARU_PPDU::~ARU_PPDU() {
    cleanup();
}

ARU_PPDU & ARU_PPDU::operator = (const ARU_PPDU & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case x400_mode_parameters_chosen:
	    if (that.x400_mode_parameters_field)
		x400_mode_parameters_field = new x400_mode_parameters(*that.x400_mode_parameters_field);
	    break;
	case normal_mode_parameters_chosen:
	    if (that.normal_mode_parameters_field)
		normal_mode_parameters_field = new normal_mode_parameters(*that.normal_mode_parameters_field);
	    break;
    }
    return *this;
}

int ARU_PPDU::operator == (const ARU_PPDU & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case x400_mode_parameters_chosen:
	    if ((x400_mode_parameters_field) && (that.x400_mode_parameters_field))
		return (*x400_mode_parameters_field == *(that.x400_mode_parameters_field));
	    else if (!((!x400_mode_parameters_field) && (!that.x400_mode_parameters_field)))
		return 0;
	    break;
	case normal_mode_parameters_chosen:
	    if ((normal_mode_parameters_field) && (that.normal_mode_parameters_field))
		return (*normal_mode_parameters_field == *(that.normal_mode_parameters_field));
	    else if (!((!normal_mode_parameters_field) && (!that.normal_mode_parameters_field)))
		return 0;
	    break;
    }

    return 1;
}

int ARU_PPDU::operator != (const ARU_PPDU & that) const {
    return !(operator ==(that));
}

ARU_PPDU::x400_mode_parameters *ARU_PPDU::get_x400_mode_parameters() {
    if (_choice == x400_mode_parameters_chosen)
	return (x400_mode_parameters *)x400_mode_parameters_field;
    else
	return 0;
}

const ARU_PPDU::x400_mode_parameters *ARU_PPDU::get_x400_mode_parameters() const {
    if (_choice == x400_mode_parameters_chosen)
	return (const x400_mode_parameters *)x400_mode_parameters_field;
    else
	return 0;
}

void ARU_PPDU::set_x400_mode_parameters(const x400_mode_parameters & x400_mode_parameters_val) {
    cleanup();
    x400_mode_parameters_field = new x400_mode_parameters(x400_mode_parameters_val);
    _choice = x400_mode_parameters_chosen;
}

ARU_PPDU::normal_mode_parameters *ARU_PPDU::get_normal_mode_parameters() {
    if (_choice == normal_mode_parameters_chosen)
	return (normal_mode_parameters *)normal_mode_parameters_field;
    else
	return 0;
}

const ARU_PPDU::normal_mode_parameters *ARU_PPDU::get_normal_mode_parameters() const {
    if (_choice == normal_mode_parameters_chosen)
	return (const normal_mode_parameters *)normal_mode_parameters_field;
    else
	return 0;
}

void ARU_PPDU::set_normal_mode_parameters(const normal_mode_parameters & normal_mode_parameters_val) {
    cleanup();
    normal_mode_parameters_field = new normal_mode_parameters(normal_mode_parameters_val);
    _choice = normal_mode_parameters_chosen;
}

void ARU_PPDU::cleanup() {
    switch (_choice) {
	case x400_mode_parameters_chosen:
	    if (x400_mode_parameters_field)
		delete x400_mode_parameters_field;
	    break;
	case normal_mode_parameters_chosen:
	    if (normal_mode_parameters_field)
		delete normal_mode_parameters_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

void *ARP_PPDU::operator new(size_t size) {
    return ossNewFunc(size);
}

void ARP_PPDU::operator delete(void *ptr) {
    asn1Free(ptr);
}

ARP_PPDU::ARP_PPDU() {
    memset(this, 0, sizeof(ARP_PPDU));
}

ARP_PPDU::ARP_PPDU(const ARP_PPDU & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	provider_reason_field = that.provider_reason_field;
	event_identifier_field = that.event_identifier_field;
    } OSSCLEAN(ARP_PPDU)
}

ARP_PPDU::ARP_PPDU(provider_reason provider_reason_val, event_identifier event_identifier_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	provider_reason_field = provider_reason_val;
	event_identifier_field = event_identifier_val;
    } OSSCLEAN(ARP_PPDU)
}

ARP_PPDU & ARP_PPDU::operator = (const ARP_PPDU & that) {
    if (this == &that)
	return *this;
    this->~ARP_PPDU();
    bit_mask = that.bit_mask;
    provider_reason_field = that.provider_reason_field;
    event_identifier_field = that.event_identifier_field;
    return *this;
}

int ARP_PPDU::operator == (const ARP_PPDU & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (provider_reason_field != that.provider_reason_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (event_identifier_field != that.event_identifier_field)
	    return 0;
    }
    return 1;
}

int ARP_PPDU::operator != (const ARP_PPDU & that) const {
    return !(operator ==(that));
}

ARP_PPDU::provider_reason *ARP_PPDU::get_provider_reason() {
    if (bit_mask & 0x80000000)
	return &provider_reason_field;
    else
	return 0;
}

const ARP_PPDU::provider_reason *ARP_PPDU::get_provider_reason() const {
    if (bit_mask & 0x80000000)
	return &provider_reason_field;
    else
	return 0;
}

void ARP_PPDU::set_provider_reason(provider_reason provider_reason_val) {
    bit_mask |= 0x80000000;
    provider_reason_field = provider_reason_val;
}

int ARP_PPDU::provider_reason_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void ARP_PPDU::omit_provider_reason() {
    bit_mask &= ~0x80000000;
}

ARP_PPDU::event_identifier *ARP_PPDU::get_event_identifier() {
    if (bit_mask & 0x40000000)
	return &event_identifier_field;
    else
	return 0;
}

const ARP_PPDU::event_identifier *ARP_PPDU::get_event_identifier() const {
    if (bit_mask & 0x40000000)
	return &event_identifier_field;
    else
	return 0;
}

void ARP_PPDU::set_event_identifier(event_identifier event_identifier_val) {
    bit_mask |= 0x40000000;
    event_identifier_field = event_identifier_val;
}

int ARP_PPDU::event_identifier_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void ARP_PPDU::omit_event_identifier() {
    bit_mask &= ~0x40000000;
}

Abort_type::Abort_type() {
    memset(this, 0, sizeof(Abort_type));
}

Abort_type::Abort_type(const Abort_type & that) {
    memset(this, 0, sizeof(Abort_type));
    operator =(that);
}

Abort_type::~Abort_type() {
    cleanup();
}

Abort_type & Abort_type::operator = (const Abort_type & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case aru_ppdu_chosen:
	    if (that.aru_ppdu_field)
		aru_ppdu_field = new aru_ppdu(*that.aru_ppdu_field);
	    break;
	case arp_ppdu_chosen:
	    if (that.arp_ppdu_field)
		arp_ppdu_field = new arp_ppdu(*that.arp_ppdu_field);
	    break;
    }
    return *this;
}

int Abort_type::operator == (const Abort_type & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case aru_ppdu_chosen:
	    if ((aru_ppdu_field) && (that.aru_ppdu_field))
		return (*aru_ppdu_field == *(that.aru_ppdu_field));
	    else if (!((!aru_ppdu_field) && (!that.aru_ppdu_field)))
		return 0;
	    break;
	case arp_ppdu_chosen:
	    if ((arp_ppdu_field) && (that.arp_ppdu_field))
		return (*arp_ppdu_field == *(that.arp_ppdu_field));
	    else if (!((!arp_ppdu_field) && (!that.arp_ppdu_field)))
		return 0;
	    break;
    }

    return 1;
}

int Abort_type::operator != (const Abort_type & that) const {
    return !(operator ==(that));
}

Abort_type::aru_ppdu *Abort_type::get_aru_ppdu() {
    if (_choice == aru_ppdu_chosen)
	return (aru_ppdu *)aru_ppdu_field;
    else
	return 0;
}

const Abort_type::aru_ppdu *Abort_type::get_aru_ppdu() const {
    if (_choice == aru_ppdu_chosen)
	return (const aru_ppdu *)aru_ppdu_field;
    else
	return 0;
}

void Abort_type::set_aru_ppdu(const aru_ppdu & aru_ppdu_val) {
    cleanup();
    aru_ppdu_field = new aru_ppdu(aru_ppdu_val);
    _choice = aru_ppdu_chosen;
}

Abort_type::arp_ppdu *Abort_type::get_arp_ppdu() {
    if (_choice == arp_ppdu_chosen)
	return (arp_ppdu *)arp_ppdu_field;
    else
	return 0;
}

const Abort_type::arp_ppdu *Abort_type::get_arp_ppdu() const {
    if (_choice == arp_ppdu_chosen)
	return (const arp_ppdu *)arp_ppdu_field;
    else
	return 0;
}

void Abort_type::set_arp_ppdu(const arp_ppdu & arp_ppdu_val) {
    cleanup();
    arp_ppdu_field = new arp_ppdu(arp_ppdu_val);
    _choice = arp_ppdu_chosen;
}

void Abort_type::cleanup() {
    switch (_choice) {
	case aru_ppdu_chosen:
	    if (aru_ppdu_field)
		delete aru_ppdu_field;
	    break;
	case arp_ppdu_chosen:
	    if (arp_ppdu_field)
		delete arp_ppdu_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

/* Auxiliary data structures and functions for class __shared22 */

class __shared22_member {
public:
    __shared22_member *next;
    __shared22::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
};

void *__shared22_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared22_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

static void *__shared22_copy(void *that) {
    __shared22_member *result = new __shared22_member;
    if (result)
	result->value = ((__shared22_member *)that)->value;
    return result;
}

static void __shared22_destroy(void *that) {
    delete (__shared22_member *)that;
}

static int __shared22_compare(void *val1, void *val2) {
    return (((__shared22_member *)val1)->value == ((__shared22_member *)val2)->value);
}

/* Constructors */

__shared22::__shared22() {
}

__shared22::__shared22(const __shared22 & that) {
    OSSTRY {
	do_copy(that, &__shared22_copy);
    } OSSCLEAN(__shared22)
}

/* Destructor */

__shared22::~__shared22() {
    do_destroy(&__shared22_destroy);
}

/* Operators: assignment, equality, inequality */

__shared22 & __shared22::operator = (const __shared22 & that) {
    do_destroy(&__shared22_destroy);
    do_copy(that, &__shared22_copy);
    return *this;
}

int __shared22::operator == (const __shared22 & that) const {
    return do_compare(that, &__shared22_compare);
}

int __shared22::operator != (const __shared22 & that) const {
    return !do_compare(that, &__shared22_compare);
}

/* Locate ("At" etc) methods */

__shared22::component *__shared22::at(OssIndex pos) {
    return &((__shared22_member *)pos)->value;
}

const __shared22::component *__shared22::at(OssIndex pos) const {
    return &((__shared22_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared22::prepend(component val) {
    __shared22_member *newrec = new __shared22_member();
    if (!newrec)
	return OSS_NOINDEX;
    newrec->value = val;
    return do_prepend(newrec);
}

OssIndex __shared22::prepend(__shared22 *seq) {
    return do_prepend(seq);
}

OssIndex __shared22::insert_after(OssIndex pos, component val) {
    __shared22_member *newrec = new __shared22_member();
    if (!newrec)
	return OSS_NOINDEX;
    newrec->value = val;
    return do_insert_after(pos, newrec);
}

OssIndex __shared22::insert_after(OssIndex pos, __shared22 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared22::remove_front() {
    __shared22_member *extr = (__shared22_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared22_destroy(extr);
    return 0;
}

int __shared22::remove_after(OssIndex pos) {
    __shared22_member *extr = (__shared22_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared22_destroy(extr);
    return 0;
}

/* Extract methods */

__shared22 *__shared22::extract_after(OssIndex begin, OssIndex end) {
    return (__shared22 *)do_extract_after(begin, end);
}

void *AC_PPDU::operator new(size_t size) {
    return ossNewFunc(size);
}

void AC_PPDU::operator delete(void *ptr) {
    asn1Free(ptr);
}

AC_PPDU::AC_PPDU() {
    memset(this, 0, sizeof(AC_PPDU));
}

AC_PPDU::AC_PPDU(const AC_PPDU & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	presentation_context_addition_list_field = that.presentation_context_addition_list_field;
	presentation_context_deletion_list_field = that.presentation_context_deletion_list_field;
	user_data_field = that.user_data_field;
    } OSSCLEAN(AC_PPDU)
}

AC_PPDU::AC_PPDU(const presentation_context_addition_list & presentation_context_addition_list_val, 
    const presentation_context_deletion_list & presentation_context_deletion_list_val, 
    const user_data & user_data_val) {
    OSSTRY {
	bit_mask = 0xe0000000;
	presentation_context_addition_list_field = presentation_context_addition_list_val;
	presentation_context_deletion_list_field = presentation_context_deletion_list_val;
	user_data_field = user_data_val;
    } OSSCLEAN(AC_PPDU)
}

AC_PPDU & AC_PPDU::operator = (const AC_PPDU & that) {
    if (this == &that)
	return *this;
    this->~AC_PPDU();
    bit_mask = that.bit_mask;
    presentation_context_addition_list_field = that.presentation_context_addition_list_field;
    presentation_context_deletion_list_field = that.presentation_context_deletion_list_field;
    user_data_field = that.user_data_field;
    return *this;
}

int AC_PPDU::operator == (const AC_PPDU & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (presentation_context_addition_list_field != that.presentation_context_addition_list_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (presentation_context_deletion_list_field != that.presentation_context_deletion_list_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (user_data_field != that.user_data_field)
	    return 0;
    }
    return 1;
}

int AC_PPDU::operator != (const AC_PPDU & that) const {
    return !(operator ==(that));
}

AC_PPDU::presentation_context_addition_list *AC_PPDU::get_presentation_context_addition_list() {
    if (bit_mask & 0x80000000)
	return &presentation_context_addition_list_field;
    else
	return 0;
}

const AC_PPDU::presentation_context_addition_list *AC_PPDU::get_presentation_context_addition_list() const {
    if (bit_mask & 0x80000000)
	return &presentation_context_addition_list_field;
    else
	return 0;
}

void AC_PPDU::set_presentation_context_addition_list(const presentation_context_addition_list & presentation_context_addition_list_val) {
    bit_mask |= 0x80000000;
    presentation_context_addition_list_field = presentation_context_addition_list_val;
}

int AC_PPDU::presentation_context_addition_list_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void AC_PPDU::omit_presentation_context_addition_list() {
    presentation_context_addition_list_field.~__shared12();
    bit_mask &= ~0x80000000;
}

AC_PPDU::presentation_context_deletion_list *AC_PPDU::get_presentation_context_deletion_list() {
    if (bit_mask & 0x40000000)
	return &presentation_context_deletion_list_field;
    else
	return 0;
}

const AC_PPDU::presentation_context_deletion_list *AC_PPDU::get_presentation_context_deletion_list() const {
    if (bit_mask & 0x40000000)
	return &presentation_context_deletion_list_field;
    else
	return 0;
}

void AC_PPDU::set_presentation_context_deletion_list(const presentation_context_deletion_list & presentation_context_deletion_list_val) {
    bit_mask |= 0x40000000;
    presentation_context_deletion_list_field = presentation_context_deletion_list_val;
}

int AC_PPDU::presentation_context_deletion_list_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void AC_PPDU::omit_presentation_context_deletion_list() {
    presentation_context_deletion_list_field.~__shared22();
    bit_mask &= ~0x40000000;
}

AC_PPDU::user_data *AC_PPDU::get_user_data() {
    if (bit_mask & 0x20000000)
	return &user_data_field;
    else
	return 0;
}

const AC_PPDU::user_data *AC_PPDU::get_user_data() const {
    if (bit_mask & 0x20000000)
	return &user_data_field;
    else
	return 0;
}

void AC_PPDU::set_user_data(const user_data & user_data_val) {
    bit_mask |= 0x20000000;
    user_data_field = user_data_val;
}

int AC_PPDU::user_data_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void AC_PPDU::omit_user_data() {
    user_data_field.~__shared14();
    bit_mask &= ~0x20000000;
}

void *ACA_PPDU::operator new(size_t size) {
    return ossNewFunc(size);
}

void ACA_PPDU::operator delete(void *ptr) {
    asn1Free(ptr);
}

ACA_PPDU::ACA_PPDU() {
    memset(this, 0, sizeof(ACA_PPDU));
}

ACA_PPDU::ACA_PPDU(const ACA_PPDU & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	presentation_context_addition_result_list_field = that.presentation_context_addition_result_list_field;
	presentation_context_deletion_result_list_field = that.presentation_context_deletion_result_list_field;
	user_data_field = that.user_data_field;
    } OSSCLEAN(ACA_PPDU)
}

ACA_PPDU::ACA_PPDU(const presentation_context_addition_result_list & presentation_context_addition_result_list_val, 
    const presentation_context_deletion_result_list & presentation_context_deletion_result_list_val, 
    const user_data & user_data_val) {
    OSSTRY {
	bit_mask = 0xe0000000;
	presentation_context_addition_result_list_field = presentation_context_addition_result_list_val;
	presentation_context_deletion_result_list_field = presentation_context_deletion_result_list_val;
	user_data_field = user_data_val;
    } OSSCLEAN(ACA_PPDU)
}

ACA_PPDU & ACA_PPDU::operator = (const ACA_PPDU & that) {
    if (this == &that)
	return *this;
    this->~ACA_PPDU();
    bit_mask = that.bit_mask;
    presentation_context_addition_result_list_field = that.presentation_context_addition_result_list_field;
    presentation_context_deletion_result_list_field = that.presentation_context_deletion_result_list_field;
    user_data_field = that.user_data_field;
    return *this;
}

int ACA_PPDU::operator == (const ACA_PPDU & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (presentation_context_addition_result_list_field != that.presentation_context_addition_result_list_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (presentation_context_deletion_result_list_field != that.presentation_context_deletion_result_list_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (user_data_field != that.user_data_field)
	    return 0;
    }
    return 1;
}

int ACA_PPDU::operator != (const ACA_PPDU & that) const {
    return !(operator ==(that));
}

ACA_PPDU::presentation_context_addition_result_list *ACA_PPDU::get_presentation_context_addition_result_list() {
    if (bit_mask & 0x80000000)
	return &presentation_context_addition_result_list_field;
    else
	return 0;
}

const ACA_PPDU::presentation_context_addition_result_list *ACA_PPDU::get_presentation_context_addition_result_list() const {
    if (bit_mask & 0x80000000)
	return &presentation_context_addition_result_list_field;
    else
	return 0;
}

void ACA_PPDU::set_presentation_context_addition_result_list(const presentation_context_addition_result_list & presentation_context_addition_result_list_val) {
    bit_mask |= 0x80000000;
    presentation_context_addition_result_list_field = presentation_context_addition_result_list_val;
}

int ACA_PPDU::presentation_context_addition_result_list_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void ACA_PPDU::omit_presentation_context_addition_result_list() {
    presentation_context_addition_result_list_field.~__shared16();
    bit_mask &= ~0x80000000;
}

ACA_PPDU::presentation_context_deletion_result_list *ACA_PPDU::get_presentation_context_deletion_result_list() {
    if (bit_mask & 0x40000000)
	return &presentation_context_deletion_result_list_field;
    else
	return 0;
}

const ACA_PPDU::presentation_context_deletion_result_list *ACA_PPDU::get_presentation_context_deletion_result_list() const {
    if (bit_mask & 0x40000000)
	return &presentation_context_deletion_result_list_field;
    else
	return 0;
}

void ACA_PPDU::set_presentation_context_deletion_result_list(const presentation_context_deletion_result_list & presentation_context_deletion_result_list_val) {
    bit_mask |= 0x40000000;
    presentation_context_deletion_result_list_field = presentation_context_deletion_result_list_val;
}

int ACA_PPDU::presentation_context_deletion_result_list_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void ACA_PPDU::omit_presentation_context_deletion_result_list() {
    presentation_context_deletion_result_list_field.~__shared22();
    bit_mask &= ~0x40000000;
}

ACA_PPDU::user_data *ACA_PPDU::get_user_data() {
    if (bit_mask & 0x20000000)
	return &user_data_field;
    else
	return 0;
}

const ACA_PPDU::user_data *ACA_PPDU::get_user_data() const {
    if (bit_mask & 0x20000000)
	return &user_data_field;
    else
	return 0;
}

void ACA_PPDU::set_user_data(const user_data & user_data_val) {
    bit_mask |= 0x20000000;
    user_data_field = user_data_val;
}

int ACA_PPDU::user_data_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void ACA_PPDU::omit_user_data() {
    user_data_field.~__shared14();
    bit_mask &= ~0x20000000;
}

Typed_data_type::Typed_data_type() {
    memset(this, 0, sizeof(Typed_data_type));
}

Typed_data_type::Typed_data_type(const Typed_data_type & that) {
    memset(this, 0, sizeof(Typed_data_type));
    operator =(that);
}

Typed_data_type::~Typed_data_type() {
    cleanup();
}

Typed_data_type & Typed_data_type::operator = (const Typed_data_type & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case acPPDU_chosen:
	    if (that.acPPDU_field)
		acPPDU_field = new acPPDU(*that.acPPDU_field);
	    break;
	case acaPPDU_chosen:
	    if (that.acaPPDU_field)
		acaPPDU_field = new acaPPDU(*that.acaPPDU_field);
	    break;
	case ttdPPDU_chosen:
	    if (that.ttdPPDU_field)
		ttdPPDU_field = new ttdPPDU(*that.ttdPPDU_field);
	    break;
    }
    return *this;
}

int Typed_data_type::operator == (const Typed_data_type & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case acPPDU_chosen:
	    if ((acPPDU_field) && (that.acPPDU_field))
		return (*acPPDU_field == *(that.acPPDU_field));
	    else if (!((!acPPDU_field) && (!that.acPPDU_field)))
		return 0;
	    break;
	case acaPPDU_chosen:
	    if ((acaPPDU_field) && (that.acaPPDU_field))
		return (*acaPPDU_field == *(that.acaPPDU_field));
	    else if (!((!acaPPDU_field) && (!that.acaPPDU_field)))
		return 0;
	    break;
	case ttdPPDU_chosen:
	    if ((ttdPPDU_field) && (that.ttdPPDU_field))
		return (*ttdPPDU_field == *(that.ttdPPDU_field));
	    else if (!((!ttdPPDU_field) && (!that.ttdPPDU_field)))
		return 0;
	    break;
    }

    return 1;
}

int Typed_data_type::operator != (const Typed_data_type & that) const {
    return !(operator ==(that));
}

Typed_data_type::acPPDU *Typed_data_type::get_acPPDU() {
    if (_choice == acPPDU_chosen)
	return (acPPDU *)acPPDU_field;
    else
	return 0;
}

const Typed_data_type::acPPDU *Typed_data_type::get_acPPDU() const {
    if (_choice == acPPDU_chosen)
	return (const acPPDU *)acPPDU_field;
    else
	return 0;
}

void Typed_data_type::set_acPPDU(const acPPDU & acPPDU_val) {
    cleanup();
    acPPDU_field = new acPPDU(acPPDU_val);
    _choice = acPPDU_chosen;
}

Typed_data_type::acaPPDU *Typed_data_type::get_acaPPDU() {
    if (_choice == acaPPDU_chosen)
	return (acaPPDU *)acaPPDU_field;
    else
	return 0;
}

const Typed_data_type::acaPPDU *Typed_data_type::get_acaPPDU() const {
    if (_choice == acaPPDU_chosen)
	return (const acaPPDU *)acaPPDU_field;
    else
	return 0;
}

void Typed_data_type::set_acaPPDU(const acaPPDU & acaPPDU_val) {
    cleanup();
    acaPPDU_field = new acaPPDU(acaPPDU_val);
    _choice = acaPPDU_chosen;
}

Typed_data_type::ttdPPDU *Typed_data_type::get_ttdPPDU() {
    if (_choice == ttdPPDU_chosen)
	return (ttdPPDU *)ttdPPDU_field;
    else
	return 0;
}

const Typed_data_type::ttdPPDU *Typed_data_type::get_ttdPPDU() const {
    if (_choice == ttdPPDU_chosen)
	return (const ttdPPDU *)ttdPPDU_field;
    else
	return 0;
}

void Typed_data_type::set_ttdPPDU(const ttdPPDU & ttdPPDU_val) {
    cleanup();
    ttdPPDU_field = new ttdPPDU(ttdPPDU_val);
    _choice = ttdPPDU_chosen;
}

void Typed_data_type::cleanup() {
    switch (_choice) {
	case acPPDU_chosen:
	    if (acPPDU_field)
		delete acPPDU_field;
	    break;
	case acaPPDU_chosen:
	    if (acaPPDU_field)
		delete acaPPDU_field;
	    break;
	case ttdPPDU_chosen:
	    if (ttdPPDU_field)
		delete ttdPPDU_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

void *__seq7::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq7::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq7::__seq7() {
    memset(this, 0, sizeof(__seq7));
}

__seq7::__seq7(const __seq7 & that) {
    OSSTRY {
	presentation_context_identifier_field = that.presentation_context_identifier_field;
	abstract_syntax_name_field = that.abstract_syntax_name_field;
	transfer_syntax_name_list_field = that.transfer_syntax_name_list_field;
    } OSSCLEAN(__seq7)
}

__seq7::__seq7(presentation_context_identifier presentation_context_identifier_val, 
    const abstract_syntax_name & abstract_syntax_name_val, const transfer_syntax_name_list & transfer_syntax_name_list_val) {
    OSSTRY {
	presentation_context_identifier_field = presentation_context_identifier_val;
	abstract_syntax_name_field = abstract_syntax_name_val;
	transfer_syntax_name_list_field = transfer_syntax_name_list_val;
    } OSSCLEAN(__seq7)
}

__seq7 & __seq7::operator = (const __seq7 & that) {
    if (this == &that)
	return *this;
    presentation_context_identifier_field = that.presentation_context_identifier_field;
    abstract_syntax_name_field = that.abstract_syntax_name_field;
    transfer_syntax_name_list_field = that.transfer_syntax_name_list_field;
    return *this;
}

int __seq7::operator == (const __seq7 & that) const {
    if (presentation_context_identifier_field != that.presentation_context_identifier_field)
	return 0;
    if (abstract_syntax_name_field != that.abstract_syntax_name_field)
	return 0;
    if (transfer_syntax_name_list_field != that.transfer_syntax_name_list_field)
	return 0;
    return 1;
}

int __seq7::operator != (const __seq7 & that) const {
    return !(operator ==(that));
}

__seq7::presentation_context_identifier & __seq7::get_presentation_context_identifier() {
    return presentation_context_identifier_field;
}

__seq7::presentation_context_identifier __seq7::get_presentation_context_identifier() const {
    return presentation_context_identifier_field;
}

void __seq7::set_presentation_context_identifier(presentation_context_identifier presentation_context_identifier_val) {
    presentation_context_identifier_field = presentation_context_identifier_val;
}

__seq7::abstract_syntax_name & __seq7::get_abstract_syntax_name() {
    return abstract_syntax_name_field;
}

const __seq7::abstract_syntax_name & __seq7::get_abstract_syntax_name() const {
    return abstract_syntax_name_field;
}

void __seq7::set_abstract_syntax_name(const abstract_syntax_name & abstract_syntax_name_val) {
    abstract_syntax_name_field = abstract_syntax_name_val;
}

__seq7::transfer_syntax_name_list & __seq7::get_transfer_syntax_name_list() {
    return transfer_syntax_name_list_field;
}

const __seq7::transfer_syntax_name_list & __seq7::get_transfer_syntax_name_list() const {
    return transfer_syntax_name_list_field;
}

void __seq7::set_transfer_syntax_name_list(const transfer_syntax_name_list & transfer_syntax_name_list_val) {
    transfer_syntax_name_list_field = transfer_syntax_name_list_val;
}

void *__seq8::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq8::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq8::__seq8() {
    memset(this, 0, sizeof(__seq8));
}

__seq8::__seq8(const __seq8 & that) {
    OSSTRY {
	presentation_context_identifier_field = that.presentation_context_identifier_field;
	transfer_syntax_name_field = that.transfer_syntax_name_field;
    } OSSCLEAN(__seq8)
}

__seq8::__seq8(presentation_context_identifier presentation_context_identifier_val, 
    const transfer_syntax_name & transfer_syntax_name_val) {
    OSSTRY {
	presentation_context_identifier_field = presentation_context_identifier_val;
	transfer_syntax_name_field = transfer_syntax_name_val;
    } OSSCLEAN(__seq8)
}

__seq8 & __seq8::operator = (const __seq8 & that) {
    if (this == &that)
	return *this;
    presentation_context_identifier_field = that.presentation_context_identifier_field;
    transfer_syntax_name_field = that.transfer_syntax_name_field;
    return *this;
}

int __seq8::operator == (const __seq8 & that) const {
    if (presentation_context_identifier_field != that.presentation_context_identifier_field)
	return 0;
    if (transfer_syntax_name_field != that.transfer_syntax_name_field)
	return 0;
    return 1;
}

int __seq8::operator != (const __seq8 & that) const {
    return !(operator ==(that));
}

__seq8::presentation_context_identifier & __seq8::get_presentation_context_identifier() {
    return presentation_context_identifier_field;
}

__seq8::presentation_context_identifier __seq8::get_presentation_context_identifier() const {
    return presentation_context_identifier_field;
}

void __seq8::set_presentation_context_identifier(presentation_context_identifier presentation_context_identifier_val) {
    presentation_context_identifier_field = presentation_context_identifier_val;
}

__seq8::transfer_syntax_name & __seq8::get_transfer_syntax_name() {
    return transfer_syntax_name_field;
}

const __seq8::transfer_syntax_name & __seq8::get_transfer_syntax_name() const {
    return transfer_syntax_name_field;
}

void __seq8::set_transfer_syntax_name(const transfer_syntax_name & transfer_syntax_name_val) {
    transfer_syntax_name_field = transfer_syntax_name_val;
}

void *__seq9::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq9::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq9::__seq9() {
    memset(this, 0, sizeof(__seq9));
}

__seq9::__seq9(const __seq9 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	result_field = that.result_field;
	transfer_syntax_name_field = that.transfer_syntax_name_field;
	provider_reason_field = that.provider_reason_field;
    } OSSCLEAN(__seq9)
}

__seq9::__seq9(result result_val, const transfer_syntax_name & transfer_syntax_name_val, 
    provider_reason provider_reason_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	result_field = result_val;
	transfer_syntax_name_field = transfer_syntax_name_val;
	provider_reason_field = provider_reason_val;
    } OSSCLEAN(__seq9)
}

__seq9::__seq9(result result_val) {
    OSSTRY {
	bit_mask = 0;
	result_field = result_val;
    } OSSCLEAN(__seq9)
}

__seq9 & __seq9::operator = (const __seq9 & that) {
    if (this == &that)
	return *this;
    this->~__seq9();
    bit_mask = that.bit_mask;
    result_field = that.result_field;
    transfer_syntax_name_field = that.transfer_syntax_name_field;
    provider_reason_field = that.provider_reason_field;
    return *this;
}

int __seq9::operator == (const __seq9 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (result_field != that.result_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (transfer_syntax_name_field != that.transfer_syntax_name_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (provider_reason_field != that.provider_reason_field)
	    return 0;
    }
    return 1;
}

int __seq9::operator != (const __seq9 & that) const {
    return !(operator ==(that));
}

__seq9::result & __seq9::get_result() {
    return result_field;
}

__seq9::result __seq9::get_result() const {
    return result_field;
}

void __seq9::set_result(result result_val) {
    result_field = result_val;
}

__seq9::transfer_syntax_name *__seq9::get_transfer_syntax_name() {
    if (bit_mask & 0x80000000)
	return &transfer_syntax_name_field;
    else
	return 0;
}

const __seq9::transfer_syntax_name *__seq9::get_transfer_syntax_name() const {
    if (bit_mask & 0x80000000)
	return &transfer_syntax_name_field;
    else
	return 0;
}

void __seq9::set_transfer_syntax_name(const transfer_syntax_name & transfer_syntax_name_val) {
    bit_mask |= 0x80000000;
    transfer_syntax_name_field = transfer_syntax_name_val;
}

int __seq9::transfer_syntax_name_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void __seq9::omit_transfer_syntax_name() {
    transfer_syntax_name_field.~OssEncOID();
    bit_mask &= ~0x80000000;
}

__seq9::provider_reason *__seq9::get_provider_reason() {
    if (bit_mask & 0x40000000)
	return &provider_reason_field;
    else
	return 0;
}

const __seq9::provider_reason *__seq9::get_provider_reason() const {
    if (bit_mask & 0x40000000)
	return &provider_reason_field;
    else
	return 0;
}

void __seq9::set_provider_reason(provider_reason provider_reason_val) {
    bit_mask |= 0x40000000;
    provider_reason_field = provider_reason_val;
}

int __seq9::provider_reason_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void __seq9::omit_provider_reason() {
    bit_mask &= ~0x40000000;
}

void *PDV_list::operator new(size_t size) {
    return ossNewFunc(size);
}

void PDV_list::operator delete(void *ptr) {
    asn1Free(ptr);
}

PDV_list::PDV_list() {
    memset(this, 0, sizeof(PDV_list));
}

PDV_list::PDV_list(const PDV_list & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	transfer_syntax_name_field = that.transfer_syntax_name_field;
	presentation_context_identifier_field = that.presentation_context_identifier_field;
	presentation_data_values_field = that.presentation_data_values_field;
    } OSSCLEAN(PDV_list)
}

PDV_list::PDV_list(const transfer_syntax_name & transfer_syntax_name_val, presentation_context_identifier presentation_context_identifier_val, 
    const presentation_data_values & presentation_data_values_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	transfer_syntax_name_field = transfer_syntax_name_val;
	presentation_context_identifier_field = presentation_context_identifier_val;
	presentation_data_values_field = presentation_data_values_val;
    } OSSCLEAN(PDV_list)
}

PDV_list::PDV_list(presentation_context_identifier presentation_context_identifier_val, 
    const presentation_data_values & presentation_data_values_val) {
    OSSTRY {
	bit_mask = 0;
	presentation_context_identifier_field = presentation_context_identifier_val;
	presentation_data_values_field = presentation_data_values_val;
    } OSSCLEAN(PDV_list)
}

PDV_list & PDV_list::operator = (const PDV_list & that) {
    if (this == &that)
	return *this;
    this->~PDV_list();
    bit_mask = that.bit_mask;
    transfer_syntax_name_field = that.transfer_syntax_name_field;
    presentation_context_identifier_field = that.presentation_context_identifier_field;
    presentation_data_values_field = that.presentation_data_values_field;
    return *this;
}

int PDV_list::operator == (const PDV_list & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (transfer_syntax_name_field != that.transfer_syntax_name_field)
	    return 0;
    }
    if (presentation_context_identifier_field != that.presentation_context_identifier_field)
	return 0;
    if (presentation_data_values_field != that.presentation_data_values_field)
	return 0;
    return 1;
}

int PDV_list::operator != (const PDV_list & that) const {
    return !(operator ==(that));
}

PDV_list::transfer_syntax_name *PDV_list::get_transfer_syntax_name() {
    if (bit_mask & 0x80000000)
	return &transfer_syntax_name_field;
    else
	return 0;
}

const PDV_list::transfer_syntax_name *PDV_list::get_transfer_syntax_name() const {
    if (bit_mask & 0x80000000)
	return &transfer_syntax_name_field;
    else
	return 0;
}

void PDV_list::set_transfer_syntax_name(const transfer_syntax_name & transfer_syntax_name_val) {
    bit_mask |= 0x80000000;
    transfer_syntax_name_field = transfer_syntax_name_val;
}

int PDV_list::transfer_syntax_name_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void PDV_list::omit_transfer_syntax_name() {
    transfer_syntax_name_field.~OssEncOID();
    bit_mask &= ~0x80000000;
}

PDV_list::presentation_context_identifier & PDV_list::get_presentation_context_identifier() {
    return presentation_context_identifier_field;
}

PDV_list::presentation_context_identifier PDV_list::get_presentation_context_identifier() const {
    return presentation_context_identifier_field;
}

void PDV_list::set_presentation_context_identifier(presentation_context_identifier presentation_context_identifier_val) {
    presentation_context_identifier_field = presentation_context_identifier_val;
}

PDV_list::presentation_data_values & PDV_list::get_presentation_data_values() {
    return presentation_data_values_field;
}

const PDV_list::presentation_data_values & PDV_list::get_presentation_data_values() const {
    return presentation_data_values_field;
}

void PDV_list::set_presentation_data_values(const presentation_data_values & presentation_data_values_val) {
    presentation_data_values_field = presentation_data_values_val;
}

__shared23::__shared23() {
    memset(this, 0, sizeof(__shared23));
}

__shared23::__shared23(const __shared23 & that) {
    memset(this, 0, sizeof(__shared23));
    operator =(that);
}

__shared23::~__shared23() {
    cleanup();
}

__shared23 & __shared23::operator = (const __shared23 & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case rtorq_apdu_chosen:
	    if (that.rtorq_apdu_field)
		rtorq_apdu_field = new rtorq_apdu(*that.rtorq_apdu_field);
	    break;
	case rtoac_apdu_chosen:
	    if (that.rtoac_apdu_field)
		rtoac_apdu_field = new rtoac_apdu(*that.rtoac_apdu_field);
	    break;
	case rtorj_apdu_chosen:
	    if (that.rtorj_apdu_field)
		rtorj_apdu_field = new rtorj_apdu(*that.rtorj_apdu_field);
	    break;
	case rttp_apdu_chosen:
	    *(rttp_apdu *)&rttp_apdu_field = *(rttp_apdu *)&that.rttp_apdu_field;
	    break;
	case rttr_apdu_chosen:
	    *(rttr_apdu *)&rttr_apdu_field = *(rttr_apdu *)&that.rttr_apdu_field;
	    break;
	case rtab_apdu_chosen:
	    if (that.rtab_apdu_field)
		rtab_apdu_field = new rtab_apdu(*that.rtab_apdu_field);
	    break;
    }
    return *this;
}

int __shared23::operator == (const __shared23 & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case rtorq_apdu_chosen:
	    if ((rtorq_apdu_field) && (that.rtorq_apdu_field))
		return (*rtorq_apdu_field == *(that.rtorq_apdu_field));
	    else if (!((!rtorq_apdu_field) && (!that.rtorq_apdu_field)))
		return 0;
	    break;
	case rtoac_apdu_chosen:
	    if ((rtoac_apdu_field) && (that.rtoac_apdu_field))
		return (*rtoac_apdu_field == *(that.rtoac_apdu_field));
	    else if (!((!rtoac_apdu_field) && (!that.rtoac_apdu_field)))
		return 0;
	    break;
	case rtorj_apdu_chosen:
	    if ((rtorj_apdu_field) && (that.rtorj_apdu_field))
		return (*rtorj_apdu_field == *(that.rtorj_apdu_field));
	    else if (!((!rtorj_apdu_field) && (!that.rtorj_apdu_field)))
		return 0;
	    break;
	case rttp_apdu_chosen:
	    return *(rttp_apdu *)&rttp_apdu_field == *(rttp_apdu *)&that.rttp_apdu_field;
	case rttr_apdu_chosen:
	    return *(rttr_apdu *)&rttr_apdu_field == *(rttr_apdu *)&that.rttr_apdu_field;
	case rtab_apdu_chosen:
	    if ((rtab_apdu_field) && (that.rtab_apdu_field))
		return (*rtab_apdu_field == *(that.rtab_apdu_field));
	    else if (!((!rtab_apdu_field) && (!that.rtab_apdu_field)))
		return 0;
	    break;
    }

    return 1;
}

int __shared23::operator != (const __shared23 & that) const {
    return !(operator ==(that));
}

__shared23::rtorq_apdu *__shared23::get_rtorq_apdu() {
    if (_choice == rtorq_apdu_chosen)
	return (rtorq_apdu *)rtorq_apdu_field;
    else
	return 0;
}

const __shared23::rtorq_apdu *__shared23::get_rtorq_apdu() const {
    if (_choice == rtorq_apdu_chosen)
	return (const rtorq_apdu *)rtorq_apdu_field;
    else
	return 0;
}

void __shared23::set_rtorq_apdu(const rtorq_apdu & rtorq_apdu_val) {
    cleanup();
    rtorq_apdu_field = new rtorq_apdu(rtorq_apdu_val);
    _choice = rtorq_apdu_chosen;
}

__shared23::rtoac_apdu *__shared23::get_rtoac_apdu() {
    if (_choice == rtoac_apdu_chosen)
	return (rtoac_apdu *)rtoac_apdu_field;
    else
	return 0;
}

const __shared23::rtoac_apdu *__shared23::get_rtoac_apdu() const {
    if (_choice == rtoac_apdu_chosen)
	return (const rtoac_apdu *)rtoac_apdu_field;
    else
	return 0;
}

void __shared23::set_rtoac_apdu(const rtoac_apdu & rtoac_apdu_val) {
    cleanup();
    rtoac_apdu_field = new rtoac_apdu(rtoac_apdu_val);
    _choice = rtoac_apdu_chosen;
}

__shared23::rtorj_apdu *__shared23::get_rtorj_apdu() {
    if (_choice == rtorj_apdu_chosen)
	return (rtorj_apdu *)rtorj_apdu_field;
    else
	return 0;
}

const __shared23::rtorj_apdu *__shared23::get_rtorj_apdu() const {
    if (_choice == rtorj_apdu_chosen)
	return (const rtorj_apdu *)rtorj_apdu_field;
    else
	return 0;
}

void __shared23::set_rtorj_apdu(const rtorj_apdu & rtorj_apdu_val) {
    cleanup();
    rtorj_apdu_field = new rtorj_apdu(rtorj_apdu_val);
    _choice = rtorj_apdu_chosen;
}

__shared23::rttp_apdu *__shared23::get_rttp_apdu() {
    if (_choice == rttp_apdu_chosen)
	return (rttp_apdu *)&rttp_apdu_field;
    else
	return 0;
}

const __shared23::rttp_apdu *__shared23::get_rttp_apdu() const {
    if (_choice == rttp_apdu_chosen)
	return (const rttp_apdu *)&rttp_apdu_field;
    else
	return 0;
}

void __shared23::set_rttp_apdu(rttp_apdu rttp_apdu_val) {
    cleanup();
    *(rttp_apdu *)&rttp_apdu_field = rttp_apdu_val;
    _choice = rttp_apdu_chosen;
}

__shared23::rttr_apdu *__shared23::get_rttr_apdu() {
    if (_choice == rttr_apdu_chosen)
	return (rttr_apdu *)&rttr_apdu_field;
    else
	return 0;
}

const __shared23::rttr_apdu *__shared23::get_rttr_apdu() const {
    if (_choice == rttr_apdu_chosen)
	return (const rttr_apdu *)&rttr_apdu_field;
    else
	return 0;
}

void __shared23::set_rttr_apdu(const rttr_apdu & rttr_apdu_val) {
    cleanup();
    *(rttr_apdu *)&rttr_apdu_field = rttr_apdu_val;
    _choice = rttr_apdu_chosen;
}

__shared23::rtab_apdu *__shared23::get_rtab_apdu() {
    if (_choice == rtab_apdu_chosen)
	return (rtab_apdu *)rtab_apdu_field;
    else
	return 0;
}

const __shared23::rtab_apdu *__shared23::get_rtab_apdu() const {
    if (_choice == rtab_apdu_chosen)
	return (const rtab_apdu *)rtab_apdu_field;
    else
	return 0;
}

void __shared23::set_rtab_apdu(const rtab_apdu & rtab_apdu_val) {
    cleanup();
    rtab_apdu_field = new rtab_apdu(rtab_apdu_val);
    _choice = rtab_apdu_chosen;
}

void __shared23::cleanup() {
    switch (_choice) {
	case rtorq_apdu_chosen:
	    if (rtorq_apdu_field)
		delete rtorq_apdu_field;
	    break;
	case rtoac_apdu_chosen:
	    if (rtoac_apdu_field)
		delete rtoac_apdu_field;
	    break;
	case rtorj_apdu_chosen:
	    if (rtorj_apdu_field)
		delete rtorj_apdu_field;
	    break;
	case rttp_apdu_chosen:
	    break;
	case rttr_apdu_chosen:
	    ((rttr_apdu *)&rttr_apdu_field)->~OssString();
	    break;
	case rtab_apdu_chosen:
	    if (rtab_apdu_field)
		delete rtab_apdu_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

__shared24::__shared24() {
    memset(this, 0, sizeof(__shared24));
}

__shared24::__shared24(const __shared24 & that) {
    memset(this, 0, sizeof(__shared24));
    operator =(that);
}

__shared24 & __shared24::operator = (const __shared24 & that) {
    if (this == &that)
	return *this;
    _choice = that._choice;
    switch (_choice) {
	case present_chosen:
	    *(present *)&present_field = *(present *)&that.present_field;
	    break;
	case absent_chosen:
	    *(absent *)&absent_field = *(absent *)&that.absent_field;
	    break;
    }
    return *this;
}

int __shared24::operator == (const __shared24 & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case present_chosen:
	    return *(present *)&present_field == *(present *)&that.present_field;
	case absent_chosen:
	    return *(absent *)&absent_field == *(absent *)&that.absent_field;
    }

    return 1;
}

int __shared24::operator != (const __shared24 & that) const {
    return !(operator ==(that));
}

__shared24::present *__shared24::get_present() {
    if (_choice == present_chosen)
	return (present *)&present_field;
    else
	return 0;
}

const __shared24::present *__shared24::get_present() const {
    if (_choice == present_chosen)
	return (const present *)&present_field;
    else
	return 0;
}

void __shared24::set_present(present present_val) {
    *(present *)&present_field = present_val;
    _choice = present_chosen;
}

__shared24::absent *__shared24::get_absent() {
    if (_choice == absent_chosen)
	return (absent *)&absent_field;
    else
	return 0;
}

const __shared24::absent *__shared24::get_absent() const {
    if (_choice == absent_chosen)
	return (const absent *)&absent_field;
    else
	return 0;
}

void __shared24::set_absent(absent absent_val) {
    *(absent *)&absent_field = absent_val;
    _choice = absent_chosen;
}

__choice3::__choice3() {
    memset(this, 0, sizeof(__choice3));
}

__choice3::__choice3(const __choice3 & that) {
    memset(this, 0, sizeof(__choice3));
    operator =(that);
}

__choice3 & __choice3::operator = (const __choice3 & that) {
    if (this == &that)
	return *this;
    _choice = that._choice;
    switch (_choice) {
	case general_chosen:
	    *(general *)&general_field = *(general *)&that.general_field;
	    break;
	case invoke_chosen:
	    *(invoke *)&invoke_field = *(invoke *)&that.invoke_field;
	    break;
	case returnResult_chosen:
	    *(returnResult *)&returnResult_field = *(returnResult *)&that.returnResult_field;
	    break;
	case returnError_chosen:
	    *(returnError *)&returnError_field = *(returnError *)&that.returnError_field;
	    break;
    }
    return *this;
}

int __choice3::operator == (const __choice3 & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case general_chosen:
	    return *(general *)&general_field == *(general *)&that.general_field;
	case invoke_chosen:
	    return *(invoke *)&invoke_field == *(invoke *)&that.invoke_field;
	case returnResult_chosen:
	    return *(returnResult *)&returnResult_field == *(returnResult *)&that.returnResult_field;
	case returnError_chosen:
	    return *(returnError *)&returnError_field == *(returnError *)&that.returnError_field;
    }

    return 1;
}

int __choice3::operator != (const __choice3 & that) const {
    return !(operator ==(that));
}

__choice3::general *__choice3::get_general() {
    if (_choice == general_chosen)
	return (general *)&general_field;
    else
	return 0;
}

const __choice3::general *__choice3::get_general() const {
    if (_choice == general_chosen)
	return (const general *)&general_field;
    else
	return 0;
}

void __choice3::set_general(general general_val) {
    *(general *)&general_field = general_val;
    _choice = general_chosen;
}

__choice3::invoke *__choice3::get_invoke() {
    if (_choice == invoke_chosen)
	return (invoke *)&invoke_field;
    else
	return 0;
}

const __choice3::invoke *__choice3::get_invoke() const {
    if (_choice == invoke_chosen)
	return (const invoke *)&invoke_field;
    else
	return 0;
}

void __choice3::set_invoke(invoke invoke_val) {
    *(invoke *)&invoke_field = invoke_val;
    _choice = invoke_chosen;
}

__choice3::returnResult *__choice3::get_returnResult() {
    if (_choice == returnResult_chosen)
	return (returnResult *)&returnResult_field;
    else
	return 0;
}

const __choice3::returnResult *__choice3::get_returnResult() const {
    if (_choice == returnResult_chosen)
	return (const returnResult *)&returnResult_field;
    else
	return 0;
}

void __choice3::set_returnResult(returnResult returnResult_val) {
    *(returnResult *)&returnResult_field = returnResult_val;
    _choice = returnResult_chosen;
}

__choice3::returnError *__choice3::get_returnError() {
    if (_choice == returnError_chosen)
	return (returnError *)&returnError_field;
    else
	return 0;
}

const __choice3::returnError *__choice3::get_returnError() const {
    if (_choice == returnError_chosen)
	return (const returnError *)&returnError_field;
    else
	return 0;
}

void __choice3::set_returnError(returnError returnError_val) {
    *(returnError *)&returnError_field = returnError_val;
    _choice = returnError_chosen;
}

void *Reject::operator new(size_t size) {
    return ossNewFunc(size);
}

void Reject::operator delete(void *ptr) {
    asn1Free(ptr);
}

Reject::Reject() {
    memset(this, 0, sizeof(Reject));
}

Reject::Reject(const Reject & that) {
    OSSTRY {
	invokeId_field = that.invokeId_field;
	problem_field = that.problem_field;
    } OSSCLEAN(Reject)
}

Reject::Reject(const invokeId & invokeId_val, const problem & problem_val) {
    OSSTRY {
	invokeId_field = invokeId_val;
	problem_field = problem_val;
    } OSSCLEAN(Reject)
}

Reject & Reject::operator = (const Reject & that) {
    if (this == &that)
	return *this;
    invokeId_field = that.invokeId_field;
    problem_field = that.problem_field;
    return *this;
}

int Reject::operator == (const Reject & that) const {
    if (invokeId_field != that.invokeId_field)
	return 0;
    if (problem_field != that.problem_field)
	return 0;
    return 1;
}

int Reject::operator != (const Reject & that) const {
    return !(operator ==(that));
}

Reject::invokeId & Reject::get_invokeId() {
    return invokeId_field;
}

const Reject::invokeId & Reject::get_invokeId() const {
    return invokeId_field;
}

void Reject::set_invokeId(const invokeId & invokeId_val) {
    invokeId_field = invokeId_val;
}

Reject::problem & Reject::get_problem() {
    return problem_field;
}

const Reject::problem & Reject::get_problem() const {
    return problem_field;
}

void Reject::set_problem(const problem & problem_val) {
    problem_field = problem_val;
}

Code::Code() {
    memset(this, 0, sizeof(Code));
}

Code::Code(const Code & that) {
    memset(this, 0, sizeof(Code));
    operator =(that);
}

Code::~Code() {
    cleanup();
}

Code & Code::operator = (const Code & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case local_chosen:
	    *(local *)&local_field = *(local *)&that.local_field;
	    break;
	case global_chosen:
	    *(global *)&global_field = *(global *)&that.global_field;
	    break;
    }
    return *this;
}

int Code::operator == (const Code & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case local_chosen:
	    return *(local *)&local_field == *(local *)&that.local_field;
	case global_chosen:
	    return *(global *)&global_field == *(global *)&that.global_field;
    }

    return 1;
}

int Code::operator != (const Code & that) const {
    return !(operator ==(that));
}

Code::local *Code::get_local() {
    if (_choice == local_chosen)
	return (local *)&local_field;
    else
	return 0;
}

const Code::local *Code::get_local() const {
    if (_choice == local_chosen)
	return (const local *)&local_field;
    else
	return 0;
}

void Code::set_local(local local_val) {
    cleanup();
    *(local *)&local_field = local_val;
    _choice = local_chosen;
}

Code::global *Code::get_global() {
    if (_choice == global_chosen)
	return (global *)&global_field;
    else
	return 0;
}

const Code::global *Code::get_global() const {
    if (_choice == global_chosen)
	return (const global *)&global_field;
    else
	return 0;
}

void Code::set_global(const global & global_val) {
    cleanup();
    *(global *)&global_field = global_val;
    _choice = global_chosen;
}

void Code::cleanup() {
    switch (_choice) {
	case local_chosen:
	    break;
	case global_chosen:
	    ((global *)&global_field)->~OssEncOID();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

UnboundedDirectoryString::UnboundedDirectoryString() {
    memset(this, 0, sizeof(UnboundedDirectoryString));
}

UnboundedDirectoryString::UnboundedDirectoryString(const UnboundedDirectoryString & that) {
    memset(this, 0, sizeof(UnboundedDirectoryString));
    operator =(that);
}

UnboundedDirectoryString::~UnboundedDirectoryString() {
    cleanup();
}

UnboundedDirectoryString & UnboundedDirectoryString::operator = (const UnboundedDirectoryString & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case teletexString_chosen:
	    *(teletexString *)&teletexString_field = *(teletexString *)&that.teletexString_field;
	    break;
	case printableString_chosen:
	    *(printableString *)&printableString_field = *(printableString *)&that.printableString_field;
	    break;
	case bmpString_chosen:
	    *(bmpString *)&bmpString_field = *(bmpString *)&that.bmpString_field;
	    break;
	case universalString_chosen:
	    *(universalString *)&universalString_field = *(universalString *)&that.universalString_field;
	    break;
	case uTF8String_chosen:
	    *(uTF8String *)&uTF8String_field = *(uTF8String *)&that.uTF8String_field;
	    break;
    }
    return *this;
}

int UnboundedDirectoryString::operator == (const UnboundedDirectoryString & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case teletexString_chosen:
	    return *(teletexString *)&teletexString_field == *(teletexString *)&that.teletexString_field;
	case printableString_chosen:
	    return *(printableString *)&printableString_field == *(printableString *)&that.printableString_field;
	case bmpString_chosen:
	    return *(bmpString *)&bmpString_field == *(bmpString *)&that.bmpString_field;
	case universalString_chosen:
	    return *(universalString *)&universalString_field == *(universalString *)&that.universalString_field;
	case uTF8String_chosen:
	    return *(uTF8String *)&uTF8String_field == *(uTF8String *)&that.uTF8String_field;
    }

    return 1;
}

int UnboundedDirectoryString::operator != (const UnboundedDirectoryString & that) const {
    return !(operator ==(that));
}

UnboundedDirectoryString::teletexString *UnboundedDirectoryString::get_teletexString() {
    if (_choice == teletexString_chosen)
	return (teletexString *)&teletexString_field;
    else
	return 0;
}

const UnboundedDirectoryString::teletexString *UnboundedDirectoryString::get_teletexString() const {
    if (_choice == teletexString_chosen)
	return (const teletexString *)&teletexString_field;
    else
	return 0;
}

void UnboundedDirectoryString::set_teletexString(const teletexString & teletexString_val) {
    cleanup();
    *(teletexString *)&teletexString_field = teletexString_val;
    _choice = teletexString_chosen;
}

UnboundedDirectoryString::printableString *UnboundedDirectoryString::get_printableString() {
    if (_choice == printableString_chosen)
	return (printableString *)&printableString_field;
    else
	return 0;
}

const UnboundedDirectoryString::printableString *UnboundedDirectoryString::get_printableString() const {
    if (_choice == printableString_chosen)
	return (const printableString *)&printableString_field;
    else
	return 0;
}

void UnboundedDirectoryString::set_printableString(const printableString & printableString_val) {
    cleanup();
    *(printableString *)&printableString_field = printableString_val;
    _choice = printableString_chosen;
}

UnboundedDirectoryString::bmpString *UnboundedDirectoryString::get_bmpString() {
    if (_choice == bmpString_chosen)
	return (bmpString *)&bmpString_field;
    else
	return 0;
}

const UnboundedDirectoryString::bmpString *UnboundedDirectoryString::get_bmpString() const {
    if (_choice == bmpString_chosen)
	return (const bmpString *)&bmpString_field;
    else
	return 0;
}

void UnboundedDirectoryString::set_bmpString(const bmpString & bmpString_val) {
    cleanup();
    *(bmpString *)&bmpString_field = bmpString_val;
    _choice = bmpString_chosen;
}

UnboundedDirectoryString::universalString *UnboundedDirectoryString::get_universalString() {
    if (_choice == universalString_chosen)
	return (universalString *)&universalString_field;
    else
	return 0;
}

const UnboundedDirectoryString::universalString *UnboundedDirectoryString::get_universalString() const {
    if (_choice == universalString_chosen)
	return (const universalString *)&universalString_field;
    else
	return 0;
}

void UnboundedDirectoryString::set_universalString(const universalString & universalString_val) {
    cleanup();
    *(universalString *)&universalString_field = universalString_val;
    _choice = universalString_chosen;
}

UnboundedDirectoryString::uTF8String *UnboundedDirectoryString::get_uTF8String() {
    if (_choice == uTF8String_chosen)
	return (uTF8String *)&uTF8String_field;
    else
	return 0;
}

const UnboundedDirectoryString::uTF8String *UnboundedDirectoryString::get_uTF8String() const {
    if (_choice == uTF8String_chosen)
	return (const uTF8String *)&uTF8String_field;
    else
	return 0;
}

void UnboundedDirectoryString::set_uTF8String(const uTF8String & uTF8String_val) {
    cleanup();
    *(uTF8String *)&uTF8String_field = uTF8String_val;
    _choice = uTF8String_chosen;
}

void UnboundedDirectoryString::cleanup() {
    switch (_choice) {
	case teletexString_chosen:
	    ((teletexString *)&teletexString_field)->~OssString();
	    break;
	case printableString_chosen:
	    ((printableString *)&printableString_field)->~OssString();
	    break;
	case bmpString_chosen:
	    ((bmpString *)&bmpString_field)->~OssBMPString();
	    break;
	case universalString_chosen:
	    ((universalString *)&universalString_field)->~OssUniversalString();
	    break;
	case uTF8String_chosen:
	    ((uTF8String *)&uTF8String_field)->~OssString();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

void *UUIDPair::operator new(size_t size) {
    return ossNewFunc(size);
}

void UUIDPair::operator delete(void *ptr) {
    asn1Free(ptr);
}

UUIDPair::UUIDPair() {
    memset(this, 0, sizeof(UUIDPair));
}

UUIDPair::UUIDPair(const UUIDPair & that) {
    OSSTRY {
	issuerUUID_field = that.issuerUUID_field;
	subjectUUID_field = that.subjectUUID_field;
    } OSSCLEAN(UUIDPair)
}

UUIDPair::UUIDPair(const issuerUUID & issuerUUID_val, const subjectUUID & subjectUUID_val) {
    OSSTRY {
	issuerUUID_field = issuerUUID_val;
	subjectUUID_field = subjectUUID_val;
    } OSSCLEAN(UUIDPair)
}

UUIDPair & UUIDPair::operator = (const UUIDPair & that) {
    if (this == &that)
	return *this;
    issuerUUID_field = that.issuerUUID_field;
    subjectUUID_field = that.subjectUUID_field;
    return *this;
}

int UUIDPair::operator == (const UUIDPair & that) const {
    if (issuerUUID_field != that.issuerUUID_field)
	return 0;
    if (subjectUUID_field != that.subjectUUID_field)
	return 0;
    return 1;
}

int UUIDPair::operator != (const UUIDPair & that) const {
    return !(operator ==(that));
}

UUIDPair::issuerUUID & UUIDPair::get_issuerUUID() {
    return issuerUUID_field;
}

const UUIDPair::issuerUUID & UUIDPair::get_issuerUUID() const {
    return issuerUUID_field;
}

void UUIDPair::set_issuerUUID(const issuerUUID & issuerUUID_val) {
    issuerUUID_field = issuerUUID_val;
}

UUIDPair::subjectUUID & UUIDPair::get_subjectUUID() {
    return subjectUUID_field;
}

const UUIDPair::subjectUUID & UUIDPair::get_subjectUUID() const {
    return subjectUUID_field;
}

void UUIDPair::set_subjectUUID(const subjectUUID & subjectUUID_val) {
    subjectUUID_field = subjectUUID_val;
}

CriteriaItem::CriteriaItem() {
    memset(this, 0, sizeof(CriteriaItem));
}

CriteriaItem::CriteriaItem(const CriteriaItem & that) {
    memset(this, 0, sizeof(CriteriaItem));
    operator =(that);
}

CriteriaItem::~CriteriaItem() {
    cleanup();
}

CriteriaItem & CriteriaItem::operator = (const CriteriaItem & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case equality_chosen:
	    *(equality *)&equality_field = *(equality *)&that.equality_field;
	    break;
	case substrings_chosen:
	    *(substrings *)&substrings_field = *(substrings *)&that.substrings_field;
	    break;
	case greaterOrEqual_chosen:
	    *(greaterOrEqual *)&greaterOrEqual_field = *(greaterOrEqual *)&that.greaterOrEqual_field;
	    break;
	case lessOrEqual_chosen:
	    *(lessOrEqual *)&lessOrEqual_field = *(lessOrEqual *)&that.lessOrEqual_field;
	    break;
	case approximateMatch_chosen:
	    *(approximateMatch *)&approximateMatch_field = *(approximateMatch *)&that.approximateMatch_field;
	    break;
    }
    return *this;
}

int CriteriaItem::operator == (const CriteriaItem & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case equality_chosen:
	    return *(equality *)&equality_field == *(equality *)&that.equality_field;
	case substrings_chosen:
	    return *(substrings *)&substrings_field == *(substrings *)&that.substrings_field;
	case greaterOrEqual_chosen:
	    return *(greaterOrEqual *)&greaterOrEqual_field == *(greaterOrEqual *)&that.greaterOrEqual_field;
	case lessOrEqual_chosen:
	    return *(lessOrEqual *)&lessOrEqual_field == *(lessOrEqual *)&that.lessOrEqual_field;
	case approximateMatch_chosen:
	    return *(approximateMatch *)&approximateMatch_field == *(approximateMatch *)&that.approximateMatch_field;
    }

    return 1;
}

int CriteriaItem::operator != (const CriteriaItem & that) const {
    return !(operator ==(that));
}

CriteriaItem::equality *CriteriaItem::get_equality() {
    if (_choice == equality_chosen)
	return (equality *)&equality_field;
    else
	return 0;
}

const CriteriaItem::equality *CriteriaItem::get_equality() const {
    if (_choice == equality_chosen)
	return (const equality *)&equality_field;
    else
	return 0;
}

void CriteriaItem::set_equality(const equality & equality_val) {
    cleanup();
    *(equality *)&equality_field = equality_val;
    _choice = equality_chosen;
}

CriteriaItem::substrings *CriteriaItem::get_substrings() {
    if (_choice == substrings_chosen)
	return (substrings *)&substrings_field;
    else
	return 0;
}

const CriteriaItem::substrings *CriteriaItem::get_substrings() const {
    if (_choice == substrings_chosen)
	return (const substrings *)&substrings_field;
    else
	return 0;
}

void CriteriaItem::set_substrings(const substrings & substrings_val) {
    cleanup();
    *(substrings *)&substrings_field = substrings_val;
    _choice = substrings_chosen;
}

CriteriaItem::greaterOrEqual *CriteriaItem::get_greaterOrEqual() {
    if (_choice == greaterOrEqual_chosen)
	return (greaterOrEqual *)&greaterOrEqual_field;
    else
	return 0;
}

const CriteriaItem::greaterOrEqual *CriteriaItem::get_greaterOrEqual() const {
    if (_choice == greaterOrEqual_chosen)
	return (const greaterOrEqual *)&greaterOrEqual_field;
    else
	return 0;
}

void CriteriaItem::set_greaterOrEqual(const greaterOrEqual & greaterOrEqual_val) {
    cleanup();
    *(greaterOrEqual *)&greaterOrEqual_field = greaterOrEqual_val;
    _choice = greaterOrEqual_chosen;
}

CriteriaItem::lessOrEqual *CriteriaItem::get_lessOrEqual() {
    if (_choice == lessOrEqual_chosen)
	return (lessOrEqual *)&lessOrEqual_field;
    else
	return 0;
}

const CriteriaItem::lessOrEqual *CriteriaItem::get_lessOrEqual() const {
    if (_choice == lessOrEqual_chosen)
	return (const lessOrEqual *)&lessOrEqual_field;
    else
	return 0;
}

void CriteriaItem::set_lessOrEqual(const lessOrEqual & lessOrEqual_val) {
    cleanup();
    *(lessOrEqual *)&lessOrEqual_field = lessOrEqual_val;
    _choice = lessOrEqual_chosen;
}

CriteriaItem::approximateMatch *CriteriaItem::get_approximateMatch() {
    if (_choice == approximateMatch_chosen)
	return (approximateMatch *)&approximateMatch_field;
    else
	return 0;
}

const CriteriaItem::approximateMatch *CriteriaItem::get_approximateMatch() const {
    if (_choice == approximateMatch_chosen)
	return (const approximateMatch *)&approximateMatch_field;
    else
	return 0;
}

void CriteriaItem::set_approximateMatch(const approximateMatch & approximateMatch_val) {
    cleanup();
    *(approximateMatch *)&approximateMatch_field = approximateMatch_val;
    _choice = approximateMatch_chosen;
}

void CriteriaItem::cleanup() {
    switch (_choice) {
	case equality_chosen:
	    ((equality *)&equality_field)->~OssEncOID();
	    break;
	case substrings_chosen:
	    ((substrings *)&substrings_field)->~OssEncOID();
	    break;
	case greaterOrEqual_chosen:
	    ((greaterOrEqual *)&greaterOrEqual_field)->~OssEncOID();
	    break;
	case lessOrEqual_chosen:
	    ((lessOrEqual *)&lessOrEqual_field)->~OssEncOID();
	    break;
	case approximateMatch_chosen:
	    ((approximateMatch *)&approximateMatch_field)->~OssEncOID();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

/* Auxiliary data structures and functions for class __shared25 */

class __shared25_member {
public:
    __shared25_member *next;
    __shared25::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared25_member();
    __shared25_member(const __shared25::component & val);
};

void *__shared25_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared25_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared25_member::__shared25_member() {
}

__shared25_member::__shared25_member(const __shared25::component & val) {
    value = val;
}

static void *__shared25_copy(void *that) {
    return new __shared25_member(((__shared25_member *)that)->value);
}

static void __shared25_destroy(void *that) {
    delete (__shared25_member *)that;
}

static int __shared25_compare(void *val1, void *val2) {
    return (((__shared25_member *)val1)->value == ((__shared25_member *)val2)->value);
}

/* Constructors */

__shared25::__shared25() {
}

__shared25::__shared25(const __shared25 & that) {
    OSSTRY {
	do_copy(that, &__shared25_copy);
    } OSSCLEAN(__shared25)
}

/* Destructor */

__shared25::~__shared25() {
    do_destroy(&__shared25_destroy);
}

/* Operators: assignment, equality, inequality */

__shared25 & __shared25::operator = (const __shared25 & that) {
    do_destroy(&__shared25_destroy);
    do_copy(that, &__shared25_copy);
    return *this;
}

int __shared25::operator == (const __shared25 & that) const {
    return do_compare(that, &__shared25_compare);
}

int __shared25::operator != (const __shared25 & that) const {
    return !do_compare(that, &__shared25_compare);
}

/* Locate ("At" etc) methods */

__shared25::component *__shared25::at(OssIndex pos) {
    return &((__shared25_member *)pos)->value;
}

const __shared25::component *__shared25::at(OssIndex pos) const {
    return &((__shared25_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared25::prepend(const component & val) {
    __shared25_member *newrec = new __shared25_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared25::prepend(__shared25 *seq) {
    return do_prepend(seq);
}

OssIndex __shared25::insert_after(OssIndex pos, const component & val) {
    __shared25_member *newrec = new __shared25_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared25::insert_after(OssIndex pos, __shared25 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared25::remove_front() {
    __shared25_member *extr = (__shared25_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared25_destroy(extr);
    return 0;
}

int __shared25::remove_after(OssIndex pos) {
    __shared25_member *extr = (__shared25_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared25_destroy(extr);
    return 0;
}

/* Extract methods */

__shared25 *__shared25::extract_after(OssIndex begin, OssIndex end) {
    return (__shared25 *)do_extract_after(begin, end);
}

Criteria::Criteria() {
    memset(this, 0, sizeof(Criteria));
}

Criteria::Criteria(const Criteria & that) {
    memset(this, 0, sizeof(Criteria));
    operator =(that);
}

Criteria::~Criteria() {
    cleanup();
}

Criteria & Criteria::operator = (const Criteria & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case type_chosen:
	    if (that.type_field)
		type_field = new type(*that.type_field);
	    break;
	case Criteria_and_chosen:
	    *(Criteria_and *)&Criteria_and_field = *(Criteria_and *)&that.Criteria_and_field;
	    break;
	case Criteria_or_chosen:
	    *(Criteria_or *)&Criteria_or_field = *(Criteria_or *)&that.Criteria_or_field;
	    break;
	case Criteria_not_chosen:
	    if (that.Criteria_not_field)
		Criteria_not_field = new Criteria_not(*that.Criteria_not_field);
	    break;
    }
    return *this;
}

int Criteria::operator == (const Criteria & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case type_chosen:
	    if ((type_field) && (that.type_field))
		return (*type_field == *(that.type_field));
	    else if (!((!type_field) && (!that.type_field)))
		return 0;
	    break;
	case Criteria_and_chosen:
	    return *(Criteria_and *)&Criteria_and_field == *(Criteria_and *)&that.Criteria_and_field;
	case Criteria_or_chosen:
	    return *(Criteria_or *)&Criteria_or_field == *(Criteria_or *)&that.Criteria_or_field;
	case Criteria_not_chosen:
	    if ((Criteria_not_field) && (that.Criteria_not_field))
		return (*Criteria_not_field == *(that.Criteria_not_field));
	    else if (!((!Criteria_not_field) && (!that.Criteria_not_field)))
		return 0;
	    break;
    }

    return 1;
}

int Criteria::operator != (const Criteria & that) const {
    return !(operator ==(that));
}

Criteria::type *Criteria::get_type() {
    if (_choice == type_chosen)
	return (type *)type_field;
    else
	return 0;
}

const Criteria::type *Criteria::get_type() const {
    if (_choice == type_chosen)
	return (const type *)type_field;
    else
	return 0;
}

void Criteria::set_type(const type & type_val) {
    cleanup();
    type_field = new type(type_val);
    _choice = type_chosen;
}

Criteria::Criteria_and *Criteria::get_Criteria_and() {
    if (_choice == Criteria_and_chosen)
	return (Criteria_and *)&Criteria_and_field;
    else
	return 0;
}

const Criteria::Criteria_and *Criteria::get_Criteria_and() const {
    if (_choice == Criteria_and_chosen)
	return (const Criteria_and *)&Criteria_and_field;
    else
	return 0;
}

void Criteria::set_Criteria_and(const Criteria_and & Criteria_and_val) {
    cleanup();
    *(Criteria_and *)&Criteria_and_field = Criteria_and_val;
    _choice = Criteria_and_chosen;
}

Criteria::Criteria_or *Criteria::get_Criteria_or() {
    if (_choice == Criteria_or_chosen)
	return (Criteria_or *)&Criteria_or_field;
    else
	return 0;
}

const Criteria::Criteria_or *Criteria::get_Criteria_or() const {
    if (_choice == Criteria_or_chosen)
	return (const Criteria_or *)&Criteria_or_field;
    else
	return 0;
}

void Criteria::set_Criteria_or(const Criteria_or & Criteria_or_val) {
    cleanup();
    *(Criteria_or *)&Criteria_or_field = Criteria_or_val;
    _choice = Criteria_or_chosen;
}

Criteria::Criteria_not *Criteria::get_Criteria_not() {
    if (_choice == Criteria_not_chosen)
	return (Criteria_not *)Criteria_not_field;
    else
	return 0;
}

const Criteria::Criteria_not *Criteria::get_Criteria_not() const {
    if (_choice == Criteria_not_chosen)
	return (const Criteria_not *)Criteria_not_field;
    else
	return 0;
}

void Criteria::set_Criteria_not(const Criteria_not & Criteria_not_val) {
    cleanup();
    Criteria_not_field = new Criteria_not(Criteria_not_val);
    _choice = Criteria_not_chosen;
}

void Criteria::cleanup() {
    switch (_choice) {
	case type_chosen:
	    if (type_field)
		delete type_field;
	    break;
	case Criteria_and_chosen:
	    ((Criteria_and *)&Criteria_and_field)->~__shared25();
	    break;
	case Criteria_or_chosen:
	    ((Criteria_or *)&Criteria_or_field)->~__shared25();
	    break;
	case Criteria_not_chosen:
	    if (Criteria_not_field)
		delete Criteria_not_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

void *Guide::operator new(size_t size) {
    return ossNewFunc(size);
}

void Guide::operator delete(void *ptr) {
    asn1Free(ptr);
}

Guide::Guide() {
    memset(this, 0, sizeof(Guide));
}

Guide::Guide(const Guide & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	objectClass_field = that.objectClass_field;
	criteria_field = that.criteria_field;
    } OSSCLEAN(Guide)
}

Guide::Guide(const objectClass & objectClass_val, const criteria & criteria_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	objectClass_field = objectClass_val;
	criteria_field = criteria_val;
    } OSSCLEAN(Guide)
}

Guide::Guide(const criteria & criteria_val) {
    OSSTRY {
	bit_mask = 0;
	criteria_field = criteria_val;
    } OSSCLEAN(Guide)
}

Guide & Guide::operator = (const Guide & that) {
    if (this == &that)
	return *this;
    this->~Guide();
    bit_mask = that.bit_mask;
    objectClass_field = that.objectClass_field;
    criteria_field = that.criteria_field;
    return *this;
}

int Guide::operator == (const Guide & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (objectClass_field != that.objectClass_field)
	    return 0;
    }
    if (criteria_field != that.criteria_field)
	return 0;
    return 1;
}

int Guide::operator != (const Guide & that) const {
    return !(operator ==(that));
}

Guide::objectClass *Guide::get_objectClass() {
    if (bit_mask & 0x80000000)
	return &objectClass_field;
    else
	return 0;
}

const Guide::objectClass *Guide::get_objectClass() const {
    if (bit_mask & 0x80000000)
	return &objectClass_field;
    else
	return 0;
}

void Guide::set_objectClass(const objectClass & objectClass_val) {
    bit_mask |= 0x80000000;
    objectClass_field = objectClass_val;
}

int Guide::objectClass_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void Guide::omit_objectClass() {
    objectClass_field.~OssEncOID();
    bit_mask &= ~0x80000000;
}

Guide::criteria & Guide::get_criteria() {
    return criteria_field;
}

const Guide::criteria & Guide::get_criteria() const {
    return criteria_field;
}

void Guide::set_criteria(const criteria & criteria_val) {
    criteria_field = criteria_val;
}

void *EnhancedGuide::operator new(size_t size) {
    return ossNewFunc(size);
}

void EnhancedGuide::operator delete(void *ptr) {
    asn1Free(ptr);
}

OSS_INT32 EnhancedGuide::get_default_subset() {
    return EnhancedGuide::default_subset;
}

EnhancedGuide::EnhancedGuide() {
    memset(this, 0, sizeof(EnhancedGuide));
}

EnhancedGuide::EnhancedGuide(const EnhancedGuide & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	objectClass_field = that.objectClass_field;
	criteria_field = that.criteria_field;
	subset_field = that.subset_field;
    } OSSCLEAN(EnhancedGuide)
}

EnhancedGuide::EnhancedGuide(const objectClass & objectClass_val, const criteria & criteria_val, 
    subset subset_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	objectClass_field = objectClass_val;
	criteria_field = criteria_val;
	subset_field = subset_val;
    } OSSCLEAN(EnhancedGuide)
}

EnhancedGuide::EnhancedGuide(const objectClass & objectClass_val, const criteria & criteria_val) {
    OSSTRY {
	bit_mask = 0;
	objectClass_field = objectClass_val;
	criteria_field = criteria_val;
    } OSSCLEAN(EnhancedGuide)
}

EnhancedGuide & EnhancedGuide::operator = (const EnhancedGuide & that) {
    if (this == &that)
	return *this;
    this->~EnhancedGuide();
    bit_mask = that.bit_mask;
    objectClass_field = that.objectClass_field;
    criteria_field = that.criteria_field;
    subset_field = that.subset_field;
    return *this;
}

int EnhancedGuide::operator == (const EnhancedGuide & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (objectClass_field != that.objectClass_field)
	return 0;
    if (criteria_field != that.criteria_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (subset_field != that.subset_field)
	    return 0;
    }
    return 1;
}

int EnhancedGuide::operator != (const EnhancedGuide & that) const {
    return !(operator ==(that));
}

EnhancedGuide::objectClass & EnhancedGuide::get_objectClass() {
    return objectClass_field;
}

const EnhancedGuide::objectClass & EnhancedGuide::get_objectClass() const {
    return objectClass_field;
}

void EnhancedGuide::set_objectClass(const objectClass & objectClass_val) {
    objectClass_field = objectClass_val;
}

EnhancedGuide::criteria & EnhancedGuide::get_criteria() {
    return criteria_field;
}

const EnhancedGuide::criteria & EnhancedGuide::get_criteria() const {
    return criteria_field;
}

void EnhancedGuide::set_criteria(const criteria & criteria_val) {
    criteria_field = criteria_val;
}

EnhancedGuide::subset *EnhancedGuide::get_subset() {
    if (bit_mask & 0x80000000)
	return &subset_field;
    else
	return 0;
}

const EnhancedGuide::subset *EnhancedGuide::get_subset() const {
    if (bit_mask & 0x80000000)
	return &subset_field;
    else
	return 0;
}

void EnhancedGuide::set_subset(subset subset_val) {
    bit_mask |= 0x80000000;
    subset_field = subset_val;
}

int EnhancedGuide::subset_is_default() const {
    return !(bit_mask & 0x80000000);
}

void EnhancedGuide::set_default_subset() {
    bit_mask &= ~0x80000000;
}

/* Auxiliary data structures and functions for class __shared26 */

class __shared26_member {
public:
    __shared26_member *next;
    __shared26::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared26_member();
    __shared26_member(const __shared26::component & val);
};

void *__shared26_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared26_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared26_member::__shared26_member() {
}

__shared26_member::__shared26_member(const __shared26::component & val) {
    value = val;
}

static void *__shared26_copy(void *that) {
    return new __shared26_member(((__shared26_member *)that)->value);
}

static void __shared26_destroy(void *that) {
    delete (__shared26_member *)that;
}

static int __shared26_compare(void *val1, void *val2) {
    return (((__shared26_member *)val1)->value == ((__shared26_member *)val2)->value);
}

/* Constructors */

__shared26::__shared26() {
}

__shared26::__shared26(const __shared26 & that) {
    OSSTRY {
	do_copy(that, &__shared26_copy);
    } OSSCLEAN(__shared26)
}

/* Destructor */

__shared26::~__shared26() {
    do_destroy(&__shared26_destroy);
}

/* Operators: assignment, equality, inequality */

__shared26 & __shared26::operator = (const __shared26 & that) {
    do_destroy(&__shared26_destroy);
    do_copy(that, &__shared26_copy);
    return *this;
}

int __shared26::operator == (const __shared26 & that) const {
    return do_compare(that, &__shared26_compare);
}

int __shared26::operator != (const __shared26 & that) const {
    return !do_compare(that, &__shared26_compare);
}

/* Locate ("At" etc) methods */

__shared26::component *__shared26::at(OssIndex pos) {
    return &((__shared26_member *)pos)->value;
}

const __shared26::component *__shared26::at(OssIndex pos) const {
    return &((__shared26_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared26::prepend(const component & val) {
    __shared26_member *newrec = new __shared26_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared26::prepend(__shared26 *seq) {
    return do_prepend(seq);
}

OssIndex __shared26::insert_after(OssIndex pos, const component & val) {
    __shared26_member *newrec = new __shared26_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared26::insert_after(OssIndex pos, __shared26 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared26::remove_front() {
    __shared26_member *extr = (__shared26_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared26_destroy(extr);
    return 0;
}

int __shared26::remove_after(OssIndex pos) {
    __shared26_member *extr = (__shared26_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared26_destroy(extr);
    return 0;
}

/* Extract methods */

__shared26 *__shared26::extract_after(OssIndex begin, OssIndex end) {
    return (__shared26 *)do_extract_after(begin, end);
}

void *TelexNumber::operator new(size_t size) {
    return ossNewFunc(size);
}

void TelexNumber::operator delete(void *ptr) {
    asn1Free(ptr);
}

TelexNumber::TelexNumber() {
    memset(this, 0, sizeof(TelexNumber));
}

TelexNumber::TelexNumber(const TelexNumber & that) {
    OSSTRY {
	telexNumber_field = that.telexNumber_field;
	countryCode_field = that.countryCode_field;
	answerback_field = that.answerback_field;
    } OSSCLEAN(TelexNumber)
}

TelexNumber::TelexNumber(const telexNumber & telexNumber_val, const countryCode & countryCode_val, 
    const answerback & answerback_val) {
    OSSTRY {
	telexNumber_field = telexNumber_val;
	countryCode_field = countryCode_val;
	answerback_field = answerback_val;
    } OSSCLEAN(TelexNumber)
}

TelexNumber & TelexNumber::operator = (const TelexNumber & that) {
    if (this == &that)
	return *this;
    telexNumber_field = that.telexNumber_field;
    countryCode_field = that.countryCode_field;
    answerback_field = that.answerback_field;
    return *this;
}

int TelexNumber::operator == (const TelexNumber & that) const {
    if (telexNumber_field != that.telexNumber_field)
	return 0;
    if (countryCode_field != that.countryCode_field)
	return 0;
    if (answerback_field != that.answerback_field)
	return 0;
    return 1;
}

int TelexNumber::operator != (const TelexNumber & that) const {
    return !(operator ==(that));
}

TelexNumber::telexNumber & TelexNumber::get_telexNumber() {
    return telexNumber_field;
}

const TelexNumber::telexNumber & TelexNumber::get_telexNumber() const {
    return telexNumber_field;
}

void TelexNumber::set_telexNumber(const telexNumber & telexNumber_val) {
    telexNumber_field = telexNumber_val;
}

TelexNumber::countryCode & TelexNumber::get_countryCode() {
    return countryCode_field;
}

const TelexNumber::countryCode & TelexNumber::get_countryCode() const {
    return countryCode_field;
}

void TelexNumber::set_countryCode(const countryCode & countryCode_val) {
    countryCode_field = countryCode_val;
}

TelexNumber::answerback & TelexNumber::get_answerback() {
    return answerback_field;
}

const TelexNumber::answerback & TelexNumber::get_answerback() const {
    return answerback_field;
}

void TelexNumber::set_answerback(const answerback & answerback_val) {
    answerback_field = answerback_val;
}

/* Auxiliary data structures and functions for class __shared27 */

class __shared27_member {
public:
    __shared27_member *next;
    __shared27::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared27_member();
    __shared27_member(const __shared27::component & val);
};

void *__shared27_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared27_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared27_member::__shared27_member() {
}

__shared27_member::__shared27_member(const __shared27::component & val) {
    value = val;
}

static void *__shared27_copy(void *that) {
    return new __shared27_member(((__shared27_member *)that)->value);
}

static void __shared27_destroy(void *that) {
    delete (__shared27_member *)that;
}

static int __shared27_compare(void *val1, void *val2) {
    return (((__shared27_member *)val1)->value == ((__shared27_member *)val2)->value);
}

/* Constructors */

__shared27::__shared27() {
}

__shared27::__shared27(const __shared27 & that) {
    OSSTRY {
	do_copy(that, &__shared27_copy);
    } OSSCLEAN(__shared27)
}

/* Destructor */

__shared27::~__shared27() {
    do_destroy(&__shared27_destroy);
}

/* Operators: assignment, equality, inequality */

__shared27 & __shared27::operator = (const __shared27 & that) {
    do_destroy(&__shared27_destroy);
    do_copy(that, &__shared27_copy);
    return *this;
}

int __shared27::operator == (const __shared27 & that) const {
    return do_compare(that, &__shared27_compare);
}

int __shared27::operator != (const __shared27 & that) const {
    return !do_compare(that, &__shared27_compare);
}

/* Locate ("At" etc) methods */

__shared27::component *__shared27::at(OssIndex pos) {
    return &((__shared27_member *)pos)->value;
}

const __shared27::component *__shared27::at(OssIndex pos) const {
    return &((__shared27_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared27::prepend(const component & val) {
    __shared27_member *newrec = new __shared27_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared27::prepend(__shared27 *seq) {
    return do_prepend(seq);
}

OssIndex __shared27::insert_after(OssIndex pos, const component & val) {
    __shared27_member *newrec = new __shared27_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared27::insert_after(OssIndex pos, __shared27 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared27::remove_front() {
    __shared27_member *extr = (__shared27_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared27_destroy(extr);
    return 0;
}

int __shared27::remove_after(OssIndex pos) {
    __shared27_member *extr = (__shared27_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared27_destroy(extr);
    return 0;
}

/* Extract methods */

__shared27 *__shared27::extract_after(OssIndex begin, OssIndex end) {
    return (__shared27 *)do_extract_after(begin, end);
}

void *PresentationAddress::operator new(size_t size) {
    return ossNewFunc(size);
}

void PresentationAddress::operator delete(void *ptr) {
    asn1Free(ptr);
}

PresentationAddress::PresentationAddress() {
    memset(this, 0, sizeof(PresentationAddress));
}

PresentationAddress::PresentationAddress(const PresentationAddress & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	pSelector_field = that.pSelector_field;
	sSelector_field = that.sSelector_field;
	tSelector_field = that.tSelector_field;
	nAddresses_field = that.nAddresses_field;
    } OSSCLEAN(PresentationAddress)
}

PresentationAddress::PresentationAddress(const pSelector & pSelector_val, const sSelector & sSelector_val, 
    const tSelector & tSelector_val, const nAddresses & nAddresses_val) {
    OSSTRY {
	bit_mask = 0xe0000000;
	pSelector_field = pSelector_val;
	sSelector_field = sSelector_val;
	tSelector_field = tSelector_val;
	nAddresses_field = nAddresses_val;
    } OSSCLEAN(PresentationAddress)
}

PresentationAddress::PresentationAddress(const nAddresses & nAddresses_val) {
    OSSTRY {
	bit_mask = 0;
	nAddresses_field = nAddresses_val;
    } OSSCLEAN(PresentationAddress)
}

PresentationAddress & PresentationAddress::operator = (const PresentationAddress & that) {
    if (this == &that)
	return *this;
    this->~PresentationAddress();
    bit_mask = that.bit_mask;
    pSelector_field = that.pSelector_field;
    sSelector_field = that.sSelector_field;
    tSelector_field = that.tSelector_field;
    nAddresses_field = that.nAddresses_field;
    return *this;
}

int PresentationAddress::operator == (const PresentationAddress & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (pSelector_field != that.pSelector_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (sSelector_field != that.sSelector_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (tSelector_field != that.tSelector_field)
	    return 0;
    }
    if (nAddresses_field != that.nAddresses_field)
	return 0;
    return 1;
}

int PresentationAddress::operator != (const PresentationAddress & that) const {
    return !(operator ==(that));
}

PresentationAddress::pSelector *PresentationAddress::get_pSelector() {
    if (bit_mask & 0x80000000)
	return &pSelector_field;
    else
	return 0;
}

const PresentationAddress::pSelector *PresentationAddress::get_pSelector() const {
    if (bit_mask & 0x80000000)
	return &pSelector_field;
    else
	return 0;
}

void PresentationAddress::set_pSelector(const pSelector & pSelector_val) {
    bit_mask |= 0x80000000;
    pSelector_field = pSelector_val;
}

int PresentationAddress::pSelector_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void PresentationAddress::omit_pSelector() {
    pSelector_field.~OssString();
    bit_mask &= ~0x80000000;
}

PresentationAddress::sSelector *PresentationAddress::get_sSelector() {
    if (bit_mask & 0x40000000)
	return &sSelector_field;
    else
	return 0;
}

const PresentationAddress::sSelector *PresentationAddress::get_sSelector() const {
    if (bit_mask & 0x40000000)
	return &sSelector_field;
    else
	return 0;
}

void PresentationAddress::set_sSelector(const sSelector & sSelector_val) {
    bit_mask |= 0x40000000;
    sSelector_field = sSelector_val;
}

int PresentationAddress::sSelector_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void PresentationAddress::omit_sSelector() {
    sSelector_field.~OssString();
    bit_mask &= ~0x40000000;
}

PresentationAddress::tSelector *PresentationAddress::get_tSelector() {
    if (bit_mask & 0x20000000)
	return &tSelector_field;
    else
	return 0;
}

const PresentationAddress::tSelector *PresentationAddress::get_tSelector() const {
    if (bit_mask & 0x20000000)
	return &tSelector_field;
    else
	return 0;
}

void PresentationAddress::set_tSelector(const tSelector & tSelector_val) {
    bit_mask |= 0x20000000;
    tSelector_field = tSelector_val;
}

int PresentationAddress::tSelector_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void PresentationAddress::omit_tSelector() {
    tSelector_field.~OssString();
    bit_mask &= ~0x20000000;
}

PresentationAddress::nAddresses & PresentationAddress::get_nAddresses() {
    return nAddresses_field;
}

const PresentationAddress::nAddresses & PresentationAddress::get_nAddresses() const {
    return nAddresses_field;
}

void PresentationAddress::set_nAddresses(const nAddresses & nAddresses_val) {
    nAddresses_field = nAddresses_val;
}

void *ProtocolInformation::operator new(size_t size) {
    return ossNewFunc(size);
}

void ProtocolInformation::operator delete(void *ptr) {
    asn1Free(ptr);
}

ProtocolInformation::ProtocolInformation() {
    memset(this, 0, sizeof(ProtocolInformation));
}

ProtocolInformation::ProtocolInformation(const ProtocolInformation & that) {
    OSSTRY {
	nAddress_field = that.nAddress_field;
	profiles_field = that.profiles_field;
    } OSSCLEAN(ProtocolInformation)
}

ProtocolInformation::ProtocolInformation(const nAddress & nAddress_val, const profiles & profiles_val) {
    OSSTRY {
	nAddress_field = nAddress_val;
	profiles_field = profiles_val;
    } OSSCLEAN(ProtocolInformation)
}

ProtocolInformation & ProtocolInformation::operator = (const ProtocolInformation & that) {
    if (this == &that)
	return *this;
    nAddress_field = that.nAddress_field;
    profiles_field = that.profiles_field;
    return *this;
}

int ProtocolInformation::operator == (const ProtocolInformation & that) const {
    if (nAddress_field != that.nAddress_field)
	return 0;
    if (profiles_field != that.profiles_field)
	return 0;
    return 1;
}

int ProtocolInformation::operator != (const ProtocolInformation & that) const {
    return !(operator ==(that));
}

ProtocolInformation::nAddress & ProtocolInformation::get_nAddress() {
    return nAddress_field;
}

const ProtocolInformation::nAddress & ProtocolInformation::get_nAddress() const {
    return nAddress_field;
}

void ProtocolInformation::set_nAddress(const nAddress & nAddress_val) {
    nAddress_field = nAddress_val;
}

ProtocolInformation::profiles & ProtocolInformation::get_profiles() {
    return profiles_field;
}

const ProtocolInformation::profiles & ProtocolInformation::get_profiles() const {
    return profiles_field;
}

void ProtocolInformation::set_profiles(const profiles & profiles_val) {
    profiles_field = profiles_val;
}

void *NameAndOptionalUID::operator new(size_t size) {
    return ossNewFunc(size);
}

void NameAndOptionalUID::operator delete(void *ptr) {
    asn1Free(ptr);
}

NameAndOptionalUID::NameAndOptionalUID() {
    memset(this, 0, sizeof(NameAndOptionalUID));
}

NameAndOptionalUID::NameAndOptionalUID(const NameAndOptionalUID & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	dn_field = that.dn_field;
	uid_field = that.uid_field;
    } OSSCLEAN(NameAndOptionalUID)
}

NameAndOptionalUID::NameAndOptionalUID(const dn & dn_val, const uid & uid_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	dn_field = dn_val;
	uid_field = uid_val;
    } OSSCLEAN(NameAndOptionalUID)
}

NameAndOptionalUID::NameAndOptionalUID(const dn & dn_val) {
    OSSTRY {
	bit_mask = 0;
	dn_field = dn_val;
    } OSSCLEAN(NameAndOptionalUID)
}

NameAndOptionalUID & NameAndOptionalUID::operator = (const NameAndOptionalUID & that) {
    if (this == &that)
	return *this;
    this->~NameAndOptionalUID();
    bit_mask = that.bit_mask;
    dn_field = that.dn_field;
    uid_field = that.uid_field;
    return *this;
}

int NameAndOptionalUID::operator == (const NameAndOptionalUID & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (dn_field != that.dn_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (uid_field != that.uid_field)
	    return 0;
    }
    return 1;
}

int NameAndOptionalUID::operator != (const NameAndOptionalUID & that) const {
    return !(operator ==(that));
}

NameAndOptionalUID::dn & NameAndOptionalUID::get_dn() {
    return dn_field;
}

const NameAndOptionalUID::dn & NameAndOptionalUID::get_dn() const {
    return dn_field;
}

void NameAndOptionalUID::set_dn(const dn & dn_val) {
    dn_field = dn_val;
}

NameAndOptionalUID::uid *NameAndOptionalUID::get_uid() {
    if (bit_mask & 0x80000000)
	return &uid_field;
    else
	return 0;
}

const NameAndOptionalUID::uid *NameAndOptionalUID::get_uid() const {
    if (bit_mask & 0x80000000)
	return &uid_field;
    else
	return 0;
}

void NameAndOptionalUID::set_uid(const uid & uid_val) {
    bit_mask |= 0x80000000;
    uid_field = uid_val;
}

int NameAndOptionalUID::uid_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void NameAndOptionalUID::omit_uid() {
    uid_field.~OssBitString();
    bit_mask &= ~0x80000000;
}

/* Auxiliary data structures and functions for class __shared3 */

class __shared3_member {
public:
    __shared3_member *next;
    __shared3::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared3_member();
    __shared3_member(const __shared3::component & val);
};

void *__shared3_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared3_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared3_member::__shared3_member() {
}

__shared3_member::__shared3_member(const __shared3::component & val) {
    value = val;
}

static void *__shared3_copy(void *that) {
    return new __shared3_member(((__shared3_member *)that)->value);
}

static void __shared3_destroy(void *that) {
    delete (__shared3_member *)that;
}

static int __shared3_compare(void *val1, void *val2) {
    return (((__shared3_member *)val1)->value == ((__shared3_member *)val2)->value);
}

/* Constructors */

__shared3::__shared3() {
}

__shared3::__shared3(const __shared3 & that) {
    OSSTRY {
	do_copy(that, &__shared3_copy);
    } OSSCLEAN(__shared3)
}

/* Destructor */

__shared3::~__shared3() {
    do_destroy(&__shared3_destroy);
}

/* Operators: assignment, equality, inequality */

__shared3 & __shared3::operator = (const __shared3 & that) {
    do_destroy(&__shared3_destroy);
    do_copy(that, &__shared3_copy);
    return *this;
}

int __shared3::operator == (const __shared3 & that) const {
    return do_compare(that, &__shared3_compare);
}

int __shared3::operator != (const __shared3 & that) const {
    return !do_compare(that, &__shared3_compare);
}

/* Locate ("At" etc) methods */

__shared3::component *__shared3::at(OssIndex pos) {
    return &((__shared3_member *)pos)->value;
}

const __shared3::component *__shared3::at(OssIndex pos) const {
    return &((__shared3_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared3::prepend(const component & val) {
    __shared3_member *newrec = new __shared3_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared3::prepend(__shared3 *seq) {
    return do_prepend(seq);
}

OssIndex __shared3::insert_after(OssIndex pos, const component & val) {
    __shared3_member *newrec = new __shared3_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared3::insert_after(OssIndex pos, __shared3 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared3::remove_front() {
    __shared3_member *extr = (__shared3_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared3_destroy(extr);
    return 0;
}

int __shared3::remove_after(OssIndex pos) {
    __shared3_member *extr = (__shared3_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared3_destroy(extr);
    return 0;
}

/* Extract methods */

__shared3 *__shared3::extract_after(OssIndex begin, OssIndex end) {
    return (__shared3 *)do_extract_after(begin, end);
}

void *ContextAssertion::operator new(size_t size) {
    return ossNewFunc(size);
}

void ContextAssertion::operator delete(void *ptr) {
    asn1Free(ptr);
}

ContextAssertion::ContextAssertion() {
    memset(this, 0, sizeof(ContextAssertion));
}

ContextAssertion::ContextAssertion(const ContextAssertion & that) {
    OSSTRY {
	contextType_field = that.contextType_field;
	contextValues_field = that.contextValues_field;
    } OSSCLEAN(ContextAssertion)
}

ContextAssertion::ContextAssertion(const contextType & contextType_val, const contextValues & contextValues_val) {
    OSSTRY {
	contextType_field = contextType_val;
	contextValues_field = contextValues_val;
    } OSSCLEAN(ContextAssertion)
}

ContextAssertion & ContextAssertion::operator = (const ContextAssertion & that) {
    if (this == &that)
	return *this;
    contextType_field = that.contextType_field;
    contextValues_field = that.contextValues_field;
    return *this;
}

int ContextAssertion::operator == (const ContextAssertion & that) const {
    if (contextType_field != that.contextType_field)
	return 0;
    if (contextValues_field != that.contextValues_field)
	return 0;
    return 1;
}

int ContextAssertion::operator != (const ContextAssertion & that) const {
    return !(operator ==(that));
}

ContextAssertion::contextType & ContextAssertion::get_contextType() {
    return contextType_field;
}

const ContextAssertion::contextType & ContextAssertion::get_contextType() const {
    return contextType_field;
}

void ContextAssertion::set_contextType(const contextType & contextType_val) {
    contextType_field = contextType_val;
}

ContextAssertion::contextValues & ContextAssertion::get_contextValues() {
    return contextValues_field;
}

const ContextAssertion::contextValues & ContextAssertion::get_contextValues() const {
    return contextValues_field;
}

void ContextAssertion::set_contextValues(const contextValues & contextValues_val) {
    contextValues_field = contextValues_val;
}

/* Auxiliary data structures and functions for class __shared28 */

class __shared28_member {
public:
    __shared28_member *next;
    __shared28::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared28_member();
    __shared28_member(const __shared28::component & val);
};

void *__shared28_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared28_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared28_member::__shared28_member() {
}

__shared28_member::__shared28_member(const __shared28::component & val) {
    value = val;
}

static void *__shared28_copy(void *that) {
    return new __shared28_member(((__shared28_member *)that)->value);
}

static void __shared28_destroy(void *that) {
    delete (__shared28_member *)that;
}

static int __shared28_compare(void *val1, void *val2) {
    return (((__shared28_member *)val1)->value == ((__shared28_member *)val2)->value);
}

/* Constructors */

__shared28::__shared28() {
}

__shared28::__shared28(const __shared28 & that) {
    OSSTRY {
	do_copy(that, &__shared28_copy);
    } OSSCLEAN(__shared28)
}

/* Destructor */

__shared28::~__shared28() {
    do_destroy(&__shared28_destroy);
}

/* Operators: assignment, equality, inequality */

__shared28 & __shared28::operator = (const __shared28 & that) {
    do_destroy(&__shared28_destroy);
    do_copy(that, &__shared28_copy);
    return *this;
}

int __shared28::operator == (const __shared28 & that) const {
    return do_compare(that, &__shared28_compare);
}

int __shared28::operator != (const __shared28 & that) const {
    return !do_compare(that, &__shared28_compare);
}

/* Locate ("At" etc) methods */

__shared28::component *__shared28::at(OssIndex pos) {
    return &((__shared28_member *)pos)->value;
}

const __shared28::component *__shared28::at(OssIndex pos) const {
    return &((__shared28_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared28::prepend(const component & val) {
    __shared28_member *newrec = new __shared28_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared28::prepend(__shared28 *seq) {
    return do_prepend(seq);
}

OssIndex __shared28::insert_after(OssIndex pos, const component & val) {
    __shared28_member *newrec = new __shared28_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared28::insert_after(OssIndex pos, __shared28 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared28::remove_front() {
    __shared28_member *extr = (__shared28_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared28_destroy(extr);
    return 0;
}

int __shared28::remove_after(OssIndex pos) {
    __shared28_member *extr = (__shared28_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared28_destroy(extr);
    return 0;
}

/* Extract methods */

__shared28 *__shared28::extract_after(OssIndex begin, OssIndex end) {
    return (__shared28 *)do_extract_after(begin, end);
}

__choice4::__choice4() {
    memset(this, 0, sizeof(__choice4));
}

__choice4::__choice4(const __choice4 & that) {
    memset(this, 0, sizeof(__choice4));
    operator =(that);
}

__choice4::~__choice4() {
    cleanup();
}

__choice4 & __choice4::operator = (const __choice4 & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case allContexts_chosen:
	    *(allContexts *)&allContexts_field = *(allContexts *)&that.allContexts_field;
	    break;
	case selectedContexts_chosen:
	    *(selectedContexts *)&selectedContexts_field = *(selectedContexts *)&that.selectedContexts_field;
	    break;
    }
    return *this;
}

int __choice4::operator == (const __choice4 & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case allContexts_chosen:
	    return *(allContexts *)&allContexts_field == *(allContexts *)&that.allContexts_field;
	case selectedContexts_chosen:
	    return *(selectedContexts *)&selectedContexts_field == *(selectedContexts *)&that.selectedContexts_field;
    }

    return 1;
}

int __choice4::operator != (const __choice4 & that) const {
    return !(operator ==(that));
}

__choice4::allContexts *__choice4::get_allContexts() {
    if (_choice == allContexts_chosen)
	return (allContexts *)&allContexts_field;
    else
	return 0;
}

const __choice4::allContexts *__choice4::get_allContexts() const {
    if (_choice == allContexts_chosen)
	return (const allContexts *)&allContexts_field;
    else
	return 0;
}

void __choice4::set_allContexts(allContexts allContexts_val) {
    cleanup();
    *(allContexts *)&allContexts_field = allContexts_val;
    _choice = allContexts_chosen;
}

__choice4::selectedContexts *__choice4::get_selectedContexts() {
    if (_choice == selectedContexts_chosen)
	return (selectedContexts *)&selectedContexts_field;
    else
	return 0;
}

const __choice4::selectedContexts *__choice4::get_selectedContexts() const {
    if (_choice == selectedContexts_chosen)
	return (const selectedContexts *)&selectedContexts_field;
    else
	return 0;
}

void __choice4::set_selectedContexts(const selectedContexts & selectedContexts_val) {
    cleanup();
    *(selectedContexts *)&selectedContexts_field = selectedContexts_val;
    _choice = selectedContexts_chosen;
}

void __choice4::cleanup() {
    switch (_choice) {
	case allContexts_chosen:
	    break;
	case selectedContexts_chosen:
	    ((selectedContexts *)&selectedContexts_field)->~__shared28();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

void *AttributeValueAssertion::operator new(size_t size) {
    return ossNewFunc(size);
}

void AttributeValueAssertion::operator delete(void *ptr) {
    asn1Free(ptr);
}

AttributeValueAssertion::AttributeValueAssertion() {
    memset(this, 0, sizeof(AttributeValueAssertion));
}

AttributeValueAssertion::AttributeValueAssertion(const AttributeValueAssertion & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	type_field = that.type_field;
	assertion_field = that.assertion_field;
	assertedContexts_field = that.assertedContexts_field;
    } OSSCLEAN(AttributeValueAssertion)
}

AttributeValueAssertion::AttributeValueAssertion(const type & type_val, const assertion & assertion_val, 
    const assertedContexts & assertedContexts_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	type_field = type_val;
	assertion_field = assertion_val;
	assertedContexts_field = assertedContexts_val;
    } OSSCLEAN(AttributeValueAssertion)
}

AttributeValueAssertion::AttributeValueAssertion(const type & type_val, const assertion & assertion_val) {
    OSSTRY {
	bit_mask = 0;
	type_field = type_val;
	assertion_field = assertion_val;
    } OSSCLEAN(AttributeValueAssertion)
}

AttributeValueAssertion & AttributeValueAssertion::operator = (const AttributeValueAssertion & that) {
    if (this == &that)
	return *this;
    this->~AttributeValueAssertion();
    bit_mask = that.bit_mask;
    type_field = that.type_field;
    assertion_field = that.assertion_field;
    assertedContexts_field = that.assertedContexts_field;
    return *this;
}

int AttributeValueAssertion::operator == (const AttributeValueAssertion & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (type_field != that.type_field)
	return 0;
    if (assertion_field != that.assertion_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (assertedContexts_field != that.assertedContexts_field)
	    return 0;
    }
    return 1;
}

int AttributeValueAssertion::operator != (const AttributeValueAssertion & that) const {
    return !(operator ==(that));
}

AttributeValueAssertion::type & AttributeValueAssertion::get_type() {
    return type_field;
}

const AttributeValueAssertion::type & AttributeValueAssertion::get_type() const {
    return type_field;
}

void AttributeValueAssertion::set_type(const type & type_val) {
    type_field = type_val;
}

AttributeValueAssertion::assertion & AttributeValueAssertion::get_assertion() {
    return assertion_field;
}

const AttributeValueAssertion::assertion & AttributeValueAssertion::get_assertion() const {
    return assertion_field;
}

void AttributeValueAssertion::set_assertion(const assertion & assertion_val) {
    assertion_field = assertion_val;
}

AttributeValueAssertion::assertedContexts *AttributeValueAssertion::get_assertedContexts() {
    if (bit_mask & 0x80000000)
	return &assertedContexts_field;
    else
	return 0;
}

const AttributeValueAssertion::assertedContexts *AttributeValueAssertion::get_assertedContexts() const {
    if (bit_mask & 0x80000000)
	return &assertedContexts_field;
    else
	return 0;
}

void AttributeValueAssertion::set_assertedContexts(const assertedContexts & assertedContexts_val) {
    bit_mask |= 0x80000000;
    assertedContexts_field = assertedContexts_val;
}

int AttributeValueAssertion::assertedContexts_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void AttributeValueAssertion::omit_assertedContexts() {
    assertedContexts_field.~__choice4();
    bit_mask &= ~0x80000000;
}

/* Auxiliary data structures and functions for class __seqof2 */

class __seqof2_member {
public:
    __seqof2_member *next;
    __seqof2::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __seqof2_member();
    __seqof2_member(const __seqof2::component & val);
};

void *__seqof2_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof2_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seqof2_member::__seqof2_member() {
}

__seqof2_member::__seqof2_member(const __seqof2::component & val) {
    value = val;
}

static void *__seqof2_copy(void *that) {
    return new __seqof2_member(((__seqof2_member *)that)->value);
}

static void __seqof2_destroy(void *that) {
    delete (__seqof2_member *)that;
}

static int __seqof2_compare(void *val1, void *val2) {
    return (((__seqof2_member *)val1)->value == ((__seqof2_member *)val2)->value);
}

/* Constructors */

__seqof2::__seqof2() {
}

__seqof2::__seqof2(const __seqof2 & that) {
    OSSTRY {
	do_copy(that, &__seqof2_copy);
    } OSSCLEAN(__seqof2)
}

/* Destructor */

__seqof2::~__seqof2() {
    do_destroy(&__seqof2_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof2 & __seqof2::operator = (const __seqof2 & that) {
    do_destroy(&__seqof2_destroy);
    do_copy(that, &__seqof2_copy);
    return *this;
}

int __seqof2::operator == (const __seqof2 & that) const {
    return do_compare(that, &__seqof2_compare);
}

int __seqof2::operator != (const __seqof2 & that) const {
    return !do_compare(that, &__seqof2_compare);
}

/* Locate ("At" etc) methods */

__seqof2::component *__seqof2::at(OssIndex pos) {
    return &((__seqof2_member *)pos)->value;
}

const __seqof2::component *__seqof2::at(OssIndex pos) const {
    return &((__seqof2_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof2::prepend(const component & val) {
    __seqof2_member *newrec = new __seqof2_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __seqof2::prepend(__seqof2 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof2::insert_after(OssIndex pos, const component & val) {
    __seqof2_member *newrec = new __seqof2_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof2::insert_after(OssIndex pos, __seqof2 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof2::remove_front() {
    __seqof2_member *extr = (__seqof2_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof2_destroy(extr);
    return 0;
}

int __seqof2::remove_after(OssIndex pos) {
    __seqof2_member *extr = (__seqof2_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof2_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof2 *__seqof2::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof2 *)do_extract_after(begin, end);
}

void *MultipleMatchingLocalities::operator new(size_t size) {
    return ossNewFunc(size);
}

void MultipleMatchingLocalities::operator delete(void *ptr) {
    asn1Free(ptr);
}

MultipleMatchingLocalities::MultipleMatchingLocalities() {
    memset(this, 0, sizeof(MultipleMatchingLocalities));
}

MultipleMatchingLocalities::MultipleMatchingLocalities(const MultipleMatchingLocalities & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	matchingRuleUsed_field = that.matchingRuleUsed_field;
	attributeList_field = that.attributeList_field;
    } OSSCLEAN(MultipleMatchingLocalities)
}

MultipleMatchingLocalities::MultipleMatchingLocalities(const matchingRuleUsed & matchingRuleUsed_val, 
    const attributeList & attributeList_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	matchingRuleUsed_field = matchingRuleUsed_val;
	attributeList_field = attributeList_val;
    } OSSCLEAN(MultipleMatchingLocalities)
}

MultipleMatchingLocalities::MultipleMatchingLocalities(const attributeList & attributeList_val) {
    OSSTRY {
	bit_mask = 0;
	attributeList_field = attributeList_val;
    } OSSCLEAN(MultipleMatchingLocalities)
}

MultipleMatchingLocalities & MultipleMatchingLocalities::operator = (const MultipleMatchingLocalities & that) {
    if (this == &that)
	return *this;
    this->~MultipleMatchingLocalities();
    bit_mask = that.bit_mask;
    matchingRuleUsed_field = that.matchingRuleUsed_field;
    attributeList_field = that.attributeList_field;
    return *this;
}

int MultipleMatchingLocalities::operator == (const MultipleMatchingLocalities & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (matchingRuleUsed_field != that.matchingRuleUsed_field)
	    return 0;
    }
    if (attributeList_field != that.attributeList_field)
	return 0;
    return 1;
}

int MultipleMatchingLocalities::operator != (const MultipleMatchingLocalities & that) const {
    return !(operator ==(that));
}

MultipleMatchingLocalities::matchingRuleUsed *MultipleMatchingLocalities::get_matchingRuleUsed() {
    if (bit_mask & 0x80000000)
	return &matchingRuleUsed_field;
    else
	return 0;
}

const MultipleMatchingLocalities::matchingRuleUsed *MultipleMatchingLocalities::get_matchingRuleUsed() const {
    if (bit_mask & 0x80000000)
	return &matchingRuleUsed_field;
    else
	return 0;
}

void MultipleMatchingLocalities::set_matchingRuleUsed(const matchingRuleUsed & matchingRuleUsed_val) {
    bit_mask |= 0x80000000;
    matchingRuleUsed_field = matchingRuleUsed_val;
}

int MultipleMatchingLocalities::matchingRuleUsed_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void MultipleMatchingLocalities::omit_matchingRuleUsed() {
    matchingRuleUsed_field.~OssEncOID();
    bit_mask &= ~0x80000000;
}

MultipleMatchingLocalities::attributeList & MultipleMatchingLocalities::get_attributeList() {
    return attributeList_field;
}

const MultipleMatchingLocalities::attributeList & MultipleMatchingLocalities::get_attributeList() const {
    return attributeList_field;
}

void MultipleMatchingLocalities::set_attributeList(const attributeList & attributeList_val) {
    attributeList_field = attributeList_val;
}

/* Auxiliary data structures and functions for class __setof13 */

class __setof13_member {
public:
    __setof13_member *next;
    __setof13::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __setof13_member();
    __setof13_member(const __setof13::component & val);
};

void *__setof13_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __setof13_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__setof13_member::__setof13_member() {
}

__setof13_member::__setof13_member(const __setof13::component & val) {
    value = val;
}

static void *__setof13_copy(void *that) {
    return new __setof13_member(((__setof13_member *)that)->value);
}

static void __setof13_destroy(void *that) {
    delete (__setof13_member *)that;
}

static int __setof13_compare(void *val1, void *val2) {
    return (((__setof13_member *)val1)->value == ((__setof13_member *)val2)->value);
}

/* Constructors */

__setof13::__setof13() {
}

__setof13::__setof13(const __setof13 & that) {
    OSSTRY {
	do_copy(that, &__setof13_copy);
    } OSSCLEAN(__setof13)
}

/* Destructor */

__setof13::~__setof13() {
    do_destroy(&__setof13_destroy);
}

/* Operators: assignment, equality, inequality */

__setof13 & __setof13::operator = (const __setof13 & that) {
    do_destroy(&__setof13_destroy);
    do_copy(that, &__setof13_copy);
    return *this;
}

int __setof13::operator == (const __setof13 & that) const {
    return do_compare(that, &__setof13_compare);
}

int __setof13::operator != (const __setof13 & that) const {
    return !do_compare(that, &__setof13_compare);
}

/* Locate ("At" etc) methods */

__setof13::component *__setof13::at(OssIndex pos) {
    return &((__setof13_member *)pos)->value;
}

const __setof13::component *__setof13::at(OssIndex pos) const {
    return &((__setof13_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __setof13::prepend(const component & val) {
    __setof13_member *newrec = new __setof13_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __setof13::prepend(__setof13 *seq) {
    return do_prepend(seq);
}

OssIndex __setof13::insert_after(OssIndex pos, const component & val) {
    __setof13_member *newrec = new __setof13_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __setof13::insert_after(OssIndex pos, __setof13 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __setof13::remove_front() {
    __setof13_member *extr = (__setof13_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __setof13_destroy(extr);
    return 0;
}

int __setof13::remove_after(OssIndex pos) {
    __setof13_member *extr = (__setof13_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __setof13_destroy(extr);
    return 0;
}

/* Extract methods */

__setof13 *__setof13::extract_after(OssIndex begin, OssIndex end) {
    return (__setof13 *)do_extract_after(begin, end);
}

/* Auxiliary data structures and functions for class __setof14 */

class __setof14_member {
public:
    __setof14_member *next;
    __setof14::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __setof14_member();
    __setof14_member(const __setof14::component & val);
};

void *__setof14_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __setof14_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__setof14_member::__setof14_member() {
}

__setof14_member::__setof14_member(const __setof14::component & val) {
    value = val;
}

static void *__setof14_copy(void *that) {
    return new __setof14_member(((__setof14_member *)that)->value);
}

static void __setof14_destroy(void *that) {
    delete (__setof14_member *)that;
}

static int __setof14_compare(void *val1, void *val2) {
    return (((__setof14_member *)val1)->value == ((__setof14_member *)val2)->value);
}

/* Constructors */

__setof14::__setof14() {
}

__setof14::__setof14(const __setof14 & that) {
    OSSTRY {
	do_copy(that, &__setof14_copy);
    } OSSCLEAN(__setof14)
}

/* Destructor */

__setof14::~__setof14() {
    do_destroy(&__setof14_destroy);
}

/* Operators: assignment, equality, inequality */

__setof14 & __setof14::operator = (const __setof14 & that) {
    do_destroy(&__setof14_destroy);
    do_copy(that, &__setof14_copy);
    return *this;
}

int __setof14::operator == (const __setof14 & that) const {
    return do_compare(that, &__setof14_compare);
}

int __setof14::operator != (const __setof14 & that) const {
    return !do_compare(that, &__setof14_compare);
}

/* Locate ("At" etc) methods */

__setof14::component *__setof14::at(OssIndex pos) {
    return &((__setof14_member *)pos)->value;
}

const __setof14::component *__setof14::at(OssIndex pos) const {
    return &((__setof14_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __setof14::prepend(const component & val) {
    __setof14_member *newrec = new __setof14_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __setof14::prepend(__setof14 *seq) {
    return do_prepend(seq);
}

OssIndex __setof14::insert_after(OssIndex pos, const component & val) {
    __setof14_member *newrec = new __setof14_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __setof14::insert_after(OssIndex pos, __setof14 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __setof14::remove_front() {
    __setof14_member *extr = (__setof14_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __setof14_destroy(extr);
    return 0;
}

int __setof14::remove_after(OssIndex pos) {
    __setof14_member *extr = (__setof14_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __setof14_destroy(extr);
    return 0;
}

/* Extract methods */

__setof14 *__setof14::extract_after(OssIndex begin, OssIndex end) {
    return (__setof14 *)do_extract_after(begin, end);
}

void *Attribute::operator new(size_t size) {
    return ossNewFunc(size);
}

void Attribute::operator delete(void *ptr) {
    asn1Free(ptr);
}

Attribute::Attribute() {
    memset(this, 0, sizeof(Attribute));
}

Attribute::Attribute(const Attribute & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	type_field = that.type_field;
	values_field = that.values_field;
	valuesWithContext_field = that.valuesWithContext_field;
    } OSSCLEAN(Attribute)
}

Attribute::Attribute(const type & type_val, const values & values_val, const valuesWithContext & valuesWithContext_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	type_field = type_val;
	values_field = values_val;
	valuesWithContext_field = valuesWithContext_val;
    } OSSCLEAN(Attribute)
}

Attribute::Attribute(const type & type_val, const values & values_val) {
    OSSTRY {
	bit_mask = 0;
	type_field = type_val;
	values_field = values_val;
    } OSSCLEAN(Attribute)
}

Attribute & Attribute::operator = (const Attribute & that) {
    if (this == &that)
	return *this;
    this->~Attribute();
    bit_mask = that.bit_mask;
    type_field = that.type_field;
    values_field = that.values_field;
    valuesWithContext_field = that.valuesWithContext_field;
    return *this;
}

int Attribute::operator == (const Attribute & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (type_field != that.type_field)
	return 0;
    if (values_field != that.values_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (valuesWithContext_field != that.valuesWithContext_field)
	    return 0;
    }
    return 1;
}

int Attribute::operator != (const Attribute & that) const {
    return !(operator ==(that));
}

Attribute::type & Attribute::get_type() {
    return type_field;
}

const Attribute::type & Attribute::get_type() const {
    return type_field;
}

void Attribute::set_type(const type & type_val) {
    type_field = type_val;
}

Attribute::values & Attribute::get_values() {
    return values_field;
}

const Attribute::values & Attribute::get_values() const {
    return values_field;
}

void Attribute::set_values(const values & values_val) {
    values_field = values_val;
}

Attribute::valuesWithContext *Attribute::get_valuesWithContext() {
    if (bit_mask & 0x80000000)
	return &valuesWithContext_field;
    else
	return 0;
}

const Attribute::valuesWithContext *Attribute::get_valuesWithContext() const {
    if (bit_mask & 0x80000000)
	return &valuesWithContext_field;
    else
	return 0;
}

void Attribute::set_valuesWithContext(const valuesWithContext & valuesWithContext_val) {
    bit_mask |= 0x80000000;
    valuesWithContext_field = valuesWithContext_val;
}

int Attribute::valuesWithContext_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void Attribute::omit_valuesWithContext() {
    valuesWithContext_field.~__setof14();
    bit_mask &= ~0x80000000;
}

__choice5::__choice5() {
    memset(this, 0, sizeof(__choice5));
}

__choice5::__choice5(const __choice5 & that) {
    memset(this, 0, sizeof(__choice5));
    operator =(that);
}

__choice5::~__choice5() {
    cleanup();
}

__choice5 & __choice5::operator = (const __choice5 & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case initial_chosen:
	    if (that.initial_field)
		initial_field = new initial(*that.initial_field);
	    break;
	case any_chosen:
	    if (that.any_field)
		any_field = new any(*that.any_field);
	    break;
	case final_chosen:
	    if (that.final_field)
		final_field = new final(*that.final_field);
	    break;
	case control_chosen:
	    if (that.control_field)
		control_field = new control(*that.control_field);
	    break;
    }
    return *this;
}

int __choice5::operator == (const __choice5 & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case initial_chosen:
	    if ((initial_field) && (that.initial_field))
		return (*initial_field == *(that.initial_field));
	    else if (!((!initial_field) && (!that.initial_field)))
		return 0;
	    break;
	case any_chosen:
	    if ((any_field) && (that.any_field))
		return (*any_field == *(that.any_field));
	    else if (!((!any_field) && (!that.any_field)))
		return 0;
	    break;
	case final_chosen:
	    if ((final_field) && (that.final_field))
		return (*final_field == *(that.final_field));
	    else if (!((!final_field) && (!that.final_field)))
		return 0;
	    break;
	case control_chosen:
	    if ((control_field) && (that.control_field))
		return (*control_field == *(that.control_field));
	    else if (!((!control_field) && (!that.control_field)))
		return 0;
	    break;
    }

    return 1;
}

int __choice5::operator != (const __choice5 & that) const {
    return !(operator ==(that));
}

__choice5::initial *__choice5::get_initial() {
    if (_choice == initial_chosen)
	return (initial *)initial_field;
    else
	return 0;
}

const __choice5::initial *__choice5::get_initial() const {
    if (_choice == initial_chosen)
	return (const initial *)initial_field;
    else
	return 0;
}

void __choice5::set_initial(const initial & initial_val) {
    cleanup();
    initial_field = new initial(initial_val);
    _choice = initial_chosen;
}

__choice5::any *__choice5::get_any() {
    if (_choice == any_chosen)
	return (any *)any_field;
    else
	return 0;
}

const __choice5::any *__choice5::get_any() const {
    if (_choice == any_chosen)
	return (const any *)any_field;
    else
	return 0;
}

void __choice5::set_any(const any & any_val) {
    cleanup();
    any_field = new any(any_val);
    _choice = any_chosen;
}

__choice5::final *__choice5::get_final() {
    if (_choice == final_chosen)
	return (final *)final_field;
    else
	return 0;
}

const __choice5::final *__choice5::get_final() const {
    if (_choice == final_chosen)
	return (const final *)final_field;
    else
	return 0;
}

void __choice5::set_final(const final & final_val) {
    cleanup();
    final_field = new final(final_val);
    _choice = final_chosen;
}

__choice5::control *__choice5::get_control() {
    if (_choice == control_chosen)
	return (control *)control_field;
    else
	return 0;
}

const __choice5::control *__choice5::get_control() const {
    if (_choice == control_chosen)
	return (const control *)control_field;
    else
	return 0;
}

void __choice5::set_control(const control & control_val) {
    cleanup();
    control_field = new control(control_val);
    _choice = control_chosen;
}

void __choice5::cleanup() {
    switch (_choice) {
	case initial_chosen:
	    if (initial_field)
		delete initial_field;
	    break;
	case any_chosen:
	    if (any_field)
		delete any_field;
	    break;
	case final_chosen:
	    if (final_field)
		delete final_field;
	    break;
	case control_chosen:
	    if (control_field)
		delete control_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

/* Auxiliary data structures and functions for class SubstringAssertion */

class SubstringAssertion_member {
public:
    SubstringAssertion_member *next;
    SubstringAssertion::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    SubstringAssertion_member();
    SubstringAssertion_member(const SubstringAssertion::component & val);
};

void *SubstringAssertion_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void SubstringAssertion_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

SubstringAssertion_member::SubstringAssertion_member() {
}

SubstringAssertion_member::SubstringAssertion_member(const SubstringAssertion::component & val) {
    value = val;
}

static void *SubstringAssertion_copy(void *that) {
    return new SubstringAssertion_member(((SubstringAssertion_member *)that)->value);
}

static void SubstringAssertion_destroy(void *that) {
    delete (SubstringAssertion_member *)that;
}

static int SubstringAssertion_compare(void *val1, void *val2) {
    return (((SubstringAssertion_member *)val1)->value == ((SubstringAssertion_member *)val2)->value);
}

/* Constructors */

SubstringAssertion::SubstringAssertion() {
}

SubstringAssertion::SubstringAssertion(const SubstringAssertion & that) {
    OSSTRY {
	do_copy(that, &SubstringAssertion_copy);
    } OSSCLEAN(SubstringAssertion)
}

/* Destructor */

SubstringAssertion::~SubstringAssertion() {
    do_destroy(&SubstringAssertion_destroy);
}

/* Operators: assignment, equality, inequality */

SubstringAssertion & SubstringAssertion::operator = (const SubstringAssertion & that) {
    do_destroy(&SubstringAssertion_destroy);
    do_copy(that, &SubstringAssertion_copy);
    return *this;
}

int SubstringAssertion::operator == (const SubstringAssertion & that) const {
    return do_compare(that, &SubstringAssertion_compare);
}

int SubstringAssertion::operator != (const SubstringAssertion & that) const {
    return !do_compare(that, &SubstringAssertion_compare);
}

/* Locate ("At" etc) methods */

SubstringAssertion::component *SubstringAssertion::at(OssIndex pos) {
    return &((SubstringAssertion_member *)pos)->value;
}

const SubstringAssertion::component *SubstringAssertion::at(OssIndex pos) const {
    return &((SubstringAssertion_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex SubstringAssertion::prepend(const component & val) {
    SubstringAssertion_member *newrec = new SubstringAssertion_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex SubstringAssertion::prepend(SubstringAssertion *seq) {
    return do_prepend(seq);
}

OssIndex SubstringAssertion::insert_after(OssIndex pos, const component & val) {
    SubstringAssertion_member *newrec = new SubstringAssertion_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex SubstringAssertion::insert_after(OssIndex pos, SubstringAssertion *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int SubstringAssertion::remove_front() {
    SubstringAssertion_member *extr = (SubstringAssertion_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    SubstringAssertion_destroy(extr);
    return 0;
}

int SubstringAssertion::remove_after(OssIndex pos) {
    SubstringAssertion_member *extr = (SubstringAssertion_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    SubstringAssertion_destroy(extr);
    return 0;
}

/* Extract methods */

SubstringAssertion *SubstringAssertion::extract_after(OssIndex begin, OssIndex end) {
    return (SubstringAssertion *)do_extract_after(begin, end);
}

__choice6::__choice6() {
    memset(this, 0, sizeof(__choice6));
}

__choice6::__choice6(const __choice6 & that) {
    memset(this, 0, sizeof(__choice6));
    operator =(that);
}

__choice6::~__choice6() {
    cleanup();
}

__choice6 & __choice6::operator = (const __choice6 & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case initial_chosen:
	    *(initial *)&initial_field = *(initial *)&that.initial_field;
	    break;
	case any_chosen:
	    *(any *)&any_field = *(any *)&that.any_field;
	    break;
	case final_chosen:
	    *(final *)&final_field = *(final *)&that.final_field;
	    break;
    }
    return *this;
}

int __choice6::operator == (const __choice6 & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case initial_chosen:
	    return *(initial *)&initial_field == *(initial *)&that.initial_field;
	case any_chosen:
	    return *(any *)&any_field == *(any *)&that.any_field;
	case final_chosen:
	    return *(final *)&final_field == *(final *)&that.final_field;
    }

    return 1;
}

int __choice6::operator != (const __choice6 & that) const {
    return !(operator ==(that));
}

__choice6::initial *__choice6::get_initial() {
    if (_choice == initial_chosen)
	return (initial *)&initial_field;
    else
	return 0;
}

const __choice6::initial *__choice6::get_initial() const {
    if (_choice == initial_chosen)
	return (const initial *)&initial_field;
    else
	return 0;
}

void __choice6::set_initial(const initial & initial_val) {
    cleanup();
    *(initial *)&initial_field = initial_val;
    _choice = initial_chosen;
}

__choice6::any *__choice6::get_any() {
    if (_choice == any_chosen)
	return (any *)&any_field;
    else
	return 0;
}

const __choice6::any *__choice6::get_any() const {
    if (_choice == any_chosen)
	return (const any *)&any_field;
    else
	return 0;
}

void __choice6::set_any(const any & any_val) {
    cleanup();
    *(any *)&any_field = any_val;
    _choice = any_chosen;
}

__choice6::final *__choice6::get_final() {
    if (_choice == final_chosen)
	return (final *)&final_field;
    else
	return 0;
}

const __choice6::final *__choice6::get_final() const {
    if (_choice == final_chosen)
	return (const final *)&final_field;
    else
	return 0;
}

void __choice6::set_final(const final & final_val) {
    cleanup();
    *(final *)&final_field = final_val;
    _choice = final_chosen;
}

void __choice6::cleanup() {
    switch (_choice) {
	case initial_chosen:
	    ((initial *)&initial_field)->~OssString();
	    break;
	case any_chosen:
	    ((any *)&any_field)->~OssString();
	    break;
	case final_chosen:
	    ((final *)&final_field)->~OssString();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

/* Auxiliary data structures and functions for class OctetSubstringAssertion */

class OctetSubstringAssertion_member {
public:
    OctetSubstringAssertion_member *next;
    OctetSubstringAssertion::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    OctetSubstringAssertion_member();
    OctetSubstringAssertion_member(const OctetSubstringAssertion::component & val);
};

void *OctetSubstringAssertion_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void OctetSubstringAssertion_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

OctetSubstringAssertion_member::OctetSubstringAssertion_member() {
}

OctetSubstringAssertion_member::OctetSubstringAssertion_member(const OctetSubstringAssertion::component & val) {
    value = val;
}

static void *OctetSubstringAssertion_copy(void *that) {
    return new OctetSubstringAssertion_member(((OctetSubstringAssertion_member *)that)->value);
}

static void OctetSubstringAssertion_destroy(void *that) {
    delete (OctetSubstringAssertion_member *)that;
}

static int OctetSubstringAssertion_compare(void *val1, void *val2) {
    return (((OctetSubstringAssertion_member *)val1)->value == ((OctetSubstringAssertion_member *)val2)->value);
}

/* Constructors */

OctetSubstringAssertion::OctetSubstringAssertion() {
}

OctetSubstringAssertion::OctetSubstringAssertion(const OctetSubstringAssertion & that) {
    OSSTRY {
	do_copy(that, &OctetSubstringAssertion_copy);
    } OSSCLEAN(OctetSubstringAssertion)
}

/* Destructor */

OctetSubstringAssertion::~OctetSubstringAssertion() {
    do_destroy(&OctetSubstringAssertion_destroy);
}

/* Operators: assignment, equality, inequality */

OctetSubstringAssertion & OctetSubstringAssertion::operator = (const OctetSubstringAssertion & that) {
    do_destroy(&OctetSubstringAssertion_destroy);
    do_copy(that, &OctetSubstringAssertion_copy);
    return *this;
}

int OctetSubstringAssertion::operator == (const OctetSubstringAssertion & that) const {
    return do_compare(that, &OctetSubstringAssertion_compare);
}

int OctetSubstringAssertion::operator != (const OctetSubstringAssertion & that) const {
    return !do_compare(that, &OctetSubstringAssertion_compare);
}

/* Locate ("At" etc) methods */

OctetSubstringAssertion::component *OctetSubstringAssertion::at(OssIndex pos) {
    return &((OctetSubstringAssertion_member *)pos)->value;
}

const OctetSubstringAssertion::component *OctetSubstringAssertion::at(OssIndex pos) const {
    return &((OctetSubstringAssertion_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex OctetSubstringAssertion::prepend(const component & val) {
    OctetSubstringAssertion_member *newrec = new OctetSubstringAssertion_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex OctetSubstringAssertion::prepend(OctetSubstringAssertion *seq) {
    return do_prepend(seq);
}

OssIndex OctetSubstringAssertion::insert_after(OssIndex pos, const component & val) {
    OctetSubstringAssertion_member *newrec = new OctetSubstringAssertion_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex OctetSubstringAssertion::insert_after(OssIndex pos, OctetSubstringAssertion *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int OctetSubstringAssertion::remove_front() {
    OctetSubstringAssertion_member *extr = (OctetSubstringAssertion_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    OctetSubstringAssertion_destroy(extr);
    return 0;
}

int OctetSubstringAssertion::remove_after(OssIndex pos) {
    OctetSubstringAssertion_member *extr = (OctetSubstringAssertion_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    OctetSubstringAssertion_destroy(extr);
    return 0;
}

/* Extract methods */

OctetSubstringAssertion *OctetSubstringAssertion::extract_after(OssIndex begin, OssIndex end) {
    return (OctetSubstringAssertion *)do_extract_after(begin, end);
}

void *DayTime::operator new(size_t size) {
    return ossNewFunc(size);
}

void DayTime::operator delete(void *ptr) {
    asn1Free(ptr);
}

OSS_UINT32 DayTime::get_default_minute() {
    return DayTime::default_minute;
}

OSS_UINT32 DayTime::get_default_second() {
    return DayTime::default_second;
}

DayTime::DayTime() {
    memset(this, 0, sizeof(DayTime));
}

DayTime::DayTime(const DayTime & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	hour_field = that.hour_field;
	minute_field = that.minute_field;
	second_field = that.second_field;
    } OSSCLEAN(DayTime)
}

DayTime::DayTime(hour hour_val, minute minute_val, second second_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	hour_field = hour_val;
	minute_field = minute_val;
	second_field = second_val;
    } OSSCLEAN(DayTime)
}

DayTime::DayTime(hour hour_val) {
    OSSTRY {
	bit_mask = 0;
	hour_field = hour_val;
    } OSSCLEAN(DayTime)
}

DayTime & DayTime::operator = (const DayTime & that) {
    if (this == &that)
	return *this;
    this->~DayTime();
    bit_mask = that.bit_mask;
    hour_field = that.hour_field;
    minute_field = that.minute_field;
    second_field = that.second_field;
    return *this;
}

int DayTime::operator == (const DayTime & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (hour_field != that.hour_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (minute_field != that.minute_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (second_field != that.second_field)
	    return 0;
    }
    return 1;
}

int DayTime::operator != (const DayTime & that) const {
    return !(operator ==(that));
}

DayTime::hour & DayTime::get_hour() {
    return hour_field;
}

DayTime::hour DayTime::get_hour() const {
    return hour_field;
}

void DayTime::set_hour(hour hour_val) {
    hour_field = hour_val;
}

DayTime::minute *DayTime::get_minute() {
    if (bit_mask & 0x80000000)
	return &minute_field;
    else
	return 0;
}

const DayTime::minute *DayTime::get_minute() const {
    if (bit_mask & 0x80000000)
	return &minute_field;
    else
	return 0;
}

void DayTime::set_minute(minute minute_val) {
    bit_mask |= 0x80000000;
    minute_field = minute_val;
}

int DayTime::minute_is_default() const {
    return !(bit_mask & 0x80000000);
}

void DayTime::set_default_minute() {
    bit_mask &= ~0x80000000;
}

DayTime::second *DayTime::get_second() {
    if (bit_mask & 0x40000000)
	return &second_field;
    else
	return 0;
}

const DayTime::second *DayTime::get_second() const {
    if (bit_mask & 0x40000000)
	return &second_field;
    else
	return 0;
}

void DayTime::set_second(second second_val) {
    bit_mask |= 0x40000000;
    second_field = second_val;
}

int DayTime::second_is_default() const {
    return !(bit_mask & 0x40000000);
}

void DayTime::set_default_second() {
    bit_mask &= ~0x40000000;
}

void *DayTimeBand::operator new(size_t size) {
    return ossNewFunc(size);
}

void DayTimeBand::operator delete(void *ptr) {
    asn1Free(ptr);
}

const DayTime& DayTimeBand::get_default_startDayTime() {
    return DayTimeBand::default_startDayTime;
}

const DayTime& DayTimeBand::get_default_endDayTime() {
    return DayTimeBand::default_endDayTime;
}

DayTimeBand::DayTimeBand() {
    memset(this, 0, sizeof(DayTimeBand));
}

DayTimeBand::DayTimeBand(const DayTimeBand & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	if (bit_mask & 0x80000000)
	    startDayTime_field = that.startDayTime_field;
	if (bit_mask & 0x40000000)
	    endDayTime_field = that.endDayTime_field;
    } OSSCLEAN(DayTimeBand)
}

DayTimeBand::DayTimeBand(const startDayTime & startDayTime_val, const endDayTime & endDayTime_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	startDayTime_field = startDayTime_val;
	endDayTime_field = endDayTime_val;
    } OSSCLEAN(DayTimeBand)
}

DayTimeBand::~DayTimeBand() {
    if (!(bit_mask & 0x80000000))
	memset(&startDayTime_field, 0, sizeof(startDayTime));
    if (!(bit_mask & 0x40000000))
	memset(&endDayTime_field, 0, sizeof(endDayTime));
}

DayTimeBand & DayTimeBand::operator = (const DayTimeBand & that) {
    if (this == &that)
	return *this;
    this->~DayTimeBand();
    bit_mask = that.bit_mask;
    if (bit_mask & 0x80000000)
	startDayTime_field = that.startDayTime_field;
    if (bit_mask & 0x40000000)
	endDayTime_field = that.endDayTime_field;
    return *this;
}

int DayTimeBand::operator == (const DayTimeBand & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (startDayTime_field != that.startDayTime_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (endDayTime_field != that.endDayTime_field)
	    return 0;
    }
    return 1;
}

int DayTimeBand::operator != (const DayTimeBand & that) const {
    return !(operator ==(that));
}

DayTimeBand::startDayTime *DayTimeBand::get_startDayTime() {
    if (bit_mask & 0x80000000)
	return &startDayTime_field;
    else
	return 0;
}

const DayTimeBand::startDayTime *DayTimeBand::get_startDayTime() const {
    if (bit_mask & 0x80000000)
	return &startDayTime_field;
    else
	return 0;
}

void DayTimeBand::set_startDayTime(const startDayTime & startDayTime_val) {
    if (!(bit_mask & 0x80000000)) {
	memset(&startDayTime_field, 0, sizeof(startDayTime));
	bit_mask |= 0x80000000;
    }
    startDayTime_field = startDayTime_val;
}

int DayTimeBand::startDayTime_is_default() const {
    return !(bit_mask & 0x80000000);
}

void DayTimeBand::set_default_startDayTime() {
    if (bit_mask & 0x80000000) {
	startDayTime_field.~DayTime();
	bit_mask &= ~0x80000000;
    }
}

DayTimeBand::endDayTime *DayTimeBand::get_endDayTime() {
    if (bit_mask & 0x40000000)
	return &endDayTime_field;
    else
	return 0;
}

const DayTimeBand::endDayTime *DayTimeBand::get_endDayTime() const {
    if (bit_mask & 0x40000000)
	return &endDayTime_field;
    else
	return 0;
}

void DayTimeBand::set_endDayTime(const endDayTime & endDayTime_val) {
    if (!(bit_mask & 0x40000000)) {
	memset(&endDayTime_field, 0, sizeof(endDayTime));
	bit_mask |= 0x40000000;
    }
    endDayTime_field = endDayTime_val;
}

int DayTimeBand::endDayTime_is_default() const {
    return !(bit_mask & 0x40000000);
}

void DayTimeBand::set_default_endDayTime() {
    if (bit_mask & 0x40000000) {
	endDayTime_field.~DayTime();
	bit_mask &= ~0x40000000;
    }
}

NamedDay::NamedDay() {
    memset(this, 0, sizeof(NamedDay));
}

NamedDay::NamedDay(const NamedDay & that) {
    memset(this, 0, sizeof(NamedDay));
    operator =(that);
}

NamedDay::~NamedDay() {
    cleanup();
}

NamedDay & NamedDay::operator = (const NamedDay & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case intNamedDays_chosen:
	    *(intNamedDays *)&intNamedDays_field = *(intNamedDays *)&that.intNamedDays_field;
	    break;
	case bitNamedDays_chosen:
	    *(bitNamedDays *)&bitNamedDays_field = *(bitNamedDays *)&that.bitNamedDays_field;
	    break;
    }
    return *this;
}

int NamedDay::operator == (const NamedDay & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case intNamedDays_chosen:
	    return *(intNamedDays *)&intNamedDays_field == *(intNamedDays *)&that.intNamedDays_field;
	case bitNamedDays_chosen:
	    return *(bitNamedDays *)&bitNamedDays_field == *(bitNamedDays *)&that.bitNamedDays_field;
    }

    return 1;
}

int NamedDay::operator != (const NamedDay & that) const {
    return !(operator ==(that));
}

NamedDay::intNamedDays *NamedDay::get_intNamedDays() {
    if (_choice == intNamedDays_chosen)
	return (intNamedDays *)&intNamedDays_field;
    else
	return 0;
}

const NamedDay::intNamedDays *NamedDay::get_intNamedDays() const {
    if (_choice == intNamedDays_chosen)
	return (const intNamedDays *)&intNamedDays_field;
    else
	return 0;
}

void NamedDay::set_intNamedDays(intNamedDays intNamedDays_val) {
    cleanup();
    *(intNamedDays *)&intNamedDays_field = intNamedDays_val;
    _choice = intNamedDays_chosen;
}

NamedDay::bitNamedDays *NamedDay::get_bitNamedDays() {
    if (_choice == bitNamedDays_chosen)
	return (bitNamedDays *)&bitNamedDays_field;
    else
	return 0;
}

const NamedDay::bitNamedDays *NamedDay::get_bitNamedDays() const {
    if (_choice == bitNamedDays_chosen)
	return (const bitNamedDays *)&bitNamedDays_field;
    else
	return 0;
}

void NamedDay::set_bitNamedDays(const bitNamedDays & bitNamedDays_val) {
    cleanup();
    *(bitNamedDays *)&bitNamedDays_field = bitNamedDays_val;
    _choice = bitNamedDays_chosen;
}

void NamedDay::cleanup() {
    switch (_choice) {
	case intNamedDays_chosen:
	    break;
	case bitNamedDays_chosen:
	    ((bitNamedDays *)&bitNamedDays_field)->~OssBitString();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

XDayOf::XDayOf() {
    memset(this, 0, sizeof(XDayOf));
}

XDayOf::XDayOf(const XDayOf & that) {
    memset(this, 0, sizeof(XDayOf));
    operator =(that);
}

XDayOf::~XDayOf() {
    cleanup();
}

XDayOf & XDayOf::operator = (const XDayOf & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case first_chosen:
	    if (that.first_field)
		first_field = new first(*that.first_field);
	    break;
	case second_chosen:
	    if (that.second_field)
		second_field = new second(*that.second_field);
	    break;
	case third_chosen:
	    if (that.third_field)
		third_field = new third(*that.third_field);
	    break;
	case fourth_chosen:
	    if (that.fourth_field)
		fourth_field = new fourth(*that.fourth_field);
	    break;
	case fifth_chosen:
	    if (that.fifth_field)
		fifth_field = new fifth(*that.fifth_field);
	    break;
    }
    return *this;
}

int XDayOf::operator == (const XDayOf & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case first_chosen:
	    if ((first_field) && (that.first_field))
		return (*first_field == *(that.first_field));
	    else if (!((!first_field) && (!that.first_field)))
		return 0;
	    break;
	case second_chosen:
	    if ((second_field) && (that.second_field))
		return (*second_field == *(that.second_field));
	    else if (!((!second_field) && (!that.second_field)))
		return 0;
	    break;
	case third_chosen:
	    if ((third_field) && (that.third_field))
		return (*third_field == *(that.third_field));
	    else if (!((!third_field) && (!that.third_field)))
		return 0;
	    break;
	case fourth_chosen:
	    if ((fourth_field) && (that.fourth_field))
		return (*fourth_field == *(that.fourth_field));
	    else if (!((!fourth_field) && (!that.fourth_field)))
		return 0;
	    break;
	case fifth_chosen:
	    if ((fifth_field) && (that.fifth_field))
		return (*fifth_field == *(that.fifth_field));
	    else if (!((!fifth_field) && (!that.fifth_field)))
		return 0;
	    break;
    }

    return 1;
}

int XDayOf::operator != (const XDayOf & that) const {
    return !(operator ==(that));
}

XDayOf::first *XDayOf::get_first() {
    if (_choice == first_chosen)
	return (first *)first_field;
    else
	return 0;
}

const XDayOf::first *XDayOf::get_first() const {
    if (_choice == first_chosen)
	return (const first *)first_field;
    else
	return 0;
}

void XDayOf::set_first(const first & first_val) {
    cleanup();
    first_field = new first(first_val);
    _choice = first_chosen;
}

XDayOf::second *XDayOf::get_second() {
    if (_choice == second_chosen)
	return (second *)second_field;
    else
	return 0;
}

const XDayOf::second *XDayOf::get_second() const {
    if (_choice == second_chosen)
	return (const second *)second_field;
    else
	return 0;
}

void XDayOf::set_second(const second & second_val) {
    cleanup();
    second_field = new second(second_val);
    _choice = second_chosen;
}

XDayOf::third *XDayOf::get_third() {
    if (_choice == third_chosen)
	return (third *)third_field;
    else
	return 0;
}

const XDayOf::third *XDayOf::get_third() const {
    if (_choice == third_chosen)
	return (const third *)third_field;
    else
	return 0;
}

void XDayOf::set_third(const third & third_val) {
    cleanup();
    third_field = new third(third_val);
    _choice = third_chosen;
}

XDayOf::fourth *XDayOf::get_fourth() {
    if (_choice == fourth_chosen)
	return (fourth *)fourth_field;
    else
	return 0;
}

const XDayOf::fourth *XDayOf::get_fourth() const {
    if (_choice == fourth_chosen)
	return (const fourth *)fourth_field;
    else
	return 0;
}

void XDayOf::set_fourth(const fourth & fourth_val) {
    cleanup();
    fourth_field = new fourth(fourth_val);
    _choice = fourth_chosen;
}

XDayOf::fifth *XDayOf::get_fifth() {
    if (_choice == fifth_chosen)
	return (fifth *)fifth_field;
    else
	return 0;
}

const XDayOf::fifth *XDayOf::get_fifth() const {
    if (_choice == fifth_chosen)
	return (const fifth *)fifth_field;
    else
	return 0;
}

void XDayOf::set_fifth(const fifth & fifth_val) {
    cleanup();
    fifth_field = new fifth(fifth_val);
    _choice = fifth_chosen;
}

void XDayOf::cleanup() {
    switch (_choice) {
	case first_chosen:
	    if (first_field)
		delete first_field;
	    break;
	case second_chosen:
	    if (second_field)
		delete second_field;
	    break;
	case third_chosen:
	    if (third_field)
		delete third_field;
	    break;
	case fourth_chosen:
	    if (fourth_field)
		delete fourth_field;
	    break;
	case fifth_chosen:
	    if (fifth_field)
		delete fifth_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

__choice7::__choice7() {
    memset(this, 0, sizeof(__choice7));
}

__choice7::__choice7(const __choice7 & that) {
    memset(this, 0, sizeof(__choice7));
    operator =(that);
}

__choice7::~__choice7() {
    cleanup();
}

__choice7 & __choice7::operator = (const __choice7 & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case intDay_chosen:
	    *(intDay *)&intDay_field = *(intDay *)&that.intDay_field;
	    break;
	case bitDay_chosen:
	    *(bitDay *)&bitDay_field = *(bitDay *)&that.bitDay_field;
	    break;
	case dayOf_chosen:
	    if (that.dayOf_field)
		dayOf_field = new dayOf(*that.dayOf_field);
	    break;
    }
    return *this;
}

int __choice7::operator == (const __choice7 & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case intDay_chosen:
	    return *(intDay *)&intDay_field == *(intDay *)&that.intDay_field;
	case bitDay_chosen:
	    return *(bitDay *)&bitDay_field == *(bitDay *)&that.bitDay_field;
	case dayOf_chosen:
	    if ((dayOf_field) && (that.dayOf_field))
		return (*dayOf_field == *(that.dayOf_field));
	    else if (!((!dayOf_field) && (!that.dayOf_field)))
		return 0;
	    break;
    }

    return 1;
}

int __choice7::operator != (const __choice7 & that) const {
    return !(operator ==(that));
}

__choice7::intDay *__choice7::get_intDay() {
    if (_choice == intDay_chosen)
	return (intDay *)&intDay_field;
    else
	return 0;
}

const __choice7::intDay *__choice7::get_intDay() const {
    if (_choice == intDay_chosen)
	return (const intDay *)&intDay_field;
    else
	return 0;
}

void __choice7::set_intDay(const intDay & intDay_val) {
    cleanup();
    *(intDay *)&intDay_field = intDay_val;
    _choice = intDay_chosen;
}

__choice7::bitDay *__choice7::get_bitDay() {
    if (_choice == bitDay_chosen)
	return (bitDay *)&bitDay_field;
    else
	return 0;
}

const __choice7::bitDay *__choice7::get_bitDay() const {
    if (_choice == bitDay_chosen)
	return (const bitDay *)&bitDay_field;
    else
	return 0;
}

void __choice7::set_bitDay(const bitDay & bitDay_val) {
    cleanup();
    *(bitDay *)&bitDay_field = bitDay_val;
    _choice = bitDay_chosen;
}

__choice7::dayOf *__choice7::get_dayOf() {
    if (_choice == dayOf_chosen)
	return (dayOf *)dayOf_field;
    else
	return 0;
}

const __choice7::dayOf *__choice7::get_dayOf() const {
    if (_choice == dayOf_chosen)
	return (const dayOf *)dayOf_field;
    else
	return 0;
}

void __choice7::set_dayOf(const dayOf & dayOf_val) {
    cleanup();
    dayOf_field = new dayOf(dayOf_val);
    _choice = dayOf_chosen;
}

void __choice7::cleanup() {
    switch (_choice) {
	case intDay_chosen:
	    ((intDay *)&intDay_field)->~__shared22();
	    break;
	case bitDay_chosen:
	    ((bitDay *)&bitDay_field)->~OssBitString();
	    break;
	case dayOf_chosen:
	    if (dayOf_field)
		delete dayOf_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

__choice8::__choice8() {
    memset(this, 0, sizeof(__choice8));
}

__choice8::__choice8(const __choice8 & that) {
    memset(this, 0, sizeof(__choice8));
    operator =(that);
}

__choice8::~__choice8() {
    cleanup();
}

__choice8 & __choice8::operator = (const __choice8 & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case allWeeks_chosen:
	    *(allWeeks *)&allWeeks_field = *(allWeeks *)&that.allWeeks_field;
	    break;
	case intWeek_chosen:
	    *(intWeek *)&intWeek_field = *(intWeek *)&that.intWeek_field;
	    break;
	case bitWeek_chosen:
	    *(bitWeek *)&bitWeek_field = *(bitWeek *)&that.bitWeek_field;
	    break;
    }
    return *this;
}

int __choice8::operator == (const __choice8 & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case allWeeks_chosen:
	    return *(allWeeks *)&allWeeks_field == *(allWeeks *)&that.allWeeks_field;
	case intWeek_chosen:
	    return *(intWeek *)&intWeek_field == *(intWeek *)&that.intWeek_field;
	case bitWeek_chosen:
	    return *(bitWeek *)&bitWeek_field == *(bitWeek *)&that.bitWeek_field;
    }

    return 1;
}

int __choice8::operator != (const __choice8 & that) const {
    return !(operator ==(that));
}

__choice8::allWeeks *__choice8::get_allWeeks() {
    if (_choice == allWeeks_chosen)
	return (allWeeks *)&allWeeks_field;
    else
	return 0;
}

const __choice8::allWeeks *__choice8::get_allWeeks() const {
    if (_choice == allWeeks_chosen)
	return (const allWeeks *)&allWeeks_field;
    else
	return 0;
}

void __choice8::set_allWeeks(allWeeks allWeeks_val) {
    cleanup();
    *(allWeeks *)&allWeeks_field = allWeeks_val;
    _choice = allWeeks_chosen;
}

__choice8::intWeek *__choice8::get_intWeek() {
    if (_choice == intWeek_chosen)
	return (intWeek *)&intWeek_field;
    else
	return 0;
}

const __choice8::intWeek *__choice8::get_intWeek() const {
    if (_choice == intWeek_chosen)
	return (const intWeek *)&intWeek_field;
    else
	return 0;
}

void __choice8::set_intWeek(const intWeek & intWeek_val) {
    cleanup();
    *(intWeek *)&intWeek_field = intWeek_val;
    _choice = intWeek_chosen;
}

__choice8::bitWeek *__choice8::get_bitWeek() {
    if (_choice == bitWeek_chosen)
	return (bitWeek *)&bitWeek_field;
    else
	return 0;
}

const __choice8::bitWeek *__choice8::get_bitWeek() const {
    if (_choice == bitWeek_chosen)
	return (const bitWeek *)&bitWeek_field;
    else
	return 0;
}

void __choice8::set_bitWeek(const bitWeek & bitWeek_val) {
    cleanup();
    *(bitWeek *)&bitWeek_field = bitWeek_val;
    _choice = bitWeek_chosen;
}

void __choice8::cleanup() {
    switch (_choice) {
	case allWeeks_chosen:
	    break;
	case intWeek_chosen:
	    ((intWeek *)&intWeek_field)->~__shared22();
	    break;
	case bitWeek_chosen:
	    ((bitWeek *)&bitWeek_field)->~OssBitString();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

__choice9::__choice9() {
    memset(this, 0, sizeof(__choice9));
}

__choice9::__choice9(const __choice9 & that) {
    memset(this, 0, sizeof(__choice9));
    operator =(that);
}

__choice9::~__choice9() {
    cleanup();
}

__choice9 & __choice9::operator = (const __choice9 & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case allMonths_chosen:
	    *(allMonths *)&allMonths_field = *(allMonths *)&that.allMonths_field;
	    break;
	case intMonth_chosen:
	    *(intMonth *)&intMonth_field = *(intMonth *)&that.intMonth_field;
	    break;
	case bitMonth_chosen:
	    *(bitMonth *)&bitMonth_field = *(bitMonth *)&that.bitMonth_field;
	    break;
    }
    return *this;
}

int __choice9::operator == (const __choice9 & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case allMonths_chosen:
	    return *(allMonths *)&allMonths_field == *(allMonths *)&that.allMonths_field;
	case intMonth_chosen:
	    return *(intMonth *)&intMonth_field == *(intMonth *)&that.intMonth_field;
	case bitMonth_chosen:
	    return *(bitMonth *)&bitMonth_field == *(bitMonth *)&that.bitMonth_field;
    }

    return 1;
}

int __choice9::operator != (const __choice9 & that) const {
    return !(operator ==(that));
}

__choice9::allMonths *__choice9::get_allMonths() {
    if (_choice == allMonths_chosen)
	return (allMonths *)&allMonths_field;
    else
	return 0;
}

const __choice9::allMonths *__choice9::get_allMonths() const {
    if (_choice == allMonths_chosen)
	return (const allMonths *)&allMonths_field;
    else
	return 0;
}

void __choice9::set_allMonths(allMonths allMonths_val) {
    cleanup();
    *(allMonths *)&allMonths_field = allMonths_val;
    _choice = allMonths_chosen;
}

__choice9::intMonth *__choice9::get_intMonth() {
    if (_choice == intMonth_chosen)
	return (intMonth *)&intMonth_field;
    else
	return 0;
}

const __choice9::intMonth *__choice9::get_intMonth() const {
    if (_choice == intMonth_chosen)
	return (const intMonth *)&intMonth_field;
    else
	return 0;
}

void __choice9::set_intMonth(const intMonth & intMonth_val) {
    cleanup();
    *(intMonth *)&intMonth_field = intMonth_val;
    _choice = intMonth_chosen;
}

__choice9::bitMonth *__choice9::get_bitMonth() {
    if (_choice == bitMonth_chosen)
	return (bitMonth *)&bitMonth_field;
    else
	return 0;
}

const __choice9::bitMonth *__choice9::get_bitMonth() const {
    if (_choice == bitMonth_chosen)
	return (const bitMonth *)&bitMonth_field;
    else
	return 0;
}

void __choice9::set_bitMonth(const bitMonth & bitMonth_val) {
    cleanup();
    *(bitMonth *)&bitMonth_field = bitMonth_val;
    _choice = bitMonth_chosen;
}

void __choice9::cleanup() {
    switch (_choice) {
	case allMonths_chosen:
	    break;
	case intMonth_chosen:
	    ((intMonth *)&intMonth_field)->~__shared22();
	    break;
	case bitMonth_chosen:
	    ((bitMonth *)&bitMonth_field)->~OssBitString();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

/* Auxiliary data structures and functions for class __setof8 */

class __setof8_member {
public:
    __setof8_member *next;
    __setof8::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __setof8_member();
    __setof8_member(const __setof8::component & val);
};

void *__setof8_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __setof8_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__setof8_member::__setof8_member() {
}

__setof8_member::__setof8_member(const __setof8::component & val) {
    value = val;
}

static void *__setof8_copy(void *that) {
    return new __setof8_member(((__setof8_member *)that)->value);
}

static void __setof8_destroy(void *that) {
    delete (__setof8_member *)that;
}

static int __setof8_compare(void *val1, void *val2) {
    return (((__setof8_member *)val1)->value == ((__setof8_member *)val2)->value);
}

/* Constructors */

__setof8::__setof8() {
}

__setof8::__setof8(const __setof8 & that) {
    OSSTRY {
	do_copy(that, &__setof8_copy);
    } OSSCLEAN(__setof8)
}

/* Destructor */

__setof8::~__setof8() {
    do_destroy(&__setof8_destroy);
}

/* Operators: assignment, equality, inequality */

__setof8 & __setof8::operator = (const __setof8 & that) {
    do_destroy(&__setof8_destroy);
    do_copy(that, &__setof8_copy);
    return *this;
}

int __setof8::operator == (const __setof8 & that) const {
    return do_compare(that, &__setof8_compare);
}

int __setof8::operator != (const __setof8 & that) const {
    return !do_compare(that, &__setof8_compare);
}

/* Locate ("At" etc) methods */

__setof8::component *__setof8::at(OssIndex pos) {
    return &((__setof8_member *)pos)->value;
}

const __setof8::component *__setof8::at(OssIndex pos) const {
    return &((__setof8_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __setof8::prepend(const component & val) {
    __setof8_member *newrec = new __setof8_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __setof8::prepend(__setof8 *seq) {
    return do_prepend(seq);
}

OssIndex __setof8::insert_after(OssIndex pos, const component & val) {
    __setof8_member *newrec = new __setof8_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __setof8::insert_after(OssIndex pos, __setof8 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __setof8::remove_front() {
    __setof8_member *extr = (__setof8_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __setof8_destroy(extr);
    return 0;
}

int __setof8::remove_after(OssIndex pos) {
    __setof8_member *extr = (__setof8_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __setof8_destroy(extr);
    return 0;
}

/* Extract methods */

__setof8 *__setof8::extract_after(OssIndex begin, OssIndex end) {
    return (__setof8 *)do_extract_after(begin, end);
}

/* Auxiliary data structures and functions for class __setof9 */

class __setof9_member {
public:
    __setof9_member *next;
    __setof9::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
};

void *__setof9_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __setof9_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

static void *__setof9_copy(void *that) {
    __setof9_member *result = new __setof9_member;
    if (result)
	result->value = ((__setof9_member *)that)->value;
    return result;
}

static void __setof9_destroy(void *that) {
    delete (__setof9_member *)that;
}

static int __setof9_compare(void *val1, void *val2) {
    return (((__setof9_member *)val1)->value == ((__setof9_member *)val2)->value);
}

/* Constructors */

__setof9::__setof9() {
}

__setof9::__setof9(const __setof9 & that) {
    OSSTRY {
	do_copy(that, &__setof9_copy);
    } OSSCLEAN(__setof9)
}

/* Destructor */

__setof9::~__setof9() {
    do_destroy(&__setof9_destroy);
}

/* Operators: assignment, equality, inequality */

__setof9 & __setof9::operator = (const __setof9 & that) {
    do_destroy(&__setof9_destroy);
    do_copy(that, &__setof9_copy);
    return *this;
}

int __setof9::operator == (const __setof9 & that) const {
    return do_compare(that, &__setof9_compare);
}

int __setof9::operator != (const __setof9 & that) const {
    return !do_compare(that, &__setof9_compare);
}

/* Locate ("At" etc) methods */

__setof9::component *__setof9::at(OssIndex pos) {
    return &((__setof9_member *)pos)->value;
}

const __setof9::component *__setof9::at(OssIndex pos) const {
    return &((__setof9_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __setof9::prepend(component val) {
    __setof9_member *newrec = new __setof9_member();
    if (!newrec)
	return OSS_NOINDEX;
    newrec->value = val;
    return do_prepend(newrec);
}

OssIndex __setof9::prepend(__setof9 *seq) {
    return do_prepend(seq);
}

OssIndex __setof9::insert_after(OssIndex pos, component val) {
    __setof9_member *newrec = new __setof9_member();
    if (!newrec)
	return OSS_NOINDEX;
    newrec->value = val;
    return do_insert_after(pos, newrec);
}

OssIndex __setof9::insert_after(OssIndex pos, __setof9 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __setof9::remove_front() {
    __setof9_member *extr = (__setof9_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __setof9_destroy(extr);
    return 0;
}

int __setof9::remove_after(OssIndex pos) {
    __setof9_member *extr = (__setof9_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __setof9_destroy(extr);
    return 0;
}

/* Extract methods */

__setof9 *__setof9::extract_after(OssIndex begin, OssIndex end) {
    return (__setof9 *)do_extract_after(begin, end);
}

void *Period::operator new(size_t size) {
    return ossNewFunc(size);
}

void Period::operator delete(void *ptr) {
    asn1Free(ptr);
}

Period::Period() {
    memset(this, 0, sizeof(Period));
}

Period::Period(const Period & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	timesOfDay_field = that.timesOfDay_field;
	days_field = that.days_field;
	weeks_field = that.weeks_field;
	months_field = that.months_field;
	years_field = that.years_field;
    } OSSCLEAN(Period)
}

Period::Period(const timesOfDay & timesOfDay_val, const days & days_val, const weeks & weeks_val, 
    const months & months_val, const years & years_val) {
    OSSTRY {
	bit_mask = 0xf8000000;
	timesOfDay_field = timesOfDay_val;
	days_field = days_val;
	weeks_field = weeks_val;
	months_field = months_val;
	years_field = years_val;
    } OSSCLEAN(Period)
}

Period & Period::operator = (const Period & that) {
    if (this == &that)
	return *this;
    this->~Period();
    bit_mask = that.bit_mask;
    timesOfDay_field = that.timesOfDay_field;
    days_field = that.days_field;
    weeks_field = that.weeks_field;
    months_field = that.months_field;
    years_field = that.years_field;
    return *this;
}

int Period::operator == (const Period & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (timesOfDay_field != that.timesOfDay_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (days_field != that.days_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (weeks_field != that.weeks_field)
	    return 0;
    }
    if (bit_mask & 0x10000000) {
	if (months_field != that.months_field)
	    return 0;
    }
    if (bit_mask & 0x8000000) {
	if (years_field != that.years_field)
	    return 0;
    }
    return 1;
}

int Period::operator != (const Period & that) const {
    return !(operator ==(that));
}

Period::timesOfDay *Period::get_timesOfDay() {
    if (bit_mask & 0x80000000)
	return &timesOfDay_field;
    else
	return 0;
}

const Period::timesOfDay *Period::get_timesOfDay() const {
    if (bit_mask & 0x80000000)
	return &timesOfDay_field;
    else
	return 0;
}

void Period::set_timesOfDay(const timesOfDay & timesOfDay_val) {
    bit_mask |= 0x80000000;
    timesOfDay_field = timesOfDay_val;
}

int Period::timesOfDay_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void Period::omit_timesOfDay() {
    timesOfDay_field.~__setof8();
    bit_mask &= ~0x80000000;
}

Period::days *Period::get_days() {
    if (bit_mask & 0x40000000)
	return &days_field;
    else
	return 0;
}

const Period::days *Period::get_days() const {
    if (bit_mask & 0x40000000)
	return &days_field;
    else
	return 0;
}

void Period::set_days(const days & days_val) {
    bit_mask |= 0x40000000;
    days_field = days_val;
}

int Period::days_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void Period::omit_days() {
    days_field.~__choice7();
    bit_mask &= ~0x40000000;
}

Period::weeks *Period::get_weeks() {
    if (bit_mask & 0x20000000)
	return &weeks_field;
    else
	return 0;
}

const Period::weeks *Period::get_weeks() const {
    if (bit_mask & 0x20000000)
	return &weeks_field;
    else
	return 0;
}

void Period::set_weeks(const weeks & weeks_val) {
    bit_mask |= 0x20000000;
    weeks_field = weeks_val;
}

int Period::weeks_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void Period::omit_weeks() {
    weeks_field.~__choice8();
    bit_mask &= ~0x20000000;
}

Period::months *Period::get_months() {
    if (bit_mask & 0x10000000)
	return &months_field;
    else
	return 0;
}

const Period::months *Period::get_months() const {
    if (bit_mask & 0x10000000)
	return &months_field;
    else
	return 0;
}

void Period::set_months(const months & months_val) {
    bit_mask |= 0x10000000;
    months_field = months_val;
}

int Period::months_is_present() const {
    return !!(bit_mask & 0x10000000);
}

void Period::omit_months() {
    months_field.~__choice9();
    bit_mask &= ~0x10000000;
}

Period::years *Period::get_years() {
    if (bit_mask & 0x8000000)
	return &years_field;
    else
	return 0;
}

const Period::years *Period::get_years() const {
    if (bit_mask & 0x8000000)
	return &years_field;
    else
	return 0;
}

void Period::set_years(const years & years_val) {
    bit_mask |= 0x8000000;
    years_field = years_val;
}

int Period::years_is_present() const {
    return !!(bit_mask & 0x8000000);
}

void Period::omit_years() {
    years_field.~__setof9();
    bit_mask &= ~0x8000000;
}

void *__seq10::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq10::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq10::__seq10() {
    memset(this, 0, sizeof(__seq10));
}

__seq10::__seq10(const __seq10 & that) {
    OSSTRY {
	startTime_field = that.startTime_field;
	endTime_field = that.endTime_field;
    } OSSCLEAN(__seq10)
}

__seq10::__seq10(const startTime & startTime_val, const endTime & endTime_val) {
    OSSTRY {
	startTime_field = startTime_val;
	endTime_field = endTime_val;
    } OSSCLEAN(__seq10)
}

__seq10 & __seq10::operator = (const __seq10 & that) {
    if (this == &that)
	return *this;
    this->~__seq10();
    startTime_field = that.startTime_field;
    endTime_field = that.endTime_field;
    return *this;
}

int __seq10::operator == (const __seq10 & that) const {
    if (startTime_field != that.startTime_field)
	return 0;
    if (endTime_field != that.endTime_field)
	return 0;
    return 1;
}

int __seq10::operator != (const __seq10 & that) const {
    return !(operator ==(that));
}

__seq10::startTime *__seq10::get_startTime() {
    if (*(char **)&startTime_field)
	return &startTime_field;
    else
	return 0;
}

const __seq10::startTime *__seq10::get_startTime() const {
    if (*(char **)&startTime_field)
	return &startTime_field;
    else
	return 0;
}

void __seq10::set_startTime(const startTime & startTime_val) {
    startTime_field = startTime_val;
}

int __seq10::startTime_is_present() const {
    return !!(*(char **)&startTime_field);
}

void __seq10::omit_startTime() {
    startTime_field.~OssGeneralizedTime();
}

__seq10::endTime *__seq10::get_endTime() {
    if (*(char **)&endTime_field)
	return &endTime_field;
    else
	return 0;
}

const __seq10::endTime *__seq10::get_endTime() const {
    if (*(char **)&endTime_field)
	return &endTime_field;
    else
	return 0;
}

void __seq10::set_endTime(const endTime & endTime_val) {
    endTime_field = endTime_val;
}

int __seq10::endTime_is_present() const {
    return !!(*(char **)&endTime_field);
}

void __seq10::omit_endTime() {
    endTime_field.~OssGeneralizedTime();
}

/* Auxiliary data structures and functions for class __setof10 */

class __setof10_member {
public:
    __setof10_member *next;
    __setof10::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __setof10_member();
    __setof10_member(const __setof10::component & val);
};

void *__setof10_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __setof10_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__setof10_member::__setof10_member() {
}

__setof10_member::__setof10_member(const __setof10::component & val) {
    value = val;
}

static void *__setof10_copy(void *that) {
    return new __setof10_member(((__setof10_member *)that)->value);
}

static void __setof10_destroy(void *that) {
    delete (__setof10_member *)that;
}

static int __setof10_compare(void *val1, void *val2) {
    return (((__setof10_member *)val1)->value == ((__setof10_member *)val2)->value);
}

/* Constructors */

__setof10::__setof10() {
}

__setof10::__setof10(const __setof10 & that) {
    OSSTRY {
	do_copy(that, &__setof10_copy);
    } OSSCLEAN(__setof10)
}

/* Destructor */

__setof10::~__setof10() {
    do_destroy(&__setof10_destroy);
}

/* Operators: assignment, equality, inequality */

__setof10 & __setof10::operator = (const __setof10 & that) {
    do_destroy(&__setof10_destroy);
    do_copy(that, &__setof10_copy);
    return *this;
}

int __setof10::operator == (const __setof10 & that) const {
    return do_compare(that, &__setof10_compare);
}

int __setof10::operator != (const __setof10 & that) const {
    return !do_compare(that, &__setof10_compare);
}

/* Locate ("At" etc) methods */

__setof10::component *__setof10::at(OssIndex pos) {
    return &((__setof10_member *)pos)->value;
}

const __setof10::component *__setof10::at(OssIndex pos) const {
    return &((__setof10_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __setof10::prepend(const component & val) {
    __setof10_member *newrec = new __setof10_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __setof10::prepend(__setof10 *seq) {
    return do_prepend(seq);
}

OssIndex __setof10::insert_after(OssIndex pos, const component & val) {
    __setof10_member *newrec = new __setof10_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __setof10::insert_after(OssIndex pos, __setof10 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __setof10::remove_front() {
    __setof10_member *extr = (__setof10_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __setof10_destroy(extr);
    return 0;
}

int __setof10::remove_after(OssIndex pos) {
    __setof10_member *extr = (__setof10_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __setof10_destroy(extr);
    return 0;
}

/* Extract methods */

__setof10 *__setof10::extract_after(OssIndex begin, OssIndex end) {
    return (__setof10 *)do_extract_after(begin, end);
}

__choice10::__choice10() {
    memset(this, 0, sizeof(__choice10));
}

__choice10::__choice10(const __choice10 & that) {
    memset(this, 0, sizeof(__choice10));
    operator =(that);
}

__choice10::~__choice10() {
    cleanup();
}

__choice10 & __choice10::operator = (const __choice10 & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case absolute_chosen:
	    if (that.absolute_field)
		absolute_field = new absolute(*that.absolute_field);
	    break;
	case periodic_chosen:
	    *(periodic *)&periodic_field = *(periodic *)&that.periodic_field;
	    break;
    }
    return *this;
}

int __choice10::operator == (const __choice10 & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case absolute_chosen:
	    if ((absolute_field) && (that.absolute_field))
		return (*absolute_field == *(that.absolute_field));
	    else if (!((!absolute_field) && (!that.absolute_field)))
		return 0;
	    break;
	case periodic_chosen:
	    return *(periodic *)&periodic_field == *(periodic *)&that.periodic_field;
    }

    return 1;
}

int __choice10::operator != (const __choice10 & that) const {
    return !(operator ==(that));
}

__choice10::absolute *__choice10::get_absolute() {
    if (_choice == absolute_chosen)
	return (absolute *)absolute_field;
    else
	return 0;
}

const __choice10::absolute *__choice10::get_absolute() const {
    if (_choice == absolute_chosen)
	return (const absolute *)absolute_field;
    else
	return 0;
}

void __choice10::set_absolute(const absolute & absolute_val) {
    cleanup();
    absolute_field = new absolute(absolute_val);
    _choice = absolute_chosen;
}

__choice10::periodic *__choice10::get_periodic() {
    if (_choice == periodic_chosen)
	return (periodic *)&periodic_field;
    else
	return 0;
}

const __choice10::periodic *__choice10::get_periodic() const {
    if (_choice == periodic_chosen)
	return (const periodic *)&periodic_field;
    else
	return 0;
}

void __choice10::set_periodic(const periodic & periodic_val) {
    cleanup();
    *(periodic *)&periodic_field = periodic_val;
    _choice = periodic_chosen;
}

void __choice10::cleanup() {
    switch (_choice) {
	case absolute_chosen:
	    if (absolute_field)
		delete absolute_field;
	    break;
	case periodic_chosen:
	    ((periodic *)&periodic_field)->~__setof10();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

void *TimeSpecification::operator new(size_t size) {
    return ossNewFunc(size);
}

void TimeSpecification::operator delete(void *ptr) {
    asn1Free(ptr);
}

ossBoolean TimeSpecification::get_default_notThisTime() {
    return TimeSpecification::default_notThisTime;
}

TimeSpecification::TimeSpecification() {
    memset(this, 0, sizeof(TimeSpecification));
}

TimeSpecification::TimeSpecification(const TimeSpecification & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	time_field = that.time_field;
	notThisTime_field = that.notThisTime_field;
	timeZone_field = that.timeZone_field;
    } OSSCLEAN(TimeSpecification)
}

TimeSpecification::TimeSpecification(const time & time_val, notThisTime notThisTime_val, 
    timeZone timeZone_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	time_field = time_val;
	notThisTime_field = notThisTime_val;
	timeZone_field = timeZone_val;
    } OSSCLEAN(TimeSpecification)
}

TimeSpecification::TimeSpecification(const time & time_val) {
    OSSTRY {
	bit_mask = 0;
	time_field = time_val;
    } OSSCLEAN(TimeSpecification)
}

TimeSpecification & TimeSpecification::operator = (const TimeSpecification & that) {
    if (this == &that)
	return *this;
    this->~TimeSpecification();
    bit_mask = that.bit_mask;
    time_field = that.time_field;
    notThisTime_field = that.notThisTime_field;
    timeZone_field = that.timeZone_field;
    return *this;
}

int TimeSpecification::operator == (const TimeSpecification & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (time_field != that.time_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (notThisTime_field != that.notThisTime_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (timeZone_field != that.timeZone_field)
	    return 0;
    }
    return 1;
}

int TimeSpecification::operator != (const TimeSpecification & that) const {
    return !(operator ==(that));
}

TimeSpecification::time & TimeSpecification::get_time() {
    return time_field;
}

const TimeSpecification::time & TimeSpecification::get_time() const {
    return time_field;
}

void TimeSpecification::set_time(const time & time_val) {
    time_field = time_val;
}

TimeSpecification::notThisTime *TimeSpecification::get_notThisTime() {
    if (bit_mask & 0x80000000)
	return &notThisTime_field;
    else
	return 0;
}

const TimeSpecification::notThisTime *TimeSpecification::get_notThisTime() const {
    if (bit_mask & 0x80000000)
	return &notThisTime_field;
    else
	return 0;
}

void TimeSpecification::set_notThisTime(notThisTime notThisTime_val) {
    bit_mask |= 0x80000000;
    notThisTime_field = notThisTime_val;
}

int TimeSpecification::notThisTime_is_default() const {
    return !(bit_mask & 0x80000000);
}

void TimeSpecification::set_default_notThisTime() {
    bit_mask &= ~0x80000000;
}

TimeSpecification::timeZone *TimeSpecification::get_timeZone() {
    if (bit_mask & 0x40000000)
	return &timeZone_field;
    else
	return 0;
}

const TimeSpecification::timeZone *TimeSpecification::get_timeZone() const {
    if (bit_mask & 0x40000000)
	return &timeZone_field;
    else
	return 0;
}

void TimeSpecification::set_timeZone(timeZone timeZone_val) {
    bit_mask |= 0x40000000;
    timeZone_field = timeZone_val;
}

int TimeSpecification::timeZone_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void TimeSpecification::omit_timeZone() {
    bit_mask &= ~0x40000000;
}

void *__seq11::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq11::operator delete(void *ptr) {
    asn1Free(ptr);
}

ossBoolean __seq11::get_default_entirely() {
    return __seq11::default_entirely;
}

__seq11::__seq11() {
    memset(this, 0, sizeof(__seq11));
}

__seq11::__seq11(const __seq11 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	startTime_field = that.startTime_field;
	endTime_field = that.endTime_field;
	entirely_field = that.entirely_field;
    } OSSCLEAN(__seq11)
}

__seq11::__seq11(const startTime & startTime_val, const endTime & endTime_val, entirely entirely_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	startTime_field = startTime_val;
	endTime_field = endTime_val;
	entirely_field = entirely_val;
    } OSSCLEAN(__seq11)
}

__seq11::__seq11(const startTime & startTime_val) {
    OSSTRY {
	bit_mask = 0;
	startTime_field = startTime_val;
    } OSSCLEAN(__seq11)
}

__seq11 & __seq11::operator = (const __seq11 & that) {
    if (this == &that)
	return *this;
    this->~__seq11();
    bit_mask = that.bit_mask;
    startTime_field = that.startTime_field;
    endTime_field = that.endTime_field;
    entirely_field = that.entirely_field;
    return *this;
}

int __seq11::operator == (const __seq11 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (startTime_field != that.startTime_field)
	return 0;
    if (endTime_field != that.endTime_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (entirely_field != that.entirely_field)
	    return 0;
    }
    return 1;
}

int __seq11::operator != (const __seq11 & that) const {
    return !(operator ==(that));
}

__seq11::startTime & __seq11::get_startTime() {
    return startTime_field;
}

const __seq11::startTime & __seq11::get_startTime() const {
    return startTime_field;
}

void __seq11::set_startTime(const startTime & startTime_val) {
    startTime_field = startTime_val;
}

__seq11::endTime *__seq11::get_endTime() {
    if (*(char **)&endTime_field)
	return &endTime_field;
    else
	return 0;
}

const __seq11::endTime *__seq11::get_endTime() const {
    if (*(char **)&endTime_field)
	return &endTime_field;
    else
	return 0;
}

void __seq11::set_endTime(const endTime & endTime_val) {
    endTime_field = endTime_val;
}

int __seq11::endTime_is_present() const {
    return !!(*(char **)&endTime_field);
}

void __seq11::omit_endTime() {
    endTime_field.~OssGeneralizedTime();
}

__seq11::entirely *__seq11::get_entirely() {
    if (bit_mask & 0x80000000)
	return &entirely_field;
    else
	return 0;
}

const __seq11::entirely *__seq11::get_entirely() const {
    if (bit_mask & 0x80000000)
	return &entirely_field;
    else
	return 0;
}

void __seq11::set_entirely(entirely entirely_val) {
    bit_mask |= 0x80000000;
    entirely_field = entirely_val;
}

int __seq11::entirely_is_default() const {
    return !(bit_mask & 0x80000000);
}

void __seq11::set_default_entirely() {
    bit_mask &= ~0x80000000;
}

TimeAssertion::TimeAssertion() {
    memset(this, 0, sizeof(TimeAssertion));
}

TimeAssertion::TimeAssertion(const TimeAssertion & that) {
    memset(this, 0, sizeof(TimeAssertion));
    operator =(that);
}

TimeAssertion::~TimeAssertion() {
    cleanup();
}

TimeAssertion & TimeAssertion::operator = (const TimeAssertion & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case now_chosen:
	    *(now *)&now_field = *(now *)&that.now_field;
	    break;
	case at_chosen:
	    *(at *)&at_field = *(at *)&that.at_field;
	    break;
	case between_chosen:
	    if (that.between_field)
		between_field = new between(*that.between_field);
	    break;
    }
    return *this;
}

int TimeAssertion::operator == (const TimeAssertion & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case now_chosen:
	    return *(now *)&now_field == *(now *)&that.now_field;
	case at_chosen:
	    return *(at *)&at_field == *(at *)&that.at_field;
	case between_chosen:
	    if ((between_field) && (that.between_field))
		return (*between_field == *(that.between_field));
	    else if (!((!between_field) && (!that.between_field)))
		return 0;
	    break;
    }

    return 1;
}

int TimeAssertion::operator != (const TimeAssertion & that) const {
    return !(operator ==(that));
}

TimeAssertion::now *TimeAssertion::get_now() {
    if (_choice == now_chosen)
	return (now *)&now_field;
    else
	return 0;
}

const TimeAssertion::now *TimeAssertion::get_now() const {
    if (_choice == now_chosen)
	return (const now *)&now_field;
    else
	return 0;
}

void TimeAssertion::set_now(now now_val) {
    cleanup();
    *(now *)&now_field = now_val;
    _choice = now_chosen;
}

TimeAssertion::at *TimeAssertion::get_at() {
    if (_choice == at_chosen)
	return (at *)&at_field;
    else
	return 0;
}

const TimeAssertion::at *TimeAssertion::get_at() const {
    if (_choice == at_chosen)
	return (const at *)&at_field;
    else
	return 0;
}

void TimeAssertion::set_at(const at & at_val) {
    cleanup();
    *(at *)&at_field = at_val;
    _choice = at_chosen;
}

TimeAssertion::between *TimeAssertion::get_between() {
    if (_choice == between_chosen)
	return (between *)between_field;
    else
	return 0;
}

const TimeAssertion::between *TimeAssertion::get_between() const {
    if (_choice == between_chosen)
	return (const between *)between_field;
    else
	return 0;
}

void TimeAssertion::set_between(const between & between_val) {
    cleanup();
    between_field = new between(between_val);
    _choice = between_chosen;
}

void TimeAssertion::cleanup() {
    switch (_choice) {
	case now_chosen:
	    break;
	case at_chosen:
	    ((at *)&at_field)->~OssGeneralizedTime();
	    break;
	case between_chosen:
	    if (between_field)
		delete between_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

LocaleContextSyntax::LocaleContextSyntax() {
    memset(this, 0, sizeof(LocaleContextSyntax));
}

LocaleContextSyntax::LocaleContextSyntax(const LocaleContextSyntax & that) {
    memset(this, 0, sizeof(LocaleContextSyntax));
    operator =(that);
}

LocaleContextSyntax::~LocaleContextSyntax() {
    cleanup();
}

LocaleContextSyntax & LocaleContextSyntax::operator = (const LocaleContextSyntax & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case localeID1_chosen:
	    *(localeID1 *)&localeID1_field = *(localeID1 *)&that.localeID1_field;
	    break;
	case localeID2_chosen:
	    if (that.localeID2_field)
		localeID2_field = new localeID2(*that.localeID2_field);
	    break;
    }
    return *this;
}

int LocaleContextSyntax::operator == (const LocaleContextSyntax & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case localeID1_chosen:
	    return *(localeID1 *)&localeID1_field == *(localeID1 *)&that.localeID1_field;
	case localeID2_chosen:
	    if ((localeID2_field) && (that.localeID2_field))
		return (*localeID2_field == *(that.localeID2_field));
	    else if (!((!localeID2_field) && (!that.localeID2_field)))
		return 0;
	    break;
    }

    return 1;
}

int LocaleContextSyntax::operator != (const LocaleContextSyntax & that) const {
    return !(operator ==(that));
}

LocaleContextSyntax::localeID1 *LocaleContextSyntax::get_localeID1() {
    if (_choice == localeID1_chosen)
	return (localeID1 *)&localeID1_field;
    else
	return 0;
}

const LocaleContextSyntax::localeID1 *LocaleContextSyntax::get_localeID1() const {
    if (_choice == localeID1_chosen)
	return (const localeID1 *)&localeID1_field;
    else
	return 0;
}

void LocaleContextSyntax::set_localeID1(const localeID1 & localeID1_val) {
    cleanup();
    *(localeID1 *)&localeID1_field = localeID1_val;
    _choice = localeID1_chosen;
}

LocaleContextSyntax::localeID2 *LocaleContextSyntax::get_localeID2() {
    if (_choice == localeID2_chosen)
	return (localeID2 *)localeID2_field;
    else
	return 0;
}

const LocaleContextSyntax::localeID2 *LocaleContextSyntax::get_localeID2() const {
    if (_choice == localeID2_chosen)
	return (const localeID2 *)localeID2_field;
    else
	return 0;
}

void LocaleContextSyntax::set_localeID2(const localeID2 & localeID2_val) {
    cleanup();
    localeID2_field = new localeID2(localeID2_val);
    _choice = localeID2_chosen;
}

void LocaleContextSyntax::cleanup() {
    switch (_choice) {
	case localeID1_chosen:
	    ((localeID1 *)&localeID1_field)->~OssEncOID();
	    break;
	case localeID2_chosen:
	    if (localeID2_field)
		delete localeID2_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

SupportedAttributes_Type::SupportedAttributes_Type()
{
}

SupportedAttributes_Type::SupportedAttributes_Type(const SupportedAttributes_Type & that)
{
    operator =(that);
}

SupportedAttributes_Type::~SupportedAttributes_Type()
{
    cleanup_decoded();
}

SupportedAttributes_Type & SupportedAttributes_Type::operator = (const SupportedAttributes_Type & that)
{
    int result;
    void *copy = nullptr;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = UpperBounds_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int SupportedAttributes_Type::operator == (const SupportedAttributes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return UpperBounds_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int SupportedAttributes_Type::operator != (const SupportedAttributes_Type & that) const
{
    return !(operator ==(that));
}

int SupportedAttributes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = UpperBounds_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int SupportedAttributes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int SupportedAttributes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int SupportedAttributes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int SupportedAttributes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

OssEncOID *SupportedAttributes_Type::get_OssEncOID()
{
    if (pdunum == 1)
	return (OssEncOID *)decoded;
    else
	return nullptr;
}

const OssEncOID *SupportedAttributes_Type::get_OssEncOID() const
{
    if (pdunum == 1)
	return (const OssEncOID *)decoded;
    else
	return nullptr;
}

void SupportedAttributes_Type::set_OssEncOID(const OssEncOID & data)
{
    void *copy;

    copy = new OssEncOID(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 1;
	decoded = copy;
    }
}

OssEncOID *SupportedAttributes_Type::release_OssEncOID()
{
    pdunum = 0;
    decoded = nullptr;
    return get_OssEncOID();
}

void SupportedAttributes_Type::set_OssEncOID(OssEncOID *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 1;
    decoded = data;
}

__shared6 *SupportedAttributes_Type::get_DistinguishedName()
{
    if (pdunum == 51)
	return (__shared6 *)decoded;
    else
	return nullptr;
}

const __shared6 *SupportedAttributes_Type::get_DistinguishedName() const
{
    if (pdunum == 51)
	return (const __shared6 *)decoded;
    else
	return nullptr;
}

void SupportedAttributes_Type::set_DistinguishedName(const __shared6 & data)
{
    void *copy;

    copy = new DistinguishedName(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 51;
	decoded = copy;
    }
}

__shared6 *SupportedAttributes_Type::release_DistinguishedName()
{
    pdunum = 0;
    decoded = nullptr;
    return get_DistinguishedName();
}

void SupportedAttributes_Type::set_DistinguishedName(__shared6 *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 51;
    decoded = data;
}

void SupportedAttributes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	UpperBounds_Table.destroy(decoded, pdunum);
	decoded = nullptr;
	pdunum = 0;
    }
}

void *Context::operator new(size_t size) {
    return ossNewFunc(size);
}

void Context::operator delete(void *ptr) {
    asn1Free(ptr);
}

ossBoolean Context::get_default_fallback() {
    return Context::default_fallback;
}

Context::Context() {
    memset(this, 0, sizeof(Context));
}

Context::Context(const Context & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	contextType_field = that.contextType_field;
	contextValues_field = that.contextValues_field;
	fallback_field = that.fallback_field;
    } OSSCLEAN(Context)
}

Context::Context(const contextType & contextType_val, const contextValues & contextValues_val, 
    fallback fallback_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	contextType_field = contextType_val;
	contextValues_field = contextValues_val;
	fallback_field = fallback_val;
    } OSSCLEAN(Context)
}

Context::Context(const contextType & contextType_val, const contextValues & contextValues_val) {
    OSSTRY {
	bit_mask = 0;
	contextType_field = contextType_val;
	contextValues_field = contextValues_val;
    } OSSCLEAN(Context)
}

Context & Context::operator = (const Context & that) {
    if (this == &that)
	return *this;
    this->~Context();
    bit_mask = that.bit_mask;
    contextType_field = that.contextType_field;
    contextValues_field = that.contextValues_field;
    fallback_field = that.fallback_field;
    return *this;
}

int Context::operator == (const Context & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (contextType_field != that.contextType_field)
	return 0;
    if (contextValues_field != that.contextValues_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (fallback_field != that.fallback_field)
	    return 0;
    }
    return 1;
}

int Context::operator != (const Context & that) const {
    return !(operator ==(that));
}

Context::contextType & Context::get_contextType() {
    return contextType_field;
}

const Context::contextType & Context::get_contextType() const {
    return contextType_field;
}

void Context::set_contextType(const contextType & contextType_val) {
    contextType_field = contextType_val;
}

Context::contextValues & Context::get_contextValues() {
    return contextValues_field;
}

const Context::contextValues & Context::get_contextValues() const {
    return contextValues_field;
}

void Context::set_contextValues(const contextValues & contextValues_val) {
    contextValues_field = contextValues_val;
}

Context::fallback *Context::get_fallback() {
    if (bit_mask & 0x80000000)
	return &fallback_field;
    else
	return 0;
}

const Context::fallback *Context::get_fallback() const {
    if (bit_mask & 0x80000000)
	return &fallback_field;
    else
	return 0;
}

void Context::set_fallback(fallback fallback_val) {
    bit_mask |= 0x80000000;
    fallback_field = fallback_val;
}

int Context::fallback_is_default() const {
    return !(bit_mask & 0x80000000);
}

void Context::set_default_fallback() {
    bit_mask &= ~0x80000000;
}

/* Auxiliary data structures and functions for class __shared4 */

class __shared4_member {
public:
    __shared4_member *next;
    __shared4::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared4_member();
    __shared4_member(const __shared4::component & val);
};

void *__shared4_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared4_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared4_member::__shared4_member() {
}

__shared4_member::__shared4_member(const __shared4::component & val) {
    value = val;
}

static void *__shared4_copy(void *that) {
    return new __shared4_member(((__shared4_member *)that)->value);
}

static void __shared4_destroy(void *that) {
    delete (__shared4_member *)that;
}

static int __shared4_compare(void *val1, void *val2) {
    return (((__shared4_member *)val1)->value == ((__shared4_member *)val2)->value);
}

/* Constructors */

__shared4::__shared4() {
}

__shared4::__shared4(const __shared4 & that) {
    OSSTRY {
	do_copy(that, &__shared4_copy);
    } OSSCLEAN(__shared4)
}

/* Destructor */

__shared4::~__shared4() {
    do_destroy(&__shared4_destroy);
}

/* Operators: assignment, equality, inequality */

__shared4 & __shared4::operator = (const __shared4 & that) {
    do_destroy(&__shared4_destroy);
    do_copy(that, &__shared4_copy);
    return *this;
}

int __shared4::operator == (const __shared4 & that) const {
    return do_compare(that, &__shared4_compare);
}

int __shared4::operator != (const __shared4 & that) const {
    return !do_compare(that, &__shared4_compare);
}

/* Locate ("At" etc) methods */

__shared4::component *__shared4::at(OssIndex pos) {
    return &((__shared4_member *)pos)->value;
}

const __shared4::component *__shared4::at(OssIndex pos) const {
    return &((__shared4_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared4::prepend(const component & val) {
    __shared4_member *newrec = new __shared4_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared4::prepend(__shared4 *seq) {
    return do_prepend(seq);
}

OssIndex __shared4::insert_after(OssIndex pos, const component & val) {
    __shared4_member *newrec = new __shared4_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared4::insert_after(OssIndex pos, __shared4 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared4::remove_front() {
    __shared4_member *extr = (__shared4_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared4_destroy(extr);
    return 0;
}

int __shared4::remove_after(OssIndex pos) {
    __shared4_member *extr = (__shared4_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared4_destroy(extr);
    return 0;
}

/* Extract methods */

__shared4 *__shared4::extract_after(OssIndex begin, OssIndex end) {
    return (__shared4 *)do_extract_after(begin, end);
}

void *__seq12::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq12::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq12::__seq12() {
    memset(this, 0, sizeof(__seq12));
}

__seq12::__seq12(const __seq12 & that) {
    OSSTRY {
	value_field = that.value_field;
	contextList_field = that.contextList_field;
    } OSSCLEAN(__seq12)
}

__seq12::__seq12(const value & value_val, const contextList & contextList_val) {
    OSSTRY {
	value_field = value_val;
	contextList_field = contextList_val;
    } OSSCLEAN(__seq12)
}

__seq12 & __seq12::operator = (const __seq12 & that) {
    if (this == &that)
	return *this;
    value_field = that.value_field;
    contextList_field = that.contextList_field;
    return *this;
}

int __seq12::operator == (const __seq12 & that) const {
    if (value_field != that.value_field)
	return 0;
    if (contextList_field != that.contextList_field)
	return 0;
    return 1;
}

int __seq12::operator != (const __seq12 & that) const {
    return !(operator ==(that));
}

__seq12::value & __seq12::get_value() {
    return value_field;
}

const __seq12::value & __seq12::get_value() const {
    return value_field;
}

void __seq12::set_value(const value & value_val) {
    value_field = value_val;
}

__seq12::contextList & __seq12::get_contextList() {
    return contextList_field;
}

const __seq12::contextList & __seq12::get_contextList() const {
    return contextList_field;
}

void __seq12::set_contextList(const contextList & contextList_val) {
    contextList_field = contextList_val;
}

void *AttributeTypeAssertion::operator new(size_t size) {
    return ossNewFunc(size);
}

void AttributeTypeAssertion::operator delete(void *ptr) {
    asn1Free(ptr);
}

AttributeTypeAssertion::AttributeTypeAssertion() {
    memset(this, 0, sizeof(AttributeTypeAssertion));
}

AttributeTypeAssertion::AttributeTypeAssertion(const AttributeTypeAssertion & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	type_field = that.type_field;
	assertedContexts_field = that.assertedContexts_field;
    } OSSCLEAN(AttributeTypeAssertion)
}

AttributeTypeAssertion::AttributeTypeAssertion(const type & type_val, const assertedContexts & assertedContexts_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	type_field = type_val;
	assertedContexts_field = assertedContexts_val;
    } OSSCLEAN(AttributeTypeAssertion)
}

AttributeTypeAssertion::AttributeTypeAssertion(const type & type_val) {
    OSSTRY {
	bit_mask = 0;
	type_field = type_val;
    } OSSCLEAN(AttributeTypeAssertion)
}

AttributeTypeAssertion & AttributeTypeAssertion::operator = (const AttributeTypeAssertion & that) {
    if (this == &that)
	return *this;
    this->~AttributeTypeAssertion();
    bit_mask = that.bit_mask;
    type_field = that.type_field;
    assertedContexts_field = that.assertedContexts_field;
    return *this;
}

int AttributeTypeAssertion::operator == (const AttributeTypeAssertion & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (type_field != that.type_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (assertedContexts_field != that.assertedContexts_field)
	    return 0;
    }
    return 1;
}

int AttributeTypeAssertion::operator != (const AttributeTypeAssertion & that) const {
    return !(operator ==(that));
}

AttributeTypeAssertion::type & AttributeTypeAssertion::get_type() {
    return type_field;
}

const AttributeTypeAssertion::type & AttributeTypeAssertion::get_type() const {
    return type_field;
}

void AttributeTypeAssertion::set_type(const type & type_val) {
    type_field = type_val;
}

AttributeTypeAssertion::assertedContexts *AttributeTypeAssertion::get_assertedContexts() {
    if (bit_mask & 0x80000000)
	return &assertedContexts_field;
    else
	return 0;
}

const AttributeTypeAssertion::assertedContexts *AttributeTypeAssertion::get_assertedContexts() const {
    if (bit_mask & 0x80000000)
	return &assertedContexts_field;
    else
	return 0;
}

void AttributeTypeAssertion::set_assertedContexts(const assertedContexts & assertedContexts_val) {
    bit_mask |= 0x80000000;
    assertedContexts_field = assertedContexts_val;
}

int AttributeTypeAssertion::assertedContexts_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void AttributeTypeAssertion::omit_assertedContexts() {
    assertedContexts_field.~__shared28();
    bit_mask &= ~0x80000000;
}

/* Auxiliary data structures and functions for class __setof16 */

class __setof16_member {
public:
    __setof16_member *next;
    __setof16::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __setof16_member();
    __setof16_member(const __setof16::component & val);
};

void *__setof16_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __setof16_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__setof16_member::__setof16_member() {
}

__setof16_member::__setof16_member(const __setof16::component & val) {
    value = val;
}

static void *__setof16_copy(void *that) {
    return new __setof16_member(((__setof16_member *)that)->value);
}

static void __setof16_destroy(void *that) {
    delete (__setof16_member *)that;
}

static int __setof16_compare(void *val1, void *val2) {
    return (((__setof16_member *)val1)->value == ((__setof16_member *)val2)->value);
}

/* Constructors */

__setof16::__setof16() {
}

__setof16::__setof16(const __setof16 & that) {
    OSSTRY {
	do_copy(that, &__setof16_copy);
    } OSSCLEAN(__setof16)
}

/* Destructor */

__setof16::~__setof16() {
    do_destroy(&__setof16_destroy);
}

/* Operators: assignment, equality, inequality */

__setof16 & __setof16::operator = (const __setof16 & that) {
    do_destroy(&__setof16_destroy);
    do_copy(that, &__setof16_copy);
    return *this;
}

int __setof16::operator == (const __setof16 & that) const {
    return do_compare(that, &__setof16_compare);
}

int __setof16::operator != (const __setof16 & that) const {
    return !do_compare(that, &__setof16_compare);
}

/* Locate ("At" etc) methods */

__setof16::component *__setof16::at(OssIndex pos) {
    return &((__setof16_member *)pos)->value;
}

const __setof16::component *__setof16::at(OssIndex pos) const {
    return &((__setof16_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __setof16::prepend(const component & val) {
    __setof16_member *newrec = new __setof16_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __setof16::prepend(__setof16 *seq) {
    return do_prepend(seq);
}

OssIndex __setof16::insert_after(OssIndex pos, const component & val) {
    __setof16_member *newrec = new __setof16_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __setof16::insert_after(OssIndex pos, __setof16 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __setof16::remove_front() {
    __setof16_member *extr = (__setof16_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __setof16_destroy(extr);
    return 0;
}

int __setof16::remove_after(OssIndex pos) {
    __setof16_member *extr = (__setof16_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __setof16_destroy(extr);
    return 0;
}

/* Extract methods */

__setof16 *__setof16::extract_after(OssIndex begin, OssIndex end) {
    return (__setof16 *)do_extract_after(begin, end);
}

void *AttributeTypeAndDistinguishedValue::operator new(size_t size) {
    return ossNewFunc(size);
}

void AttributeTypeAndDistinguishedValue::operator delete(void *ptr) {
    asn1Free(ptr);
}

ossBoolean AttributeTypeAndDistinguishedValue::get_default_primaryDistinguished() {
    return AttributeTypeAndDistinguishedValue::default_primaryDistinguished;
}

AttributeTypeAndDistinguishedValue::AttributeTypeAndDistinguishedValue() {
    memset(this, 0, sizeof(AttributeTypeAndDistinguishedValue));
}

AttributeTypeAndDistinguishedValue::AttributeTypeAndDistinguishedValue(const AttributeTypeAndDistinguishedValue & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	type_field = that.type_field;
	value_field = that.value_field;
	primaryDistinguished_field = that.primaryDistinguished_field;
	valuesWithContext_field = that.valuesWithContext_field;
    } OSSCLEAN(AttributeTypeAndDistinguishedValue)
}

AttributeTypeAndDistinguishedValue::AttributeTypeAndDistinguishedValue(const type & type_val, 
    const value & value_val, primaryDistinguished primaryDistinguished_val, const valuesWithContext & valuesWithContext_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	type_field = type_val;
	value_field = value_val;
	primaryDistinguished_field = primaryDistinguished_val;
	valuesWithContext_field = valuesWithContext_val;
    } OSSCLEAN(AttributeTypeAndDistinguishedValue)
}

AttributeTypeAndDistinguishedValue::AttributeTypeAndDistinguishedValue(const type & type_val, 
    const value & value_val) {
    OSSTRY {
	bit_mask = 0;
	type_field = type_val;
	value_field = value_val;
    } OSSCLEAN(AttributeTypeAndDistinguishedValue)
}

AttributeTypeAndDistinguishedValue & AttributeTypeAndDistinguishedValue::operator = (const AttributeTypeAndDistinguishedValue & that) {
    if (this == &that)
	return *this;
    this->~AttributeTypeAndDistinguishedValue();
    bit_mask = that.bit_mask;
    type_field = that.type_field;
    value_field = that.value_field;
    primaryDistinguished_field = that.primaryDistinguished_field;
    valuesWithContext_field = that.valuesWithContext_field;
    return *this;
}

int AttributeTypeAndDistinguishedValue::operator == (const AttributeTypeAndDistinguishedValue & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (type_field != that.type_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (primaryDistinguished_field != that.primaryDistinguished_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (valuesWithContext_field != that.valuesWithContext_field)
	    return 0;
    }
    return 1;
}

int AttributeTypeAndDistinguishedValue::operator != (const AttributeTypeAndDistinguishedValue & that) const {
    return !(operator ==(that));
}

AttributeTypeAndDistinguishedValue::type & AttributeTypeAndDistinguishedValue::get_type() {
    return type_field;
}

const AttributeTypeAndDistinguishedValue::type & AttributeTypeAndDistinguishedValue::get_type() const {
    return type_field;
}

void AttributeTypeAndDistinguishedValue::set_type(const type & type_val) {
    type_field = type_val;
}

AttributeTypeAndDistinguishedValue::value & AttributeTypeAndDistinguishedValue::get_value() {
    return value_field;
}

const AttributeTypeAndDistinguishedValue::value & AttributeTypeAndDistinguishedValue::get_value() const {
    return value_field;
}

void AttributeTypeAndDistinguishedValue::set_value(const value & value_val) {
    value_field = value_val;
}

AttributeTypeAndDistinguishedValue::primaryDistinguished *AttributeTypeAndDistinguishedValue::get_primaryDistinguished() {
    if (bit_mask & 0x80000000)
	return &primaryDistinguished_field;
    else
	return 0;
}

const AttributeTypeAndDistinguishedValue::primaryDistinguished *AttributeTypeAndDistinguishedValue::get_primaryDistinguished() const {
    if (bit_mask & 0x80000000)
	return &primaryDistinguished_field;
    else
	return 0;
}

void AttributeTypeAndDistinguishedValue::set_primaryDistinguished(primaryDistinguished primaryDistinguished_val) {
    bit_mask |= 0x80000000;
    primaryDistinguished_field = primaryDistinguished_val;
}

int AttributeTypeAndDistinguishedValue::primaryDistinguished_is_default() const {
    return !(bit_mask & 0x80000000);
}

void AttributeTypeAndDistinguishedValue::set_default_primaryDistinguished() {
    bit_mask &= ~0x80000000;
}

AttributeTypeAndDistinguishedValue::valuesWithContext *AttributeTypeAndDistinguishedValue::get_valuesWithContext() {
    if (bit_mask & 0x40000000)
	return &valuesWithContext_field;
    else
	return 0;
}

const AttributeTypeAndDistinguishedValue::valuesWithContext *AttributeTypeAndDistinguishedValue::get_valuesWithContext() const {
    if (bit_mask & 0x40000000)
	return &valuesWithContext_field;
    else
	return 0;
}

void AttributeTypeAndDistinguishedValue::set_valuesWithContext(const valuesWithContext & valuesWithContext_val) {
    bit_mask |= 0x40000000;
    valuesWithContext_field = valuesWithContext_val;
}

int AttributeTypeAndDistinguishedValue::valuesWithContext_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void AttributeTypeAndDistinguishedValue::omit_valuesWithContext() {
    valuesWithContext_field.~__setof16();
    bit_mask &= ~0x40000000;
}

void *__seq13::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq13::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq13::__seq13() {
    memset(this, 0, sizeof(__seq13));
}

__seq13::__seq13(const __seq13 & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	distingAttrValue_field = that.distingAttrValue_field;
	contextList_field = that.contextList_field;
    } OSSCLEAN(__seq13)
}

__seq13::__seq13(const distingAttrValue & distingAttrValue_val, const contextList & contextList_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	distingAttrValue_field = distingAttrValue_val;
	contextList_field = contextList_val;
    } OSSCLEAN(__seq13)
}

__seq13::__seq13(const contextList & contextList_val) {
    OSSTRY {
	bit_mask = 0;
	contextList_field = contextList_val;
    } OSSCLEAN(__seq13)
}

__seq13 & __seq13::operator = (const __seq13 & that) {
    if (this == &that)
	return *this;
    this->~__seq13();
    bit_mask = that.bit_mask;
    distingAttrValue_field = that.distingAttrValue_field;
    contextList_field = that.contextList_field;
    return *this;
}

int __seq13::operator == (const __seq13 & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (distingAttrValue_field != that.distingAttrValue_field)
	    return 0;
    }
    if (contextList_field != that.contextList_field)
	return 0;
    return 1;
}

int __seq13::operator != (const __seq13 & that) const {
    return !(operator ==(that));
}

__seq13::distingAttrValue *__seq13::get_distingAttrValue() {
    if (bit_mask & 0x80000000)
	return &distingAttrValue_field;
    else
	return 0;
}

const __seq13::distingAttrValue *__seq13::get_distingAttrValue() const {
    if (bit_mask & 0x80000000)
	return &distingAttrValue_field;
    else
	return 0;
}

void __seq13::set_distingAttrValue(const distingAttrValue & distingAttrValue_val) {
    bit_mask |= 0x80000000;
    distingAttrValue_field = distingAttrValue_val;
}

int __seq13::distingAttrValue_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void __seq13::omit_distingAttrValue() {
    distingAttrValue_field.~SupportedAttributes_Type();
    bit_mask &= ~0x80000000;
}

__seq13::contextList & __seq13::get_contextList() {
    return contextList_field;
}

const __seq13::contextList & __seq13::get_contextList() const {
    return contextList_field;
}

void __seq13::set_contextList(const contextList & contextList_val) {
    contextList_field = contextList_val;
}

/* Auxiliary data structures and functions for class __shared29 */

class __shared29_member {
public:
    __shared29_member *next;
    __shared29::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared29_member();
    __shared29_member(const __shared29::component & val);
};

void *__shared29_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared29_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared29_member::__shared29_member() {
}

__shared29_member::__shared29_member(const __shared29::component & val) {
    value = val;
}

static void *__shared29_copy(void *that) {
    return new __shared29_member(((__shared29_member *)that)->value);
}

static void __shared29_destroy(void *that) {
    delete (__shared29_member *)that;
}

static int __shared29_compare(void *val1, void *val2) {
    return (((__shared29_member *)val1)->value == ((__shared29_member *)val2)->value);
}

/* Constructors */

__shared29::__shared29() {
}

__shared29::__shared29(const __shared29 & that) {
    OSSTRY {
	do_copy(that, &__shared29_copy);
    } OSSCLEAN(__shared29)
}

/* Destructor */

__shared29::~__shared29() {
    do_destroy(&__shared29_destroy);
}

/* Operators: assignment, equality, inequality */

__shared29 & __shared29::operator = (const __shared29 & that) {
    do_destroy(&__shared29_destroy);
    do_copy(that, &__shared29_copy);
    return *this;
}

int __shared29::operator == (const __shared29 & that) const {
    return do_compare(that, &__shared29_compare);
}

int __shared29::operator != (const __shared29 & that) const {
    return !do_compare(that, &__shared29_compare);
}

/* Locate ("At" etc) methods */

__shared29::component *__shared29::at(OssIndex pos) {
    return &((__shared29_member *)pos)->value;
}

const __shared29::component *__shared29::at(OssIndex pos) const {
    return &((__shared29_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared29::prepend(const component & val) {
    __shared29_member *newrec = new __shared29_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared29::prepend(__shared29 *seq) {
    return do_prepend(seq);
}

OssIndex __shared29::insert_after(OssIndex pos, const component & val) {
    __shared29_member *newrec = new __shared29_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared29::insert_after(OssIndex pos, __shared29 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared29::remove_front() {
    __shared29_member *extr = (__shared29_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared29_destroy(extr);
    return 0;
}

int __shared29::remove_after(OssIndex pos) {
    __shared29_member *extr = (__shared29_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared29_destroy(extr);
    return 0;
}

/* Extract methods */

__shared29 *__shared29::extract_after(OssIndex begin, OssIndex end) {
    return (__shared29 *)do_extract_after(begin, end);
}

Refinement::Refinement() {
    memset(this, 0, sizeof(Refinement));
}

Refinement::Refinement(const Refinement & that) {
    memset(this, 0, sizeof(Refinement));
    operator =(that);
}

Refinement::~Refinement() {
    cleanup();
}

Refinement & Refinement::operator = (const Refinement & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case item_chosen:
	    *(item *)&item_field = *(item *)&that.item_field;
	    break;
	case Refinement_and_chosen:
	    *(Refinement_and *)&Refinement_and_field = *(Refinement_and *)&that.Refinement_and_field;
	    break;
	case Refinement_or_chosen:
	    *(Refinement_or *)&Refinement_or_field = *(Refinement_or *)&that.Refinement_or_field;
	    break;
	case Refinement_not_chosen:
	    if (that.Refinement_not_field)
		Refinement_not_field = new Refinement_not(*that.Refinement_not_field);
	    break;
    }
    return *this;
}

int Refinement::operator == (const Refinement & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case item_chosen:
	    return *(item *)&item_field == *(item *)&that.item_field;
	case Refinement_and_chosen:
	    return *(Refinement_and *)&Refinement_and_field == *(Refinement_and *)&that.Refinement_and_field;
	case Refinement_or_chosen:
	    return *(Refinement_or *)&Refinement_or_field == *(Refinement_or *)&that.Refinement_or_field;
	case Refinement_not_chosen:
	    if ((Refinement_not_field) && (that.Refinement_not_field))
		return (*Refinement_not_field == *(that.Refinement_not_field));
	    else if (!((!Refinement_not_field) && (!that.Refinement_not_field)))
		return 0;
	    break;
    }

    return 1;
}

int Refinement::operator != (const Refinement & that) const {
    return !(operator ==(that));
}

Refinement::item *Refinement::get_item() {
    if (_choice == item_chosen)
	return (item *)&item_field;
    else
	return 0;
}

const Refinement::item *Refinement::get_item() const {
    if (_choice == item_chosen)
	return (const item *)&item_field;
    else
	return 0;
}

void Refinement::set_item(const item & item_val) {
    cleanup();
    *(item *)&item_field = item_val;
    _choice = item_chosen;
}

Refinement::Refinement_and *Refinement::get_Refinement_and() {
    if (_choice == Refinement_and_chosen)
	return (Refinement_and *)&Refinement_and_field;
    else
	return 0;
}

const Refinement::Refinement_and *Refinement::get_Refinement_and() const {
    if (_choice == Refinement_and_chosen)
	return (const Refinement_and *)&Refinement_and_field;
    else
	return 0;
}

void Refinement::set_Refinement_and(const Refinement_and & Refinement_and_val) {
    cleanup();
    *(Refinement_and *)&Refinement_and_field = Refinement_and_val;
    _choice = Refinement_and_chosen;
}

Refinement::Refinement_or *Refinement::get_Refinement_or() {
    if (_choice == Refinement_or_chosen)
	return (Refinement_or *)&Refinement_or_field;
    else
	return 0;
}

const Refinement::Refinement_or *Refinement::get_Refinement_or() const {
    if (_choice == Refinement_or_chosen)
	return (const Refinement_or *)&Refinement_or_field;
    else
	return 0;
}

void Refinement::set_Refinement_or(const Refinement_or & Refinement_or_val) {
    cleanup();
    *(Refinement_or *)&Refinement_or_field = Refinement_or_val;
    _choice = Refinement_or_chosen;
}

Refinement::Refinement_not *Refinement::get_Refinement_not() {
    if (_choice == Refinement_not_chosen)
	return (Refinement_not *)Refinement_not_field;
    else
	return 0;
}

const Refinement::Refinement_not *Refinement::get_Refinement_not() const {
    if (_choice == Refinement_not_chosen)
	return (const Refinement_not *)Refinement_not_field;
    else
	return 0;
}

void Refinement::set_Refinement_not(const Refinement_not & Refinement_not_val) {
    cleanup();
    Refinement_not_field = new Refinement_not(Refinement_not_val);
    _choice = Refinement_not_chosen;
}

void Refinement::cleanup() {
    switch (_choice) {
	case item_chosen:
	    ((item *)&item_field)->~OssEncOID();
	    break;
	case Refinement_and_chosen:
	    ((Refinement_and *)&Refinement_and_field)->~__shared29();
	    break;
	case Refinement_or_chosen:
	    ((Refinement_or *)&Refinement_or_field)->~__shared29();
	    break;
	case Refinement_not_chosen:
	    if (Refinement_not_field)
		delete Refinement_not_field;
	    break;
    }
    memset(this, 0, sizeof(*this));
}

__choice11::__choice11() {
    memset(this, 0, sizeof(__choice11));
}

__choice11::__choice11(const __choice11 & that) {
    memset(this, 0, sizeof(__choice11));
    operator =(that);
}

__choice11::~__choice11() {
    cleanup();
}

__choice11 & __choice11::operator = (const __choice11 & that) {
    if (this == &that)
	return *this;
    cleanup();
    _choice = that._choice;
    switch (_choice) {
	case chopBefore_chosen:
	    *(chopBefore *)&chopBefore_field = *(chopBefore *)&that.chopBefore_field;
	    break;
	case chopAfter_chosen:
	    *(chopAfter *)&chopAfter_field = *(chopAfter *)&that.chopAfter_field;
	    break;
    }
    return *this;
}

int __choice11::operator == (const __choice11 & that) const {
    if (_choice != that._choice)
	return 0;
    switch (_choice) {
	case chopBefore_chosen:
	    return *(chopBefore *)&chopBefore_field == *(chopBefore *)&that.chopBefore_field;
	case chopAfter_chosen:
	    return *(chopAfter *)&chopAfter_field == *(chopAfter *)&that.chopAfter_field;
    }

    return 1;
}

int __choice11::operator != (const __choice11 & that) const {
    return !(operator ==(that));
}

__choice11::chopBefore *__choice11::get_chopBefore() {
    if (_choice == chopBefore_chosen)
	return (chopBefore *)&chopBefore_field;
    else
	return 0;
}

const __choice11::chopBefore *__choice11::get_chopBefore() const {
    if (_choice == chopBefore_chosen)
	return (const chopBefore *)&chopBefore_field;
    else
	return 0;
}

void __choice11::set_chopBefore(const chopBefore & chopBefore_val) {
    cleanup();
    *(chopBefore *)&chopBefore_field = chopBefore_val;
    _choice = chopBefore_chosen;
}

__choice11::chopAfter *__choice11::get_chopAfter() {
    if (_choice == chopAfter_chosen)
	return (chopAfter *)&chopAfter_field;
    else
	return 0;
}

const __choice11::chopAfter *__choice11::get_chopAfter() const {
    if (_choice == chopAfter_chosen)
	return (const chopAfter *)&chopAfter_field;
    else
	return 0;
}

void __choice11::set_chopAfter(const chopAfter & chopAfter_val) {
    cleanup();
    *(chopAfter *)&chopAfter_field = chopAfter_val;
    _choice = chopAfter_chosen;
}

void __choice11::cleanup() {
    switch (_choice) {
	case chopBefore_chosen:
	    ((chopBefore *)&chopBefore_field)->~__shared6();
	    break;
	case chopAfter_chosen:
	    ((chopAfter *)&chopAfter_field)->~__shared6();
	    break;
    }
    memset(this, 0, sizeof(*this));
}

/* Auxiliary data structures and functions for class __setof19 */

class __setof19_member {
public:
    __setof19_member *next;
    __setof19::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __setof19_member();
    __setof19_member(const __setof19::component & val);
};

void *__setof19_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __setof19_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__setof19_member::__setof19_member() {
}

__setof19_member::__setof19_member(const __setof19::component & val) {
    value = val;
}

static void *__setof19_copy(void *that) {
    return new __setof19_member(((__setof19_member *)that)->value);
}

static void __setof19_destroy(void *that) {
    delete (__setof19_member *)that;
}

static int __setof19_compare(void *val1, void *val2) {
    return (((__setof19_member *)val1)->value == ((__setof19_member *)val2)->value);
}

/* Constructors */

__setof19::__setof19() {
}

__setof19::__setof19(const __setof19 & that) {
    OSSTRY {
	do_copy(that, &__setof19_copy);
    } OSSCLEAN(__setof19)
}

/* Destructor */

__setof19::~__setof19() {
    do_destroy(&__setof19_destroy);
}

/* Operators: assignment, equality, inequality */

__setof19 & __setof19::operator = (const __setof19 & that) {
    do_destroy(&__setof19_destroy);
    do_copy(that, &__setof19_copy);
    return *this;
}

int __setof19::operator == (const __setof19 & that) const {
    return do_compare(that, &__setof19_compare);
}

int __setof19::operator != (const __setof19 & that) const {
    return !do_compare(that, &__setof19_compare);
}

/* Locate ("At" etc) methods */

__setof19::component *__setof19::at(OssIndex pos) {
    return &((__setof19_member *)pos)->value;
}

const __setof19::component *__setof19::at(OssIndex pos) const {
    return &((__setof19_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __setof19::prepend(const component & val) {
    __setof19_member *newrec = new __setof19_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __setof19::prepend(__setof19 *seq) {
    return do_prepend(seq);
}

OssIndex __setof19::insert_after(OssIndex pos, const component & val) {
    __setof19_member *newrec = new __setof19_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __setof19::insert_after(OssIndex pos, __setof19 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __setof19::remove_front() {
    __setof19_member *extr = (__setof19_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __setof19_destroy(extr);
    return 0;
}

int __setof19::remove_after(OssIndex pos) {
    __setof19_member *extr = (__setof19_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __setof19_destroy(extr);
    return 0;
}

/* Extract methods */

__setof19 *__setof19::extract_after(OssIndex begin, OssIndex end) {
    return (__setof19 *)do_extract_after(begin, end);
}

void *SubtreeSpecification::operator new(size_t size) {
    return ossNewFunc(size);
}

void SubtreeSpecification::operator delete(void *ptr) {
    asn1Free(ptr);
}

const __shared6& SubtreeSpecification::get_default_base() {
    return SubtreeSpecification::default_base;
}

OSS_UINT32 SubtreeSpecification::get_default_minimum() {
    return SubtreeSpecification::default_minimum;
}

SubtreeSpecification::SubtreeSpecification() {
    memset(this, 0, sizeof(SubtreeSpecification));
}

SubtreeSpecification::SubtreeSpecification(const SubtreeSpecification & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	if (bit_mask & 0x80000000)
	    base_field = that.base_field;
	specificExclusions_field = that.specificExclusions_field;
	minimum_field = that.minimum_field;
	maximum_field = that.maximum_field;
	specificationFilter_field = that.specificationFilter_field;
    } OSSCLEAN(SubtreeSpecification)
}

SubtreeSpecification::SubtreeSpecification(const base & base_val, const specificExclusions & specificExclusions_val, 
    minimum minimum_val, maximum maximum_val, const specificationFilter & specificationFilter_val) {
    OSSTRY {
	bit_mask = 0xf8000000;
	base_field = base_val;
	specificExclusions_field = specificExclusions_val;
	minimum_field = minimum_val;
	maximum_field = maximum_val;
	specificationFilter_field = specificationFilter_val;
    } OSSCLEAN(SubtreeSpecification)
}

SubtreeSpecification::~SubtreeSpecification() {
    if (!(bit_mask & 0x80000000))
	memset(&base_field, 0, sizeof(base));
}

SubtreeSpecification & SubtreeSpecification::operator = (const SubtreeSpecification & that) {
    if (this == &that)
	return *this;
    this->~SubtreeSpecification();
    bit_mask = that.bit_mask;
    if (bit_mask & 0x80000000)
	base_field = that.base_field;
    specificExclusions_field = that.specificExclusions_field;
    minimum_field = that.minimum_field;
    maximum_field = that.maximum_field;
    specificationFilter_field = that.specificationFilter_field;
    return *this;
}

int SubtreeSpecification::operator == (const SubtreeSpecification & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (bit_mask & 0x80000000) {
	if (base_field != that.base_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (specificExclusions_field != that.specificExclusions_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (minimum_field != that.minimum_field)
	    return 0;
    }
    if (bit_mask & 0x10000000) {
	if (maximum_field != that.maximum_field)
	    return 0;
    }
    if (bit_mask & 0x8000000) {
	if (specificationFilter_field != that.specificationFilter_field)
	    return 0;
    }
    return 1;
}

int SubtreeSpecification::operator != (const SubtreeSpecification & that) const {
    return !(operator ==(that));
}

SubtreeSpecification::base *SubtreeSpecification::get_base() {
    if (bit_mask & 0x80000000)
	return &base_field;
    else
	return 0;
}

const SubtreeSpecification::base *SubtreeSpecification::get_base() const {
    if (bit_mask & 0x80000000)
	return &base_field;
    else
	return 0;
}

void SubtreeSpecification::set_base(const base & base_val) {
    if (!(bit_mask & 0x80000000)) {
	memset(&base_field, 0, sizeof(base));
	bit_mask |= 0x80000000;
    }
    base_field = base_val;
}

int SubtreeSpecification::base_is_default() const {
    return !(bit_mask & 0x80000000);
}

void SubtreeSpecification::set_default_base() {
    if (bit_mask & 0x80000000) {
	base_field.~__shared6();
	bit_mask &= ~0x80000000;
    }
}

SubtreeSpecification::specificExclusions *SubtreeSpecification::get_specificExclusions() {
    if (bit_mask & 0x40000000)
	return &specificExclusions_field;
    else
	return 0;
}

const SubtreeSpecification::specificExclusions *SubtreeSpecification::get_specificExclusions() const {
    if (bit_mask & 0x40000000)
	return &specificExclusions_field;
    else
	return 0;
}

void SubtreeSpecification::set_specificExclusions(const specificExclusions & specificExclusions_val) {
    bit_mask |= 0x40000000;
    specificExclusions_field = specificExclusions_val;
}

int SubtreeSpecification::specificExclusions_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void SubtreeSpecification::omit_specificExclusions() {
    specificExclusions_field.~__setof19();
    bit_mask &= ~0x40000000;
}

SubtreeSpecification::minimum *SubtreeSpecification::get_minimum() {
    if (bit_mask & 0x20000000)
	return &minimum_field;
    else
	return 0;
}

const SubtreeSpecification::minimum *SubtreeSpecification::get_minimum() const {
    if (bit_mask & 0x20000000)
	return &minimum_field;
    else
	return 0;
}

void SubtreeSpecification::set_minimum(minimum minimum_val) {
    bit_mask |= 0x20000000;
    minimum_field = minimum_val;
}

int SubtreeSpecification::minimum_is_default() const {
    return !(bit_mask & 0x20000000);
}

void SubtreeSpecification::set_default_minimum() {
    bit_mask &= ~0x20000000;
}

SubtreeSpecification::maximum *SubtreeSpecification::get_maximum() {
    if (bit_mask & 0x10000000)
	return &maximum_field;
    else
	return 0;
}

const SubtreeSpecification::maximum *SubtreeSpecification::get_maximum() const {
    if (bit_mask & 0x10000000)
	return &maximum_field;
    else
	return 0;
}

void SubtreeSpecification::set_maximum(maximum maximum_val) {
    bit_mask |= 0x10000000;
    maximum_field = maximum_val;
}

int SubtreeSpecification::maximum_is_present() const {
    return !!(bit_mask & 0x10000000);
}

void SubtreeSpecification::omit_maximum() {
    bit_mask &= ~0x10000000;
}

SubtreeSpecification::specificationFilter *SubtreeSpecification::get_specificationFilter() {
    if (bit_mask & 0x8000000)
	return &specificationFilter_field;
    else
	return 0;
}

const SubtreeSpecification::specificationFilter *SubtreeSpecification::get_specificationFilter() const {
    if (bit_mask & 0x8000000)
	return &specificationFilter_field;
    else
	return 0;
}

void SubtreeSpecification::set_specificationFilter(const specificationFilter & specificationFilter_val) {
    bit_mask |= 0x8000000;
    specificationFilter_field = specificationFilter_val;
}

int SubtreeSpecification::specificationFilter_is_present() const {
    return !!(bit_mask & 0x8000000);
}

void SubtreeSpecification::omit_specificationFilter() {
    specificationFilter_field.~Refinement();
    bit_mask &= ~0x8000000;
}

void *DITStructureRule::operator new(size_t size) {
    return ossNewFunc(size);
}

void DITStructureRule::operator delete(void *ptr) {
    asn1Free(ptr);
}

DITStructureRule::DITStructureRule() {
    memset(this, 0, sizeof(DITStructureRule));
}

DITStructureRule::DITStructureRule(const DITStructureRule & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	ruleIdentifier_field = that.ruleIdentifier_field;
	nameForm_field = that.nameForm_field;
	superiorStructureRules_field = that.superiorStructureRules_field;
    } OSSCLEAN(DITStructureRule)
}

DITStructureRule::DITStructureRule(ruleIdentifier ruleIdentifier_val, const nameForm & nameForm_val, 
    const superiorStructureRules & superiorStructureRules_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	ruleIdentifier_field = ruleIdentifier_val;
	nameForm_field = nameForm_val;
	superiorStructureRules_field = superiorStructureRules_val;
    } OSSCLEAN(DITStructureRule)
}

DITStructureRule::DITStructureRule(ruleIdentifier ruleIdentifier_val, const nameForm & nameForm_val) {
    OSSTRY {
	bit_mask = 0;
	ruleIdentifier_field = ruleIdentifier_val;
	nameForm_field = nameForm_val;
    } OSSCLEAN(DITStructureRule)
}

DITStructureRule & DITStructureRule::operator = (const DITStructureRule & that) {
    if (this == &that)
	return *this;
    this->~DITStructureRule();
    bit_mask = that.bit_mask;
    ruleIdentifier_field = that.ruleIdentifier_field;
    nameForm_field = that.nameForm_field;
    superiorStructureRules_field = that.superiorStructureRules_field;
    return *this;
}

int DITStructureRule::operator == (const DITStructureRule & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (ruleIdentifier_field != that.ruleIdentifier_field)
	return 0;
    if (nameForm_field != that.nameForm_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (superiorStructureRules_field != that.superiorStructureRules_field)
	    return 0;
    }
    return 1;
}

int DITStructureRule::operator != (const DITStructureRule & that) const {
    return !(operator ==(that));
}

DITStructureRule::ruleIdentifier & DITStructureRule::get_ruleIdentifier() {
    return ruleIdentifier_field;
}

DITStructureRule::ruleIdentifier DITStructureRule::get_ruleIdentifier() const {
    return ruleIdentifier_field;
}

void DITStructureRule::set_ruleIdentifier(ruleIdentifier ruleIdentifier_val) {
    ruleIdentifier_field = ruleIdentifier_val;
}

DITStructureRule::nameForm & DITStructureRule::get_nameForm() {
    return nameForm_field;
}

const DITStructureRule::nameForm & DITStructureRule::get_nameForm() const {
    return nameForm_field;
}

void DITStructureRule::set_nameForm(const nameForm & nameForm_val) {
    nameForm_field = nameForm_val;
}

DITStructureRule::superiorStructureRules *DITStructureRule::get_superiorStructureRules() {
    if (bit_mask & 0x80000000)
	return &superiorStructureRules_field;
    else
	return 0;
}

const DITStructureRule::superiorStructureRules *DITStructureRule::get_superiorStructureRules() const {
    if (bit_mask & 0x80000000)
	return &superiorStructureRules_field;
    else
	return 0;
}

void DITStructureRule::set_superiorStructureRules(const superiorStructureRules & superiorStructureRules_val) {
    bit_mask |= 0x80000000;
    superiorStructureRules_field = superiorStructureRules_val;
}

int DITStructureRule::superiorStructureRules_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void DITStructureRule::omit_superiorStructureRules() {
    superiorStructureRules_field.~__shared22();
    bit_mask &= ~0x80000000;
}

void *DITContentRule::operator new(size_t size) {
    return ossNewFunc(size);
}

void DITContentRule::operator delete(void *ptr) {
    asn1Free(ptr);
}

DITContentRule::DITContentRule() {
    memset(this, 0, sizeof(DITContentRule));
}

DITContentRule::DITContentRule(const DITContentRule & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	structuralObjectClass_field = that.structuralObjectClass_field;
	auxiliaries_field = that.auxiliaries_field;
	mandatory_field = that.mandatory_field;
	optional_field = that.optional_field;
	precluded_field = that.precluded_field;
    } OSSCLEAN(DITContentRule)
}

DITContentRule::DITContentRule(const structuralObjectClass & structuralObjectClass_val, 
    const auxiliaries & auxiliaries_val, const mandatory & mandatory_val, const optional & optional_val, 
    const precluded & precluded_val) {
    OSSTRY {
	bit_mask = 0xf0000000;
	structuralObjectClass_field = structuralObjectClass_val;
	auxiliaries_field = auxiliaries_val;
	mandatory_field = mandatory_val;
	optional_field = optional_val;
	precluded_field = precluded_val;
    } OSSCLEAN(DITContentRule)
}

DITContentRule::DITContentRule(const structuralObjectClass & structuralObjectClass_val) {
    OSSTRY {
	bit_mask = 0;
	structuralObjectClass_field = structuralObjectClass_val;
    } OSSCLEAN(DITContentRule)
}

DITContentRule & DITContentRule::operator = (const DITContentRule & that) {
    if (this == &that)
	return *this;
    this->~DITContentRule();
    bit_mask = that.bit_mask;
    structuralObjectClass_field = that.structuralObjectClass_field;
    auxiliaries_field = that.auxiliaries_field;
    mandatory_field = that.mandatory_field;
    optional_field = that.optional_field;
    precluded_field = that.precluded_field;
    return *this;
}

int DITContentRule::operator == (const DITContentRule & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (structuralObjectClass_field != that.structuralObjectClass_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (auxiliaries_field != that.auxiliaries_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (mandatory_field != that.mandatory_field)
	    return 0;
    }
    if (bit_mask & 0x20000000) {
	if (optional_field != that.optional_field)
	    return 0;
    }
    if (bit_mask & 0x10000000) {
	if (precluded_field != that.precluded_field)
	    return 0;
    }
    return 1;
}

int DITContentRule::operator != (const DITContentRule & that) const {
    return !(operator ==(that));
}

DITContentRule::structuralObjectClass & DITContentRule::get_structuralObjectClass() {
    return structuralObjectClass_field;
}

const DITContentRule::structuralObjectClass & DITContentRule::get_structuralObjectClass() const {
    return structuralObjectClass_field;
}

void DITContentRule::set_structuralObjectClass(const structuralObjectClass & structuralObjectClass_val) {
    structuralObjectClass_field = structuralObjectClass_val;
}

DITContentRule::auxiliaries *DITContentRule::get_auxiliaries() {
    if (bit_mask & 0x80000000)
	return &auxiliaries_field;
    else
	return 0;
}

const DITContentRule::auxiliaries *DITContentRule::get_auxiliaries() const {
    if (bit_mask & 0x80000000)
	return &auxiliaries_field;
    else
	return 0;
}

void DITContentRule::set_auxiliaries(const auxiliaries & auxiliaries_val) {
    bit_mask |= 0x80000000;
    auxiliaries_field = auxiliaries_val;
}

int DITContentRule::auxiliaries_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void DITContentRule::omit_auxiliaries() {
    auxiliaries_field.~__shared8();
    bit_mask &= ~0x80000000;
}

DITContentRule::mandatory *DITContentRule::get_mandatory() {
    if (bit_mask & 0x40000000)
	return &mandatory_field;
    else
	return 0;
}

const DITContentRule::mandatory *DITContentRule::get_mandatory() const {
    if (bit_mask & 0x40000000)
	return &mandatory_field;
    else
	return 0;
}

void DITContentRule::set_mandatory(const mandatory & mandatory_val) {
    bit_mask |= 0x40000000;
    mandatory_field = mandatory_val;
}

int DITContentRule::mandatory_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void DITContentRule::omit_mandatory() {
    mandatory_field.~__shared8();
    bit_mask &= ~0x40000000;
}

DITContentRule::optional *DITContentRule::get_optional() {
    if (bit_mask & 0x20000000)
	return &optional_field;
    else
	return 0;
}

const DITContentRule::optional *DITContentRule::get_optional() const {
    if (bit_mask & 0x20000000)
	return &optional_field;
    else
	return 0;
}

void DITContentRule::set_optional(const optional & optional_val) {
    bit_mask |= 0x20000000;
    optional_field = optional_val;
}

int DITContentRule::optional_is_present() const {
    return !!(bit_mask & 0x20000000);
}

void DITContentRule::omit_optional() {
    optional_field.~__shared8();
    bit_mask &= ~0x20000000;
}

DITContentRule::precluded *DITContentRule::get_precluded() {
    if (bit_mask & 0x10000000)
	return &precluded_field;
    else
	return 0;
}

const DITContentRule::precluded *DITContentRule::get_precluded() const {
    if (bit_mask & 0x10000000)
	return &precluded_field;
    else
	return 0;
}

void DITContentRule::set_precluded(const precluded & precluded_val) {
    bit_mask |= 0x10000000;
    precluded_field = precluded_val;
}

int DITContentRule::precluded_is_present() const {
    return !!(bit_mask & 0x10000000);
}

void DITContentRule::omit_precluded() {
    precluded_field.~__shared8();
    bit_mask &= ~0x10000000;
}

void *DITContextUse::operator new(size_t size) {
    return ossNewFunc(size);
}

void DITContextUse::operator delete(void *ptr) {
    asn1Free(ptr);
}

DITContextUse::DITContextUse() {
    memset(this, 0, sizeof(DITContextUse));
}

DITContextUse::DITContextUse(const DITContextUse & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	attributeType_field = that.attributeType_field;
	mandatoryContexts_field = that.mandatoryContexts_field;
	optionalContexts_field = that.optionalContexts_field;
    } OSSCLEAN(DITContextUse)
}

DITContextUse::DITContextUse(const attributeType & attributeType_val, const mandatoryContexts & mandatoryContexts_val, 
    const optionalContexts & optionalContexts_val) {
    OSSTRY {
	bit_mask = 0xc0000000;
	attributeType_field = attributeType_val;
	mandatoryContexts_field = mandatoryContexts_val;
	optionalContexts_field = optionalContexts_val;
    } OSSCLEAN(DITContextUse)
}

DITContextUse::DITContextUse(const attributeType & attributeType_val) {
    OSSTRY {
	bit_mask = 0;
	attributeType_field = attributeType_val;
    } OSSCLEAN(DITContextUse)
}

DITContextUse & DITContextUse::operator = (const DITContextUse & that) {
    if (this == &that)
	return *this;
    this->~DITContextUse();
    bit_mask = that.bit_mask;
    attributeType_field = that.attributeType_field;
    mandatoryContexts_field = that.mandatoryContexts_field;
    optionalContexts_field = that.optionalContexts_field;
    return *this;
}

int DITContextUse::operator == (const DITContextUse & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (attributeType_field != that.attributeType_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (mandatoryContexts_field != that.mandatoryContexts_field)
	    return 0;
    }
    if (bit_mask & 0x40000000) {
	if (optionalContexts_field != that.optionalContexts_field)
	    return 0;
    }
    return 1;
}

int DITContextUse::operator != (const DITContextUse & that) const {
    return !(operator ==(that));
}

DITContextUse::attributeType & DITContextUse::get_attributeType() {
    return attributeType_field;
}

const DITContextUse::attributeType & DITContextUse::get_attributeType() const {
    return attributeType_field;
}

void DITContextUse::set_attributeType(const attributeType & attributeType_val) {
    attributeType_field = attributeType_val;
}

DITContextUse::mandatoryContexts *DITContextUse::get_mandatoryContexts() {
    if (bit_mask & 0x80000000)
	return &mandatoryContexts_field;
    else
	return 0;
}

const DITContextUse::mandatoryContexts *DITContextUse::get_mandatoryContexts() const {
    if (bit_mask & 0x80000000)
	return &mandatoryContexts_field;
    else
	return 0;
}

void DITContextUse::set_mandatoryContexts(const mandatoryContexts & mandatoryContexts_val) {
    bit_mask |= 0x80000000;
    mandatoryContexts_field = mandatoryContexts_val;
}

int DITContextUse::mandatoryContexts_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void DITContextUse::omit_mandatoryContexts() {
    mandatoryContexts_field.~__shared8();
    bit_mask &= ~0x80000000;
}

DITContextUse::optionalContexts *DITContextUse::get_optionalContexts() {
    if (bit_mask & 0x40000000)
	return &optionalContexts_field;
    else
	return 0;
}

const DITContextUse::optionalContexts *DITContextUse::get_optionalContexts() const {
    if (bit_mask & 0x40000000)
	return &optionalContexts_field;
    else
	return 0;
}

void DITContextUse::set_optionalContexts(const optionalContexts & optionalContexts_val) {
    bit_mask |= 0x40000000;
    optionalContexts_field = optionalContexts_val;
}

int DITContextUse::optionalContexts_is_present() const {
    return !!(bit_mask & 0x40000000);
}

void DITContextUse::omit_optionalContexts() {
    optionalContexts_field.~__shared8();
    bit_mask &= ~0x40000000;
}

/* Universal PDU class */

UpperBounds_PDU::UpperBounds_PDU() {
}

void UpperBounds_PDU::set_OssEncOID(OssEncOID & d) {
    index = 1;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

OssEncOID *UpperBounds_PDU::get_OssEncOID() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 1 && !constant)
#else
    if (index == 1)
#endif
	return (OssEncOID *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_ACSE_apdu(ACSE_apdu & d) {
    index = 2;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ACSE_apdu *UpperBounds_PDU::get_ACSE_apdu() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 2 && !constant)
#else
    if (index == 2)
#endif
	return (ACSE_apdu *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_AE_title(AE_title & d) {
    index = 3;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AE_title *UpperBounds_PDU::get_AE_title() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 3 && !constant)
#else
    if (index == 3)
#endif
	return (AE_title *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_CP_type(CP_type & d) {
    index = 4;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CP_type *UpperBounds_PDU::get_CP_type() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 4 && !constant)
#else
    if (index == 4)
#endif
	return (CP_type *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_CPC_type(CPC_type & d) {
    index = 5;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CPC_type *UpperBounds_PDU::get_CPC_type() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 5 && !constant)
#else
    if (index == 5)
#endif
	return (CPC_type *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_CPA_PPDU(CPA_PPDU & d) {
    index = 6;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CPA_PPDU *UpperBounds_PDU::get_CPA_PPDU() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 6 && !constant)
#else
    if (index == 6)
#endif
	return (CPA_PPDU *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_CPR_PPDU(CPR_PPDU & d) {
    index = 7;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CPR_PPDU *UpperBounds_PDU::get_CPR_PPDU() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 7 && !constant)
#else
    if (index == 7)
#endif
	return (CPR_PPDU *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_Abort_type(Abort_type & d) {
    index = 8;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Abort_type *UpperBounds_PDU::get_Abort_type() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 8 && !constant)
#else
    if (index == 8)
#endif
	return (Abort_type *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_Typed_data_type(Typed_data_type & d) {
    index = 9;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Typed_data_type *UpperBounds_PDU::get_Typed_data_type() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 9 && !constant)
#else
    if (index == 9)
#endif
	return (Typed_data_type *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_RS_PPDU(RS_PPDU & d) {
    index = 10;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

RS_PPDU *UpperBounds_PDU::get_RS_PPDU() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 10 && !constant)
#else
    if (index == 10)
#endif
	return (RS_PPDU *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_RSA_PPDU(RSA_PPDU & d) {
    index = 11;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

RSA_PPDU *UpperBounds_PDU::get_RSA_PPDU() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 11 && !constant)
#else
    if (index == 11)
#endif
	return (RSA_PPDU *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_Reliable_Transfer_APDU_RTSE_apdus(Reliable_Transfer_APDU_RTSE_apdus & d) {
    index = 12;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Reliable_Transfer_APDU_RTSE_apdus *UpperBounds_PDU::get_Reliable_Transfer_APDU_RTSE_apdus() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 12 && !constant)
#else
    if (index == 12)
#endif
	return (Reliable_Transfer_APDU_RTSE_apdus *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_Remote_Operations_Abstract_Syntaxes_RTSE_apdus(Remote_Operations_Abstract_Syntaxes_RTSE_apdus & d) {
    index = 13;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Remote_Operations_Abstract_Syntaxes_RTSE_apdus *UpperBounds_PDU::get_Remote_Operations_Abstract_Syntaxes_RTSE_apdus() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 13 && !constant)
#else
    if (index == 13)
#endif
	return (Remote_Operations_Abstract_Syntaxes_RTSE_apdus *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_ROSEInvokeIds(ROSEInvokeIds & d) {
    index = 14;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ROSEInvokeIds *UpperBounds_PDU::get_ROSEInvokeIds() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 14 && !constant)
#else
    if (index == 14)
#endif
	return (ROSEInvokeIds *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_Reject(Reject & d) {
    index = 15;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Reject *UpperBounds_PDU::get_Reject() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 15 && !constant)
#else
    if (index == 15)
#endif
	return (Reject *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_NoInvokeId(NoInvokeId & d) {
    index = 16;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoInvokeId *UpperBounds_PDU::get_NoInvokeId() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 16 && !constant)
#else
    if (index == 16)
#endif
	return (NoInvokeId *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_UnboundedDirectoryString(UnboundedDirectoryString & d) {
    index = 17;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

UnboundedDirectoryString *UpperBounds_PDU::get_UnboundedDirectoryString() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 17 && !constant)
#else
    if (index == 17)
#endif
	return (UnboundedDirectoryString *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_UniqueIdentifier(UniqueIdentifier & d) {
    index = 18;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

UniqueIdentifier *UpperBounds_PDU::get_UniqueIdentifier() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 18 && !constant)
#else
    if (index == 18)
#endif
	return (UniqueIdentifier *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_UUIDPair(UUIDPair & d) {
    index = 19;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

UUIDPair *UpperBounds_PDU::get_UUIDPair() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 19 && !constant)
#else
    if (index == 19)
#endif
	return (UUIDPair *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_CountryName(CountryName & d) {
    index = 20;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CountryName *UpperBounds_PDU::get_CountryName() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 20 && !constant)
#else
    if (index == 20)
#endif
	return (CountryName *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_Guide(Guide & d) {
    index = 21;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Guide *UpperBounds_PDU::get_Guide() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 21 && !constant)
#else
    if (index == 21)
#endif
	return (Guide *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_EnhancedGuide(EnhancedGuide & d) {
    index = 22;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EnhancedGuide *UpperBounds_PDU::get_EnhancedGuide() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 22 && !constant)
#else
    if (index == 22)
#endif
	return (EnhancedGuide *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_PostalAddress(PostalAddress & d) {
    index = 23;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PostalAddress *UpperBounds_PDU::get_PostalAddress() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 23 && !constant)
#else
    if (index == 23)
#endif
	return (PostalAddress *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_TelephoneNumber(TelephoneNumber & d) {
    index = 24;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TelephoneNumber *UpperBounds_PDU::get_TelephoneNumber() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 24 && !constant)
#else
    if (index == 24)
#endif
	return (TelephoneNumber *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_TelexNumber(TelexNumber & d) {
    index = 25;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TelexNumber *UpperBounds_PDU::get_TelexNumber() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 25 && !constant)
#else
    if (index == 25)
#endif
	return (TelexNumber *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_X121Address(X121Address & d) {
    index = 26;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

X121Address *UpperBounds_PDU::get_X121Address() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 26 && !constant)
#else
    if (index == 26)
#endif
	return (X121Address *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_InternationalISDNNumber(InternationalISDNNumber & d) {
    index = 27;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

InternationalISDNNumber *UpperBounds_PDU::get_InternationalISDNNumber() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 27 && !constant)
#else
    if (index == 27)
#endif
	return (InternationalISDNNumber *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_DestinationIndicator(DestinationIndicator & d) {
    index = 28;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

DestinationIndicator *UpperBounds_PDU::get_DestinationIndicator() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 28 && !constant)
#else
    if (index == 28)
#endif
	return (DestinationIndicator *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_CommunicationsService(CommunicationsService & d) {
    index = 29;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CommunicationsService *UpperBounds_PDU::get_CommunicationsService() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 29 && !constant)
#else
    if (index == 29)
#endif
	return (CommunicationsService *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_CommunicationsNetwork(CommunicationsNetwork & d) {
    index = 30;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CommunicationsNetwork *UpperBounds_PDU::get_CommunicationsNetwork() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 30 && !constant)
#else
    if (index == 30)
#endif
	return (CommunicationsNetwork *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_PreferredDeliveryMethod(PreferredDeliveryMethod & d) {
    index = 31;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PreferredDeliveryMethod *UpperBounds_PDU::get_PreferredDeliveryMethod() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 31 && !constant)
#else
    if (index == 31)
#endif
	return (PreferredDeliveryMethod *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_PresentationAddress(PresentationAddress & d) {
    index = 32;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PresentationAddress *UpperBounds_PDU::get_PresentationAddress() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 32 && !constant)
#else
    if (index == 32)
#endif
	return (PresentationAddress *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_ProtocolInformation(ProtocolInformation & d) {
    index = 33;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ProtocolInformation *UpperBounds_PDU::get_ProtocolInformation() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 33 && !constant)
#else
    if (index == 33)
#endif
	return (ProtocolInformation *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_NameAndOptionalUID(NameAndOptionalUID & d) {
    index = 34;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NameAndOptionalUID *UpperBounds_PDU::get_NameAndOptionalUID() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 34 && !constant)
#else
    if (index == 34)
#endif
	return (NameAndOptionalUID *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_MultipleMatchingLocalities(MultipleMatchingLocalities & d) {
    index = 35;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

MultipleMatchingLocalities *UpperBounds_PDU::get_MultipleMatchingLocalities() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 35 && !constant)
#else
    if (index == 35)
#endif
	return (MultipleMatchingLocalities *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_SubstringAssertion(SubstringAssertion & d) {
    index = 36;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SubstringAssertion *UpperBounds_PDU::get_SubstringAssertion() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 36 && !constant)
#else
    if (index == 36)
#endif
	return (SubstringAssertion *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_CaseIgnoreList(CaseIgnoreList & d) {
    index = 37;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CaseIgnoreList *UpperBounds_PDU::get_CaseIgnoreList() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 37 && !constant)
#else
    if (index == 37)
#endif
	return (CaseIgnoreList *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_OctetSubstringAssertion(OctetSubstringAssertion & d) {
    index = 38;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

OctetSubstringAssertion *UpperBounds_PDU::get_OctetSubstringAssertion() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 38 && !constant)
#else
    if (index == 38)
#endif
	return (OctetSubstringAssertion *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_SequenceMatchType(SequenceMatchType & d) {
    index = 39;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SequenceMatchType *UpperBounds_PDU::get_SequenceMatchType() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 39 && !constant)
#else
    if (index == 39)
#endif
	return (SequenceMatchType *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_WordMatchTypes(WordMatchTypes & d) {
    index = 40;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WordMatchTypes *UpperBounds_PDU::get_WordMatchTypes() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 40 && !constant)
#else
    if (index == 40)
#endif
	return (WordMatchTypes *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_CharacterMatchTypes(CharacterMatchTypes & d) {
    index = 41;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CharacterMatchTypes *UpperBounds_PDU::get_CharacterMatchTypes() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 41 && !constant)
#else
    if (index == 41)
#endif
	return (CharacterMatchTypes *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_LanguageContextSyntax(LanguageContextSyntax & d) {
    index = 42;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

LanguageContextSyntax *UpperBounds_PDU::get_LanguageContextSyntax() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 42 && !constant)
#else
    if (index == 42)
#endif
	return (LanguageContextSyntax *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_TimeSpecification(TimeSpecification & d) {
    index = 43;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TimeSpecification *UpperBounds_PDU::get_TimeSpecification() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 43 && !constant)
#else
    if (index == 43)
#endif
	return (TimeSpecification *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_TimeAssertion(TimeAssertion & d) {
    index = 44;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TimeAssertion *UpperBounds_PDU::get_TimeAssertion() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 44 && !constant)
#else
    if (index == 44)
#endif
	return (TimeAssertion *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_LocaleContextSyntax(LocaleContextSyntax & d) {
    index = 45;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

LocaleContextSyntax *UpperBounds_PDU::get_LocaleContextSyntax() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 45 && !constant)
#else
    if (index == 45)
#endif
	return (LocaleContextSyntax *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_AttributeOptionList(AttributeOptionList & d) {
    index = 46;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AttributeOptionList *UpperBounds_PDU::get_AttributeOptionList() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 46 && !constant)
#else
    if (index == 46)
#endif
	return (AttributeOptionList *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_ID(ID & d) {
    index = 47;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ID *UpperBounds_PDU::get_ID() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 47 && !constant)
#else
    if (index == 47)
#endif
	return (ID *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_AttributeValue(AttributeValue & d) {
    index = 48;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AttributeValue *UpperBounds_PDU::get_AttributeValue() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 48 && !constant)
#else
    if (index == 48)
#endif
	return (AttributeValue *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_ContextAssertion(ContextAssertion & d) {
    index = 49;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ContextAssertion *UpperBounds_PDU::get_ContextAssertion() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 49 && !constant)
#else
    if (index == 49)
#endif
	return (ContextAssertion *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_AttributeTypeAssertion(AttributeTypeAssertion & d) {
    index = 50;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AttributeTypeAssertion *UpperBounds_PDU::get_AttributeTypeAssertion() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 50 && !constant)
#else
    if (index == 50)
#endif
	return (AttributeTypeAssertion *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_DistinguishedName(DistinguishedName & d) {
    index = 51;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

DistinguishedName *UpperBounds_PDU::get_DistinguishedName() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 51 && !constant)
#else
    if (index == 51)
#endif
	return (DistinguishedName *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_SubtreeSpecification(SubtreeSpecification & d) {
    index = 52;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SubtreeSpecification *UpperBounds_PDU::get_SubtreeSpecification() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 52 && !constant)
#else
    if (index == 52)
#endif
	return (SubtreeSpecification *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_DITStructureRule(DITStructureRule & d) {
    index = 53;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

DITStructureRule *UpperBounds_PDU::get_DITStructureRule() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 53 && !constant)
#else
    if (index == 53)
#endif
	return (DITStructureRule *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_DITContentRule(DITContentRule & d) {
    index = 54;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

DITContentRule *UpperBounds_PDU::get_DITContentRule() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 54 && !constant)
#else
    if (index == 54)
#endif
	return (DITContentRule *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_DITContextUse(DITContextUse & d) {
    index = 55;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

DITContextUse *UpperBounds_PDU::get_DITContextUse() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 55 && !constant)
#else
    if (index == 55)
#endif
	return (DITContextUse *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_HierarchyLevel(HierarchyLevel & d) {
    index = 56;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

HierarchyLevel *UpperBounds_PDU::get_HierarchyLevel() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 56 && !constant)
#else
    if (index == 56)
#endif
	return (HierarchyLevel *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_HierarchyBelow(HierarchyBelow & d) {
    index = 57;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

HierarchyBelow *UpperBounds_PDU::get_HierarchyBelow() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 57 && !constant)
#else
    if (index == 57)
#endif
	return (HierarchyBelow *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_Acse_RealizationParameter(Acse_RealizationParameter & d) {
    index = 58;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Acse_RealizationParameter *UpperBounds_PDU::get_Acse_RealizationParameter() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 58 && !constant)
#else
    if (index == 58)
#endif
	return (Acse_RealizationParameter *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_Acse_with_concatenation_RealizationParameter(Acse_with_concatenation_RealizationParameter & d) {
    index = 59;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Acse_with_concatenation_RealizationParameter *UpperBounds_PDU::get_Acse_with_concatenation_RealizationParameter() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 59 && !constant)
#else
    if (index == 59)
#endif
	return (Acse_with_concatenation_RealizationParameter *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_Association_by_RTSE_RealizationParameter(Association_by_RTSE_RealizationParameter & d) {
    index = 60;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Association_by_RTSE_RealizationParameter *UpperBounds_PDU::get_Association_by_RTSE_RealizationParameter() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 60 && !constant)
#else
    if (index == 60)
#endif
	return (Association_by_RTSE_RealizationParameter *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_PData_RealizationParameter(PData_RealizationParameter & d) {
    index = 61;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PData_RealizationParameter *UpperBounds_PDU::get_PData_RealizationParameter() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 61 && !constant)
#else
    if (index == 61)
#endif
	return (PData_RealizationParameter *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_PData_with_concatenation_RealizationParameter(PData_with_concatenation_RealizationParameter & d) {
    index = 62;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PData_with_concatenation_RealizationParameter *UpperBounds_PDU::get_PData_with_concatenation_RealizationParameter() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 62 && !constant)
#else
    if (index == 62)
#endif
	return (PData_with_concatenation_RealizationParameter *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_Transfer_by_RTSE_RealizationParameter(Transfer_by_RTSE_RealizationParameter & d) {
    index = 63;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Transfer_by_RTSE_RealizationParameter *UpperBounds_PDU::get_Transfer_by_RTSE_RealizationParameter() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 63 && !constant)
#else
    if (index == 63)
#endif
	return (Transfer_by_RTSE_RealizationParameter *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_BitStringMatch_SYNTAX(BitStringMatch_SYNTAX & d) {
    index = 64;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

BitStringMatch_SYNTAX *UpperBounds_PDU::get_BitStringMatch_SYNTAX() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 64 && !constant)
#else
    if (index == 64)
#endif
	return (BitStringMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_DnQualifier_WITH_SYNTAX(DnQualifier_WITH_SYNTAX & d) {
    index = 65;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

DnQualifier_WITH_SYNTAX *UpperBounds_PDU::get_DnQualifier_WITH_SYNTAX() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 65 && !constant)
#else
    if (index == 65)
#endif
	return (DnQualifier_WITH_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_SerialNumber_WITH_SYNTAX(SerialNumber_WITH_SYNTAX & d) {
    index = 66;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SerialNumber_WITH_SYNTAX *UpperBounds_PDU::get_SerialNumber_WITH_SYNTAX() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 66 && !constant)
#else
    if (index == 66)
#endif
	return (SerialNumber_WITH_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_NumericStringMatch_SYNTAX(NumericStringMatch_SYNTAX & d) {
    index = 67;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NumericStringMatch_SYNTAX *UpperBounds_PDU::get_NumericStringMatch_SYNTAX() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 67 && !constant)
#else
    if (index == 67)
#endif
	return (NumericStringMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_ProtocolInformationMatch_SYNTAX(ProtocolInformationMatch_SYNTAX & d) {
    index = 68;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ProtocolInformationMatch_SYNTAX *UpperBounds_PDU::get_ProtocolInformationMatch_SYNTAX() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 68 && !constant)
#else
    if (index == 68)
#endif
	return (ProtocolInformationMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_UiiInUrn_WITH_SYNTAX(UiiInUrn_WITH_SYNTAX & d) {
    index = 69;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

UiiInUrn_WITH_SYNTAX *UpperBounds_PDU::get_UiiInUrn_WITH_SYNTAX() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 69 && !constant)
#else
    if (index == 69)
#endif
	return (UiiInUrn_WITH_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_NumericStringOrderingMatch_SYNTAX(NumericStringOrderingMatch_SYNTAX & d) {
    index = 70;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NumericStringOrderingMatch_SYNTAX *UpperBounds_PDU::get_NumericStringOrderingMatch_SYNTAX() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 70 && !constant)
#else
    if (index == 70)
#endif
	return (NumericStringOrderingMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_BooleanMatch_SYNTAX(BooleanMatch_SYNTAX & d) {
    index = 71;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

BooleanMatch_SYNTAX *UpperBounds_PDU::get_BooleanMatch_SYNTAX() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 71 && !constant)
#else
    if (index == 71)
#endif
	return (BooleanMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_IntegerMatch_SYNTAX(IntegerMatch_SYNTAX & d) {
    index = 72;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

IntegerMatch_SYNTAX *UpperBounds_PDU::get_IntegerMatch_SYNTAX() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 72 && !constant)
#else
    if (index == 72)
#endif
	return (IntegerMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_IntegerOrderingMatch_SYNTAX(IntegerOrderingMatch_SYNTAX & d) {
    index = 73;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

IntegerOrderingMatch_SYNTAX *UpperBounds_PDU::get_IntegerOrderingMatch_SYNTAX() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 73 && !constant)
#else
    if (index == 73)
#endif
	return (IntegerOrderingMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_OctetStringMatch_SYNTAX(OctetStringMatch_SYNTAX & d) {
    index = 74;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

OctetStringMatch_SYNTAX *UpperBounds_PDU::get_OctetStringMatch_SYNTAX() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 74 && !constant)
#else
    if (index == 74)
#endif
	return (OctetStringMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_OctetStringOrderingMatch_SYNTAX(OctetStringOrderingMatch_SYNTAX & d) {
    index = 75;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

OctetStringOrderingMatch_SYNTAX *UpperBounds_PDU::get_OctetStringOrderingMatch_SYNTAX() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 75 && !constant)
#else
    if (index == 75)
#endif
	return (OctetStringOrderingMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_UTCTimeMatch_SYNTAX(UTCTimeMatch_SYNTAX & d) {
    index = 76;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

UTCTimeMatch_SYNTAX *UpperBounds_PDU::get_UTCTimeMatch_SYNTAX() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 76 && !constant)
#else
    if (index == 76)
#endif
	return (UTCTimeMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_UTCTimeOrderingMatch_SYNTAX(UTCTimeOrderingMatch_SYNTAX & d) {
    index = 77;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

UTCTimeOrderingMatch_SYNTAX *UpperBounds_PDU::get_UTCTimeOrderingMatch_SYNTAX() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 77 && !constant)
#else
    if (index == 77)
#endif
	return (UTCTimeOrderingMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_GeneralizedTimeMatch_SYNTAX(GeneralizedTimeMatch_SYNTAX & d) {
    index = 78;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

GeneralizedTimeMatch_SYNTAX *UpperBounds_PDU::get_GeneralizedTimeMatch_SYNTAX() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 78 && !constant)
#else
    if (index == 78)
#endif
	return (GeneralizedTimeMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_GeneralizedTimeOrderingMatch_SYNTAX(GeneralizedTimeOrderingMatch_SYNTAX & d) {
    index = 79;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

GeneralizedTimeOrderingMatch_SYNTAX *UpperBounds_PDU::get_GeneralizedTimeOrderingMatch_SYNTAX() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 79 && !constant)
#else
    if (index == 79)
#endif
	return (GeneralizedTimeOrderingMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_IntegerFirstComponentMatch_SYNTAX(IntegerFirstComponentMatch_SYNTAX & d) {
    index = 80;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

IntegerFirstComponentMatch_SYNTAX *UpperBounds_PDU::get_IntegerFirstComponentMatch_SYNTAX() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 80 && !constant)
#else
    if (index == 80)
#endif
	return (IntegerFirstComponentMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_AdministrativeRole_WITH_SYNTAX(AdministrativeRole_WITH_SYNTAX & d) {
    index = 81;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AdministrativeRole_WITH_SYNTAX *UpperBounds_PDU::get_AdministrativeRole_WITH_SYNTAX() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 81 && !constant)
#else
    if (index == 81)
#endif
	return (AdministrativeRole_WITH_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_CreateTimestamp_WITH_SYNTAX(CreateTimestamp_WITH_SYNTAX & d) {
    index = 82;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CreateTimestamp_WITH_SYNTAX *UpperBounds_PDU::get_CreateTimestamp_WITH_SYNTAX() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 82 && !constant)
#else
    if (index == 82)
#endif
	return (CreateTimestamp_WITH_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_ModifyTimestamp_WITH_SYNTAX(ModifyTimestamp_WITH_SYNTAX & d) {
    index = 83;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ModifyTimestamp_WITH_SYNTAX *UpperBounds_PDU::get_ModifyTimestamp_WITH_SYNTAX() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 83 && !constant)
#else
    if (index == 83)
#endif
	return (ModifyTimestamp_WITH_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_SubschemaTimestamp_WITH_SYNTAX(SubschemaTimestamp_WITH_SYNTAX & d) {
    index = 84;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SubschemaTimestamp_WITH_SYNTAX *UpperBounds_PDU::get_SubschemaTimestamp_WITH_SYNTAX() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 84 && !constant)
#else
    if (index == 84)
#endif
	return (SubschemaTimestamp_WITH_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_HasSubordinates_WITH_SYNTAX(HasSubordinates_WITH_SYNTAX & d) {
    index = 85;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

HasSubordinates_WITH_SYNTAX *UpperBounds_PDU::get_HasSubordinates_WITH_SYNTAX() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 85 && !constant)
#else
    if (index == 85)
#endif
	return (HasSubordinates_WITH_SYNTAX *)data;
    else
	return 0;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
void UpperBounds_PDU::set_const_OssEncOID(const OssEncOID & d) {
    index = 1;
    data = (void *)&d;
    constant = 1;
}

const OssEncOID *UpperBounds_PDU::get_const_OssEncOID() const {
    if (index == 1)
	return (const OssEncOID *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_ACSE_apdu(const ACSE_apdu & d) {
    index = 2;
    data = (void *)&d;
    constant = 1;
}

const ACSE_apdu *UpperBounds_PDU::get_const_ACSE_apdu() const {
    if (index == 2)
	return (const ACSE_apdu *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_AE_title(const AE_title & d) {
    index = 3;
    data = (void *)&d;
    constant = 1;
}

const AE_title *UpperBounds_PDU::get_const_AE_title() const {
    if (index == 3)
	return (const AE_title *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_CP_type(const CP_type & d) {
    index = 4;
    data = (void *)&d;
    constant = 1;
}

const CP_type *UpperBounds_PDU::get_const_CP_type() const {
    if (index == 4)
	return (const CP_type *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_CPC_type(const CPC_type & d) {
    index = 5;
    data = (void *)&d;
    constant = 1;
}

const CPC_type *UpperBounds_PDU::get_const_CPC_type() const {
    if (index == 5)
	return (const CPC_type *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_CPA_PPDU(const CPA_PPDU & d) {
    index = 6;
    data = (void *)&d;
    constant = 1;
}

const CPA_PPDU *UpperBounds_PDU::get_const_CPA_PPDU() const {
    if (index == 6)
	return (const CPA_PPDU *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_CPR_PPDU(const CPR_PPDU & d) {
    index = 7;
    data = (void *)&d;
    constant = 1;
}

const CPR_PPDU *UpperBounds_PDU::get_const_CPR_PPDU() const {
    if (index == 7)
	return (const CPR_PPDU *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_Abort_type(const Abort_type & d) {
    index = 8;
    data = (void *)&d;
    constant = 1;
}

const Abort_type *UpperBounds_PDU::get_const_Abort_type() const {
    if (index == 8)
	return (const Abort_type *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_Typed_data_type(const Typed_data_type & d) {
    index = 9;
    data = (void *)&d;
    constant = 1;
}

const Typed_data_type *UpperBounds_PDU::get_const_Typed_data_type() const {
    if (index == 9)
	return (const Typed_data_type *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_RS_PPDU(const RS_PPDU & d) {
    index = 10;
    data = (void *)&d;
    constant = 1;
}

const RS_PPDU *UpperBounds_PDU::get_const_RS_PPDU() const {
    if (index == 10)
	return (const RS_PPDU *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_RSA_PPDU(const RSA_PPDU & d) {
    index = 11;
    data = (void *)&d;
    constant = 1;
}

const RSA_PPDU *UpperBounds_PDU::get_const_RSA_PPDU() const {
    if (index == 11)
	return (const RSA_PPDU *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_Reliable_Transfer_APDU_RTSE_apdus(const Reliable_Transfer_APDU_RTSE_apdus & d) {
    index = 12;
    data = (void *)&d;
    constant = 1;
}

const Reliable_Transfer_APDU_RTSE_apdus *UpperBounds_PDU::get_const_Reliable_Transfer_APDU_RTSE_apdus() const {
    if (index == 12)
	return (const Reliable_Transfer_APDU_RTSE_apdus *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_Remote_Operations_Abstract_Syntaxes_RTSE_apdus(const Remote_Operations_Abstract_Syntaxes_RTSE_apdus & d) {
    index = 13;
    data = (void *)&d;
    constant = 1;
}

const Remote_Operations_Abstract_Syntaxes_RTSE_apdus *UpperBounds_PDU::get_const_Remote_Operations_Abstract_Syntaxes_RTSE_apdus() const {
    if (index == 13)
	return (const Remote_Operations_Abstract_Syntaxes_RTSE_apdus *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_ROSEInvokeIds(const ROSEInvokeIds & d) {
    index = 14;
    data = (void *)&d;
    constant = 1;
}

const ROSEInvokeIds *UpperBounds_PDU::get_const_ROSEInvokeIds() const {
    if (index == 14)
	return (const ROSEInvokeIds *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_Reject(const Reject & d) {
    index = 15;
    data = (void *)&d;
    constant = 1;
}

const Reject *UpperBounds_PDU::get_const_Reject() const {
    if (index == 15)
	return (const Reject *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_NoInvokeId(const NoInvokeId & d) {
    index = 16;
    data = (void *)&d;
    constant = 1;
}

const NoInvokeId *UpperBounds_PDU::get_const_NoInvokeId() const {
    if (index == 16)
	return (const NoInvokeId *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_UnboundedDirectoryString(const UnboundedDirectoryString & d) {
    index = 17;
    data = (void *)&d;
    constant = 1;
}

const UnboundedDirectoryString *UpperBounds_PDU::get_const_UnboundedDirectoryString() const {
    if (index == 17)
	return (const UnboundedDirectoryString *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_UniqueIdentifier(const UniqueIdentifier & d) {
    index = 18;
    data = (void *)&d;
    constant = 1;
}

const UniqueIdentifier *UpperBounds_PDU::get_const_UniqueIdentifier() const {
    if (index == 18)
	return (const UniqueIdentifier *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_UUIDPair(const UUIDPair & d) {
    index = 19;
    data = (void *)&d;
    constant = 1;
}

const UUIDPair *UpperBounds_PDU::get_const_UUIDPair() const {
    if (index == 19)
	return (const UUIDPair *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_CountryName(const CountryName & d) {
    index = 20;
    data = (void *)&d;
    constant = 1;
}

const CountryName *UpperBounds_PDU::get_const_CountryName() const {
    if (index == 20)
	return (const CountryName *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_Guide(const Guide & d) {
    index = 21;
    data = (void *)&d;
    constant = 1;
}

const Guide *UpperBounds_PDU::get_const_Guide() const {
    if (index == 21)
	return (const Guide *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_EnhancedGuide(const EnhancedGuide & d) {
    index = 22;
    data = (void *)&d;
    constant = 1;
}

const EnhancedGuide *UpperBounds_PDU::get_const_EnhancedGuide() const {
    if (index == 22)
	return (const EnhancedGuide *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_PostalAddress(const PostalAddress & d) {
    index = 23;
    data = (void *)&d;
    constant = 1;
}

const PostalAddress *UpperBounds_PDU::get_const_PostalAddress() const {
    if (index == 23)
	return (const PostalAddress *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_TelephoneNumber(const TelephoneNumber & d) {
    index = 24;
    data = (void *)&d;
    constant = 1;
}

const TelephoneNumber *UpperBounds_PDU::get_const_TelephoneNumber() const {
    if (index == 24)
	return (const TelephoneNumber *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_TelexNumber(const TelexNumber & d) {
    index = 25;
    data = (void *)&d;
    constant = 1;
}

const TelexNumber *UpperBounds_PDU::get_const_TelexNumber() const {
    if (index == 25)
	return (const TelexNumber *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_X121Address(const X121Address & d) {
    index = 26;
    data = (void *)&d;
    constant = 1;
}

const X121Address *UpperBounds_PDU::get_const_X121Address() const {
    if (index == 26)
	return (const X121Address *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_InternationalISDNNumber(const InternationalISDNNumber & d) {
    index = 27;
    data = (void *)&d;
    constant = 1;
}

const InternationalISDNNumber *UpperBounds_PDU::get_const_InternationalISDNNumber() const {
    if (index == 27)
	return (const InternationalISDNNumber *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_DestinationIndicator(const DestinationIndicator & d) {
    index = 28;
    data = (void *)&d;
    constant = 1;
}

const DestinationIndicator *UpperBounds_PDU::get_const_DestinationIndicator() const {
    if (index == 28)
	return (const DestinationIndicator *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_CommunicationsService(const CommunicationsService & d) {
    index = 29;
    data = (void *)&d;
    constant = 1;
}

const CommunicationsService *UpperBounds_PDU::get_const_CommunicationsService() const {
    if (index == 29)
	return (const CommunicationsService *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_CommunicationsNetwork(const CommunicationsNetwork & d) {
    index = 30;
    data = (void *)&d;
    constant = 1;
}

const CommunicationsNetwork *UpperBounds_PDU::get_const_CommunicationsNetwork() const {
    if (index == 30)
	return (const CommunicationsNetwork *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_PreferredDeliveryMethod(const PreferredDeliveryMethod & d) {
    index = 31;
    data = (void *)&d;
    constant = 1;
}

const PreferredDeliveryMethod *UpperBounds_PDU::get_const_PreferredDeliveryMethod() const {
    if (index == 31)
	return (const PreferredDeliveryMethod *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_PresentationAddress(const PresentationAddress & d) {
    index = 32;
    data = (void *)&d;
    constant = 1;
}

const PresentationAddress *UpperBounds_PDU::get_const_PresentationAddress() const {
    if (index == 32)
	return (const PresentationAddress *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_ProtocolInformation(const ProtocolInformation & d) {
    index = 33;
    data = (void *)&d;
    constant = 1;
}

const ProtocolInformation *UpperBounds_PDU::get_const_ProtocolInformation() const {
    if (index == 33)
	return (const ProtocolInformation *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_NameAndOptionalUID(const NameAndOptionalUID & d) {
    index = 34;
    data = (void *)&d;
    constant = 1;
}

const NameAndOptionalUID *UpperBounds_PDU::get_const_NameAndOptionalUID() const {
    if (index == 34)
	return (const NameAndOptionalUID *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_MultipleMatchingLocalities(const MultipleMatchingLocalities & d) {
    index = 35;
    data = (void *)&d;
    constant = 1;
}

const MultipleMatchingLocalities *UpperBounds_PDU::get_const_MultipleMatchingLocalities() const {
    if (index == 35)
	return (const MultipleMatchingLocalities *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_SubstringAssertion(const SubstringAssertion & d) {
    index = 36;
    data = (void *)&d;
    constant = 1;
}

const SubstringAssertion *UpperBounds_PDU::get_const_SubstringAssertion() const {
    if (index == 36)
	return (const SubstringAssertion *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_CaseIgnoreList(const CaseIgnoreList & d) {
    index = 37;
    data = (void *)&d;
    constant = 1;
}

const CaseIgnoreList *UpperBounds_PDU::get_const_CaseIgnoreList() const {
    if (index == 37)
	return (const CaseIgnoreList *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_OctetSubstringAssertion(const OctetSubstringAssertion & d) {
    index = 38;
    data = (void *)&d;
    constant = 1;
}

const OctetSubstringAssertion *UpperBounds_PDU::get_const_OctetSubstringAssertion() const {
    if (index == 38)
	return (const OctetSubstringAssertion *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_SequenceMatchType(const SequenceMatchType & d) {
    index = 39;
    data = (void *)&d;
    constant = 1;
}

const SequenceMatchType *UpperBounds_PDU::get_const_SequenceMatchType() const {
    if (index == 39)
	return (const SequenceMatchType *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_WordMatchTypes(const WordMatchTypes & d) {
    index = 40;
    data = (void *)&d;
    constant = 1;
}

const WordMatchTypes *UpperBounds_PDU::get_const_WordMatchTypes() const {
    if (index == 40)
	return (const WordMatchTypes *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_CharacterMatchTypes(const CharacterMatchTypes & d) {
    index = 41;
    data = (void *)&d;
    constant = 1;
}

const CharacterMatchTypes *UpperBounds_PDU::get_const_CharacterMatchTypes() const {
    if (index == 41)
	return (const CharacterMatchTypes *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_LanguageContextSyntax(const LanguageContextSyntax & d) {
    index = 42;
    data = (void *)&d;
    constant = 1;
}

const LanguageContextSyntax *UpperBounds_PDU::get_const_LanguageContextSyntax() const {
    if (index == 42)
	return (const LanguageContextSyntax *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_TimeSpecification(const TimeSpecification & d) {
    index = 43;
    data = (void *)&d;
    constant = 1;
}

const TimeSpecification *UpperBounds_PDU::get_const_TimeSpecification() const {
    if (index == 43)
	return (const TimeSpecification *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_TimeAssertion(const TimeAssertion & d) {
    index = 44;
    data = (void *)&d;
    constant = 1;
}

const TimeAssertion *UpperBounds_PDU::get_const_TimeAssertion() const {
    if (index == 44)
	return (const TimeAssertion *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_LocaleContextSyntax(const LocaleContextSyntax & d) {
    index = 45;
    data = (void *)&d;
    constant = 1;
}

const LocaleContextSyntax *UpperBounds_PDU::get_const_LocaleContextSyntax() const {
    if (index == 45)
	return (const LocaleContextSyntax *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_AttributeOptionList(const AttributeOptionList & d) {
    index = 46;
    data = (void *)&d;
    constant = 1;
}

const AttributeOptionList *UpperBounds_PDU::get_const_AttributeOptionList() const {
    if (index == 46)
	return (const AttributeOptionList *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_ID(const ID & d) {
    index = 47;
    data = (void *)&d;
    constant = 1;
}

const ID *UpperBounds_PDU::get_const_ID() const {
    if (index == 47)
	return (const ID *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_AttributeValue(const AttributeValue & d) {
    index = 48;
    data = (void *)&d;
    constant = 1;
}

const AttributeValue *UpperBounds_PDU::get_const_AttributeValue() const {
    if (index == 48)
	return (const AttributeValue *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_ContextAssertion(const ContextAssertion & d) {
    index = 49;
    data = (void *)&d;
    constant = 1;
}

const ContextAssertion *UpperBounds_PDU::get_const_ContextAssertion() const {
    if (index == 49)
	return (const ContextAssertion *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_AttributeTypeAssertion(const AttributeTypeAssertion & d) {
    index = 50;
    data = (void *)&d;
    constant = 1;
}

const AttributeTypeAssertion *UpperBounds_PDU::get_const_AttributeTypeAssertion() const {
    if (index == 50)
	return (const AttributeTypeAssertion *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_DistinguishedName(const DistinguishedName & d) {
    index = 51;
    data = (void *)&d;
    constant = 1;
}

const DistinguishedName *UpperBounds_PDU::get_const_DistinguishedName() const {
    if (index == 51)
	return (const DistinguishedName *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_SubtreeSpecification(const SubtreeSpecification & d) {
    index = 52;
    data = (void *)&d;
    constant = 1;
}

const SubtreeSpecification *UpperBounds_PDU::get_const_SubtreeSpecification() const {
    if (index == 52)
	return (const SubtreeSpecification *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_DITStructureRule(const DITStructureRule & d) {
    index = 53;
    data = (void *)&d;
    constant = 1;
}

const DITStructureRule *UpperBounds_PDU::get_const_DITStructureRule() const {
    if (index == 53)
	return (const DITStructureRule *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_DITContentRule(const DITContentRule & d) {
    index = 54;
    data = (void *)&d;
    constant = 1;
}

const DITContentRule *UpperBounds_PDU::get_const_DITContentRule() const {
    if (index == 54)
	return (const DITContentRule *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_DITContextUse(const DITContextUse & d) {
    index = 55;
    data = (void *)&d;
    constant = 1;
}

const DITContextUse *UpperBounds_PDU::get_const_DITContextUse() const {
    if (index == 55)
	return (const DITContextUse *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_HierarchyLevel(const HierarchyLevel & d) {
    index = 56;
    data = (void *)&d;
    constant = 1;
}

const HierarchyLevel *UpperBounds_PDU::get_const_HierarchyLevel() const {
    if (index == 56)
	return (const HierarchyLevel *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_HierarchyBelow(const HierarchyBelow & d) {
    index = 57;
    data = (void *)&d;
    constant = 1;
}

const HierarchyBelow *UpperBounds_PDU::get_const_HierarchyBelow() const {
    if (index == 57)
	return (const HierarchyBelow *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_Acse_RealizationParameter(const Acse_RealizationParameter & d) {
    index = 58;
    data = (void *)&d;
    constant = 1;
}

const Acse_RealizationParameter *UpperBounds_PDU::get_const_Acse_RealizationParameter() const {
    if (index == 58)
	return (const Acse_RealizationParameter *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_Acse_with_concatenation_RealizationParameter(const Acse_with_concatenation_RealizationParameter & d) {
    index = 59;
    data = (void *)&d;
    constant = 1;
}

const Acse_with_concatenation_RealizationParameter *UpperBounds_PDU::get_const_Acse_with_concatenation_RealizationParameter() const {
    if (index == 59)
	return (const Acse_with_concatenation_RealizationParameter *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_Association_by_RTSE_RealizationParameter(const Association_by_RTSE_RealizationParameter & d) {
    index = 60;
    data = (void *)&d;
    constant = 1;
}

const Association_by_RTSE_RealizationParameter *UpperBounds_PDU::get_const_Association_by_RTSE_RealizationParameter() const {
    if (index == 60)
	return (const Association_by_RTSE_RealizationParameter *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_PData_RealizationParameter(const PData_RealizationParameter & d) {
    index = 61;
    data = (void *)&d;
    constant = 1;
}

const PData_RealizationParameter *UpperBounds_PDU::get_const_PData_RealizationParameter() const {
    if (index == 61)
	return (const PData_RealizationParameter *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_PData_with_concatenation_RealizationParameter(const PData_with_concatenation_RealizationParameter & d) {
    index = 62;
    data = (void *)&d;
    constant = 1;
}

const PData_with_concatenation_RealizationParameter *UpperBounds_PDU::get_const_PData_with_concatenation_RealizationParameter() const {
    if (index == 62)
	return (const PData_with_concatenation_RealizationParameter *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_Transfer_by_RTSE_RealizationParameter(const Transfer_by_RTSE_RealizationParameter & d) {
    index = 63;
    data = (void *)&d;
    constant = 1;
}

const Transfer_by_RTSE_RealizationParameter *UpperBounds_PDU::get_const_Transfer_by_RTSE_RealizationParameter() const {
    if (index == 63)
	return (const Transfer_by_RTSE_RealizationParameter *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_BitStringMatch_SYNTAX(const BitStringMatch_SYNTAX & d) {
    index = 64;
    data = (void *)&d;
    constant = 1;
}

const BitStringMatch_SYNTAX *UpperBounds_PDU::get_const_BitStringMatch_SYNTAX() const {
    if (index == 64)
	return (const BitStringMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_DnQualifier_WITH_SYNTAX(const DnQualifier_WITH_SYNTAX & d) {
    index = 65;
    data = (void *)&d;
    constant = 1;
}

const DnQualifier_WITH_SYNTAX *UpperBounds_PDU::get_const_DnQualifier_WITH_SYNTAX() const {
    if (index == 65)
	return (const DnQualifier_WITH_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_SerialNumber_WITH_SYNTAX(const SerialNumber_WITH_SYNTAX & d) {
    index = 66;
    data = (void *)&d;
    constant = 1;
}

const SerialNumber_WITH_SYNTAX *UpperBounds_PDU::get_const_SerialNumber_WITH_SYNTAX() const {
    if (index == 66)
	return (const SerialNumber_WITH_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_NumericStringMatch_SYNTAX(const NumericStringMatch_SYNTAX & d) {
    index = 67;
    data = (void *)&d;
    constant = 1;
}

const NumericStringMatch_SYNTAX *UpperBounds_PDU::get_const_NumericStringMatch_SYNTAX() const {
    if (index == 67)
	return (const NumericStringMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_ProtocolInformationMatch_SYNTAX(const ProtocolInformationMatch_SYNTAX & d) {
    index = 68;
    data = (void *)&d;
    constant = 1;
}

const ProtocolInformationMatch_SYNTAX *UpperBounds_PDU::get_const_ProtocolInformationMatch_SYNTAX() const {
    if (index == 68)
	return (const ProtocolInformationMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_UiiInUrn_WITH_SYNTAX(const UiiInUrn_WITH_SYNTAX & d) {
    index = 69;
    data = (void *)&d;
    constant = 1;
}

const UiiInUrn_WITH_SYNTAX *UpperBounds_PDU::get_const_UiiInUrn_WITH_SYNTAX() const {
    if (index == 69)
	return (const UiiInUrn_WITH_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_NumericStringOrderingMatch_SYNTAX(const NumericStringOrderingMatch_SYNTAX & d) {
    index = 70;
    data = (void *)&d;
    constant = 1;
}

const NumericStringOrderingMatch_SYNTAX *UpperBounds_PDU::get_const_NumericStringOrderingMatch_SYNTAX() const {
    if (index == 70)
	return (const NumericStringOrderingMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_BooleanMatch_SYNTAX(const BooleanMatch_SYNTAX & d) {
    index = 71;
    data = (void *)&d;
    constant = 1;
}

const BooleanMatch_SYNTAX *UpperBounds_PDU::get_const_BooleanMatch_SYNTAX() const {
    if (index == 71)
	return (const BooleanMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_IntegerMatch_SYNTAX(const IntegerMatch_SYNTAX & d) {
    index = 72;
    data = (void *)&d;
    constant = 1;
}

const IntegerMatch_SYNTAX *UpperBounds_PDU::get_const_IntegerMatch_SYNTAX() const {
    if (index == 72)
	return (const IntegerMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_IntegerOrderingMatch_SYNTAX(const IntegerOrderingMatch_SYNTAX & d) {
    index = 73;
    data = (void *)&d;
    constant = 1;
}

const IntegerOrderingMatch_SYNTAX *UpperBounds_PDU::get_const_IntegerOrderingMatch_SYNTAX() const {
    if (index == 73)
	return (const IntegerOrderingMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_OctetStringMatch_SYNTAX(const OctetStringMatch_SYNTAX & d) {
    index = 74;
    data = (void *)&d;
    constant = 1;
}

const OctetStringMatch_SYNTAX *UpperBounds_PDU::get_const_OctetStringMatch_SYNTAX() const {
    if (index == 74)
	return (const OctetStringMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_OctetStringOrderingMatch_SYNTAX(const OctetStringOrderingMatch_SYNTAX & d) {
    index = 75;
    data = (void *)&d;
    constant = 1;
}

const OctetStringOrderingMatch_SYNTAX *UpperBounds_PDU::get_const_OctetStringOrderingMatch_SYNTAX() const {
    if (index == 75)
	return (const OctetStringOrderingMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_UTCTimeMatch_SYNTAX(const UTCTimeMatch_SYNTAX & d) {
    index = 76;
    data = (void *)&d;
    constant = 1;
}

const UTCTimeMatch_SYNTAX *UpperBounds_PDU::get_const_UTCTimeMatch_SYNTAX() const {
    if (index == 76)
	return (const UTCTimeMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_UTCTimeOrderingMatch_SYNTAX(const UTCTimeOrderingMatch_SYNTAX & d) {
    index = 77;
    data = (void *)&d;
    constant = 1;
}

const UTCTimeOrderingMatch_SYNTAX *UpperBounds_PDU::get_const_UTCTimeOrderingMatch_SYNTAX() const {
    if (index == 77)
	return (const UTCTimeOrderingMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_GeneralizedTimeMatch_SYNTAX(const GeneralizedTimeMatch_SYNTAX & d) {
    index = 78;
    data = (void *)&d;
    constant = 1;
}

const GeneralizedTimeMatch_SYNTAX *UpperBounds_PDU::get_const_GeneralizedTimeMatch_SYNTAX() const {
    if (index == 78)
	return (const GeneralizedTimeMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_GeneralizedTimeOrderingMatch_SYNTAX(const GeneralizedTimeOrderingMatch_SYNTAX & d) {
    index = 79;
    data = (void *)&d;
    constant = 1;
}

const GeneralizedTimeOrderingMatch_SYNTAX *UpperBounds_PDU::get_const_GeneralizedTimeOrderingMatch_SYNTAX() const {
    if (index == 79)
	return (const GeneralizedTimeOrderingMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_IntegerFirstComponentMatch_SYNTAX(const IntegerFirstComponentMatch_SYNTAX & d) {
    index = 80;
    data = (void *)&d;
    constant = 1;
}

const IntegerFirstComponentMatch_SYNTAX *UpperBounds_PDU::get_const_IntegerFirstComponentMatch_SYNTAX() const {
    if (index == 80)
	return (const IntegerFirstComponentMatch_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_AdministrativeRole_WITH_SYNTAX(const AdministrativeRole_WITH_SYNTAX & d) {
    index = 81;
    data = (void *)&d;
    constant = 1;
}

const AdministrativeRole_WITH_SYNTAX *UpperBounds_PDU::get_const_AdministrativeRole_WITH_SYNTAX() const {
    if (index == 81)
	return (const AdministrativeRole_WITH_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_CreateTimestamp_WITH_SYNTAX(const CreateTimestamp_WITH_SYNTAX & d) {
    index = 82;
    data = (void *)&d;
    constant = 1;
}

const CreateTimestamp_WITH_SYNTAX *UpperBounds_PDU::get_const_CreateTimestamp_WITH_SYNTAX() const {
    if (index == 82)
	return (const CreateTimestamp_WITH_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_ModifyTimestamp_WITH_SYNTAX(const ModifyTimestamp_WITH_SYNTAX & d) {
    index = 83;
    data = (void *)&d;
    constant = 1;
}

const ModifyTimestamp_WITH_SYNTAX *UpperBounds_PDU::get_const_ModifyTimestamp_WITH_SYNTAX() const {
    if (index == 83)
	return (const ModifyTimestamp_WITH_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_SubschemaTimestamp_WITH_SYNTAX(const SubschemaTimestamp_WITH_SYNTAX & d) {
    index = 84;
    data = (void *)&d;
    constant = 1;
}

const SubschemaTimestamp_WITH_SYNTAX *UpperBounds_PDU::get_const_SubschemaTimestamp_WITH_SYNTAX() const {
    if (index == 84)
	return (const SubschemaTimestamp_WITH_SYNTAX *)data;
    else
	return 0;
}

void UpperBounds_PDU::set_const_HasSubordinates_WITH_SYNTAX(const HasSubordinates_WITH_SYNTAX & d) {
    index = 85;
    data = (void *)&d;
    constant = 1;
}

const HasSubordinates_WITH_SYNTAX *UpperBounds_PDU::get_const_HasSubordinates_WITH_SYNTAX() const {
    if (index == 85)
	return (const HasSubordinates_WITH_SYNTAX *)data;
    else
	return 0;
}

#endif
/* Specific PDU classes */

OssEncOID_PDU::OssEncOID_PDU() {
}

void OssEncOID_PDU::set_data(OssEncOID & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

OssEncOID *OssEncOID_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (OssEncOID *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void OssEncOID_PDU::set_const_data(const OssEncOID & d) {
    data = (void *)&d;
    constant = 1;
}

const OssEncOID *OssEncOID_PDU::get_const_data() const {
    return (const OssEncOID *)data;
}

#endif

OssTypeIndex OssEncOID_PDU::get_index() const {
    return 1;
}

ACSE_apdu_PDU::ACSE_apdu_PDU() {
}

void ACSE_apdu_PDU::set_data(ACSE_apdu & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ACSE_apdu *ACSE_apdu_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ACSE_apdu *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ACSE_apdu_PDU::set_const_data(const ACSE_apdu & d) {
    data = (void *)&d;
    constant = 1;
}

const ACSE_apdu *ACSE_apdu_PDU::get_const_data() const {
    return (const ACSE_apdu *)data;
}

#endif

OssTypeIndex ACSE_apdu_PDU::get_index() const {
    return 2;
}

AE_title_PDU::AE_title_PDU() {
}

void AE_title_PDU::set_data(AE_title & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AE_title *AE_title_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (AE_title *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void AE_title_PDU::set_const_data(const AE_title & d) {
    data = (void *)&d;
    constant = 1;
}

const AE_title *AE_title_PDU::get_const_data() const {
    return (const AE_title *)data;
}

#endif

OssTypeIndex AE_title_PDU::get_index() const {
    return 3;
}

CP_type_PDU::CP_type_PDU() {
}

void CP_type_PDU::set_data(CP_type & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CP_type *CP_type_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (CP_type *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void CP_type_PDU::set_const_data(const CP_type & d) {
    data = (void *)&d;
    constant = 1;
}

const CP_type *CP_type_PDU::get_const_data() const {
    return (const CP_type *)data;
}

#endif

OssTypeIndex CP_type_PDU::get_index() const {
    return 4;
}

CPC_type_PDU::CPC_type_PDU() {
}

void CPC_type_PDU::set_data(CPC_type & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CPC_type *CPC_type_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (CPC_type *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void CPC_type_PDU::set_const_data(const CPC_type & d) {
    data = (void *)&d;
    constant = 1;
}

const CPC_type *CPC_type_PDU::get_const_data() const {
    return (const CPC_type *)data;
}

#endif

OssTypeIndex CPC_type_PDU::get_index() const {
    return 5;
}

CPA_PPDU_PDU::CPA_PPDU_PDU() {
}

void CPA_PPDU_PDU::set_data(CPA_PPDU & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CPA_PPDU *CPA_PPDU_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (CPA_PPDU *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void CPA_PPDU_PDU::set_const_data(const CPA_PPDU & d) {
    data = (void *)&d;
    constant = 1;
}

const CPA_PPDU *CPA_PPDU_PDU::get_const_data() const {
    return (const CPA_PPDU *)data;
}

#endif

OssTypeIndex CPA_PPDU_PDU::get_index() const {
    return 6;
}

CPR_PPDU_PDU::CPR_PPDU_PDU() {
}

void CPR_PPDU_PDU::set_data(CPR_PPDU & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CPR_PPDU *CPR_PPDU_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (CPR_PPDU *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void CPR_PPDU_PDU::set_const_data(const CPR_PPDU & d) {
    data = (void *)&d;
    constant = 1;
}

const CPR_PPDU *CPR_PPDU_PDU::get_const_data() const {
    return (const CPR_PPDU *)data;
}

#endif

OssTypeIndex CPR_PPDU_PDU::get_index() const {
    return 7;
}

Abort_type_PDU::Abort_type_PDU() {
}

void Abort_type_PDU::set_data(Abort_type & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Abort_type *Abort_type_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Abort_type *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Abort_type_PDU::set_const_data(const Abort_type & d) {
    data = (void *)&d;
    constant = 1;
}

const Abort_type *Abort_type_PDU::get_const_data() const {
    return (const Abort_type *)data;
}

#endif

OssTypeIndex Abort_type_PDU::get_index() const {
    return 8;
}

Typed_data_type_PDU::Typed_data_type_PDU() {
}

void Typed_data_type_PDU::set_data(Typed_data_type & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Typed_data_type *Typed_data_type_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Typed_data_type *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Typed_data_type_PDU::set_const_data(const Typed_data_type & d) {
    data = (void *)&d;
    constant = 1;
}

const Typed_data_type *Typed_data_type_PDU::get_const_data() const {
    return (const Typed_data_type *)data;
}

#endif

OssTypeIndex Typed_data_type_PDU::get_index() const {
    return 9;
}

RS_PPDU_PDU::RS_PPDU_PDU() {
}

void RS_PPDU_PDU::set_data(RS_PPDU & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

RS_PPDU *RS_PPDU_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (RS_PPDU *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void RS_PPDU_PDU::set_const_data(const RS_PPDU & d) {
    data = (void *)&d;
    constant = 1;
}

const RS_PPDU *RS_PPDU_PDU::get_const_data() const {
    return (const RS_PPDU *)data;
}

#endif

OssTypeIndex RS_PPDU_PDU::get_index() const {
    return 10;
}

RSA_PPDU_PDU::RSA_PPDU_PDU() {
}

void RSA_PPDU_PDU::set_data(RSA_PPDU & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

RSA_PPDU *RSA_PPDU_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (RSA_PPDU *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void RSA_PPDU_PDU::set_const_data(const RSA_PPDU & d) {
    data = (void *)&d;
    constant = 1;
}

const RSA_PPDU *RSA_PPDU_PDU::get_const_data() const {
    return (const RSA_PPDU *)data;
}

#endif

OssTypeIndex RSA_PPDU_PDU::get_index() const {
    return 11;
}

Reliable_Transfer_APDU_RTSE_apdus_PDU::Reliable_Transfer_APDU_RTSE_apdus_PDU() {
}

void Reliable_Transfer_APDU_RTSE_apdus_PDU::set_data(Reliable_Transfer_APDU_RTSE_apdus & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Reliable_Transfer_APDU_RTSE_apdus *Reliable_Transfer_APDU_RTSE_apdus_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Reliable_Transfer_APDU_RTSE_apdus *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Reliable_Transfer_APDU_RTSE_apdus_PDU::set_const_data(const Reliable_Transfer_APDU_RTSE_apdus & d) {
    data = (void *)&d;
    constant = 1;
}

const Reliable_Transfer_APDU_RTSE_apdus *Reliable_Transfer_APDU_RTSE_apdus_PDU::get_const_data() const {
    return (const Reliable_Transfer_APDU_RTSE_apdus *)data;
}

#endif

OssTypeIndex Reliable_Transfer_APDU_RTSE_apdus_PDU::get_index() const {
    return 12;
}

Remote_Operations_Abstract_Syntaxes_RTSE_apdus_PDU::Remote_Operations_Abstract_Syntaxes_RTSE_apdus_PDU() {
}

void Remote_Operations_Abstract_Syntaxes_RTSE_apdus_PDU::set_data(Remote_Operations_Abstract_Syntaxes_RTSE_apdus & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Remote_Operations_Abstract_Syntaxes_RTSE_apdus *Remote_Operations_Abstract_Syntaxes_RTSE_apdus_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Remote_Operations_Abstract_Syntaxes_RTSE_apdus *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Remote_Operations_Abstract_Syntaxes_RTSE_apdus_PDU::set_const_data(const Remote_Operations_Abstract_Syntaxes_RTSE_apdus & d) {
    data = (void *)&d;
    constant = 1;
}

const Remote_Operations_Abstract_Syntaxes_RTSE_apdus *Remote_Operations_Abstract_Syntaxes_RTSE_apdus_PDU::get_const_data() const {
    return (const Remote_Operations_Abstract_Syntaxes_RTSE_apdus *)data;
}

#endif

OssTypeIndex Remote_Operations_Abstract_Syntaxes_RTSE_apdus_PDU::get_index() const {
    return 13;
}

ROSEInvokeIds_PDU::ROSEInvokeIds_PDU() {
}

void ROSEInvokeIds_PDU::set_data(ROSEInvokeIds & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ROSEInvokeIds *ROSEInvokeIds_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ROSEInvokeIds *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ROSEInvokeIds_PDU::set_const_data(const ROSEInvokeIds & d) {
    data = (void *)&d;
    constant = 1;
}

const ROSEInvokeIds *ROSEInvokeIds_PDU::get_const_data() const {
    return (const ROSEInvokeIds *)data;
}

#endif

OssTypeIndex ROSEInvokeIds_PDU::get_index() const {
    return 14;
}

Reject_PDU::Reject_PDU() {
}

void Reject_PDU::set_data(Reject & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Reject *Reject_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Reject *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Reject_PDU::set_const_data(const Reject & d) {
    data = (void *)&d;
    constant = 1;
}

const Reject *Reject_PDU::get_const_data() const {
    return (const Reject *)data;
}

#endif

OssTypeIndex Reject_PDU::get_index() const {
    return 15;
}

NoInvokeId_PDU::NoInvokeId_PDU() {
}

void NoInvokeId_PDU::set_data(NoInvokeId & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NoInvokeId *NoInvokeId_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (NoInvokeId *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void NoInvokeId_PDU::set_const_data(const NoInvokeId & d) {
    data = (void *)&d;
    constant = 1;
}

const NoInvokeId *NoInvokeId_PDU::get_const_data() const {
    return (const NoInvokeId *)data;
}

#endif

OssTypeIndex NoInvokeId_PDU::get_index() const {
    return 16;
}

UnboundedDirectoryString_PDU::UnboundedDirectoryString_PDU() {
}

void UnboundedDirectoryString_PDU::set_data(UnboundedDirectoryString & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

UnboundedDirectoryString *UnboundedDirectoryString_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (UnboundedDirectoryString *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void UnboundedDirectoryString_PDU::set_const_data(const UnboundedDirectoryString & d) {
    data = (void *)&d;
    constant = 1;
}

const UnboundedDirectoryString *UnboundedDirectoryString_PDU::get_const_data() const {
    return (const UnboundedDirectoryString *)data;
}

#endif

OssTypeIndex UnboundedDirectoryString_PDU::get_index() const {
    return 17;
}

UniqueIdentifier_PDU::UniqueIdentifier_PDU() {
}

void UniqueIdentifier_PDU::set_data(UniqueIdentifier & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

UniqueIdentifier *UniqueIdentifier_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (UniqueIdentifier *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void UniqueIdentifier_PDU::set_const_data(const UniqueIdentifier & d) {
    data = (void *)&d;
    constant = 1;
}

const UniqueIdentifier *UniqueIdentifier_PDU::get_const_data() const {
    return (const UniqueIdentifier *)data;
}

#endif

OssTypeIndex UniqueIdentifier_PDU::get_index() const {
    return 18;
}

UUIDPair_PDU::UUIDPair_PDU() {
}

void UUIDPair_PDU::set_data(UUIDPair & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

UUIDPair *UUIDPair_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (UUIDPair *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void UUIDPair_PDU::set_const_data(const UUIDPair & d) {
    data = (void *)&d;
    constant = 1;
}

const UUIDPair *UUIDPair_PDU::get_const_data() const {
    return (const UUIDPair *)data;
}

#endif

OssTypeIndex UUIDPair_PDU::get_index() const {
    return 19;
}

CountryName_PDU::CountryName_PDU() {
}

void CountryName_PDU::set_data(CountryName & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CountryName *CountryName_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (CountryName *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void CountryName_PDU::set_const_data(const CountryName & d) {
    data = (void *)&d;
    constant = 1;
}

const CountryName *CountryName_PDU::get_const_data() const {
    return (const CountryName *)data;
}

#endif

OssTypeIndex CountryName_PDU::get_index() const {
    return 20;
}

Guide_PDU::Guide_PDU() {
}

void Guide_PDU::set_data(Guide & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Guide *Guide_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Guide *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Guide_PDU::set_const_data(const Guide & d) {
    data = (void *)&d;
    constant = 1;
}

const Guide *Guide_PDU::get_const_data() const {
    return (const Guide *)data;
}

#endif

OssTypeIndex Guide_PDU::get_index() const {
    return 21;
}

EnhancedGuide_PDU::EnhancedGuide_PDU() {
}

void EnhancedGuide_PDU::set_data(EnhancedGuide & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EnhancedGuide *EnhancedGuide_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (EnhancedGuide *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void EnhancedGuide_PDU::set_const_data(const EnhancedGuide & d) {
    data = (void *)&d;
    constant = 1;
}

const EnhancedGuide *EnhancedGuide_PDU::get_const_data() const {
    return (const EnhancedGuide *)data;
}

#endif

OssTypeIndex EnhancedGuide_PDU::get_index() const {
    return 22;
}

PostalAddress_PDU::PostalAddress_PDU() {
}

void PostalAddress_PDU::set_data(PostalAddress & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PostalAddress *PostalAddress_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PostalAddress *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PostalAddress_PDU::set_const_data(const PostalAddress & d) {
    data = (void *)&d;
    constant = 1;
}

const PostalAddress *PostalAddress_PDU::get_const_data() const {
    return (const PostalAddress *)data;
}

#endif

OssTypeIndex PostalAddress_PDU::get_index() const {
    return 23;
}

TelephoneNumber_PDU::TelephoneNumber_PDU() {
}

void TelephoneNumber_PDU::set_data(TelephoneNumber & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TelephoneNumber *TelephoneNumber_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (TelephoneNumber *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void TelephoneNumber_PDU::set_const_data(const TelephoneNumber & d) {
    data = (void *)&d;
    constant = 1;
}

const TelephoneNumber *TelephoneNumber_PDU::get_const_data() const {
    return (const TelephoneNumber *)data;
}

#endif

OssTypeIndex TelephoneNumber_PDU::get_index() const {
    return 24;
}

TelexNumber_PDU::TelexNumber_PDU() {
}

void TelexNumber_PDU::set_data(TelexNumber & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TelexNumber *TelexNumber_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (TelexNumber *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void TelexNumber_PDU::set_const_data(const TelexNumber & d) {
    data = (void *)&d;
    constant = 1;
}

const TelexNumber *TelexNumber_PDU::get_const_data() const {
    return (const TelexNumber *)data;
}

#endif

OssTypeIndex TelexNumber_PDU::get_index() const {
    return 25;
}

X121Address_PDU::X121Address_PDU() {
}

void X121Address_PDU::set_data(X121Address & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

X121Address *X121Address_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (X121Address *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void X121Address_PDU::set_const_data(const X121Address & d) {
    data = (void *)&d;
    constant = 1;
}

const X121Address *X121Address_PDU::get_const_data() const {
    return (const X121Address *)data;
}

#endif

OssTypeIndex X121Address_PDU::get_index() const {
    return 26;
}

InternationalISDNNumber_PDU::InternationalISDNNumber_PDU() {
}

void InternationalISDNNumber_PDU::set_data(InternationalISDNNumber & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

InternationalISDNNumber *InternationalISDNNumber_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (InternationalISDNNumber *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void InternationalISDNNumber_PDU::set_const_data(const InternationalISDNNumber & d) {
    data = (void *)&d;
    constant = 1;
}

const InternationalISDNNumber *InternationalISDNNumber_PDU::get_const_data() const {
    return (const InternationalISDNNumber *)data;
}

#endif

OssTypeIndex InternationalISDNNumber_PDU::get_index() const {
    return 27;
}

DestinationIndicator_PDU::DestinationIndicator_PDU() {
}

void DestinationIndicator_PDU::set_data(DestinationIndicator & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

DestinationIndicator *DestinationIndicator_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (DestinationIndicator *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void DestinationIndicator_PDU::set_const_data(const DestinationIndicator & d) {
    data = (void *)&d;
    constant = 1;
}

const DestinationIndicator *DestinationIndicator_PDU::get_const_data() const {
    return (const DestinationIndicator *)data;
}

#endif

OssTypeIndex DestinationIndicator_PDU::get_index() const {
    return 28;
}

CommunicationsService_PDU::CommunicationsService_PDU() {
}

void CommunicationsService_PDU::set_data(CommunicationsService & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CommunicationsService *CommunicationsService_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (CommunicationsService *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void CommunicationsService_PDU::set_const_data(const CommunicationsService & d) {
    data = (void *)&d;
    constant = 1;
}

const CommunicationsService *CommunicationsService_PDU::get_const_data() const {
    return (const CommunicationsService *)data;
}

#endif

OssTypeIndex CommunicationsService_PDU::get_index() const {
    return 29;
}

CommunicationsNetwork_PDU::CommunicationsNetwork_PDU() {
}

void CommunicationsNetwork_PDU::set_data(CommunicationsNetwork & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CommunicationsNetwork *CommunicationsNetwork_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (CommunicationsNetwork *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void CommunicationsNetwork_PDU::set_const_data(const CommunicationsNetwork & d) {
    data = (void *)&d;
    constant = 1;
}

const CommunicationsNetwork *CommunicationsNetwork_PDU::get_const_data() const {
    return (const CommunicationsNetwork *)data;
}

#endif

OssTypeIndex CommunicationsNetwork_PDU::get_index() const {
    return 30;
}

PreferredDeliveryMethod_PDU::PreferredDeliveryMethod_PDU() {
}

void PreferredDeliveryMethod_PDU::set_data(PreferredDeliveryMethod & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PreferredDeliveryMethod *PreferredDeliveryMethod_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PreferredDeliveryMethod *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PreferredDeliveryMethod_PDU::set_const_data(const PreferredDeliveryMethod & d) {
    data = (void *)&d;
    constant = 1;
}

const PreferredDeliveryMethod *PreferredDeliveryMethod_PDU::get_const_data() const {
    return (const PreferredDeliveryMethod *)data;
}

#endif

OssTypeIndex PreferredDeliveryMethod_PDU::get_index() const {
    return 31;
}

PresentationAddress_PDU::PresentationAddress_PDU() {
}

void PresentationAddress_PDU::set_data(PresentationAddress & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PresentationAddress *PresentationAddress_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PresentationAddress *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PresentationAddress_PDU::set_const_data(const PresentationAddress & d) {
    data = (void *)&d;
    constant = 1;
}

const PresentationAddress *PresentationAddress_PDU::get_const_data() const {
    return (const PresentationAddress *)data;
}

#endif

OssTypeIndex PresentationAddress_PDU::get_index() const {
    return 32;
}

ProtocolInformation_PDU::ProtocolInformation_PDU() {
}

void ProtocolInformation_PDU::set_data(ProtocolInformation & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ProtocolInformation *ProtocolInformation_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ProtocolInformation *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ProtocolInformation_PDU::set_const_data(const ProtocolInformation & d) {
    data = (void *)&d;
    constant = 1;
}

const ProtocolInformation *ProtocolInformation_PDU::get_const_data() const {
    return (const ProtocolInformation *)data;
}

#endif

OssTypeIndex ProtocolInformation_PDU::get_index() const {
    return 33;
}

NameAndOptionalUID_PDU::NameAndOptionalUID_PDU() {
}

void NameAndOptionalUID_PDU::set_data(NameAndOptionalUID & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NameAndOptionalUID *NameAndOptionalUID_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (NameAndOptionalUID *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void NameAndOptionalUID_PDU::set_const_data(const NameAndOptionalUID & d) {
    data = (void *)&d;
    constant = 1;
}

const NameAndOptionalUID *NameAndOptionalUID_PDU::get_const_data() const {
    return (const NameAndOptionalUID *)data;
}

#endif

OssTypeIndex NameAndOptionalUID_PDU::get_index() const {
    return 34;
}

MultipleMatchingLocalities_PDU::MultipleMatchingLocalities_PDU() {
}

void MultipleMatchingLocalities_PDU::set_data(MultipleMatchingLocalities & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

MultipleMatchingLocalities *MultipleMatchingLocalities_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (MultipleMatchingLocalities *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void MultipleMatchingLocalities_PDU::set_const_data(const MultipleMatchingLocalities & d) {
    data = (void *)&d;
    constant = 1;
}

const MultipleMatchingLocalities *MultipleMatchingLocalities_PDU::get_const_data() const {
    return (const MultipleMatchingLocalities *)data;
}

#endif

OssTypeIndex MultipleMatchingLocalities_PDU::get_index() const {
    return 35;
}

SubstringAssertion_PDU::SubstringAssertion_PDU() {
}

void SubstringAssertion_PDU::set_data(SubstringAssertion & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SubstringAssertion *SubstringAssertion_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (SubstringAssertion *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void SubstringAssertion_PDU::set_const_data(const SubstringAssertion & d) {
    data = (void *)&d;
    constant = 1;
}

const SubstringAssertion *SubstringAssertion_PDU::get_const_data() const {
    return (const SubstringAssertion *)data;
}

#endif

OssTypeIndex SubstringAssertion_PDU::get_index() const {
    return 36;
}

CaseIgnoreList_PDU::CaseIgnoreList_PDU() {
}

void CaseIgnoreList_PDU::set_data(CaseIgnoreList & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CaseIgnoreList *CaseIgnoreList_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (CaseIgnoreList *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void CaseIgnoreList_PDU::set_const_data(const CaseIgnoreList & d) {
    data = (void *)&d;
    constant = 1;
}

const CaseIgnoreList *CaseIgnoreList_PDU::get_const_data() const {
    return (const CaseIgnoreList *)data;
}

#endif

OssTypeIndex CaseIgnoreList_PDU::get_index() const {
    return 37;
}

OctetSubstringAssertion_PDU::OctetSubstringAssertion_PDU() {
}

void OctetSubstringAssertion_PDU::set_data(OctetSubstringAssertion & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

OctetSubstringAssertion *OctetSubstringAssertion_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (OctetSubstringAssertion *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void OctetSubstringAssertion_PDU::set_const_data(const OctetSubstringAssertion & d) {
    data = (void *)&d;
    constant = 1;
}

const OctetSubstringAssertion *OctetSubstringAssertion_PDU::get_const_data() const {
    return (const OctetSubstringAssertion *)data;
}

#endif

OssTypeIndex OctetSubstringAssertion_PDU::get_index() const {
    return 38;
}

SequenceMatchType_PDU::SequenceMatchType_PDU() {
}

void SequenceMatchType_PDU::set_data(SequenceMatchType & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SequenceMatchType *SequenceMatchType_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (SequenceMatchType *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void SequenceMatchType_PDU::set_const_data(const SequenceMatchType & d) {
    data = (void *)&d;
    constant = 1;
}

const SequenceMatchType *SequenceMatchType_PDU::get_const_data() const {
    return (const SequenceMatchType *)data;
}

#endif

OssTypeIndex SequenceMatchType_PDU::get_index() const {
    return 39;
}

WordMatchTypes_PDU::WordMatchTypes_PDU() {
}

void WordMatchTypes_PDU::set_data(WordMatchTypes & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WordMatchTypes *WordMatchTypes_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (WordMatchTypes *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void WordMatchTypes_PDU::set_const_data(const WordMatchTypes & d) {
    data = (void *)&d;
    constant = 1;
}

const WordMatchTypes *WordMatchTypes_PDU::get_const_data() const {
    return (const WordMatchTypes *)data;
}

#endif

OssTypeIndex WordMatchTypes_PDU::get_index() const {
    return 40;
}

CharacterMatchTypes_PDU::CharacterMatchTypes_PDU() {
}

void CharacterMatchTypes_PDU::set_data(CharacterMatchTypes & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CharacterMatchTypes *CharacterMatchTypes_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (CharacterMatchTypes *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void CharacterMatchTypes_PDU::set_const_data(const CharacterMatchTypes & d) {
    data = (void *)&d;
    constant = 1;
}

const CharacterMatchTypes *CharacterMatchTypes_PDU::get_const_data() const {
    return (const CharacterMatchTypes *)data;
}

#endif

OssTypeIndex CharacterMatchTypes_PDU::get_index() const {
    return 41;
}

LanguageContextSyntax_PDU::LanguageContextSyntax_PDU() {
}

void LanguageContextSyntax_PDU::set_data(LanguageContextSyntax & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

LanguageContextSyntax *LanguageContextSyntax_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (LanguageContextSyntax *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void LanguageContextSyntax_PDU::set_const_data(const LanguageContextSyntax & d) {
    data = (void *)&d;
    constant = 1;
}

const LanguageContextSyntax *LanguageContextSyntax_PDU::get_const_data() const {
    return (const LanguageContextSyntax *)data;
}

#endif

OssTypeIndex LanguageContextSyntax_PDU::get_index() const {
    return 42;
}

TimeSpecification_PDU::TimeSpecification_PDU() {
}

void TimeSpecification_PDU::set_data(TimeSpecification & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TimeSpecification *TimeSpecification_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (TimeSpecification *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void TimeSpecification_PDU::set_const_data(const TimeSpecification & d) {
    data = (void *)&d;
    constant = 1;
}

const TimeSpecification *TimeSpecification_PDU::get_const_data() const {
    return (const TimeSpecification *)data;
}

#endif

OssTypeIndex TimeSpecification_PDU::get_index() const {
    return 43;
}

TimeAssertion_PDU::TimeAssertion_PDU() {
}

void TimeAssertion_PDU::set_data(TimeAssertion & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TimeAssertion *TimeAssertion_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (TimeAssertion *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void TimeAssertion_PDU::set_const_data(const TimeAssertion & d) {
    data = (void *)&d;
    constant = 1;
}

const TimeAssertion *TimeAssertion_PDU::get_const_data() const {
    return (const TimeAssertion *)data;
}

#endif

OssTypeIndex TimeAssertion_PDU::get_index() const {
    return 44;
}

LocaleContextSyntax_PDU::LocaleContextSyntax_PDU() {
}

void LocaleContextSyntax_PDU::set_data(LocaleContextSyntax & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

LocaleContextSyntax *LocaleContextSyntax_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (LocaleContextSyntax *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void LocaleContextSyntax_PDU::set_const_data(const LocaleContextSyntax & d) {
    data = (void *)&d;
    constant = 1;
}

const LocaleContextSyntax *LocaleContextSyntax_PDU::get_const_data() const {
    return (const LocaleContextSyntax *)data;
}

#endif

OssTypeIndex LocaleContextSyntax_PDU::get_index() const {
    return 45;
}

AttributeOptionList_PDU::AttributeOptionList_PDU() {
}

void AttributeOptionList_PDU::set_data(AttributeOptionList & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AttributeOptionList *AttributeOptionList_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (AttributeOptionList *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void AttributeOptionList_PDU::set_const_data(const AttributeOptionList & d) {
    data = (void *)&d;
    constant = 1;
}

const AttributeOptionList *AttributeOptionList_PDU::get_const_data() const {
    return (const AttributeOptionList *)data;
}

#endif

OssTypeIndex AttributeOptionList_PDU::get_index() const {
    return 46;
}

ID_PDU::ID_PDU() {
}

void ID_PDU::set_data(ID & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ID *ID_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ID *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ID_PDU::set_const_data(const ID & d) {
    data = (void *)&d;
    constant = 1;
}

const ID *ID_PDU::get_const_data() const {
    return (const ID *)data;
}

#endif

OssTypeIndex ID_PDU::get_index() const {
    return 47;
}

AttributeValue_PDU::AttributeValue_PDU() {
}

void AttributeValue_PDU::set_data(AttributeValue & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AttributeValue *AttributeValue_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (AttributeValue *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void AttributeValue_PDU::set_const_data(const AttributeValue & d) {
    data = (void *)&d;
    constant = 1;
}

const AttributeValue *AttributeValue_PDU::get_const_data() const {
    return (const AttributeValue *)data;
}

#endif

OssTypeIndex AttributeValue_PDU::get_index() const {
    return 48;
}

ContextAssertion_PDU::ContextAssertion_PDU() {
}

void ContextAssertion_PDU::set_data(ContextAssertion & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ContextAssertion *ContextAssertion_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ContextAssertion *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ContextAssertion_PDU::set_const_data(const ContextAssertion & d) {
    data = (void *)&d;
    constant = 1;
}

const ContextAssertion *ContextAssertion_PDU::get_const_data() const {
    return (const ContextAssertion *)data;
}

#endif

OssTypeIndex ContextAssertion_PDU::get_index() const {
    return 49;
}

AttributeTypeAssertion_PDU::AttributeTypeAssertion_PDU() {
}

void AttributeTypeAssertion_PDU::set_data(AttributeTypeAssertion & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AttributeTypeAssertion *AttributeTypeAssertion_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (AttributeTypeAssertion *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void AttributeTypeAssertion_PDU::set_const_data(const AttributeTypeAssertion & d) {
    data = (void *)&d;
    constant = 1;
}

const AttributeTypeAssertion *AttributeTypeAssertion_PDU::get_const_data() const {
    return (const AttributeTypeAssertion *)data;
}

#endif

OssTypeIndex AttributeTypeAssertion_PDU::get_index() const {
    return 50;
}

DistinguishedName_PDU::DistinguishedName_PDU() {
}

void DistinguishedName_PDU::set_data(DistinguishedName & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

DistinguishedName *DistinguishedName_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (DistinguishedName *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void DistinguishedName_PDU::set_const_data(const DistinguishedName & d) {
    data = (void *)&d;
    constant = 1;
}

const DistinguishedName *DistinguishedName_PDU::get_const_data() const {
    return (const DistinguishedName *)data;
}

#endif

OssTypeIndex DistinguishedName_PDU::get_index() const {
    return 51;
}

SubtreeSpecification_PDU::SubtreeSpecification_PDU() {
}

void SubtreeSpecification_PDU::set_data(SubtreeSpecification & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SubtreeSpecification *SubtreeSpecification_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (SubtreeSpecification *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void SubtreeSpecification_PDU::set_const_data(const SubtreeSpecification & d) {
    data = (void *)&d;
    constant = 1;
}

const SubtreeSpecification *SubtreeSpecification_PDU::get_const_data() const {
    return (const SubtreeSpecification *)data;
}

#endif

OssTypeIndex SubtreeSpecification_PDU::get_index() const {
    return 52;
}

DITStructureRule_PDU::DITStructureRule_PDU() {
}

void DITStructureRule_PDU::set_data(DITStructureRule & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

DITStructureRule *DITStructureRule_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (DITStructureRule *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void DITStructureRule_PDU::set_const_data(const DITStructureRule & d) {
    data = (void *)&d;
    constant = 1;
}

const DITStructureRule *DITStructureRule_PDU::get_const_data() const {
    return (const DITStructureRule *)data;
}

#endif

OssTypeIndex DITStructureRule_PDU::get_index() const {
    return 53;
}

DITContentRule_PDU::DITContentRule_PDU() {
}

void DITContentRule_PDU::set_data(DITContentRule & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

DITContentRule *DITContentRule_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (DITContentRule *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void DITContentRule_PDU::set_const_data(const DITContentRule & d) {
    data = (void *)&d;
    constant = 1;
}

const DITContentRule *DITContentRule_PDU::get_const_data() const {
    return (const DITContentRule *)data;
}

#endif

OssTypeIndex DITContentRule_PDU::get_index() const {
    return 54;
}

DITContextUse_PDU::DITContextUse_PDU() {
}

void DITContextUse_PDU::set_data(DITContextUse & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

DITContextUse *DITContextUse_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (DITContextUse *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void DITContextUse_PDU::set_const_data(const DITContextUse & d) {
    data = (void *)&d;
    constant = 1;
}

const DITContextUse *DITContextUse_PDU::get_const_data() const {
    return (const DITContextUse *)data;
}

#endif

OssTypeIndex DITContextUse_PDU::get_index() const {
    return 55;
}

HierarchyLevel_PDU::HierarchyLevel_PDU() {
}

void HierarchyLevel_PDU::set_data(HierarchyLevel & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

HierarchyLevel *HierarchyLevel_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (HierarchyLevel *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void HierarchyLevel_PDU::set_const_data(const HierarchyLevel & d) {
    data = (void *)&d;
    constant = 1;
}

const HierarchyLevel *HierarchyLevel_PDU::get_const_data() const {
    return (const HierarchyLevel *)data;
}

#endif

OssTypeIndex HierarchyLevel_PDU::get_index() const {
    return 56;
}

HierarchyBelow_PDU::HierarchyBelow_PDU() {
}

void HierarchyBelow_PDU::set_data(HierarchyBelow & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

HierarchyBelow *HierarchyBelow_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (HierarchyBelow *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void HierarchyBelow_PDU::set_const_data(const HierarchyBelow & d) {
    data = (void *)&d;
    constant = 1;
}

const HierarchyBelow *HierarchyBelow_PDU::get_const_data() const {
    return (const HierarchyBelow *)data;
}

#endif

OssTypeIndex HierarchyBelow_PDU::get_index() const {
    return 57;
}

Acse_RealizationParameter_PDU::Acse_RealizationParameter_PDU() {
}

void Acse_RealizationParameter_PDU::set_data(Acse_RealizationParameter & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Acse_RealizationParameter *Acse_RealizationParameter_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Acse_RealizationParameter *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Acse_RealizationParameter_PDU::set_const_data(const Acse_RealizationParameter & d) {
    data = (void *)&d;
    constant = 1;
}

const Acse_RealizationParameter *Acse_RealizationParameter_PDU::get_const_data() const {
    return (const Acse_RealizationParameter *)data;
}

#endif

OssTypeIndex Acse_RealizationParameter_PDU::get_index() const {
    return 58;
}

Acse_with_concatenation_RealizationParameter_PDU::Acse_with_concatenation_RealizationParameter_PDU() {
}

void Acse_with_concatenation_RealizationParameter_PDU::set_data(Acse_with_concatenation_RealizationParameter & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Acse_with_concatenation_RealizationParameter *Acse_with_concatenation_RealizationParameter_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Acse_with_concatenation_RealizationParameter *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Acse_with_concatenation_RealizationParameter_PDU::set_const_data(const Acse_with_concatenation_RealizationParameter & d) {
    data = (void *)&d;
    constant = 1;
}

const Acse_with_concatenation_RealizationParameter *Acse_with_concatenation_RealizationParameter_PDU::get_const_data() const {
    return (const Acse_with_concatenation_RealizationParameter *)data;
}

#endif

OssTypeIndex Acse_with_concatenation_RealizationParameter_PDU::get_index() const {
    return 59;
}

Association_by_RTSE_RealizationParameter_PDU::Association_by_RTSE_RealizationParameter_PDU() {
}

void Association_by_RTSE_RealizationParameter_PDU::set_data(Association_by_RTSE_RealizationParameter & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Association_by_RTSE_RealizationParameter *Association_by_RTSE_RealizationParameter_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Association_by_RTSE_RealizationParameter *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Association_by_RTSE_RealizationParameter_PDU::set_const_data(const Association_by_RTSE_RealizationParameter & d) {
    data = (void *)&d;
    constant = 1;
}

const Association_by_RTSE_RealizationParameter *Association_by_RTSE_RealizationParameter_PDU::get_const_data() const {
    return (const Association_by_RTSE_RealizationParameter *)data;
}

#endif

OssTypeIndex Association_by_RTSE_RealizationParameter_PDU::get_index() const {
    return 60;
}

PData_RealizationParameter_PDU::PData_RealizationParameter_PDU() {
}

void PData_RealizationParameter_PDU::set_data(PData_RealizationParameter & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PData_RealizationParameter *PData_RealizationParameter_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PData_RealizationParameter *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PData_RealizationParameter_PDU::set_const_data(const PData_RealizationParameter & d) {
    data = (void *)&d;
    constant = 1;
}

const PData_RealizationParameter *PData_RealizationParameter_PDU::get_const_data() const {
    return (const PData_RealizationParameter *)data;
}

#endif

OssTypeIndex PData_RealizationParameter_PDU::get_index() const {
    return 61;
}

PData_with_concatenation_RealizationParameter_PDU::PData_with_concatenation_RealizationParameter_PDU() {
}

void PData_with_concatenation_RealizationParameter_PDU::set_data(PData_with_concatenation_RealizationParameter & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PData_with_concatenation_RealizationParameter *PData_with_concatenation_RealizationParameter_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PData_with_concatenation_RealizationParameter *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PData_with_concatenation_RealizationParameter_PDU::set_const_data(const PData_with_concatenation_RealizationParameter & d) {
    data = (void *)&d;
    constant = 1;
}

const PData_with_concatenation_RealizationParameter *PData_with_concatenation_RealizationParameter_PDU::get_const_data() const {
    return (const PData_with_concatenation_RealizationParameter *)data;
}

#endif

OssTypeIndex PData_with_concatenation_RealizationParameter_PDU::get_index() const {
    return 62;
}

Transfer_by_RTSE_RealizationParameter_PDU::Transfer_by_RTSE_RealizationParameter_PDU() {
}

void Transfer_by_RTSE_RealizationParameter_PDU::set_data(Transfer_by_RTSE_RealizationParameter & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Transfer_by_RTSE_RealizationParameter *Transfer_by_RTSE_RealizationParameter_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Transfer_by_RTSE_RealizationParameter *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Transfer_by_RTSE_RealizationParameter_PDU::set_const_data(const Transfer_by_RTSE_RealizationParameter & d) {
    data = (void *)&d;
    constant = 1;
}

const Transfer_by_RTSE_RealizationParameter *Transfer_by_RTSE_RealizationParameter_PDU::get_const_data() const {
    return (const Transfer_by_RTSE_RealizationParameter *)data;
}

#endif

OssTypeIndex Transfer_by_RTSE_RealizationParameter_PDU::get_index() const {
    return 63;
}

BitStringMatch_SYNTAX_PDU::BitStringMatch_SYNTAX_PDU() {
}

void BitStringMatch_SYNTAX_PDU::set_data(BitStringMatch_SYNTAX & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

BitStringMatch_SYNTAX *BitStringMatch_SYNTAX_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (BitStringMatch_SYNTAX *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void BitStringMatch_SYNTAX_PDU::set_const_data(const BitStringMatch_SYNTAX & d) {
    data = (void *)&d;
    constant = 1;
}

const BitStringMatch_SYNTAX *BitStringMatch_SYNTAX_PDU::get_const_data() const {
    return (const BitStringMatch_SYNTAX *)data;
}

#endif

OssTypeIndex BitStringMatch_SYNTAX_PDU::get_index() const {
    return 64;
}

DnQualifier_WITH_SYNTAX_PDU::DnQualifier_WITH_SYNTAX_PDU() {
}

void DnQualifier_WITH_SYNTAX_PDU::set_data(DnQualifier_WITH_SYNTAX & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

DnQualifier_WITH_SYNTAX *DnQualifier_WITH_SYNTAX_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (DnQualifier_WITH_SYNTAX *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void DnQualifier_WITH_SYNTAX_PDU::set_const_data(const DnQualifier_WITH_SYNTAX & d) {
    data = (void *)&d;
    constant = 1;
}

const DnQualifier_WITH_SYNTAX *DnQualifier_WITH_SYNTAX_PDU::get_const_data() const {
    return (const DnQualifier_WITH_SYNTAX *)data;
}

#endif

OssTypeIndex DnQualifier_WITH_SYNTAX_PDU::get_index() const {
    return 65;
}

SerialNumber_WITH_SYNTAX_PDU::SerialNumber_WITH_SYNTAX_PDU() {
}

void SerialNumber_WITH_SYNTAX_PDU::set_data(SerialNumber_WITH_SYNTAX & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SerialNumber_WITH_SYNTAX *SerialNumber_WITH_SYNTAX_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (SerialNumber_WITH_SYNTAX *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void SerialNumber_WITH_SYNTAX_PDU::set_const_data(const SerialNumber_WITH_SYNTAX & d) {
    data = (void *)&d;
    constant = 1;
}

const SerialNumber_WITH_SYNTAX *SerialNumber_WITH_SYNTAX_PDU::get_const_data() const {
    return (const SerialNumber_WITH_SYNTAX *)data;
}

#endif

OssTypeIndex SerialNumber_WITH_SYNTAX_PDU::get_index() const {
    return 66;
}

NumericStringMatch_SYNTAX_PDU::NumericStringMatch_SYNTAX_PDU() {
}

void NumericStringMatch_SYNTAX_PDU::set_data(NumericStringMatch_SYNTAX & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NumericStringMatch_SYNTAX *NumericStringMatch_SYNTAX_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (NumericStringMatch_SYNTAX *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void NumericStringMatch_SYNTAX_PDU::set_const_data(const NumericStringMatch_SYNTAX & d) {
    data = (void *)&d;
    constant = 1;
}

const NumericStringMatch_SYNTAX *NumericStringMatch_SYNTAX_PDU::get_const_data() const {
    return (const NumericStringMatch_SYNTAX *)data;
}

#endif

OssTypeIndex NumericStringMatch_SYNTAX_PDU::get_index() const {
    return 67;
}

ProtocolInformationMatch_SYNTAX_PDU::ProtocolInformationMatch_SYNTAX_PDU() {
}

void ProtocolInformationMatch_SYNTAX_PDU::set_data(ProtocolInformationMatch_SYNTAX & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ProtocolInformationMatch_SYNTAX *ProtocolInformationMatch_SYNTAX_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ProtocolInformationMatch_SYNTAX *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ProtocolInformationMatch_SYNTAX_PDU::set_const_data(const ProtocolInformationMatch_SYNTAX & d) {
    data = (void *)&d;
    constant = 1;
}

const ProtocolInformationMatch_SYNTAX *ProtocolInformationMatch_SYNTAX_PDU::get_const_data() const {
    return (const ProtocolInformationMatch_SYNTAX *)data;
}

#endif

OssTypeIndex ProtocolInformationMatch_SYNTAX_PDU::get_index() const {
    return 68;
}

UiiInUrn_WITH_SYNTAX_PDU::UiiInUrn_WITH_SYNTAX_PDU() {
}

void UiiInUrn_WITH_SYNTAX_PDU::set_data(UiiInUrn_WITH_SYNTAX & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

UiiInUrn_WITH_SYNTAX *UiiInUrn_WITH_SYNTAX_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (UiiInUrn_WITH_SYNTAX *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void UiiInUrn_WITH_SYNTAX_PDU::set_const_data(const UiiInUrn_WITH_SYNTAX & d) {
    data = (void *)&d;
    constant = 1;
}

const UiiInUrn_WITH_SYNTAX *UiiInUrn_WITH_SYNTAX_PDU::get_const_data() const {
    return (const UiiInUrn_WITH_SYNTAX *)data;
}

#endif

OssTypeIndex UiiInUrn_WITH_SYNTAX_PDU::get_index() const {
    return 69;
}

NumericStringOrderingMatch_SYNTAX_PDU::NumericStringOrderingMatch_SYNTAX_PDU() {
}

void NumericStringOrderingMatch_SYNTAX_PDU::set_data(NumericStringOrderingMatch_SYNTAX & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

NumericStringOrderingMatch_SYNTAX *NumericStringOrderingMatch_SYNTAX_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (NumericStringOrderingMatch_SYNTAX *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void NumericStringOrderingMatch_SYNTAX_PDU::set_const_data(const NumericStringOrderingMatch_SYNTAX & d) {
    data = (void *)&d;
    constant = 1;
}

const NumericStringOrderingMatch_SYNTAX *NumericStringOrderingMatch_SYNTAX_PDU::get_const_data() const {
    return (const NumericStringOrderingMatch_SYNTAX *)data;
}

#endif

OssTypeIndex NumericStringOrderingMatch_SYNTAX_PDU::get_index() const {
    return 70;
}

BooleanMatch_SYNTAX_PDU::BooleanMatch_SYNTAX_PDU() {
}

void BooleanMatch_SYNTAX_PDU::set_data(BooleanMatch_SYNTAX & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

BooleanMatch_SYNTAX *BooleanMatch_SYNTAX_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (BooleanMatch_SYNTAX *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void BooleanMatch_SYNTAX_PDU::set_const_data(const BooleanMatch_SYNTAX & d) {
    data = (void *)&d;
    constant = 1;
}

const BooleanMatch_SYNTAX *BooleanMatch_SYNTAX_PDU::get_const_data() const {
    return (const BooleanMatch_SYNTAX *)data;
}

#endif

OssTypeIndex BooleanMatch_SYNTAX_PDU::get_index() const {
    return 71;
}

IntegerMatch_SYNTAX_PDU::IntegerMatch_SYNTAX_PDU() {
}

void IntegerMatch_SYNTAX_PDU::set_data(IntegerMatch_SYNTAX & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

IntegerMatch_SYNTAX *IntegerMatch_SYNTAX_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (IntegerMatch_SYNTAX *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void IntegerMatch_SYNTAX_PDU::set_const_data(const IntegerMatch_SYNTAX & d) {
    data = (void *)&d;
    constant = 1;
}

const IntegerMatch_SYNTAX *IntegerMatch_SYNTAX_PDU::get_const_data() const {
    return (const IntegerMatch_SYNTAX *)data;
}

#endif

OssTypeIndex IntegerMatch_SYNTAX_PDU::get_index() const {
    return 72;
}

IntegerOrderingMatch_SYNTAX_PDU::IntegerOrderingMatch_SYNTAX_PDU() {
}

void IntegerOrderingMatch_SYNTAX_PDU::set_data(IntegerOrderingMatch_SYNTAX & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

IntegerOrderingMatch_SYNTAX *IntegerOrderingMatch_SYNTAX_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (IntegerOrderingMatch_SYNTAX *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void IntegerOrderingMatch_SYNTAX_PDU::set_const_data(const IntegerOrderingMatch_SYNTAX & d) {
    data = (void *)&d;
    constant = 1;
}

const IntegerOrderingMatch_SYNTAX *IntegerOrderingMatch_SYNTAX_PDU::get_const_data() const {
    return (const IntegerOrderingMatch_SYNTAX *)data;
}

#endif

OssTypeIndex IntegerOrderingMatch_SYNTAX_PDU::get_index() const {
    return 73;
}

OctetStringMatch_SYNTAX_PDU::OctetStringMatch_SYNTAX_PDU() {
}

void OctetStringMatch_SYNTAX_PDU::set_data(OctetStringMatch_SYNTAX & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

OctetStringMatch_SYNTAX *OctetStringMatch_SYNTAX_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (OctetStringMatch_SYNTAX *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void OctetStringMatch_SYNTAX_PDU::set_const_data(const OctetStringMatch_SYNTAX & d) {
    data = (void *)&d;
    constant = 1;
}

const OctetStringMatch_SYNTAX *OctetStringMatch_SYNTAX_PDU::get_const_data() const {
    return (const OctetStringMatch_SYNTAX *)data;
}

#endif

OssTypeIndex OctetStringMatch_SYNTAX_PDU::get_index() const {
    return 74;
}

OctetStringOrderingMatch_SYNTAX_PDU::OctetStringOrderingMatch_SYNTAX_PDU() {
}

void OctetStringOrderingMatch_SYNTAX_PDU::set_data(OctetStringOrderingMatch_SYNTAX & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

OctetStringOrderingMatch_SYNTAX *OctetStringOrderingMatch_SYNTAX_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (OctetStringOrderingMatch_SYNTAX *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void OctetStringOrderingMatch_SYNTAX_PDU::set_const_data(const OctetStringOrderingMatch_SYNTAX & d) {
    data = (void *)&d;
    constant = 1;
}

const OctetStringOrderingMatch_SYNTAX *OctetStringOrderingMatch_SYNTAX_PDU::get_const_data() const {
    return (const OctetStringOrderingMatch_SYNTAX *)data;
}

#endif

OssTypeIndex OctetStringOrderingMatch_SYNTAX_PDU::get_index() const {
    return 75;
}

UTCTimeMatch_SYNTAX_PDU::UTCTimeMatch_SYNTAX_PDU() {
}

void UTCTimeMatch_SYNTAX_PDU::set_data(UTCTimeMatch_SYNTAX & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

UTCTimeMatch_SYNTAX *UTCTimeMatch_SYNTAX_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (UTCTimeMatch_SYNTAX *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void UTCTimeMatch_SYNTAX_PDU::set_const_data(const UTCTimeMatch_SYNTAX & d) {
    data = (void *)&d;
    constant = 1;
}

const UTCTimeMatch_SYNTAX *UTCTimeMatch_SYNTAX_PDU::get_const_data() const {
    return (const UTCTimeMatch_SYNTAX *)data;
}

#endif

OssTypeIndex UTCTimeMatch_SYNTAX_PDU::get_index() const {
    return 76;
}

UTCTimeOrderingMatch_SYNTAX_PDU::UTCTimeOrderingMatch_SYNTAX_PDU() {
}

void UTCTimeOrderingMatch_SYNTAX_PDU::set_data(UTCTimeOrderingMatch_SYNTAX & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

UTCTimeOrderingMatch_SYNTAX *UTCTimeOrderingMatch_SYNTAX_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (UTCTimeOrderingMatch_SYNTAX *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void UTCTimeOrderingMatch_SYNTAX_PDU::set_const_data(const UTCTimeOrderingMatch_SYNTAX & d) {
    data = (void *)&d;
    constant = 1;
}

const UTCTimeOrderingMatch_SYNTAX *UTCTimeOrderingMatch_SYNTAX_PDU::get_const_data() const {
    return (const UTCTimeOrderingMatch_SYNTAX *)data;
}

#endif

OssTypeIndex UTCTimeOrderingMatch_SYNTAX_PDU::get_index() const {
    return 77;
}

GeneralizedTimeMatch_SYNTAX_PDU::GeneralizedTimeMatch_SYNTAX_PDU() {
}

void GeneralizedTimeMatch_SYNTAX_PDU::set_data(GeneralizedTimeMatch_SYNTAX & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

GeneralizedTimeMatch_SYNTAX *GeneralizedTimeMatch_SYNTAX_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (GeneralizedTimeMatch_SYNTAX *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void GeneralizedTimeMatch_SYNTAX_PDU::set_const_data(const GeneralizedTimeMatch_SYNTAX & d) {
    data = (void *)&d;
    constant = 1;
}

const GeneralizedTimeMatch_SYNTAX *GeneralizedTimeMatch_SYNTAX_PDU::get_const_data() const {
    return (const GeneralizedTimeMatch_SYNTAX *)data;
}

#endif

OssTypeIndex GeneralizedTimeMatch_SYNTAX_PDU::get_index() const {
    return 78;
}

GeneralizedTimeOrderingMatch_SYNTAX_PDU::GeneralizedTimeOrderingMatch_SYNTAX_PDU() {
}

void GeneralizedTimeOrderingMatch_SYNTAX_PDU::set_data(GeneralizedTimeOrderingMatch_SYNTAX & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

GeneralizedTimeOrderingMatch_SYNTAX *GeneralizedTimeOrderingMatch_SYNTAX_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (GeneralizedTimeOrderingMatch_SYNTAX *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void GeneralizedTimeOrderingMatch_SYNTAX_PDU::set_const_data(const GeneralizedTimeOrderingMatch_SYNTAX & d) {
    data = (void *)&d;
    constant = 1;
}

const GeneralizedTimeOrderingMatch_SYNTAX *GeneralizedTimeOrderingMatch_SYNTAX_PDU::get_const_data() const {
    return (const GeneralizedTimeOrderingMatch_SYNTAX *)data;
}

#endif

OssTypeIndex GeneralizedTimeOrderingMatch_SYNTAX_PDU::get_index() const {
    return 79;
}

IntegerFirstComponentMatch_SYNTAX_PDU::IntegerFirstComponentMatch_SYNTAX_PDU() {
}

void IntegerFirstComponentMatch_SYNTAX_PDU::set_data(IntegerFirstComponentMatch_SYNTAX & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

IntegerFirstComponentMatch_SYNTAX *IntegerFirstComponentMatch_SYNTAX_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (IntegerFirstComponentMatch_SYNTAX *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void IntegerFirstComponentMatch_SYNTAX_PDU::set_const_data(const IntegerFirstComponentMatch_SYNTAX & d) {
    data = (void *)&d;
    constant = 1;
}

const IntegerFirstComponentMatch_SYNTAX *IntegerFirstComponentMatch_SYNTAX_PDU::get_const_data() const {
    return (const IntegerFirstComponentMatch_SYNTAX *)data;
}

#endif

OssTypeIndex IntegerFirstComponentMatch_SYNTAX_PDU::get_index() const {
    return 80;
}

AdministrativeRole_WITH_SYNTAX_PDU::AdministrativeRole_WITH_SYNTAX_PDU() {
}

void AdministrativeRole_WITH_SYNTAX_PDU::set_data(AdministrativeRole_WITH_SYNTAX & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AdministrativeRole_WITH_SYNTAX *AdministrativeRole_WITH_SYNTAX_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (AdministrativeRole_WITH_SYNTAX *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void AdministrativeRole_WITH_SYNTAX_PDU::set_const_data(const AdministrativeRole_WITH_SYNTAX & d) {
    data = (void *)&d;
    constant = 1;
}

const AdministrativeRole_WITH_SYNTAX *AdministrativeRole_WITH_SYNTAX_PDU::get_const_data() const {
    return (const AdministrativeRole_WITH_SYNTAX *)data;
}

#endif

OssTypeIndex AdministrativeRole_WITH_SYNTAX_PDU::get_index() const {
    return 81;
}

CreateTimestamp_WITH_SYNTAX_PDU::CreateTimestamp_WITH_SYNTAX_PDU() {
}

void CreateTimestamp_WITH_SYNTAX_PDU::set_data(CreateTimestamp_WITH_SYNTAX & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CreateTimestamp_WITH_SYNTAX *CreateTimestamp_WITH_SYNTAX_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (CreateTimestamp_WITH_SYNTAX *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void CreateTimestamp_WITH_SYNTAX_PDU::set_const_data(const CreateTimestamp_WITH_SYNTAX & d) {
    data = (void *)&d;
    constant = 1;
}

const CreateTimestamp_WITH_SYNTAX *CreateTimestamp_WITH_SYNTAX_PDU::get_const_data() const {
    return (const CreateTimestamp_WITH_SYNTAX *)data;
}

#endif

OssTypeIndex CreateTimestamp_WITH_SYNTAX_PDU::get_index() const {
    return 82;
}

ModifyTimestamp_WITH_SYNTAX_PDU::ModifyTimestamp_WITH_SYNTAX_PDU() {
}

void ModifyTimestamp_WITH_SYNTAX_PDU::set_data(ModifyTimestamp_WITH_SYNTAX & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

ModifyTimestamp_WITH_SYNTAX *ModifyTimestamp_WITH_SYNTAX_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (ModifyTimestamp_WITH_SYNTAX *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void ModifyTimestamp_WITH_SYNTAX_PDU::set_const_data(const ModifyTimestamp_WITH_SYNTAX & d) {
    data = (void *)&d;
    constant = 1;
}

const ModifyTimestamp_WITH_SYNTAX *ModifyTimestamp_WITH_SYNTAX_PDU::get_const_data() const {
    return (const ModifyTimestamp_WITH_SYNTAX *)data;
}

#endif

OssTypeIndex ModifyTimestamp_WITH_SYNTAX_PDU::get_index() const {
    return 83;
}

SubschemaTimestamp_WITH_SYNTAX_PDU::SubschemaTimestamp_WITH_SYNTAX_PDU() {
}

void SubschemaTimestamp_WITH_SYNTAX_PDU::set_data(SubschemaTimestamp_WITH_SYNTAX & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SubschemaTimestamp_WITH_SYNTAX *SubschemaTimestamp_WITH_SYNTAX_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (SubschemaTimestamp_WITH_SYNTAX *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void SubschemaTimestamp_WITH_SYNTAX_PDU::set_const_data(const SubschemaTimestamp_WITH_SYNTAX & d) {
    data = (void *)&d;
    constant = 1;
}

const SubschemaTimestamp_WITH_SYNTAX *SubschemaTimestamp_WITH_SYNTAX_PDU::get_const_data() const {
    return (const SubschemaTimestamp_WITH_SYNTAX *)data;
}

#endif

OssTypeIndex SubschemaTimestamp_WITH_SYNTAX_PDU::get_index() const {
    return 84;
}

HasSubordinates_WITH_SYNTAX_PDU::HasSubordinates_WITH_SYNTAX_PDU() {
}

void HasSubordinates_WITH_SYNTAX_PDU::set_data(HasSubordinates_WITH_SYNTAX & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

HasSubordinates_WITH_SYNTAX *HasSubordinates_WITH_SYNTAX_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (HasSubordinates_WITH_SYNTAX *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void HasSubordinates_WITH_SYNTAX_PDU::set_const_data(const HasSubordinates_WITH_SYNTAX & d) {
    data = (void *)&d;
    constant = 1;
}

const HasSubordinates_WITH_SYNTAX *HasSubordinates_WITH_SYNTAX_PDU::get_const_data() const {
    return (const HasSubordinates_WITH_SYNTAX *)data;
}

#endif

OssTypeIndex HasSubordinates_WITH_SYNTAX_PDU::get_index() const {
    return 85;
}

/* Control object class */

UpperBounds_Control::UpperBounds_Control() : OssControl(&UpperBounds_Table, UpperBounds_TableType::internal) {
}

UpperBounds_Control::UpperBounds_Control(const UpperBounds_Control & that) : OssControl(that) {
}


/* ASN.1 data initialization */
static unsigned char _v1[] = { 0x52, 0x01, 0x00, 0x01 };
static OSSC::COssEncOID _v0 = {
    4,
    _v1
};

const OssEncOID& acse_as_id = (const OssEncOID&)_v0;

static unsigned char _v3[] = { 0x52, 0x03, 0x01, 0x01 };
static OSSC::COssEncOID _v2 = {
    4,
    _v3
};

const OssEncOID& aCSE_id = (const OssEncOID&)_v2;

static unsigned char _v5[] = { 0x53, 0x02 };
static OSSC::COssEncOID _v4 = {
    2,
    _v5
};

const OssEncOID& rTSE_abstract_syntax = (const OssEncOID&)_v4;


struct _InvokeId {
    OSS_UINT32 choice;
    union {
	OSS_INT32  present;
	char  absent;
    } u;
};
static _InvokeId _v6 = {
    2, {0}
};

const __shared24& noInvokeId = (const __shared24&)_v6;

static unsigned char _v8[] = { 0x55, 0x04, 0x02 };
static OSSC::COssEncOID _v7 = {
    3,
    _v8
};

const OssEncOID& id_at_knowledgeInformation = (const OssEncOID&)_v7;

static unsigned char _v10[] = { 0x55, 0x04, 0x03 };
static OSSC::COssEncOID _v9 = {
    3,
    _v10
};

const OssEncOID& id_at_commonName = (const OssEncOID&)_v9;

static unsigned char _v12[] = { 0x55, 0x04, 0x04 };
static OSSC::COssEncOID _v11 = {
    3,
    _v12
};

const OssEncOID& id_at_surname = (const OssEncOID&)_v11;

static unsigned char _v14[] = { 0x55, 0x04, 0x05 };
static OSSC::COssEncOID _v13 = {
    3,
    _v14
};

const OssEncOID& id_at_serialNumber = (const OssEncOID&)_v13;

static unsigned char _v16[] = { 0x55, 0x04, 0x06 };
static OSSC::COssEncOID _v15 = {
    3,
    _v16
};

const OssEncOID& id_at_countryName = (const OssEncOID&)_v15;

static unsigned char _v18[] = { 0x55, 0x04, 0x07 };
static OSSC::COssEncOID _v17 = {
    3,
    _v18
};

const OssEncOID& id_at_localityName = (const OssEncOID&)_v17;

static unsigned char _v20[] = { 0x55, 0x04, 0x07, 0x01 };
static OSSC::COssEncOID _v19 = {
    4,
    _v20
};

const OssEncOID& id_at_collectiveLocalityName = (const OssEncOID&)_v19;

static unsigned char _v22[] = { 0x55, 0x04, 0x08 };
static OSSC::COssEncOID _v21 = {
    3,
    _v22
};

const OssEncOID& id_at_stateOrProvinceName = (const OssEncOID&)_v21;

static unsigned char _v24[] = { 0x55, 0x04, 0x08, 0x01 };
static OSSC::COssEncOID _v23 = {
    4,
    _v24
};

const OssEncOID& id_at_collectiveStateOrProvinceName = (const OssEncOID&)_v23;

static unsigned char _v26[] = { 0x55, 0x04, 0x09 };
static OSSC::COssEncOID _v25 = {
    3,
    _v26
};

const OssEncOID& id_at_streetAddress = (const OssEncOID&)_v25;

static unsigned char _v28[] = { 0x55, 0x04, 0x09, 0x01 };
static OSSC::COssEncOID _v27 = {
    4,
    _v28
};

const OssEncOID& id_at_collectiveStreetAddress = (const OssEncOID&)_v27;

static unsigned char _v30[] = { 0x55, 0x04, 0x0A };
static OSSC::COssEncOID _v29 = {
    3,
    _v30
};

const OssEncOID& id_at_organizationName = (const OssEncOID&)_v29;

static unsigned char _v32[] = { 0x55, 0x04, 0x0A, 0x01 };
static OSSC::COssEncOID _v31 = {
    4,
    _v32
};

const OssEncOID& id_at_collectiveOrganizationName = (const OssEncOID&)_v31;

static unsigned char _v34[] = { 0x55, 0x04, 0x0B };
static OSSC::COssEncOID _v33 = {
    3,
    _v34
};

const OssEncOID& id_at_organizationalUnitName = (const OssEncOID&)_v33;

static unsigned char _v36[] = { 0x55, 0x04, 0x0B, 0x01 };
static OSSC::COssEncOID _v35 = {
    4,
    _v36
};

const OssEncOID& id_at_collectiveOrganizationalUnitName = (const OssEncOID&)_v35;

static unsigned char _v38[] = { 0x55, 0x04, 0x0C };
static OSSC::COssEncOID _v37 = {
    3,
    _v38
};

const OssEncOID& id_at_title = (const OssEncOID&)_v37;

static unsigned char _v40[] = { 0x55, 0x04, 0x0D };
static OSSC::COssEncOID _v39 = {
    3,
    _v40
};

const OssEncOID& id_at_description = (const OssEncOID&)_v39;

static unsigned char _v42[] = { 0x55, 0x04, 0x0E };
static OSSC::COssEncOID _v41 = {
    3,
    _v42
};

const OssEncOID& id_at_searchGuide = (const OssEncOID&)_v41;

static unsigned char _v44[] = { 0x55, 0x04, 0x0F };
static OSSC::COssEncOID _v43 = {
    3,
    _v44
};

const OssEncOID& id_at_businessCategory = (const OssEncOID&)_v43;

static unsigned char _v46[] = { 0x55, 0x04, 0x10 };
static OSSC::COssEncOID _v45 = {
    3,
    _v46
};

const OssEncOID& id_at_postalAddress = (const OssEncOID&)_v45;

static unsigned char _v48[] = { 0x55, 0x04, 0x10, 0x01 };
static OSSC::COssEncOID _v47 = {
    4,
    _v48
};

const OssEncOID& id_at_collectivePostalAddress = (const OssEncOID&)_v47;

static unsigned char _v50[] = { 0x55, 0x04, 0x11 };
static OSSC::COssEncOID _v49 = {
    3,
    _v50
};

const OssEncOID& id_at_postalCode = (const OssEncOID&)_v49;

static unsigned char _v52[] = { 0x55, 0x04, 0x11, 0x01 };
static OSSC::COssEncOID _v51 = {
    4,
    _v52
};

const OssEncOID& id_at_collectivePostalCode = (const OssEncOID&)_v51;

static unsigned char _v54[] = { 0x55, 0x04, 0x12 };
static OSSC::COssEncOID _v53 = {
    3,
    _v54
};

const OssEncOID& id_at_postOfficeBox = (const OssEncOID&)_v53;

static unsigned char _v56[] = { 0x55, 0x04, 0x12, 0x01 };
static OSSC::COssEncOID _v55 = {
    4,
    _v56
};

const OssEncOID& id_at_collectivePostOfficeBox = (const OssEncOID&)_v55;

static unsigned char _v58[] = { 0x55, 0x04, 0x13 };
static OSSC::COssEncOID _v57 = {
    3,
    _v58
};

const OssEncOID& id_at_physicalDeliveryOfficeName = (const OssEncOID&)_v57;

static unsigned char _v60[] = { 0x55, 0x04, 0x13, 0x01 };
static OSSC::COssEncOID _v59 = {
    4,
    _v60
};

const OssEncOID& id_at_collectivePhysicalDeliveryOfficeName = (const OssEncOID&)_v59;

static unsigned char _v62[] = { 0x55, 0x04, 0x14 };
static OSSC::COssEncOID _v61 = {
    3,
    _v62
};

const OssEncOID& id_at_telephoneNumber = (const OssEncOID&)_v61;

static unsigned char _v64[] = { 0x55, 0x04, 0x14, 0x01 };
static OSSC::COssEncOID _v63 = {
    4,
    _v64
};

const OssEncOID& id_at_collectiveTelephoneNumber = (const OssEncOID&)_v63;

static unsigned char _v66[] = { 0x55, 0x04, 0x15 };
static OSSC::COssEncOID _v65 = {
    3,
    _v66
};

const OssEncOID& id_at_telexNumber = (const OssEncOID&)_v65;

static unsigned char _v68[] = { 0x55, 0x04, 0x15, 0x01 };
static OSSC::COssEncOID _v67 = {
    4,
    _v68
};

const OssEncOID& id_at_collectiveTelexNumber = (const OssEncOID&)_v67;

static unsigned char _v70[] = { 0x55, 0x04, 0x17 };
static OSSC::COssEncOID _v69 = {
    3,
    _v70
};

const OssEncOID& id_at_facsimileTelephoneNumber = (const OssEncOID&)_v69;

static unsigned char _v72[] = { 0x55, 0x04, 0x17, 0x01 };
static OSSC::COssEncOID _v71 = {
    4,
    _v72
};

const OssEncOID& id_at_collectiveFacsimileTelephoneNumber = (const OssEncOID&)_v71;

static unsigned char _v74[] = { 0x55, 0x04, 0x18 };
static OSSC::COssEncOID _v73 = {
    3,
    _v74
};

const OssEncOID& id_at_x121Address = (const OssEncOID&)_v73;

static unsigned char _v76[] = { 0x55, 0x04, 0x19 };
static OSSC::COssEncOID _v75 = {
    3,
    _v76
};

const OssEncOID& id_at_internationalISDNNumber = (const OssEncOID&)_v75;

static unsigned char _v78[] = { 0x55, 0x04, 0x19, 0x01 };
static OSSC::COssEncOID _v77 = {
    4,
    _v78
};

const OssEncOID& id_at_collectiveInternationalISDNNumber = (const OssEncOID&)_v77;

static unsigned char _v80[] = { 0x55, 0x04, 0x1A };
static OSSC::COssEncOID _v79 = {
    3,
    _v80
};

const OssEncOID& id_at_registeredAddress = (const OssEncOID&)_v79;

static unsigned char _v82[] = { 0x55, 0x04, 0x1B };
static OSSC::COssEncOID _v81 = {
    3,
    _v82
};

const OssEncOID& id_at_destinationIndicator = (const OssEncOID&)_v81;

static unsigned char _v84[] = { 0x55, 0x04, 0x1C };
static OSSC::COssEncOID _v83 = {
    3,
    _v84
};

const OssEncOID& id_at_preferredDeliveryMethod = (const OssEncOID&)_v83;

static unsigned char _v86[] = { 0x55, 0x04, 0x1D };
static OSSC::COssEncOID _v85 = {
    3,
    _v86
};

const OssEncOID& id_at_presentationAddress = (const OssEncOID&)_v85;

static unsigned char _v88[] = { 0x55, 0x04, 0x1E };
static OSSC::COssEncOID _v87 = {
    3,
    _v88
};

const OssEncOID& id_at_supportedApplicationContext = (const OssEncOID&)_v87;

static unsigned char _v90[] = { 0x55, 0x04, 0x1F };
static OSSC::COssEncOID _v89 = {
    3,
    _v90
};

const OssEncOID& id_at_member = (const OssEncOID&)_v89;

static unsigned char _v92[] = { 0x55, 0x04, 0x20 };
static OSSC::COssEncOID _v91 = {
    3,
    _v92
};

const OssEncOID& id_at_owner = (const OssEncOID&)_v91;

static unsigned char _v94[] = { 0x55, 0x04, 0x21 };
static OSSC::COssEncOID _v93 = {
    3,
    _v94
};

const OssEncOID& id_at_roleOccupant = (const OssEncOID&)_v93;

static unsigned char _v96[] = { 0x55, 0x04, 0x22 };
static OSSC::COssEncOID _v95 = {
    3,
    _v96
};

const OssEncOID& id_at_seeAlso = (const OssEncOID&)_v95;

static unsigned char _v98[] = { 0x55, 0x04, 0x29 };
static OSSC::COssEncOID _v97 = {
    3,
    _v98
};

const OssEncOID& id_at_name = (const OssEncOID&)_v97;

static unsigned char _v100[] = { 0x55, 0x04, 0x2A };
static OSSC::COssEncOID _v99 = {
    3,
    _v100
};

const OssEncOID& id_at_givenName = (const OssEncOID&)_v99;

static unsigned char _v102[] = { 0x55, 0x04, 0x2B };
static OSSC::COssEncOID _v101 = {
    3,
    _v102
};

const OssEncOID& id_at_initials = (const OssEncOID&)_v101;

static unsigned char _v104[] = { 0x55, 0x04, 0x2C };
static OSSC::COssEncOID _v103 = {
    3,
    _v104
};

const OssEncOID& id_at_generationQualifier = (const OssEncOID&)_v103;

static unsigned char _v106[] = { 0x55, 0x04, 0x2D };
static OSSC::COssEncOID _v105 = {
    3,
    _v106
};

const OssEncOID& id_at_uniqueIdentifier = (const OssEncOID&)_v105;

static unsigned char _v108[] = { 0x55, 0x04, 0x2E };
static OSSC::COssEncOID _v107 = {
    3,
    _v108
};

const OssEncOID& id_at_dnQualifier = (const OssEncOID&)_v107;

static unsigned char _v110[] = { 0x55, 0x04, 0x2F };
static OSSC::COssEncOID _v109 = {
    3,
    _v110
};

const OssEncOID& id_at_enhancedSearchGuide = (const OssEncOID&)_v109;

static unsigned char _v112[] = { 0x55, 0x04, 0x30 };
static OSSC::COssEncOID _v111 = {
    3,
    _v112
};

const OssEncOID& id_at_protocolInformation = (const OssEncOID&)_v111;

static unsigned char _v114[] = { 0x55, 0x04, 0x31 };
static OSSC::COssEncOID _v113 = {
    3,
    _v114
};

const OssEncOID& id_at_distinguishedName = (const OssEncOID&)_v113;

static unsigned char _v116[] = { 0x55, 0x04, 0x32 };
static OSSC::COssEncOID _v115 = {
    3,
    _v116
};

const OssEncOID& id_at_uniqueMember = (const OssEncOID&)_v115;

static unsigned char _v118[] = { 0x55, 0x04, 0x33 };
static OSSC::COssEncOID _v117 = {
    3,
    _v118
};

const OssEncOID& id_at_houseIdentifier = (const OssEncOID&)_v117;

static unsigned char _v120[] = { 0x55, 0x04, 0x36 };
static OSSC::COssEncOID _v119 = {
    3,
    _v120
};

const OssEncOID& id_at_dmdName = (const OssEncOID&)_v119;

static unsigned char _v122[] = { 0x55, 0x04, 0x41 };
static OSSC::COssEncOID _v121 = {
    3,
    _v122
};

const OssEncOID& id_at_pseudonym = (const OssEncOID&)_v121;

static unsigned char _v124[] = { 0x55, 0x04, 0x42 };
static OSSC::COssEncOID _v123 = {
    3,
    _v124
};

const OssEncOID& id_at_communicationsService = (const OssEncOID&)_v123;

static unsigned char _v126[] = { 0x55, 0x04, 0x43 };
static OSSC::COssEncOID _v125 = {
    3,
    _v126
};

const OssEncOID& id_at_communicationsNetwork = (const OssEncOID&)_v125;

static unsigned char _v128[] = { 0x55, 0x04, 0x4D };
static OSSC::COssEncOID _v127 = {
    3,
    _v128
};

const OssEncOID& id_at_uuidpair = (const OssEncOID&)_v127;

static unsigned char _v130[] = { 0x55, 0x04, 0x4E };
static OSSC::COssEncOID _v129 = {
    3,
    _v130
};

const OssEncOID& id_at_tagOid = (const OssEncOID&)_v129;

static unsigned char _v132[] = { 0x55, 0x04, 0x4F };
static OSSC::COssEncOID _v131 = {
    3,
    _v132
};

const OssEncOID& id_at_uiiFormat = (const OssEncOID&)_v131;

static unsigned char _v134[] = { 0x55, 0x04, 0x50 };
static OSSC::COssEncOID _v133 = {
    3,
    _v134
};

const OssEncOID& id_at_uiiInUrn = (const OssEncOID&)_v133;

static unsigned char _v136[] = { 0x55, 0x04, 0x51 };
static OSSC::COssEncOID _v135 = {
    3,
    _v136
};

const OssEncOID& id_at_contentUri = (const OssEncOID&)_v135;

static unsigned char _v138[] = { 0x55, 0x25, 0x01 };
static OSSC::COssEncOID _v137 = {
    3,
    _v138
};

const OssEncOID& id_cat_sequenceMatchType = (const OssEncOID&)_v137;

static unsigned char _v140[] = { 0x55, 0x25, 0x02 };
static OSSC::COssEncOID _v139 = {
    3,
    _v140
};

const OssEncOID& id_cat_wordMatchType = (const OssEncOID&)_v139;

static unsigned char _v142[] = { 0x55, 0x25, 0x03 };
static OSSC::COssEncOID _v141 = {
    3,
    _v142
};

const OssEncOID& id_cat_characterMatchTypes = (const OssEncOID&)_v141;

static unsigned char _v144[] = { 0x55, 0x25, 0x04 };
static OSSC::COssEncOID _v143 = {
    3,
    _v144
};

const OssEncOID& id_cat_selectedContexts = (const OssEncOID&)_v143;

static unsigned char _v146[] = { 0x55, 0x23, 0x00 };
static OSSC::COssEncOID _v145 = {
    3,
    _v146
};

const OssEncOID& id_not_dSAProblem = (const OssEncOID&)_v145;

static unsigned char _v148[] = { 0x55, 0x23, 0x01 };
static OSSC::COssEncOID _v147 = {
    3,
    _v148
};

const OssEncOID& id_not_searchServiceProblem = (const OssEncOID&)_v147;

static unsigned char _v150[] = { 0x55, 0x23, 0x02 };
static OSSC::COssEncOID _v149 = {
    3,
    _v150
};

const OssEncOID& id_not_serviceType = (const OssEncOID&)_v149;

static unsigned char _v152[] = { 0x55, 0x23, 0x03 };
static OSSC::COssEncOID _v151 = {
    3,
    _v152
};

const OssEncOID& id_not_attributeTypeList = (const OssEncOID&)_v151;

static unsigned char _v154[] = { 0x55, 0x23, 0x04 };
static OSSC::COssEncOID _v153 = {
    3,
    _v154
};

const OssEncOID& id_not_matchingRuleList = (const OssEncOID&)_v153;

static unsigned char _v156[] = { 0x55, 0x23, 0x05 };
static OSSC::COssEncOID _v155 = {
    3,
    _v156
};

const OssEncOID& id_not_filterItem = (const OssEncOID&)_v155;

static unsigned char _v158[] = { 0x55, 0x23, 0x06 };
static OSSC::COssEncOID _v157 = {
    3,
    _v158
};

const OssEncOID& id_not_attributeCombinations = (const OssEncOID&)_v157;

static unsigned char _v160[] = { 0x55, 0x23, 0x07 };
static OSSC::COssEncOID _v159 = {
    3,
    _v160
};

const OssEncOID& id_not_contextTypeList = (const OssEncOID&)_v159;

static unsigned char _v162[] = { 0x55, 0x23, 0x08 };
static OSSC::COssEncOID _v161 = {
    3,
    _v162
};

const OssEncOID& id_not_contextList = (const OssEncOID&)_v161;

static unsigned char _v164[] = { 0x55, 0x23, 0x09 };
static OSSC::COssEncOID _v163 = {
    3,
    _v164
};

const OssEncOID& id_not_contextCombinations = (const OssEncOID&)_v163;

static unsigned char _v166[] = { 0x55, 0x23, 0x0A };
static OSSC::COssEncOID _v165 = {
    3,
    _v166
};

const OssEncOID& id_not_hierarchySelectList = (const OssEncOID&)_v165;

static unsigned char _v168[] = { 0x55, 0x23, 0x0B };
static OSSC::COssEncOID _v167 = {
    3,
    _v168
};

const OssEncOID& id_not_searchControlOptionsList = (const OssEncOID&)_v167;

static unsigned char _v170[] = { 0x55, 0x23, 0x0C };
static OSSC::COssEncOID _v169 = {
    3,
    _v170
};

const OssEncOID& id_not_serviceControlOptionsList = (const OssEncOID&)_v169;

static unsigned char _v172[] = { 0x55, 0x23, 0x0D };
static OSSC::COssEncOID _v171 = {
    3,
    _v172
};

const OssEncOID& id_not_multipleMatchingLocalities = (const OssEncOID&)_v171;

static unsigned char _v174[] = { 0x55, 0x23, 0x0E };
static OSSC::COssEncOID _v173 = {
    3,
    _v174
};

const OssEncOID& id_not_proposedRelaxation = (const OssEncOID&)_v173;

static unsigned char _v176[] = { 0x55, 0x23, 0x0F };
static OSSC::COssEncOID _v175 = {
    3,
    _v176
};

const OssEncOID& id_not_appliedRelaxation = (const OssEncOID&)_v175;

static unsigned char _v178[] = { 0x55, 0x22, 0x01 };
static OSSC::COssEncOID _v177 = {
    3,
    _v178
};

const OssEncOID& id_pr_targetDsaUnavailable = (const OssEncOID&)_v177;

static unsigned char _v180[] = { 0x55, 0x22, 0x02 };
static OSSC::COssEncOID _v179 = {
    3,
    _v180
};

const OssEncOID& id_pr_dataSourceUnavailable = (const OssEncOID&)_v179;

static unsigned char _v182[] = { 0x55, 0x22, 0x03 };
static OSSC::COssEncOID _v181 = {
    3,
    _v182
};

const OssEncOID& id_pr_unidentifiedOperation = (const OssEncOID&)_v181;

static unsigned char _v184[] = { 0x55, 0x22, 0x04 };
static OSSC::COssEncOID _v183 = {
    3,
    _v184
};

const OssEncOID& id_pr_unavailableOperation = (const OssEncOID&)_v183;

static unsigned char _v186[] = { 0x55, 0x22, 0x05 };
static OSSC::COssEncOID _v185 = {
    3,
    _v186
};

const OssEncOID& id_pr_searchAttributeViolation = (const OssEncOID&)_v185;

static unsigned char _v188[] = { 0x55, 0x22, 0x06 };
static OSSC::COssEncOID _v187 = {
    3,
    _v188
};

const OssEncOID& id_pr_searchAttributeCombinationViolation = (const OssEncOID&)_v187;

static unsigned char _v190[] = { 0x55, 0x22, 0x07 };
static OSSC::COssEncOID _v189 = {
    3,
    _v190
};

const OssEncOID& id_pr_searchValueNotAllowed = (const OssEncOID&)_v189;

static unsigned char _v192[] = { 0x55, 0x22, 0x08 };
static OSSC::COssEncOID _v191 = {
    3,
    _v192
};

const OssEncOID& id_pr_missingSearchAttribute = (const OssEncOID&)_v191;

static unsigned char _v194[] = { 0x55, 0x22, 0x09 };
static OSSC::COssEncOID _v193 = {
    3,
    _v194
};

const OssEncOID& id_pr_searchValueViolation = (const OssEncOID&)_v193;

static unsigned char _v196[] = { 0x55, 0x22, 0x0A };
static OSSC::COssEncOID _v195 = {
    3,
    _v196
};

const OssEncOID& id_pr_attributeNegationViolation = (const OssEncOID&)_v195;

static unsigned char _v198[] = { 0x55, 0x22, 0x0B };
static OSSC::COssEncOID _v197 = {
    3,
    _v198
};

const OssEncOID& id_pr_searchValueRequired = (const OssEncOID&)_v197;

static unsigned char _v200[] = { 0x55, 0x22, 0x0C };
static OSSC::COssEncOID _v199 = {
    3,
    _v200
};

const OssEncOID& id_pr_invalidSearchValue = (const OssEncOID&)_v199;

static unsigned char _v202[] = { 0x55, 0x22, 0x0D };
static OSSC::COssEncOID _v201 = {
    3,
    _v202
};

const OssEncOID& id_pr_searchContextViolation = (const OssEncOID&)_v201;

static unsigned char _v204[] = { 0x55, 0x22, 0x0E };
static OSSC::COssEncOID _v203 = {
    3,
    _v204
};

const OssEncOID& id_pr_searchContextCombinationViolation = (const OssEncOID&)_v203;

static unsigned char _v206[] = { 0x55, 0x22, 0x0F };
static OSSC::COssEncOID _v205 = {
    3,
    _v206
};

const OssEncOID& id_pr_missingSearchContext = (const OssEncOID&)_v205;

static unsigned char _v208[] = { 0x55, 0x22, 0x10 };
static OSSC::COssEncOID _v207 = {
    3,
    _v208
};

const OssEncOID& id_pr_searchContextValueViolation = (const OssEncOID&)_v207;

static unsigned char _v210[] = { 0x55, 0x22, 0x11 };
static OSSC::COssEncOID _v209 = {
    3,
    _v210
};

const OssEncOID& id_pr_searchContextValueRequired = (const OssEncOID&)_v209;

static unsigned char _v212[] = { 0x55, 0x22, 0x12 };
static OSSC::COssEncOID _v211 = {
    3,
    _v212
};

const OssEncOID& id_pr_invalidContextSearchValue = (const OssEncOID&)_v211;

static unsigned char _v214[] = { 0x55, 0x22, 0x13 };
static OSSC::COssEncOID _v213 = {
    3,
    _v214
};

const OssEncOID& id_pr_unsupportedMatchingRule = (const OssEncOID&)_v213;

static unsigned char _v216[] = { 0x55, 0x22, 0x14 };
static OSSC::COssEncOID _v215 = {
    3,
    _v216
};

const OssEncOID& id_pr_attributeMatchingViolation = (const OssEncOID&)_v215;

static unsigned char _v218[] = { 0x55, 0x22, 0x15 };
static OSSC::COssEncOID _v217 = {
    3,
    _v218
};

const OssEncOID& id_pr_unsupportedMatchingUse = (const OssEncOID&)_v217;

static unsigned char _v220[] = { 0x55, 0x22, 0x16 };
static OSSC::COssEncOID _v219 = {
    3,
    _v220
};

const OssEncOID& id_pr_matchingUseViolation = (const OssEncOID&)_v219;

static unsigned char _v222[] = { 0x55, 0x22, 0x17 };
static OSSC::COssEncOID _v221 = {
    3,
    _v222
};

const OssEncOID& id_pr_hierarchySelectForbidden = (const OssEncOID&)_v221;

static unsigned char _v224[] = { 0x55, 0x22, 0x18 };
static OSSC::COssEncOID _v223 = {
    3,
    _v224
};

const OssEncOID& id_pr_invalidHierarchySelect = (const OssEncOID&)_v223;

static unsigned char _v226[] = { 0x55, 0x22, 0x19 };
static OSSC::COssEncOID _v225 = {
    3,
    _v226
};

const OssEncOID& id_pr_unavailableHierarchySelect = (const OssEncOID&)_v225;

static unsigned char _v228[] = { 0x55, 0x22, 0x1A };
static OSSC::COssEncOID _v227 = {
    3,
    _v228
};

const OssEncOID& id_pr_invalidSearchControlOptions = (const OssEncOID&)_v227;

static unsigned char _v230[] = { 0x55, 0x22, 0x1B };
static OSSC::COssEncOID _v229 = {
    3,
    _v230
};

const OssEncOID& id_pr_invalidServiceControlOptions = (const OssEncOID&)_v229;

static unsigned char _v232[] = { 0x55, 0x22, 0x1C };
static OSSC::COssEncOID _v231 = {
    3,
    _v232
};

const OssEncOID& id_pr_searchSubsetViolation = (const OssEncOID&)_v231;

static unsigned char _v234[] = { 0x55, 0x22, 0x1D };
static OSSC::COssEncOID _v233 = {
    3,
    _v234
};

const OssEncOID& id_pr_unmatchedKeyAttributes = (const OssEncOID&)_v233;

static unsigned char _v236[] = { 0x55, 0x22, 0x1E };
static OSSC::COssEncOID _v235 = {
    3,
    _v236
};

const OssEncOID& id_pr_ambiguousKeyAttributes = (const OssEncOID&)_v235;

static unsigned char _v238[] = { 0x55, 0x22, 0x1F };
static OSSC::COssEncOID _v237 = {
    3,
    _v238
};

const OssEncOID& id_pr_unavailableRelaxationLevel = (const OssEncOID&)_v237;

static unsigned char _v240[] = { 0x55, 0x22, 0x20 };
static OSSC::COssEncOID _v239 = {
    3,
    _v240
};

const OssEncOID& id_pr_emptyHierarchySelection = (const OssEncOID&)_v239;

static unsigned char _v242[] = { 0x55, 0x22, 0x21 };
static OSSC::COssEncOID _v241 = {
    3,
    _v242
};

const OssEncOID& id_pr_administratorImposedLimit = (const OssEncOID&)_v241;

static unsigned char _v244[] = { 0x55, 0x22, 0x22 };
static OSSC::COssEncOID _v243 = {
    3,
    _v244
};

const OssEncOID& id_pr_permanentRestriction = (const OssEncOID&)_v243;

static unsigned char _v246[] = { 0x55, 0x22, 0x23 };
static OSSC::COssEncOID _v245 = {
    3,
    _v246
};

const OssEncOID& id_pr_temporaryRestriction = (const OssEncOID&)_v245;

static unsigned char _v248[] = { 0x55, 0x22, 0x24 };
static OSSC::COssEncOID _v247 = {
    3,
    _v248
};

const OssEncOID& id_pr_relaxationNotSupported = (const OssEncOID&)_v247;

static unsigned char _v250[] = { 0x55, 0x0D, 0x02 };
static OSSC::COssEncOID _v249 = {
    3,
    _v250
};

const OssEncOID& id_mr_caseIgnoreMatch = (const OssEncOID&)_v249;

static unsigned char _v252[] = { 0x55, 0x0D, 0x03 };
static OSSC::COssEncOID _v251 = {
    3,
    _v252
};

const OssEncOID& id_mr_caseIgnoreOrderingMatch = (const OssEncOID&)_v251;

static unsigned char _v254[] = { 0x55, 0x0D, 0x04 };
static OSSC::COssEncOID _v253 = {
    3,
    _v254
};

const OssEncOID& id_mr_caseIgnoreSubstringsMatch = (const OssEncOID&)_v253;

static unsigned char _v256[] = { 0x55, 0x0D, 0x05 };
static OSSC::COssEncOID _v255 = {
    3,
    _v256
};

const OssEncOID& id_mr_caseExactMatch = (const OssEncOID&)_v255;

static unsigned char _v258[] = { 0x55, 0x0D, 0x06 };
static OSSC::COssEncOID _v257 = {
    3,
    _v258
};

const OssEncOID& id_mr_caseExactOrderingMatch = (const OssEncOID&)_v257;

static unsigned char _v260[] = { 0x55, 0x0D, 0x07 };
static OSSC::COssEncOID _v259 = {
    3,
    _v260
};

const OssEncOID& id_mr_caseExactSubstringsMatch = (const OssEncOID&)_v259;

static unsigned char _v262[] = { 0x55, 0x0D, 0x08 };
static OSSC::COssEncOID _v261 = {
    3,
    _v262
};

const OssEncOID& id_mr_numericStringMatch = (const OssEncOID&)_v261;

static unsigned char _v264[] = { 0x55, 0x0D, 0x09 };
static OSSC::COssEncOID _v263 = {
    3,
    _v264
};

const OssEncOID& id_mr_numericStringOrderingMatch = (const OssEncOID&)_v263;

static unsigned char _v266[] = { 0x55, 0x0D, 0x0A };
static OSSC::COssEncOID _v265 = {
    3,
    _v266
};

const OssEncOID& id_mr_numericStringSubstringsMatch = (const OssEncOID&)_v265;

static unsigned char _v268[] = { 0x55, 0x0D, 0x0B };
static OSSC::COssEncOID _v267 = {
    3,
    _v268
};

const OssEncOID& id_mr_caseIgnoreListMatch = (const OssEncOID&)_v267;

static unsigned char _v270[] = { 0x55, 0x0D, 0x0C };
static OSSC::COssEncOID _v269 = {
    3,
    _v270
};

const OssEncOID& id_mr_caseIgnoreListSubstringsMatch = (const OssEncOID&)_v269;

static unsigned char _v272[] = { 0x55, 0x0D, 0x0D };
static OSSC::COssEncOID _v271 = {
    3,
    _v272
};

const OssEncOID& id_mr_booleanMatch = (const OssEncOID&)_v271;

static unsigned char _v274[] = { 0x55, 0x0D, 0x0E };
static OSSC::COssEncOID _v273 = {
    3,
    _v274
};

const OssEncOID& id_mr_integerMatch = (const OssEncOID&)_v273;

static unsigned char _v276[] = { 0x55, 0x0D, 0x0F };
static OSSC::COssEncOID _v275 = {
    3,
    _v276
};

const OssEncOID& id_mr_integerOrderingMatch = (const OssEncOID&)_v275;

static unsigned char _v278[] = { 0x55, 0x0D, 0x10 };
static OSSC::COssEncOID _v277 = {
    3,
    _v278
};

const OssEncOID& id_mr_bitStringMatch = (const OssEncOID&)_v277;

static unsigned char _v280[] = { 0x55, 0x0D, 0x11 };
static OSSC::COssEncOID _v279 = {
    3,
    _v280
};

const OssEncOID& id_mr_octetStringMatch = (const OssEncOID&)_v279;

static unsigned char _v282[] = { 0x55, 0x0D, 0x12 };
static OSSC::COssEncOID _v281 = {
    3,
    _v282
};

const OssEncOID& id_mr_octetStringOrderingMatch = (const OssEncOID&)_v281;

static unsigned char _v284[] = { 0x55, 0x0D, 0x13 };
static OSSC::COssEncOID _v283 = {
    3,
    _v284
};

const OssEncOID& id_mr_octetStringSubstringsMatch = (const OssEncOID&)_v283;

static unsigned char _v286[] = { 0x55, 0x0D, 0x14 };
static OSSC::COssEncOID _v285 = {
    3,
    _v286
};

const OssEncOID& id_mr_telephoneNumberMatch = (const OssEncOID&)_v285;

static unsigned char _v288[] = { 0x55, 0x0D, 0x15 };
static OSSC::COssEncOID _v287 = {
    3,
    _v288
};

const OssEncOID& id_mr_telephoneNumberSubstringsMatch = (const OssEncOID&)_v287;

static unsigned char _v290[] = { 0x55, 0x0D, 0x16 };
static OSSC::COssEncOID _v289 = {
    3,
    _v290
};

const OssEncOID& id_mr_presentationAddressMatch = (const OssEncOID&)_v289;

static unsigned char _v292[] = { 0x55, 0x0D, 0x17 };
static OSSC::COssEncOID _v291 = {
    3,
    _v292
};

const OssEncOID& id_mr_uniqueMemberMatch = (const OssEncOID&)_v291;

static unsigned char _v294[] = { 0x55, 0x0D, 0x18 };
static OSSC::COssEncOID _v293 = {
    3,
    _v294
};

const OssEncOID& id_mr_protocolInformationMatch = (const OssEncOID&)_v293;

static unsigned char _v296[] = { 0x55, 0x0D, 0x19 };
static OSSC::COssEncOID _v295 = {
    3,
    _v296
};

const OssEncOID& id_mr_uTCTimeMatch = (const OssEncOID&)_v295;

static unsigned char _v298[] = { 0x55, 0x0D, 0x1A };
static OSSC::COssEncOID _v297 = {
    3,
    _v298
};

const OssEncOID& id_mr_uTCTimeOrderingMatch = (const OssEncOID&)_v297;

static unsigned char _v300[] = { 0x55, 0x0D, 0x1B };
static OSSC::COssEncOID _v299 = {
    3,
    _v300
};

const OssEncOID& id_mr_generalizedTimeMatch = (const OssEncOID&)_v299;

static unsigned char _v302[] = { 0x55, 0x0D, 0x1C };
static OSSC::COssEncOID _v301 = {
    3,
    _v302
};

const OssEncOID& id_mr_generalizedTimeOrderingMatch = (const OssEncOID&)_v301;

static unsigned char _v304[] = { 0x55, 0x0D, 0x1D };
static OSSC::COssEncOID _v303 = {
    3,
    _v304
};

const OssEncOID& id_mr_integerFirstComponentMatch = (const OssEncOID&)_v303;

static unsigned char _v306[] = { 0x55, 0x0D, 0x1E };
static OSSC::COssEncOID _v305 = {
    3,
    _v306
};

const OssEncOID& id_mr_objectIdentifierFirstComponentMatch = (const OssEncOID&)_v305;

static unsigned char _v308[] = { 0x55, 0x0D, 0x1F };
static OSSC::COssEncOID _v307 = {
    3,
    _v308
};

const OssEncOID& id_mr_directoryStringFirstComponentMatch = (const OssEncOID&)_v307;

static unsigned char _v310[] = { 0x55, 0x0D, 0x20 };
static OSSC::COssEncOID _v309 = {
    3,
    _v310
};

const OssEncOID& id_mr_wordMatch = (const OssEncOID&)_v309;

static unsigned char _v312[] = { 0x55, 0x0D, 0x21 };
static OSSC::COssEncOID _v311 = {
    3,
    _v312
};

const OssEncOID& id_mr_keywordMatch = (const OssEncOID&)_v311;

static unsigned char _v314[] = { 0x55, 0x0D, 0x29 };
static OSSC::COssEncOID _v313 = {
    3,
    _v314
};

const OssEncOID& id_mr_storedPrefixMatch = (const OssEncOID&)_v313;

static unsigned char _v316[] = { 0x55, 0x0D, 0x2F };
static OSSC::COssEncOID _v315 = {
    3,
    _v316
};

const OssEncOID& id_mr_systemProposedMatch = (const OssEncOID&)_v315;

static unsigned char _v318[] = { 0x55, 0x0D, 0x30 };
static OSSC::COssEncOID _v317 = {
    3,
    _v318
};

const OssEncOID& id_mr_generalWordMatch = (const OssEncOID&)_v317;

static unsigned char _v320[] = { 0x55, 0x0D, 0x31 };
static OSSC::COssEncOID _v319 = {
    3,
    _v320
};

const OssEncOID& id_mr_approximateStringMatch = (const OssEncOID&)_v319;

static unsigned char _v322[] = { 0x55, 0x0D, 0x32 };
static OSSC::COssEncOID _v321 = {
    3,
    _v322
};

const OssEncOID& id_mr_ignoreIfAbsentMatch = (const OssEncOID&)_v321;

static unsigned char _v324[] = { 0x55, 0x0D, 0x33 };
static OSSC::COssEncOID _v323 = {
    3,
    _v324
};

const OssEncOID& id_mr_nullMatch = (const OssEncOID&)_v323;

static unsigned char _v326[] = { 0x55, 0x0D, 0x34 };
static OSSC::COssEncOID _v325 = {
    3,
    _v326
};

const OssEncOID& id_mr_zonalMatch = (const OssEncOID&)_v325;

static unsigned char _v328[] = { 0x55, 0x0D, 0x3F };
static OSSC::COssEncOID _v327 = {
    3,
    _v328
};

const OssEncOID& id_mr_facsimileNumberMatch = (const OssEncOID&)_v327;

static unsigned char _v330[] = { 0x55, 0x0D, 0x40 };
static OSSC::COssEncOID _v329 = {
    3,
    _v330
};

const OssEncOID& id_mr_facsimileNumberSubstringsMatch = (const OssEncOID&)_v329;

static unsigned char _v332[] = { 0x55, 0x0D, 0x44 };
static OSSC::COssEncOID _v331 = {
    3,
    _v332
};

const OssEncOID& id_mr_uuidpairmatch = (const OssEncOID&)_v331;

static unsigned char _v334[] = { 0x55, 0x1F, 0x00 };
static OSSC::COssEncOID _v333 = {
    3,
    _v334
};

const OssEncOID& id_avc_language = (const OssEncOID&)_v333;

static unsigned char _v336[] = { 0x55, 0x1F, 0x01 };
static OSSC::COssEncOID _v335 = {
    3,
    _v336
};

const OssEncOID& id_avc_temporal = (const OssEncOID&)_v335;

static unsigned char _v338[] = { 0x55, 0x1F, 0x02 };
static OSSC::COssEncOID _v337 = {
    3,
    _v338
};

const OssEncOID& id_avc_locale = (const OssEncOID&)_v337;

static unsigned char _v340[] = { 0x55, 0x1F, 0x05 };
static OSSC::COssEncOID _v339 = {
    3,
    _v340
};

const OssEncOID& id_avc_ldapAttributeOption = (const OssEncOID&)_v339;

static unsigned char _v342[] = { 0x55 };
static OSSC::COssEncOID _v341 = {
    1,
    _v342
};

const OssEncOID& ds = (const OssEncOID&)_v341;

static unsigned char _v344[] = { 0x55, 0x01 };
static OSSC::COssEncOID _v343 = {
    2,
    _v344
};

const OssEncOID& module = (const OssEncOID&)_v343;

static unsigned char _v346[] = { 0x55, 0x02 };
static OSSC::COssEncOID _v345 = {
    2,
    _v346
};

const OssEncOID& serviceElement = (const OssEncOID&)_v345;

static unsigned char _v348[] = { 0x55, 0x03 };
static OSSC::COssEncOID _v347 = {
    2,
    _v348
};

const OssEncOID& applicationContext = (const OssEncOID&)_v347;

static unsigned char _v350[] = { 0x55, 0x04 };
static OSSC::COssEncOID _v349 = {
    2,
    _v350
};

const OssEncOID& attributeType = (const OssEncOID&)_v349;

static unsigned char _v352[] = { 0x55, 0x05 };
static OSSC::COssEncOID _v351 = {
    2,
    _v352
};

const OssEncOID& attributeSyntax = (const OssEncOID&)_v351;

static unsigned char _v354[] = { 0x55, 0x06 };
static OSSC::COssEncOID _v353 = {
    2,
    _v354
};

const OssEncOID& UsefulDefinitions_objectClass = (const OssEncOID&)_v353;

static unsigned char _v356[] = { 0x55, 0x08 };
static OSSC::COssEncOID _v355 = {
    2,
    _v356
};

const OssEncOID& algorithm = (const OssEncOID&)_v355;

static unsigned char _v358[] = { 0x55, 0x09 };
static OSSC::COssEncOID _v357 = {
    2,
    _v358
};

const OssEncOID& abstractSyntax = (const OssEncOID&)_v357;

static unsigned char _v360[] = { 0x55, 0x0C };
static OSSC::COssEncOID _v359 = {
    2,
    _v360
};

const OssEncOID& dsaOperationalAttribute = (const OssEncOID&)_v359;

static unsigned char _v362[] = { 0x55, 0x0D };
static OSSC::COssEncOID _v361 = {
    2,
    _v362
};

const OssEncOID& matchingRule = (const OssEncOID&)_v361;

static unsigned char _v364[] = { 0x55, 0x0E };
static OSSC::COssEncOID _v363 = {
    2,
    _v364
};

const OssEncOID& knowledgeMatchingRule = (const OssEncOID&)_v363;

static unsigned char _v366[] = { 0x55, 0x0F };
static OSSC::COssEncOID _v365 = {
    2,
    _v366
};

const OssEncOID& nameForm = (const OssEncOID&)_v365;

static unsigned char _v368[] = { 0x55, 0x10 };
static OSSC::COssEncOID _v367 = {
    2,
    _v368
};

const OssEncOID& group = (const OssEncOID&)_v367;

static unsigned char _v370[] = { 0x55, 0x11 };
static OSSC::COssEncOID _v369 = {
    2,
    _v370
};

const OssEncOID& UsefulDefinitions_subentry = (const OssEncOID&)_v369;

static unsigned char _v372[] = { 0x55, 0x12 };
static OSSC::COssEncOID _v371 = {
    2,
    _v372
};

const OssEncOID& operationalAttributeType = (const OssEncOID&)_v371;

static unsigned char _v374[] = { 0x55, 0x13 };
static OSSC::COssEncOID _v373 = {
    2,
    _v374
};

const OssEncOID& operationalBinding = (const OssEncOID&)_v373;

static unsigned char _v376[] = { 0x55, 0x14 };
static OSSC::COssEncOID _v375 = {
    2,
    _v376
};

const OssEncOID& schemaObjectClass = (const OssEncOID&)_v375;

static unsigned char _v378[] = { 0x55, 0x15 };
static OSSC::COssEncOID _v377 = {
    2,
    _v378
};

const OssEncOID& schemaOperationalAttribute = (const OssEncOID&)_v377;

static unsigned char _v380[] = { 0x55, 0x17 };
static OSSC::COssEncOID _v379 = {
    2,
    _v380
};

const OssEncOID& administrativeRoles = (const OssEncOID&)_v379;

static unsigned char _v382[] = { 0x55, 0x18 };
static OSSC::COssEncOID _v381 = {
    2,
    _v382
};

const OssEncOID& accessControlAttribute = (const OssEncOID&)_v381;

static unsigned char _v384[] = { 0x55, 0x19 };
static OSSC::COssEncOID _v383 = {
    2,
    _v384
};

const OssEncOID& rosObject = (const OssEncOID&)_v383;

static unsigned char _v386[] = { 0x55, 0x1A };
static OSSC::COssEncOID _v385 = {
    2,
    _v386
};

const OssEncOID& contract = (const OssEncOID&)_v385;

static unsigned char _v388[] = { 0x55, 0x1B };
static OSSC::COssEncOID _v387 = {
    2,
    _v388
};

const OssEncOID& package = (const OssEncOID&)_v387;

static unsigned char _v390[] = { 0x55, 0x1C };
static OSSC::COssEncOID _v389 = {
    2,
    _v390
};

const OssEncOID& accessControlSchemes = (const OssEncOID&)_v389;

static unsigned char _v392[] = { 0x55, 0x1D };
static OSSC::COssEncOID _v391 = {
    2,
    _v392
};

const OssEncOID& certificateExtension = (const OssEncOID&)_v391;

static unsigned char _v394[] = { 0x55, 0x1E };
static OSSC::COssEncOID _v393 = {
    2,
    _v394
};

const OssEncOID& managementObject = (const OssEncOID&)_v393;

static unsigned char _v396[] = { 0x55, 0x1F };
static OSSC::COssEncOID _v395 = {
    2,
    _v396
};

const OssEncOID& attributeValueContext = (const OssEncOID&)_v395;

static unsigned char _v398[] = { 0x55, 0x21 };
static OSSC::COssEncOID _v397 = {
    2,
    _v398
};

const OssEncOID& idmProtocol = (const OssEncOID&)_v397;

static unsigned char _v400[] = { 0x55, 0x22 };
static OSSC::COssEncOID _v399 = {
    2,
    _v400
};

const OssEncOID& problem = (const OssEncOID&)_v399;

static unsigned char _v402[] = { 0x55, 0x23 };
static OSSC::COssEncOID _v401 = {
    2,
    _v402
};

const OssEncOID& notification = (const OssEncOID&)_v401;

static unsigned char _v404[] = { 0x55, 0x24 };
static OSSC::COssEncOID _v403 = {
    2,
    _v404
};

const OssEncOID& matchingRestriction = (const OssEncOID&)_v403;

static unsigned char _v406[] = { 0x55, 0x25 };
static OSSC::COssEncOID _v405 = {
    2,
    _v406
};

const OssEncOID& controlAttributeType = (const OssEncOID&)_v405;

static unsigned char _v408[] = { 0x55, 0x26 };
static OSSC::COssEncOID _v407 = {
    2,
    _v408
};

const OssEncOID& keyPurposes = (const OssEncOID&)_v407;

static unsigned char _v410[] = { 0x55, 0x01, 0x00, 0x06 };
static OSSC::COssEncOID _v409 = {
    4,
    _v410
};

const OssEncOID& usefulDefinitions = (const OssEncOID&)_v409;

static unsigned char _v412[] = { 0x55, 0x01, 0x01, 0x06 };
static OSSC::COssEncOID _v411 = {
    4,
    _v412
};

const OssEncOID& informationFramework = (const OssEncOID&)_v411;

static unsigned char _v414[] = { 0x55, 0x01, 0x02, 0x06 };
static OSSC::COssEncOID _v413 = {
    4,
    _v414
};

const OssEncOID& directoryAbstractService = (const OssEncOID&)_v413;

static unsigned char _v416[] = { 0x55, 0x01, 0x03, 0x06 };
static OSSC::COssEncOID _v415 = {
    4,
    _v416
};

const OssEncOID& distributedOperations = (const OssEncOID&)_v415;

static unsigned char _v418[] = { 0x55, 0x01, 0x04, 0x06 };
static OSSC::COssEncOID _v417 = {
    4,
    _v418
};

const OssEncOID& protocolObjectIdentifiers = (const OssEncOID&)_v417;

static unsigned char _v420[] = { 0x55, 0x01, 0x05, 0x06 };
static OSSC::COssEncOID _v419 = {
    4,
    _v420
};

const OssEncOID& selectedAttributeTypes = (const OssEncOID&)_v419;

static unsigned char _v422[] = { 0x55, 0x01, 0x06, 0x06 };
static OSSC::COssEncOID _v421 = {
    4,
    _v422
};

const OssEncOID& selectedObjectClasses = (const OssEncOID&)_v421;

static unsigned char _v424[] = { 0x55, 0x01, 0x07, 0x06 };
static OSSC::COssEncOID _v423 = {
    4,
    _v424
};

const OssEncOID& authenticationFramework = (const OssEncOID&)_v423;

static unsigned char _v426[] = { 0x55, 0x01, 0x08, 0x06 };
static OSSC::COssEncOID _v425 = {
    4,
    _v426
};

const OssEncOID& algorithmObjectIdentifiers = (const OssEncOID&)_v425;

static unsigned char _v428[] = { 0x55, 0x01, 0x09, 0x06 };
static OSSC::COssEncOID _v427 = {
    4,
    _v428
};

const OssEncOID& directoryObjectIdentifiers = (const OssEncOID&)_v427;

static unsigned char _v430[] = { 0x55, 0x01, 0x0A, 0x06 };
static OSSC::COssEncOID _v429 = {
    4,
    _v430
};

const OssEncOID& upperBounds = (const OssEncOID&)_v429;

static unsigned char _v432[] = { 0x55, 0x01, 0x0B, 0x06 };
static OSSC::COssEncOID _v431 = {
    4,
    _v432
};

const OssEncOID& dap = (const OssEncOID&)_v431;

static unsigned char _v434[] = { 0x55, 0x01, 0x0C, 0x06 };
static OSSC::COssEncOID _v433 = {
    4,
    _v434
};

const OssEncOID& dsp = (const OssEncOID&)_v433;

static unsigned char _v436[] = { 0x55, 0x01, 0x0D, 0x06 };
static OSSC::COssEncOID _v435 = {
    4,
    _v436
};

const OssEncOID& distributedDirectoryOIDs = (const OssEncOID&)_v435;

static unsigned char _v438[] = { 0x55, 0x01, 0x0E, 0x06 };
static OSSC::COssEncOID _v437 = {
    4,
    _v438
};

const OssEncOID& directoryShadowOIDs = (const OssEncOID&)_v437;

static unsigned char _v440[] = { 0x55, 0x01, 0x0F, 0x06 };
static OSSC::COssEncOID _v439 = {
    4,
    _v440
};

const OssEncOID& directoryShadowAbstractService = (const OssEncOID&)_v439;

static unsigned char _v442[] = { 0x55, 0x01, 0x10, 0x06 };
static OSSC::COssEncOID _v441 = {
    4,
    _v442
};

const OssEncOID& disp = (const OssEncOID&)_v441;

static unsigned char _v444[] = { 0x55, 0x01, 0x11, 0x06 };
static OSSC::COssEncOID _v443 = {
    4,
    _v444
};

const OssEncOID& dop = (const OssEncOID&)_v443;

static unsigned char _v446[] = { 0x55, 0x01, 0x12, 0x06 };
static OSSC::COssEncOID _v445 = {
    4,
    _v446
};

const OssEncOID& opBindingManagement = (const OssEncOID&)_v445;

static unsigned char _v448[] = { 0x55, 0x01, 0x13, 0x06 };
static OSSC::COssEncOID _v447 = {
    4,
    _v448
};

const OssEncOID& opBindingOIDs = (const OssEncOID&)_v447;

static unsigned char _v450[] = { 0x55, 0x01, 0x14, 0x06 };
static OSSC::COssEncOID _v449 = {
    4,
    _v450
};

const OssEncOID& hierarchicalOperationalBindings = (const OssEncOID&)_v449;

static unsigned char _v452[] = { 0x55, 0x01, 0x16, 0x06 };
static OSSC::COssEncOID _v451 = {
    4,
    _v452
};

const OssEncOID& dsaOperationalAttributeTypes = (const OssEncOID&)_v451;

static unsigned char _v454[] = { 0x55, 0x01, 0x17, 0x06 };
static OSSC::COssEncOID _v453 = {
    4,
    _v454
};

const OssEncOID& schemaAdministration = (const OssEncOID&)_v453;

static unsigned char _v456[] = { 0x55, 0x01, 0x18, 0x06 };
static OSSC::COssEncOID _v455 = {
    4,
    _v456
};

const OssEncOID& basicAccessControl = (const OssEncOID&)_v455;

static unsigned char _v458[] = { 0x55, 0x01, 0x19, 0x06 };
static OSSC::COssEncOID _v457 = {
    4,
    _v458
};

const OssEncOID& directoryOperationalBindingTypes = (const OssEncOID&)_v457;

static unsigned char _v460[] = { 0x55, 0x01, 0x1A, 0x06 };
static OSSC::COssEncOID _v459 = {
    4,
    _v460
};

const OssEncOID& certificateExtensions = (const OssEncOID&)_v459;

static unsigned char _v462[] = { 0x55, 0x01, 0x1B, 0x06 };
static OSSC::COssEncOID _v461 = {
    4,
    _v462
};

const OssEncOID& directoryManagement = (const OssEncOID&)_v461;

static unsigned char _v464[] = { 0x55, 0x01, 0x1C, 0x06 };
static OSSC::COssEncOID _v463 = {
    4,
    _v464
};

const OssEncOID& enhancedSecurity = (const OssEncOID&)_v463;

static unsigned char _v466[] = { 0x55, 0x01, 0x1E, 0x06 };
static OSSC::COssEncOID _v465 = {
    4,
    _v466
};

const OssEncOID& iDMProtocolSpecification = (const OssEncOID&)_v465;

static unsigned char _v468[] = { 0x55, 0x01, 0x1F, 0x06 };
static OSSC::COssEncOID _v467 = {
    4,
    _v468
};

const OssEncOID& directoryIDMProtocols = (const OssEncOID&)_v467;

static unsigned char _v470[] = { 0x55, 0x01, 0x20, 0x06 };
static OSSC::COssEncOID _v469 = {
    4,
    _v470
};

const OssEncOID& attributeCertificateDefinitions = (const OssEncOID&)_v469;

static unsigned char _v472[] = { 0x55, 0x01, 0x21, 0x06 };
static OSSC::COssEncOID _v471 = {
    4,
    _v472
};

const OssEncOID& serviceAdministration = (const OssEncOID&)_v471;

static unsigned char _v474[] = { 0x55, 0x01, 0x22, 0x06 };
static OSSC::COssEncOID _v473 = {
    4,
    _v474
};

const OssEncOID& externalDefinitions = (const OssEncOID&)_v473;

static unsigned char _v476[] = { 0x55, 0x01, 0x23, 0x06 };
static OSSC::COssEncOID _v475 = {
    4,
    _v476
};

const OssEncOID& commonProtocolSpecification = (const OssEncOID&)_v475;

static unsigned char _v478[] = { 0x55, 0x01, 0x24, 0x06 };
static OSSC::COssEncOID _v477 = {
    4,
    _v478
};

const OssEncOID& oSIProtocolSpecification = (const OssEncOID&)_v477;

static unsigned char _v480[] = { 0x55, 0x01, 0x25, 0x06 };
static OSSC::COssEncOID _v479 = {
    4,
    _v480
};

const OssEncOID& directoryOSIProtocols = (const OssEncOID&)_v479;

static unsigned char _v482[] = { 0x55, 0x06 };
static OSSC::COssEncOID _v481 = {
    2,
    _v482
};

const OssEncOID& id_oc = (const OssEncOID&)_v481;

static unsigned char _v484[] = { 0x55, 0x04 };
static OSSC::COssEncOID _v483 = {
    2,
    _v484
};

const OssEncOID& id_at = (const OssEncOID&)_v483;

static unsigned char _v486[] = { 0x55, 0x09 };
static OSSC::COssEncOID _v485 = {
    2,
    _v486
};

const OssEncOID& id_as = (const OssEncOID&)_v485;

static unsigned char _v488[] = { 0x55, 0x0D };
static OSSC::COssEncOID _v487 = {
    2,
    _v488
};

const OssEncOID& id_mr = (const OssEncOID&)_v487;

static unsigned char _v490[] = { 0x55, 0x0F };
static OSSC::COssEncOID _v489 = {
    2,
    _v490
};

const OssEncOID& id_nf = (const OssEncOID&)_v489;

static unsigned char _v492[] = { 0x55, 0x11 };
static OSSC::COssEncOID _v491 = {
    2,
    _v492
};

const OssEncOID& id_sc = (const OssEncOID&)_v491;

static unsigned char _v494[] = { 0x55, 0x12 };
static OSSC::COssEncOID _v493 = {
    2,
    _v494
};

const OssEncOID& id_oa = (const OssEncOID&)_v493;

static unsigned char _v496[] = { 0x55, 0x13 };
static OSSC::COssEncOID _v495 = {
    2,
    _v496
};

const OssEncOID& id_ob = (const OssEncOID&)_v495;

static unsigned char _v498[] = { 0x55, 0x0C };
static OSSC::COssEncOID _v497 = {
    2,
    _v498
};

const OssEncOID& id_doa = (const OssEncOID&)_v497;

static unsigned char _v500[] = { 0x55, 0x0E };
static OSSC::COssEncOID _v499 = {
    2,
    _v500
};

const OssEncOID& id_kmr = (const OssEncOID&)_v499;

static unsigned char _v502[] = { 0x55, 0x14 };
static OSSC::COssEncOID _v501 = {
    2,
    _v502
};

const OssEncOID& id_soc = (const OssEncOID&)_v501;

static unsigned char _v504[] = { 0x55, 0x15 };
static OSSC::COssEncOID _v503 = {
    2,
    _v504
};

const OssEncOID& id_soa = (const OssEncOID&)_v503;

static unsigned char _v506[] = { 0x55, 0x17 };
static OSSC::COssEncOID _v505 = {
    2,
    _v506
};

const OssEncOID& id_ar = (const OssEncOID&)_v505;

static unsigned char _v508[] = { 0x55, 0x18 };
static OSSC::COssEncOID _v507 = {
    2,
    _v508
};

const OssEncOID& id_aca = (const OssEncOID&)_v507;

static unsigned char _v510[] = { 0x55, 0x03 };
static OSSC::COssEncOID _v509 = {
    2,
    _v510
};

const OssEncOID& id_ac = (const OssEncOID&)_v509;

static unsigned char _v512[] = { 0x55, 0x19 };
static OSSC::COssEncOID _v511 = {
    2,
    _v512
};

const OssEncOID& id_rosObject = (const OssEncOID&)_v511;

static unsigned char _v514[] = { 0x55, 0x1A };
static OSSC::COssEncOID _v513 = {
    2,
    _v514
};

const OssEncOID& id_contract = (const OssEncOID&)_v513;

static unsigned char _v516[] = { 0x55, 0x1B };
static OSSC::COssEncOID _v515 = {
    2,
    _v516
};

const OssEncOID& id_package = (const OssEncOID&)_v515;

static unsigned char _v518[] = { 0x55, 0x1C };
static OSSC::COssEncOID _v517 = {
    2,
    _v518
};

const OssEncOID& id_acScheme = (const OssEncOID&)_v517;

static unsigned char _v520[] = { 0x55, 0x1D };
static OSSC::COssEncOID _v519 = {
    2,
    _v520
};

const OssEncOID& id_ce = (const OssEncOID&)_v519;

static unsigned char _v522[] = { 0x55, 0x1E };
static OSSC::COssEncOID _v521 = {
    2,
    _v522
};

const OssEncOID& id_mgt = (const OssEncOID&)_v521;

static unsigned char _v524[] = { 0x55, 0x1F };
static OSSC::COssEncOID _v523 = {
    2,
    _v524
};

const OssEncOID& id_avc = (const OssEncOID&)_v523;

static unsigned char _v526[] = { 0x55, 0x21 };
static OSSC::COssEncOID _v525 = {
    2,
    _v526
};

const OssEncOID& id_idm = (const OssEncOID&)_v525;

static unsigned char _v528[] = { 0x55, 0x22 };
static OSSC::COssEncOID _v527 = {
    2,
    _v528
};

const OssEncOID& id_pr = (const OssEncOID&)_v527;

static unsigned char _v530[] = { 0x55, 0x23 };
static OSSC::COssEncOID _v529 = {
    2,
    _v530
};

const OssEncOID& id_not = (const OssEncOID&)_v529;

static unsigned char _v532[] = { 0x55, 0x24 };
static OSSC::COssEncOID _v531 = {
    2,
    _v532
};

const OssEncOID& id_mre = (const OssEncOID&)_v531;

static unsigned char _v534[] = { 0x55, 0x25 };
static OSSC::COssEncOID _v533 = {
    2,
    _v534
};

const OssEncOID& id_cat = (const OssEncOID&)_v533;

static unsigned char _v536[] = { 0x55, 0x26 };
static OSSC::COssEncOID _v535 = {
    2,
    _v536
};

const OssEncOID& id_kp = (const OssEncOID&)_v535;

static unsigned char _v538[] = { 0x55, 0x01, 0x0D };
static OSSC::COssEncOID _v537 = {
    3,
    _v538
};

const OssEncOID& distributedDirectoryObjectIdentifiers = (const OssEncOID&)_v537;

static unsigned char _v540[] = { 0x55, 0x06, 0x00 };
static OSSC::COssEncOID _v539 = {
    3,
    _v540
};

const OssEncOID& id_oc_top = (const OssEncOID&)_v539;

static unsigned char _v542[] = { 0x55, 0x06, 0x01 };
static OSSC::COssEncOID _v541 = {
    3,
    _v542
};

const OssEncOID& id_oc_alias = (const OssEncOID&)_v541;

static unsigned char _v544[] = { 0x55, 0x06, 0x1C };
static OSSC::COssEncOID _v543 = {
    3,
    _v544
};

const OssEncOID& id_oc_parent = (const OssEncOID&)_v543;

static unsigned char _v546[] = { 0x55, 0x06, 0x1D };
static OSSC::COssEncOID _v545 = {
    3,
    _v546
};

const OssEncOID& id_oc_child = (const OssEncOID&)_v545;

static unsigned char _v548[] = { 0x55, 0x04, 0x00 };
static OSSC::COssEncOID _v547 = {
    3,
    _v548
};

const OssEncOID& id_at_objectClass = (const OssEncOID&)_v547;

static unsigned char _v550[] = { 0x55, 0x04, 0x01 };
static OSSC::COssEncOID _v549 = {
    3,
    _v550
};

const OssEncOID& id_at_aliasedEntryName = (const OssEncOID&)_v549;

static unsigned char _v552[] = { 0x55, 0x0D, 0x00 };
static OSSC::COssEncOID _v551 = {
    3,
    _v552
};

const OssEncOID& id_mr_objectIdentifierMatch = (const OssEncOID&)_v551;

static unsigned char _v554[] = { 0x55, 0x0D, 0x01 };
static OSSC::COssEncOID _v553 = {
    3,
    _v554
};

const OssEncOID& id_mr_distinguishedNameMatch = (const OssEncOID&)_v553;

static unsigned char _v556[] = { 0x55, 0x12, 0x00 };
static OSSC::COssEncOID _v555 = {
    3,
    _v556
};

const OssEncOID& id_oa_excludeAllCollectiveAttributes = (const OssEncOID&)_v555;

static unsigned char _v558[] = { 0x55, 0x12, 0x01 };
static OSSC::COssEncOID _v557 = {
    3,
    _v558
};

const OssEncOID& id_oa_createTimestamp = (const OssEncOID&)_v557;

static unsigned char _v560[] = { 0x55, 0x12, 0x02 };
static OSSC::COssEncOID _v559 = {
    3,
    _v560
};

const OssEncOID& id_oa_modifyTimestamp = (const OssEncOID&)_v559;

static unsigned char _v562[] = { 0x55, 0x12, 0x03 };
static OSSC::COssEncOID _v561 = {
    3,
    _v562
};

const OssEncOID& id_oa_creatorsName = (const OssEncOID&)_v561;

static unsigned char _v564[] = { 0x55, 0x12, 0x04 };
static OSSC::COssEncOID _v563 = {
    3,
    _v564
};

const OssEncOID& id_oa_modifiersName = (const OssEncOID&)_v563;

static unsigned char _v566[] = { 0x55, 0x12, 0x05 };
static OSSC::COssEncOID _v565 = {
    3,
    _v566
};

const OssEncOID& id_oa_administrativeRole = (const OssEncOID&)_v565;

static unsigned char _v568[] = { 0x55, 0x12, 0x06 };
static OSSC::COssEncOID _v567 = {
    3,
    _v568
};

const OssEncOID& id_oa_subtreeSpecification = (const OssEncOID&)_v567;

static unsigned char _v570[] = { 0x55, 0x12, 0x07 };
static OSSC::COssEncOID _v569 = {
    3,
    _v570
};

const OssEncOID& id_oa_collectiveExclusions = (const OssEncOID&)_v569;

static unsigned char _v572[] = { 0x55, 0x12, 0x08 };
static OSSC::COssEncOID _v571 = {
    3,
    _v572
};

const OssEncOID& id_oa_subschemaTimestamp = (const OssEncOID&)_v571;

static unsigned char _v574[] = { 0x55, 0x12, 0x09 };
static OSSC::COssEncOID _v573 = {
    3,
    _v574
};

const OssEncOID& id_oa_hasSubordinates = (const OssEncOID&)_v573;

static unsigned char _v576[] = { 0x55, 0x12, 0x0A };
static OSSC::COssEncOID _v575 = {
    3,
    _v576
};

const OssEncOID& id_oa_subschemaSubentryList = (const OssEncOID&)_v575;

static unsigned char _v578[] = { 0x55, 0x12, 0x0B };
static OSSC::COssEncOID _v577 = {
    3,
    _v578
};

const OssEncOID& id_oa_accessControlSubentryList = (const OssEncOID&)_v577;

static unsigned char _v580[] = { 0x55, 0x12, 0x0C };
static OSSC::COssEncOID _v579 = {
    3,
    _v580
};

const OssEncOID& id_oa_collectiveAttributeSubentryList = (const OssEncOID&)_v579;

static unsigned char _v582[] = { 0x55, 0x12, 0x0D };
static OSSC::COssEncOID _v581 = {
    3,
    _v582
};

const OssEncOID& id_oa_contextDefaultSubentryList = (const OssEncOID&)_v581;

static unsigned char _v584[] = { 0x55, 0x12, 0x0E };
static OSSC::COssEncOID _v583 = {
    3,
    _v584
};

const OssEncOID& id_oa_contextAssertionDefault = (const OssEncOID&)_v583;

static unsigned char _v586[] = { 0x55, 0x12, 0x0F };
static OSSC::COssEncOID _v585 = {
    3,
    _v586
};

const OssEncOID& id_oa_serviceAdminSubentryList = (const OssEncOID&)_v585;

static unsigned char _v588[] = { 0x55, 0x12, 0x10 };
static OSSC::COssEncOID _v587 = {
    3,
    _v588
};

const OssEncOID& id_oa_searchRules = (const OssEncOID&)_v587;

static unsigned char _v590[] = { 0x55, 0x12, 0x11 };
static OSSC::COssEncOID _v589 = {
    3,
    _v590
};

const OssEncOID& id_oa_hierarchyLevel = (const OssEncOID&)_v589;

static unsigned char _v592[] = { 0x55, 0x12, 0x12 };
static OSSC::COssEncOID _v591 = {
    3,
    _v592
};

const OssEncOID& id_oa_hierarchyBelow = (const OssEncOID&)_v591;

static unsigned char _v594[] = { 0x55, 0x12, 0x13 };
static OSSC::COssEncOID _v593 = {
    3,
    _v594
};

const OssEncOID& id_oa_hierarchyParent = (const OssEncOID&)_v593;

static unsigned char _v596[] = { 0x55, 0x12, 0x14 };
static OSSC::COssEncOID _v595 = {
    3,
    _v596
};

const OssEncOID& id_oa_hierarchyTop = (const OssEncOID&)_v595;

static unsigned char _v598[] = { 0x55, 0x12, 0x30 };
static OSSC::COssEncOID _v597 = {
    3,
    _v598
};

const OssEncOID& id_oa_allAttributeTypes = (const OssEncOID&)_v597;

static unsigned char _v600[] = { 0x55, 0x11, 0x00 };
static OSSC::COssEncOID _v599 = {
    3,
    _v600
};

const OssEncOID& id_sc_subentry = (const OssEncOID&)_v599;

static unsigned char _v602[] = { 0x55, 0x11, 0x01 };
static OSSC::COssEncOID _v601 = {
    3,
    _v602
};

const OssEncOID& id_sc_accessControlSubentry = (const OssEncOID&)_v601;

static unsigned char _v604[] = { 0x55, 0x11, 0x02 };
static OSSC::COssEncOID _v603 = {
    3,
    _v604
};

const OssEncOID& id_sc_collectiveAttributeSubentry = (const OssEncOID&)_v603;

static unsigned char _v606[] = { 0x55, 0x11, 0x03 };
static OSSC::COssEncOID _v605 = {
    3,
    _v606
};

const OssEncOID& id_sc_contextAssertionSubentry = (const OssEncOID&)_v605;

static unsigned char _v608[] = { 0x55, 0x11, 0x04 };
static OSSC::COssEncOID _v607 = {
    3,
    _v608
};

const OssEncOID& id_sc_serviceAdminSubentry = (const OssEncOID&)_v607;

static unsigned char _v610[] = { 0x55, 0x0F, 0x10 };
static OSSC::COssEncOID _v609 = {
    3,
    _v610
};

const OssEncOID& id_nf_subentryNameForm = (const OssEncOID&)_v609;

static unsigned char _v612[] = { 0x55, 0x17, 0x01 };
static OSSC::COssEncOID _v611 = {
    3,
    _v612
};

const OssEncOID& id_ar_autonomousArea = (const OssEncOID&)_v611;

static unsigned char _v614[] = { 0x55, 0x17, 0x02 };
static OSSC::COssEncOID _v613 = {
    3,
    _v614
};

const OssEncOID& id_ar_accessControlSpecificArea = (const OssEncOID&)_v613;

static unsigned char _v616[] = { 0x55, 0x17, 0x03 };
static OSSC::COssEncOID _v615 = {
    3,
    _v616
};

const OssEncOID& id_ar_accessControlInnerArea = (const OssEncOID&)_v615;

static unsigned char _v618[] = { 0x55, 0x17, 0x04 };
static OSSC::COssEncOID _v617 = {
    3,
    _v618
};

const OssEncOID& id_ar_subschemaAdminSpecificArea = (const OssEncOID&)_v617;

static unsigned char _v620[] = { 0x55, 0x17, 0x05 };
static OSSC::COssEncOID _v619 = {
    3,
    _v620
};

const OssEncOID& id_ar_collectiveAttributeSpecificArea = (const OssEncOID&)_v619;

static unsigned char _v622[] = { 0x55, 0x17, 0x06 };
static OSSC::COssEncOID _v621 = {
    3,
    _v622
};

const OssEncOID& id_ar_collectiveAttributeInnerArea = (const OssEncOID&)_v621;

static unsigned char _v624[] = { 0x55, 0x17, 0x07 };
static OSSC::COssEncOID _v623 = {
    3,
    _v624
};

const OssEncOID& id_ar_contextDefaultSpecificArea = (const OssEncOID&)_v623;

static unsigned char _v626[] = { 0x55, 0x17, 0x08 };
static OSSC::COssEncOID _v625 = {
    3,
    _v626
};

const OssEncOID& id_ar_serviceSpecificArea = (const OssEncOID&)_v625;

const ossBoolean Context::default_fallback = FALSE;

const ossBoolean AttributeTypeAndDistinguishedValue::default_primaryDistinguished = TRUE;

static unsigned char _v629[] = {
    0x80
};
static OSSC::COssBitString _v628 = {
    1,
    _v629
};

const OssBitString& AARQ_apdu::default_protocol_version = (const OssBitString&)_v628;

static OSSC::COssBitString _v630 = {
    1,
    _v629
};

const OssBitString& AARE_apdu::default_protocol_version = (const OssBitString&)_v630;

const OSS_INT32 __shared15::default_checkpointSize = 0;

const OSS_INT32 __shared15::default_windowSize = 3;

const OSS_INT32 __shared15::default_dialogueMode = __shared15::default_checkpointSize;

static OSSC::COssBitString _v631 = {
    1,
    _v629
};

const OssBitString& __seq3::default_protocol_version = (const OssBitString&)_v631;

static OSSC::COssBitString _v632 = {
    0,
    nullptr
};

const OssBitString& __seq3::default_protocol_options = (const OssBitString&)_v632;

const OSS_INT32 __shared17::default_checkpointSize = __shared15::default_checkpointSize;

const OSS_INT32 __shared17::default_windowSize = __shared15::default_windowSize;

static OSSC::COssBitString _v633 = {
    1,
    _v629
};

const OssBitString& __seq4::default_protocol_version = (const OssBitString&)_v633;

static OSSC::COssBitString _v634 = {
    0,
    nullptr
};

const OssBitString& __seq4::default_protocol_options = (const OssBitString&)_v634;

static OSSC::COssBitString _v635 = {
    1,
    _v629
};

const OssBitString& __seq5::default_protocol_version = (const OssBitString&)_v635;


struct _Code {
    OSS_UINT32 choice;
    union {
	OSS_INT32  local;
	OSSC::COssEncOID  global;
    } u;
};

struct _ERROR {
    OSS_UINT32 bit_mask;
    unsigned short ParameterType;
    ossBoolean parameterTypeOptional;
    unsigned short ErrorPriority;
    _Code errorCode;
};
struct _OPERATION;

struct _OPERATION {
    OSS_UINT32 bit_mask;
    unsigned short ArgumentType;
    ossBoolean argumentTypeOptional;
    ossBoolean returnResult;
    unsigned short ResultType;
    ossBoolean resultTypeOptional;
    struct ObjectSetEntry *Errors;
    struct ObjectSetEntry *Linked;
    ossBoolean synchronous;
    ossBoolean alwaysReturns;
    unsigned short InvokePriority;
    unsigned short ResultPriority;
    _Code operationCode;
};
const ossBoolean __shared11::default_concatenation = Context::default_fallback;

const OSS_INT32 EnhancedGuide::default_subset = 1;

const OSS_UINT32 DayTime::default_minute = 0;

const OSS_UINT32 DayTime::default_second = 0;


struct _DayTime {
    OSS_UINT32 bit_mask;
    OSS_UINT32  hour;
    OSS_UINT32  minute;
    OSS_UINT32  second;
};
static _DayTime _v636 = {
    0,
    0,
    0,
    0
};

const DayTime& DayTimeBand::default_startDayTime = (const DayTime&)_v636;

static _DayTime _v637 = {
    0x80000000 | 0x40000000,
    23,
    59,
    59
};

const DayTime& DayTimeBand::default_endDayTime = (const DayTime&)_v637;

const ossBoolean TimeSpecification::default_notThisTime = Context::default_fallback;

const ossBoolean __seq11::default_entirely = Context::default_fallback;

struct _ATTRIBUTE;
struct _MATCHING_RULE;

struct _MATCHING_RULE {
    OSS_UINT32 bit_mask;
    struct ObjectSetEntry *ParentMatchingRules;
    unsigned short AssertionType;
    _ATTRIBUTE *uniqueMatchIndicator;
    OSSC::COssEncOID id;
};

struct _ATTRIBUTE {
    OSS_UINT32 bit_mask;
    _ATTRIBUTE *derivation;
    unsigned short Type;
    _MATCHING_RULE *equality_match;
    _MATCHING_RULE *ordering_match;
    _MATCHING_RULE *substrings_match;
    ossBoolean single_valued;
    ossBoolean collective;
    ossBoolean dummy;
    ossBoolean no_user_modification;
    enum AttributeUsage usage;
    OSSC::COssEncOID id;
};

struct _setof11 {
    struct _setof11 * next;
    OSSC::COssConstrainedOpenType  value;
};

struct _Context {
    OSS_UINT32 bit_mask;
    OSSC::COssEncOID  contextType;
    _setof11 * contextValues;
    ossBoolean  fallback;
};

struct _setof15 {
    struct _setof15 * next;
    _Context  value;
};

struct _seq13 {
    OSS_UINT32 bit_mask;
    OSSC::COssConstrainedOpenType  distingAttrValue;
    _setof15 * contextList;
};

struct _setof16 {
    struct _setof16 * next;
    _seq13  value;
};

struct _AttributeTypeAndDistinguishedValue {
    OSS_UINT32 bit_mask;
    OSSC::COssEncOID  type;
    OSSC::COssConstrainedOpenType  value;
    ossBoolean  primaryDistinguished;
    _setof16 * valuesWithContext;
};

struct _RelativeDistinguishedName {
    struct _RelativeDistinguishedName * next;
    _AttributeTypeAndDistinguishedValue  value;
};

struct _RDNSequence {
    struct _RDNSequence * next;
    _RelativeDistinguishedName * value;
};
static _RDNSequence* _v642 = nullptr;

const __shared6& SubtreeSpecification::default_base = (const __shared6&)_v642;

const OSS_UINT32 SubtreeSpecification::default_minimum = 0;

/* Local control table initialization */

extern "C" void DLL_ENTRY _oss_run_TOED_on_INTEL_X86_WINDOWS_AND_WINNT(void);

extern "C" {
static void _oss_post_init(struct ossGlobal *world);

/* TOED internal function declarations */

#ifdef OSS_COPY_VALUE
int DLL_ENTRY _CPUpperBounds_(struct ossGlobal * _g, int pduNum, void * src, void ** pdst);
#endif /* OSS_COPY_VALUE */

#ifdef OSS_COMPARE_VALUE
int DLL_ENTRY _CMUpperBounds_(struct ossGlobal * _g, int _pduNum, void * _odata, void * _cdata);
#endif /* OSS_COMPARE_VALUE */

#if OSS_TOED_API_LEVEL >= 31
void DLL_ENTRY _oeUpperBounds_(OssGlobal * _g, int _pdunum, void * _inbuf);
void * DLL_ENTRY _odUpperBounds_(OssGlobal * _g, int _pdunum);
#endif
static const _oss_xapi_entries_struct _oss_xapi_entries = {
     31
#ifdef OSS_COPY_VALUE
    ,_CPUpperBounds_
#else
    ,nullptr
#endif
#ifdef OSS_COMPARE_VALUE
    ,_CMUpperBounds_
#else
    ,nullptr
#endif
    ,nullptr
    ,nullptr
    ,102
    ,nullptr
    ,nullptr
#if OSS_TOED_API_LEVEL >= 24
    ,nullptr
    ,nullptr
    ,100
#endif
#if OSS_TOED_API_LEVEL >= 31
    ,100
    ,_oeUpperBounds_
    ,_odUpperBounds_
#endif
};

/* Local control table initialization */

static unsigned char _privateFlags[] = {0x0b,0x00};
void DLL_ENTRY_FDEF _ossinit_UpperBounds(struct ossGlobal *world) {
    _EncDecGlobals *_oss_c;

    _v6.u.absent = 0;
    _oss_run_TOED_on_INTEL_X86_WINDOWS_AND_WINNT();
    ossPrivateSetMoreFlags(world, 13, _privateFlags);
    ossLinkBer(world);
    ossLinkPer(world);
    if (world) {
        _oss_c = (_EncDecGlobals *)world->encDecVar;
        _oss_c->der = 1;
    }
    ossInitXAPIentries(world, &_oss_xapi_entries);
    _oss_post_init(world);
}

/* TOED internal function declarations */


struct _Name {
    OSS_UINT32 choice;
    union {
	_RDNSequence * rdnSequence;
    } u;
};

struct _AP_title {
    OSS_UINT32 choice;
    union {
	_Name * ap_title_form1;
	OSSC::COssEncOID  ap_title_form2;
    } u;
};

struct _AE_qualifier {
    OSS_UINT32 choice;
    union {
	_RelativeDistinguishedName * ae_qualifier_form1;
	OSS_INT32  ae_qualifier_form2;
    } u;
};

struct _choice1 {
    OSS_UINT32 choice;
    union {
	OSSC::COssOpen  single_ASN1_type;
	OSSC::COssString  octet_aligned;
	OSSC::COssBitString  arbitrary;
    } u;
};

struct _External {
    OSS_UINT32 bit_mask;
    OSSC::COssEncOID  direct_reference;
    OSS_INT32  indirect_reference;
    OSSC::COssString  data_value_descriptor;
    _choice1  encoding;
};

struct _seq1 {
    OSSC::COssEncOID  other_mechanism_name;
    OSSC::COssConstrainedOpenType  other_mechanism_value;
};

struct _Authentication_value {
    OSS_UINT32 choice;
    union {
	OSSC::COssString  charstring;
	OSSC::COssBitString  bitstring;
	_External * external;
	_seq1 * other;
    } u;
};

struct _Application_context_name_list {
    struct _Application_context_name_list * next;
    OSSC::COssEncOID  value;
};

struct _Association_information {
    struct _Association_information * next;
    _External  value;
};

struct _AARQ_apdu {
    OSS_UINT32 bit_mask;
    OSSC::COssBitString  protocol_version;
    OSSC::COssEncOID  application_context_name;
    _AP_title  called_AP_title;
    _AE_qualifier  called_AE_qualifier;
    OSS_INT32  called_AP_invocation_identifier;
    OSS_INT32  called_AE_invocation_identifier;
    _AP_title  calling_AP_title;
    _AE_qualifier  calling_AE_qualifier;
    OSS_INT32  calling_AP_invocation_identifier;
    OSS_INT32  calling_AE_invocation_identifier;
    OSSC::COssBitString  sender_acse_requirements;
    OSSC::COssEncOID  mechanism_name;
    _Authentication_value  calling_authentication_value;
    _Application_context_name_list * application_context_name_list;
    OSSC::COssString  implementation_information;
    _Association_information * user_information;
};

struct _Associate_source_diagnostic {
    OSS_UINT32 choice;
    union {
	OSS_INT32  acse_service_user;
	OSS_INT32  acse_service_provider;
    } u;
};

struct _AARE_apdu {
    OSS_UINT32 bit_mask;
    OSSC::COssBitString  protocol_version;
    OSSC::COssEncOID  application_context_name;
    OSS_INT32  result;
    _Associate_source_diagnostic  result_source_diagnostic;
    _AP_title  responding_AP_title;
    _AE_qualifier  responding_AE_qualifier;
    OSS_INT32  responding_AP_invocation_identifier;
    OSS_INT32  responding_AE_invocation_identifier;
    OSSC::COssBitString  responder_acse_requirements;
    OSSC::COssEncOID  mechanism_name;
    _Authentication_value  responding_authentication_value;
    _Application_context_name_list * application_context_name_list;
    OSSC::COssString  implementation_information;
    _Association_information * user_information;
};

struct _RLRQ_apdu {
    OSS_UINT32 bit_mask;
    OSS_INT32  reason;
    _Association_information * user_information;
};

struct _ABRT_apdu {
    OSS_UINT32 bit_mask;
    OSS_INT32  abort_source;
    enum ABRT_diagnostic  abort_diagnostic;
    _Association_information * user_information;
};

struct _ACSE_apdu {
    OSS_UINT32 choice;
    union {
	_AARQ_apdu * aarq;
	_AARE_apdu * aare;
	_RLRQ_apdu * rlrq;
	_RLRQ_apdu * rlre;
	_ABRT_apdu * abrt;
    } u;
};

struct _AE_title {
    OSS_UINT32 choice;
    union {
	_Name * ae_title_form1;
	OSSC::COssEncOID  ae_title_form2;
    } u;
};

struct _Mode_selector {
    OSS_INT32  mode_value;
};

struct _CallingSSuserReference {
    OSS_UINT32 choice;
    union {
	OSSC::COssString  t61String;
	OSSC::COssString  octetString;
    } u;
};

struct _SessionConnectionIdentifier {
    OSS_UINT32 bit_mask;
    _CallingSSuserReference  callingSSuserReference;
    char *  commonReference;
    OSSC::COssString  additionalReferenceInformation;
};

struct _ConnectionData {
    OSS_UINT32 choice;
    union {
	OSSC::COssOpen  open;
	_SessionConnectionIdentifier * recover;
    } u;
};

struct _set1 {
    OSS_UINT32 bit_mask;
    OSS_INT32  checkpointSize;
    OSS_INT32  windowSize;
    OSS_INT32  dialogueMode;
    _ConnectionData  connectionDataRQ;
    OSS_INT32  applicationProtocol;
};

struct _seq7 {
    OSS_INT32  presentation_context_identifier;
    OSSC::COssEncOID  abstract_syntax_name;
    _Application_context_name_list * transfer_syntax_name_list;
};

struct _Context_list {
    struct _Context_list * next;
    _seq7  value;
};

struct _Default_context_name {
    OSSC::COssEncOID  abstract_syntax_name;
    OSSC::COssEncOID  transfer_syntax_name;
};

struct _seq2 {
    char Any;
};

struct _PDV_list {
    OSS_UINT32 bit_mask;
    OSSC::COssEncOID  transfer_syntax_name;
    OSS_INT32  presentation_context_identifier;
    _choice1  presentation_data_values;
};

struct _Fully_encoded_data {
    struct _Fully_encoded_data * next;
    _PDV_list  value;
};

struct _User_data {
    OSS_UINT32 choice;
    union {
	OSSC::COssString  simply_encoded_data;
	_Fully_encoded_data * fully_encoded_data;
    } u;
};

struct _seq3 {
    OSS_UINT32 bit_mask;
    OSSC::COssBitString  protocol_version;
    OSSC::COssString  calling_presentation_selector;
    OSSC::COssString  called_presentation_selector;
    _Context_list * presentation_context_definition_list;
    _Default_context_name  default_context_name;
    OSSC::COssBitString  presentation_requirements;
    OSSC::COssBitString  user_session_requirements;
    OSSC::COssBitString  protocol_options;
    OSS_INT32  initiators_nominated_context;
    _seq2  extensions;
    _User_data  user_data;
};

struct _CP_type {
    OSS_UINT32 bit_mask;
    _Mode_selector  mode_selector;
    _set1  x410_mode_parameters;
    _seq3  normal_mode_parameters;
};

struct _set2 {
    OSS_UINT32 bit_mask;
    OSS_INT32  checkpointSize;
    OSS_INT32  windowSize;
    _ConnectionData  connectionDataAC;
};

struct _seq9 {
    OSS_UINT32 bit_mask;
    OSS_INT32  result;
    OSSC::COssEncOID  transfer_syntax_name;
    OSS_INT32  provider_reason;
};

struct _Result_list {
    struct _Result_list * next;
    _seq9  value;
};

struct _seq4 {
    OSS_UINT32 bit_mask;
    OSSC::COssBitString  protocol_version;
    OSSC::COssString  responding_presentation_selector;
    _Result_list * presentation_context_definition_result_list;
    OSSC::COssBitString  presentation_requirements;
    OSSC::COssBitString  user_session_requirements;
    OSSC::COssBitString  protocol_options;
    OSS_INT32  responders_nominated_context;
    _User_data  user_data;
};

struct _CPA_PPDU {
    OSS_UINT32 bit_mask;
    _Mode_selector  mode_selector;
    _set2  x410_mode_parameters;
    _seq4  normal_mode_parameters;
};

struct _set3 {
    OSS_UINT32 bit_mask;
    OSS_INT32  refuseReason;
    OSSC::COssOpen  userDataRJ;
};

struct _seq5 {
    OSS_UINT32 bit_mask;
    OSSC::COssBitString  protocol_version;
    OSSC::COssString  responding_presentation_selector;
    _Result_list * presentation_context_definition_result_list;
    OSS_INT32  default_context_result;
    OSS_INT32  provider_reason;
    _User_data  user_data;
};

struct _CPR_PPDU {
    OSS_UINT32 choice;
    union {
	_set3 * x400_mode_parameters;
	_seq5 * normal_mode_parameters;
    } u;
};

struct _set4 {
    OSS_UINT32 bit_mask;
    OSS_INT32  abortReason;
    OSSC::COssBitString  reflectedParameter;
    OSSC::COssOpen  userdataAB;
};

struct _seq8 {
    OSS_INT32  presentation_context_identifier;
    OSSC::COssEncOID  transfer_syntax_name;
};

struct _Presentation_context_identifier_list {
    struct _Presentation_context_identifier_list * next;
    _seq8  value;
};

struct _seq6 {
    OSS_UINT32 bit_mask;
    _Presentation_context_identifier_list * presentation_context_identifier_list;
    _User_data  user_data;
};

struct _ARU_PPDU {
    OSS_UINT32 choice;
    union {
	_set4 * x400_mode_parameters;
	_seq6 * normal_mode_parameters;
    } u;
};

struct _ARP_PPDU {
    OSS_UINT32 bit_mask;
    OSS_INT32  provider_reason;
    OSS_INT32  event_identifier;
};

struct _Abort_type {
    OSS_UINT32 choice;
    union {
	_ARU_PPDU * aru_ppdu;
	_ARP_PPDU * arp_ppdu;
    } u;
};

struct _Presentation_context_deletion_list {
    struct _Presentation_context_deletion_list * next;
    OSS_INT32  value;
};

struct _AC_PPDU {
    OSS_UINT32 bit_mask;
    _Context_list * presentation_context_addition_list;
    _Presentation_context_deletion_list * presentation_context_deletion_list;
    _User_data  user_data;
};

struct _ACA_PPDU {
    OSS_UINT32 bit_mask;
    _Result_list * presentation_context_addition_result_list;
    _Presentation_context_deletion_list * presentation_context_deletion_result_list;
    _User_data  user_data;
};

struct _Typed_data_type {
    OSS_UINT32 choice;
    union {
	_AC_PPDU * acPPDU;
	_ACA_PPDU * acaPPDU;
	_User_data * ttdPPDU;
    } u;
};

struct _Reliable_Transfer_APDU_RTSE_apdus {
    OSS_UINT32 choice;
    union {
	_set1 * rtorq_apdu;
	_set2 * rtoac_apdu;
	_set3 * rtorj_apdu;
	OSS_INT32  rttp_apdu;
	OSSC::COssString  rttr_apdu;
	_set4 * rtab_apdu;
    } u;
};

struct _choice3 {
    OSS_UINT32 choice;
    union {
	OSS_INT32  general;
	OSS_INT32  invoke;
	OSS_INT32  returnResult;
	OSS_INT32  returnError;
    } u;
};

struct _Reject {
    _InvokeId  invokeId;
    _choice3  problem;
};

struct _UnboundedDirectoryString {
    OSS_UINT32 choice;
    union {
	OSSC::COssString  teletexString;
	OSSC::COssString  printableString;
	OSSC::COssBMPString  bmpString;
	OSSC::COssUniversalString  universalString;
	OSSC::COssString  uTF8String;
    } u;
};
static long _edUnboundedDirectoryString(OssGlobal * _g, char ** _out_pos, long * _max_len, _UnboundedDirectoryString * _in_data);
static void _ep_UnboundedDirectoryString(OssGlobal * _g, _UnboundedDirectoryString * _in_data);
static void _d_UnboundedDirectoryString(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _UnboundedDirectoryString * _out_data);
static void _dp_UnboundedDirectoryString(OssGlobal * _g, _UnboundedDirectoryString * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_UnboundedDirectoryString(OssGlobal * _g, _UnboundedDirectoryString * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_UnboundedDirectoryString(OssGlobal * _g, _UnboundedDirectoryString * _data_ptr);
#endif

struct _UUIDPair {
    OSSC::COssString  issuerUUID;
    OSSC::COssString  subjectUUID;
};

struct _CriteriaItem {
    OSS_UINT32 choice;
    union {
	OSSC::COssEncOID  equality;
	OSSC::COssEncOID  substrings;
	OSSC::COssEncOID  greaterOrEqual;
	OSSC::COssEncOID  lessOrEqual;
	OSSC::COssEncOID  approximateMatch;
    } u;
};
struct _setof1;
struct _Criteria;

struct _Criteria {
    OSS_UINT32 choice;
    union {
	_CriteriaItem * type;
	_setof1 * Criteria_and;
	_setof1 * Criteria_or;
	_Criteria * Criteria_not;
    } u;
};

struct _setof1 {
    struct _setof1 * next;
    _Criteria  value;
};

struct _Guide {
    OSS_UINT32 bit_mask;
    OSSC::COssEncOID  objectClass;
    _Criteria  criteria;
};

struct _EnhancedGuide {
    OSS_UINT32 bit_mask;
    OSSC::COssEncOID  objectClass;
    _Criteria  criteria;
    OSS_INT32  subset;
};

struct _PostalAddress {
    struct _PostalAddress * next;
    _UnboundedDirectoryString  value;
};

struct _TelexNumber {
    OSSC::COssString  telexNumber;
    OSSC::COssString  countryCode;
    OSSC::COssString  answerback;
};

struct _setof3 {
    struct _setof3 * next;
    OSSC::COssString  value;
};

struct _PresentationAddress {
    OSS_UINT32 bit_mask;
    OSSC::COssString  pSelector;
    OSSC::COssString  sSelector;
    OSSC::COssString  tSelector;
    _setof3 * nAddresses;
};

struct _ProtocolInformation {
    OSSC::COssString  nAddress;
    _Application_context_name_list * profiles;
};

struct _NameAndOptionalUID {
    OSS_UINT32 bit_mask;
    _RDNSequence * dn;
    OSSC::COssBitString  uid;
};

struct _ContextAssertion {
    OSSC::COssEncOID  contextType;
    _setof11 * contextValues;
};

struct _setof6 {
    struct _setof6 * next;
    _ContextAssertion  value;
};

struct _choice4 {
    OSS_UINT32 choice;
    union {
	char  allContexts;
	_setof6 * selectedContexts;
    } u;
};

struct _AttributeValueAssertion {
    OSS_UINT32 bit_mask;
    OSSC::COssEncOID  type;
    OSSC::COssConstrainedOpenType  assertion;
    _choice4  assertedContexts;
};

struct _seqof2 {
    struct _seqof2 * next;
    _AttributeValueAssertion  value;
};

struct _MultipleMatchingLocalities {
    OSS_UINT32 bit_mask;
    OSSC::COssEncOID  matchingRuleUsed;
    _seqof2 * attributeList;
};

struct _setof13 {
    struct _setof13 * next;
    OSSC::COssConstrainedOpenType  value;
};

struct _seq12 {
    OSSC::COssConstrainedOpenType  value;
    _setof15 * contextList;
};

struct _setof14 {
    struct _setof14 * next;
    _seq12  value;
};

struct _Attribute {
    OSS_UINT32 bit_mask;
    OSSC::COssEncOID  type;
    _setof13 * values;
    _setof14 * valuesWithContext;
};

struct _choice5 {
    OSS_UINT32 choice;
    union {
	_UnboundedDirectoryString * initial;
	_UnboundedDirectoryString * any;
	_UnboundedDirectoryString * final;
	_Attribute * control;
    } u;
};

struct _SubstringAssertion {
    struct _SubstringAssertion * next;
    _choice5  value;
};

struct _choice6 {
    OSS_UINT32 choice;
    union {
	OSSC::COssString  initial;
	OSSC::COssString  any;
	OSSC::COssString  final;
    } u;
};

struct _OctetSubstringAssertion {
    struct _OctetSubstringAssertion * next;
    _choice6  value;
};

struct _seq10 {
    char *  startTime;
    char *  endTime;
};

struct _DayTimeBand {
    OSS_UINT32 bit_mask;
    _DayTime  startDayTime;
    _DayTime  endDayTime;
};

struct _setof8 {
    struct _setof8 * next;
    _DayTimeBand  value;
};

struct _NamedDay {
    OSS_UINT32 choice;
    union {
	enum _enum2  intNamedDays;
	OSSC::COssBitString  bitNamedDays;
    } u;
};

struct _XDayOf {
    OSS_UINT32 choice;
    union {
	_NamedDay * first;
	_NamedDay * second;
	_NamedDay * third;
	_NamedDay * fourth;
	_NamedDay * fifth;
    } u;
};

struct _choice7 {
    OSS_UINT32 choice;
    union {
	_Presentation_context_deletion_list * intDay;
	OSSC::COssBitString  bitDay;
	_XDayOf * dayOf;
    } u;
};

struct _choice8 {
    OSS_UINT32 choice;
    union {
	char  allWeeks;
	_Presentation_context_deletion_list * intWeek;
	OSSC::COssBitString  bitWeek;
    } u;
};

struct _choice9 {
    OSS_UINT32 choice;
    union {
	char  allMonths;
	_Presentation_context_deletion_list * intMonth;
	OSSC::COssBitString  bitMonth;
    } u;
};

struct _setof9 {
    struct _setof9 * next;
    OSS_UINT32  value;
};

struct _Period {
    OSS_UINT32 bit_mask;
    _setof8 * timesOfDay;
    _choice7  days;
    _choice8  weeks;
    _choice9  months;
    _setof9 * years;
};

struct _setof10 {
    struct _setof10 * next;
    _Period  value;
};

struct _choice10 {
    OSS_UINT32 choice;
    union {
	_seq10 * absolute;
	_setof10 * periodic;
    } u;
};

struct _TimeSpecification {
    OSS_UINT32 bit_mask;
    _choice10  time;
    ossBoolean  notThisTime;
    OSS_INT32  timeZone;
};

struct _seq11 {
    OSS_UINT32 bit_mask;
    char *  startTime;
    char *  endTime;
    ossBoolean  entirely;
};

struct _TimeAssertion {
    OSS_UINT32 choice;
    union {
	char  now;
	char *  at;
	_seq11 * between;
    } u;
};

struct _LocaleContextSyntax {
    OSS_UINT32 choice;
    union {
	OSSC::COssEncOID  localeID1;
	_UnboundedDirectoryString * localeID2;
    } u;
};
static long _edContextAssertion(OssGlobal * _g, char ** _out_pos, long * _max_len, _ContextAssertion * _in_data);
static void _ep_ContextAssertion(OssGlobal * _g, _ContextAssertion * _in_data);
static void _d_ContextAssertion(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _ContextAssertion * _out_data);
static void _dp_ContextAssertion(OssGlobal * _g, _ContextAssertion * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_ContextAssertion(OssGlobal * _g, _ContextAssertion * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_ContextAssertion(OssGlobal * _g, _ContextAssertion * _data_ptr);
#endif

struct _AttributeTypeAssertion {
    OSS_UINT32 bit_mask;
    OSSC::COssEncOID  type;
    _setof6 * assertedContexts;
};

struct _choice11 {
    OSS_UINT32 choice;
    union {
	_RDNSequence * chopBefore;
	_RDNSequence * chopAfter;
    } u;
};

struct _setof19 {
    struct _setof19 * next;
    _choice11  value;
};
struct _setof17;
struct _Refinement;

struct _Refinement {
    OSS_UINT32 choice;
    union {
	OSSC::COssEncOID  item;
	_setof17 * Refinement_and;
	_setof17 * Refinement_or;
	_Refinement * Refinement_not;
    } u;
};

struct _setof17 {
    struct _setof17 * next;
    _Refinement  value;
};

struct _SubtreeSpecification {
    OSS_UINT32 bit_mask;
    _RDNSequence * base;
    _setof19 * specificExclusions;
    OSS_UINT32  minimum;
    OSS_UINT32  maximum;
    _Refinement  specificationFilter;
};

struct _DITStructureRule {
    OSS_UINT32 bit_mask;
    OSS_INT32  ruleIdentifier;
    OSSC::COssEncOID  nameForm;
    _Presentation_context_deletion_list * superiorStructureRules;
};

struct _DITContentRule {
    OSS_UINT32 bit_mask;
    OSSC::COssEncOID  structuralObjectClass;
    _Application_context_name_list * auxiliaries;
    _Application_context_name_list * mandatory;
    _Application_context_name_list * optional;
    _Application_context_name_list * precluded;
};

struct _DITContextUse {
    OSS_UINT32 bit_mask;
    OSSC::COssEncOID  attributeType;
    _Application_context_name_list * mandatoryContexts;
    _Application_context_name_list * optionalContexts;
};

struct _RealizationParameter {
    OSS_UINT32 bit_mask;
    enum _enum1  realization_type;
    ossBoolean  concatenation;
};

struct _TYPE_IDENTIFIER {
    OSSC::COssEncOID id;
    unsigned short Type;
};

struct _ABSTRACT_SYNTAX {
    OSS_UINT32 bit_mask;
    OSSC::COssEncOID id;
    unsigned short Type;
    OSSC::COssBitString property;
};
static long _ed_choice1(OssGlobal * _g, char ** _out_pos, long * _max_len, _choice1 * _in_data);
static void _ep__choice1(OssGlobal * _g, _choice1 * _in_data);
static void _d__choice1(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _choice1 * _out_data);
static void _dp__choice1(OssGlobal * _g, _choice1 * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__choice1(OssGlobal * _g, _choice1 * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__choice1(OssGlobal * _g, _choice1 * _data_ptr);
#endif
static long _edExternal(OssGlobal * _g, char ** _out_pos, long * _max_len, _External * _in_data);
static void _ep_External(OssGlobal * _g, _External * _in_data);
static void _d_External(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _External * _out_data);
static void _dp_External(OssGlobal * _g, _External * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_External(OssGlobal * _g, _External * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_External(OssGlobal * _g, _External * _data_ptr);
#endif
static long _edName(OssGlobal * _g, char ** _out_pos, long * _max_len, _Name * _in_data);
static void _ep_Name(OssGlobal * _g, _Name * _in_data);
static void _d_Name(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Name * _out_data);
static void _dp_Name(OssGlobal * _g, _Name * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_Name(OssGlobal * _g, _Name * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_Name(OssGlobal * _g, _Name * _data_ptr);
#endif
static long _edAP_title(OssGlobal * _g, char ** _out_pos, long * _max_len, _AP_title * _in_data);
static void _ep_AP_title(OssGlobal * _g, _AP_title * _in_data);
static void _d_AP_title(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _AP_title * _out_data);
static void _dp_AP_title(OssGlobal * _g, _AP_title * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_AP_title(OssGlobal * _g, _AP_title * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_AP_title(OssGlobal * _g, _AP_title * _data_ptr);
#endif
static long _edAE_qualifier(OssGlobal * _g, char ** _out_pos, long * _max_len, _AE_qualifier * _in_data);
static void _ep_AE_qualifier(OssGlobal * _g, _AE_qualifier * _in_data);
static void _d_AE_qualifier(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _AE_qualifier * _out_data);
static void _dp_AE_qualifier(OssGlobal * _g, _AE_qualifier * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_AE_qualifier(OssGlobal * _g, _AE_qualifier * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_AE_qualifier(OssGlobal * _g, _AE_qualifier * _data_ptr);
#endif
static long _edRealizationParameter(OssGlobal * _g, char ** _out_pos, long * _max_len, _RealizationParameter * _in_data);
static void _ep_RealizationParameter(OssGlobal * _g, _RealizationParameter * _in_data);
static void _d_RealizationParameter(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _RealizationParameter * _out_data);
static void _dp_RealizationParameter(OssGlobal * _g, _RealizationParameter * _out_data);
#ifdef OSSPRINT
static void _p_RealizationParameter(OssGlobal * _g, _RealizationParameter * _data_ptr);
#endif
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__seq1(OssGlobal * _g, _seq1 * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__seq1(OssGlobal * _g, _seq1 * _data_ptr);
#endif
static long _edAuthentication_value(OssGlobal * _g, char ** _out_pos, long * _max_len, _Authentication_value * _in_data);
static void _ep_Authentication_value(OssGlobal * _g, _Authentication_value * _in_data);
static void _d_Authentication_value(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Authentication_value * _out_data);
static void _dp_Authentication_value(OssGlobal * _g, _Authentication_value * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_Authentication_value(OssGlobal * _g, _Authentication_value * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_Authentication_value(OssGlobal * _g, _Authentication_value * _data_ptr);
#endif
static long _ed13Application_context_name_l(OssGlobal * _g, char ** _out_pos, long * _max_len, _Application_context_name_list ** _in_data);
static void _ep_13Application_context_name_l(OssGlobal * _g, _Application_context_name_list ** _in_data);
static void _d_13Application_context_name_l(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Application_context_name_list ** _out_data);
static void _dp_13Application_context_name_l(OssGlobal * _g, _Application_context_name_list ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_13Application_context_name_l(OssGlobal * _g, _Application_context_name_list ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_13Application_context_name_l(OssGlobal * _g, _Application_context_name_list ** _data_ptr);
#endif
static long _edAssociation_information(OssGlobal * _g, char ** _out_pos, long * _max_len, _Association_information ** _in_data);
static void _ep_Association_information(OssGlobal * _g, _Association_information ** _in_data);
static void _d_Association_information(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Association_information ** _out_data);
static void _dp_Association_information(OssGlobal * _g, _Association_information ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_Association_information(OssGlobal * _g, _Association_information ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_Association_information(OssGlobal * _g, _Association_information ** _data_ptr);
#endif
static long _edMode_selector(OssGlobal * _g, char ** _out_pos, long * _max_len, _Mode_selector * _in_data);
static void _ep_Mode_selector(OssGlobal * _g, _Mode_selector * _in_data);
static void _d_Mode_selector(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Mode_selector * _out_data);
static void _dp_Mode_selector(OssGlobal * _g, _Mode_selector * _out_data);
#ifdef OSSPRINT
static void _p_Mode_selector(OssGlobal * _g, _Mode_selector * _data_ptr);
#endif
static long _edConnectionData(OssGlobal * _g, char ** _out_pos, long * _max_len, _ConnectionData * _in_data);
static void _ep_ConnectionData(OssGlobal * _g, _ConnectionData * _in_data);
static void _d_ConnectionData(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _ConnectionData * _out_data);
static void _dp_ConnectionData(OssGlobal * _g, _ConnectionData * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_ConnectionData(OssGlobal * _g, _ConnectionData * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_ConnectionData(OssGlobal * _g, _ConnectionData * _data_ptr);
#endif
static long _edUser_data(OssGlobal * _g, char ** _out_pos, long * _max_len, _User_data * _in_data);
static void _ep_User_data(OssGlobal * _g, _User_data * _in_data);
static void _d_User_data(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _User_data * _out_data);
static void _dp_User_data(OssGlobal * _g, _User_data * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_User_data(OssGlobal * _g, _User_data * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_User_data(OssGlobal * _g, _User_data * _data_ptr);
#endif
static long _ed_seq7(OssGlobal * _g, char ** _out_pos, long * _max_len, _seq7 * _in_data);
static void _ep__seq7(OssGlobal * _g, _seq7 * _in_data);
static void _d__seq7(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seq7 * _out_data);
static void _dp__seq7(OssGlobal * _g, _seq7 * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__seq7(OssGlobal * _g, _seq7 * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__seq7(OssGlobal * _g, _seq7 * _data_ptr);
#endif
static long _edContext_list(OssGlobal * _g, char ** _out_pos, long * _max_len, _Context_list ** _in_data);
static void _ep_Context_list(OssGlobal * _g, _Context_list ** _in_data);
static void _d_Context_list(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Context_list ** _out_data);
static void _dp_Context_list(OssGlobal * _g, _Context_list ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_Context_list(OssGlobal * _g, _Context_list ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_Context_list(OssGlobal * _g, _Context_list ** _data_ptr);
#endif
static long _ed_seq8(OssGlobal * _g, char ** _out_pos, long * _max_len, _seq8 * _in_data);
static void _ep__seq8(OssGlobal * _g, _seq8 * _in_data);
static void _d__seq8(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seq8 * _out_data);
static void _dp__seq8(OssGlobal * _g, _seq8 * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__seq8(OssGlobal * _g, _seq8 * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__seq8(OssGlobal * _g, _seq8 * _data_ptr);
#endif
static long _ed14Presentation_context_ident(OssGlobal * _g, char ** _out_pos, long * _max_len, _Presentation_context_identifier_list ** _in_data);
static void _ep_14Presentation_context_ident(OssGlobal * _g, _Presentation_context_identifier_list ** _in_data);
static void _d_14Presentation_context_ident(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Presentation_context_identifier_list ** _out_data);
static void _dp_14Presentation_context_ident(OssGlobal * _g, _Presentation_context_identifier_list ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_14Presentation_context_ident(OssGlobal * _g, _Presentation_context_identifier_list ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_14Presentation_context_ident(OssGlobal * _g, _Presentation_context_identifier_list ** _data_ptr);
#endif
static long _ed_seq9(OssGlobal * _g, char ** _out_pos, long * _max_len, _seq9 * _in_data);
static void _ep__seq9(OssGlobal * _g, _seq9 * _in_data);
static void _d__seq9(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seq9 * _out_data);
static void _dp__seq9(OssGlobal * _g, _seq9 * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__seq9(OssGlobal * _g, _seq9 * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__seq9(OssGlobal * _g, _seq9 * _data_ptr);
#endif
static long _edResult_list(OssGlobal * _g, char ** _out_pos, long * _max_len, _Result_list ** _in_data);
static void _ep_Result_list(OssGlobal * _g, _Result_list ** _in_data);
static void _d_Result_list(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Result_list ** _out_data);
static void _dp_Result_list(OssGlobal * _g, _Result_list ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_Result_list(OssGlobal * _g, _Result_list ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_Result_list(OssGlobal * _g, _Result_list ** _data_ptr);
#endif
static long _edPDV_list(OssGlobal * _g, char ** _out_pos, long * _max_len, _PDV_list * _in_data);
static void _ep_PDV_list(OssGlobal * _g, _PDV_list * _in_data);
static void _d_PDV_list(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _PDV_list * _out_data);
static void _dp_PDV_list(OssGlobal * _g, _PDV_list * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_PDV_list(OssGlobal * _g, _PDV_list * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_PDV_list(OssGlobal * _g, _PDV_list * _data_ptr);
#endif
static long _edFully_encoded_data(OssGlobal * _g, char ** _out_pos, long * _max_len, _Fully_encoded_data ** _in_data);
static void _ep_Fully_encoded_data(OssGlobal * _g, _Fully_encoded_data ** _in_data);
static void _d_Fully_encoded_data(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Fully_encoded_data ** _out_data);
static void _dp_Fully_encoded_data(OssGlobal * _g, _Fully_encoded_data ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_Fully_encoded_data(OssGlobal * _g, _Fully_encoded_data ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_Fully_encoded_data(OssGlobal * _g, _Fully_encoded_data ** _data_ptr);
#endif
static long _edRTORQapdu(OssGlobal * _g, char ** _out_pos, long * _max_len, _set1 * _in_data);
static void _ep_RTORQapdu(OssGlobal * _g, _set1 * _in_data);
static void _d_RTORQapdu(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _set1 * _out_data);
static void _dp_RTORQapdu(OssGlobal * _g, _set1 * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_RTORQapdu(OssGlobal * _g, _set1 * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_RTORQapdu(OssGlobal * _g, _set1 * _data_ptr);
#endif
static long _edRTOACapdu(OssGlobal * _g, char ** _out_pos, long * _max_len, _set2 * _in_data);
static void _ep_RTOACapdu(OssGlobal * _g, _set2 * _in_data);
static void _d_RTOACapdu(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _set2 * _out_data);
static void _dp_RTOACapdu(OssGlobal * _g, _set2 * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_RTOACapdu(OssGlobal * _g, _set2 * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_RTOACapdu(OssGlobal * _g, _set2 * _data_ptr);
#endif
static long _edRTORJapdu(OssGlobal * _g, char ** _out_pos, long * _max_len, _set3 * _in_data);
static void _ep_RTORJapdu(OssGlobal * _g, _set3 * _in_data);
static void _d_RTORJapdu(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _set3 * _out_data);
static void _dp_RTORJapdu(OssGlobal * _g, _set3 * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_RTORJapdu(OssGlobal * _g, _set3 * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_RTORJapdu(OssGlobal * _g, _set3 * _data_ptr);
#endif
static long _edCallingSSuserReference(OssGlobal * _g, char ** _out_pos, long * _max_len, _CallingSSuserReference * _in_data);
static void _ep_CallingSSuserReference(OssGlobal * _g, _CallingSSuserReference * _in_data);
static void _d_CallingSSuserReference(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _CallingSSuserReference * _out_data);
static void _dp_CallingSSuserReference(OssGlobal * _g, _CallingSSuserReference * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_CallingSSuserReference(OssGlobal * _g, _CallingSSuserReference * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_CallingSSuserReference(OssGlobal * _g, _CallingSSuserReference * _data_ptr);
#endif
static long _edSessionConnectionIdentifier(OssGlobal * _g, char ** _out_pos, long * _max_len, _SessionConnectionIdentifier * _in_data);
static void _ep_SessionConnectionIdentifier(OssGlobal * _g, _SessionConnectionIdentifier * _in_data);
static void _d_SessionConnectionIdentifier(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _SessionConnectionIdentifier * _out_data);
static void _dp_SessionConnectionIdentifier(OssGlobal * _g, _SessionConnectionIdentifier * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_SessionConnectionIdentifier(OssGlobal * _g, _SessionConnectionIdentifier * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_SessionConnectionIdentifier(OssGlobal * _g, _SessionConnectionIdentifier * _data_ptr);
#endif
static long _edInvokeId(OssGlobal * _g, char ** _out_pos, long * _max_len, _InvokeId * _in_data);
static void _ep_InvokeId(OssGlobal * _g, _InvokeId * _in_data);
static void _d_InvokeId(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _InvokeId * _out_data);
static void _dp_InvokeId(OssGlobal * _g, _InvokeId * _out_data);
#ifdef OSSPRINT
static void _p_InvokeId(OssGlobal * _g, _InvokeId * _data_ptr);
#endif

struct _OPERATION_PACKAGE {
    OSS_UINT32 bit_mask;
    struct ObjectSetEntry *Both;
    struct ObjectSetEntry *Consumer;
    struct ObjectSetEntry *Supplier;
    OSSC::COssEncOID id;
};

struct _CONNECTION_PACKAGE {
    OSS_UINT32 bit_mask;
    _OPERATION *bind;
    _OPERATION *unbind;
    ossBoolean responderCanUnbind;
    ossBoolean unbindCanFail;
    OSSC::COssEncOID id;
};

struct _CONTRACT {
    OSS_UINT32 bit_mask;
    _CONNECTION_PACKAGE *connection;
    struct ObjectSetEntry *OperationsOf;
    struct ObjectSetEntry *InitiatorConsumerOf;
    struct ObjectSetEntry *InitiatorSupplierOf;
    OSSC::COssEncOID id;
};
static long _edCriteria(OssGlobal * _g, char ** _out_pos, long * _max_len, _Criteria * _in_data);
static void _ep_Criteria(OssGlobal * _g, _Criteria * _in_data);
static void _d_Criteria(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Criteria * _out_data);
static void _dp_Criteria(OssGlobal * _g, _Criteria * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_Criteria(OssGlobal * _g, _Criteria * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_Criteria(OssGlobal * _g, _Criteria * _data_ptr);
#endif
static long _ed_setof2(OssGlobal * _g, char ** _out_pos, long * _max_len, _setof1 ** _in_data);
static void _ep__setof2(OssGlobal * _g, _setof1 ** _in_data);
static void _d__setof2(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _setof1 ** _out_data);
static void _dp__setof2(OssGlobal * _g, _setof1 ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__setof2(OssGlobal * _g, _setof1 ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__setof2(OssGlobal * _g, _setof1 ** _data_ptr);
#endif
static long _ed_setof1(OssGlobal * _g, char ** _out_pos, long * _max_len, _setof1 ** _in_data);
static void _ep__setof1(OssGlobal * _g, _setof1 ** _in_data);
static void _d__setof1(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _setof1 ** _out_data);
static void _dp__setof1(OssGlobal * _g, _setof1 ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__setof1(OssGlobal * _g, _setof1 ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__setof1(OssGlobal * _g, _setof1 ** _data_ptr);
#endif
static long _edCriteriaItem(OssGlobal * _g, char ** _out_pos, long * _max_len, _CriteriaItem * _in_data);
static void _ep_CriteriaItem(OssGlobal * _g, _CriteriaItem * _in_data);
static void _d_CriteriaItem(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _CriteriaItem * _out_data);
static void _dp_CriteriaItem(OssGlobal * _g, _CriteriaItem * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_CriteriaItem(OssGlobal * _g, _CriteriaItem * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_CriteriaItem(OssGlobal * _g, _CriteriaItem * _data_ptr);
#endif
static long _edDayTime(OssGlobal * _g, char ** _out_pos, long * _max_len, _DayTime * _in_data);
static void _ep_DayTime(OssGlobal * _g, _DayTime * _in_data);
static void _d_DayTime(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _DayTime * _out_data);
static void _dp_DayTime(OssGlobal * _g, _DayTime * _out_data);
#ifdef OSSPRINT
static void _p_DayTime(OssGlobal * _g, _DayTime * _data_ptr);
#endif
static long _ed_setof7(OssGlobal * _g, char ** _out_pos, long * _max_len, _Presentation_context_deletion_list ** _in_data);
static void _ep__setof7(OssGlobal * _g, _Presentation_context_deletion_list ** _in_data);
static void _d__setof7(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Presentation_context_deletion_list ** _out_data);
static void _dp__setof7(OssGlobal * _g, _Presentation_context_deletion_list ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__setof7(OssGlobal * _g, _Presentation_context_deletion_list ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__setof7(OssGlobal * _g, _Presentation_context_deletion_list ** _data_ptr);
#endif
static long _edNamedDay(OssGlobal * _g, char ** _out_pos, long * _max_len, _NamedDay * _in_data);
static void _ep_NamedDay(OssGlobal * _g, _NamedDay * _in_data);
static void _d_NamedDay(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _NamedDay * _out_data);
static void _dp_NamedDay(OssGlobal * _g, _NamedDay * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_NamedDay(OssGlobal * _g, _NamedDay * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_NamedDay(OssGlobal * _g, _NamedDay * _data_ptr);
#endif
static long _edContext(OssGlobal * _g, char ** _out_pos, long * _max_len, _Context * _in_data);
static void _ep_Context(OssGlobal * _g, _Context * _in_data);
static void _d_Context(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Context * _out_data);
static void _dp_Context(OssGlobal * _g, _Context * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_Context(OssGlobal * _g, _Context * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_Context(OssGlobal * _g, _Context * _data_ptr);
#endif
static long _edRDNSequence(OssGlobal * _g, char ** _out_pos, long * _max_len, _RDNSequence ** _in_data);
static void _ep_RDNSequence(OssGlobal * _g, _RDNSequence ** _in_data);
static void _d_RDNSequence(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _RDNSequence ** _out_data);
static void _dp_RDNSequence(OssGlobal * _g, _RDNSequence ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_RDNSequence(OssGlobal * _g, _RDNSequence ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_RDNSequence(OssGlobal * _g, _RDNSequence ** _data_ptr);
#endif
static long _ed15AttributeTypeAndDistinguis(OssGlobal * _g, char ** _out_pos, long * _max_len, _AttributeTypeAndDistinguishedValue * _in_data);
static void _ep_15AttributeTypeAndDistinguis(OssGlobal * _g, _AttributeTypeAndDistinguishedValue * _in_data);
static void _d_15AttributeTypeAndDistinguis(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _AttributeTypeAndDistinguishedValue * _out_data);
static void _dp_15AttributeTypeAndDistinguis(OssGlobal * _g, _AttributeTypeAndDistinguishedValue * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_15AttributeTypeAndDistinguis(OssGlobal * _g, _AttributeTypeAndDistinguishedValue * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_15AttributeTypeAndDistinguis(OssGlobal * _g, _AttributeTypeAndDistinguishedValue * _data_ptr);
#endif
static long _edRelativeDistinguishedName(OssGlobal * _g, char ** _out_pos, long * _max_len, _RelativeDistinguishedName ** _in_data);
static void _ep_RelativeDistinguishedName(OssGlobal * _g, _RelativeDistinguishedName ** _in_data);
static void _d_RelativeDistinguishedName(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _RelativeDistinguishedName ** _out_data);
static void _dp_RelativeDistinguishedName(OssGlobal * _g, _RelativeDistinguishedName ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_RelativeDistinguishedName(OssGlobal * _g, _RelativeDistinguishedName ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_RelativeDistinguishedName(OssGlobal * _g, _RelativeDistinguishedName ** _data_ptr);
#endif
static long _edRefinement(OssGlobal * _g, char ** _out_pos, long * _max_len, _Refinement * _in_data);
static void _ep_Refinement(OssGlobal * _g, _Refinement * _in_data);
static void _d_Refinement(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Refinement * _out_data);
static void _dp_Refinement(OssGlobal * _g, _Refinement * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_Refinement(OssGlobal * _g, _Refinement * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_Refinement(OssGlobal * _g, _Refinement * _data_ptr);
#endif
static long _ed_setof18(OssGlobal * _g, char ** _out_pos, long * _max_len, _setof17 ** _in_data);
static void _ep__setof18(OssGlobal * _g, _setof17 ** _in_data);
static void _d__setof18(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _setof17 ** _out_data);
static void _dp__setof18(OssGlobal * _g, _setof17 ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__setof18(OssGlobal * _g, _setof17 ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__setof18(OssGlobal * _g, _setof17 ** _data_ptr);
#endif
static long _ed_setof17(OssGlobal * _g, char ** _out_pos, long * _max_len, _setof17 ** _in_data);
static void _ep__setof17(OssGlobal * _g, _setof17 ** _in_data);
static void _d__setof17(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _setof17 ** _out_data);
static void _dp__setof17(OssGlobal * _g, _setof17 ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__setof17(OssGlobal * _g, _setof17 ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__setof17(OssGlobal * _g, _setof17 ** _data_ptr);
#endif
struct _OBJECT_CLASS;

struct _OBJECT_CLASS {
    OSS_UINT32 bit_mask;
    struct ObjectSetEntry *Superclasses;
    enum ObjectClassKind kind;
    struct ObjectSetEntry *MandatoryAttributes;
    struct ObjectSetEntry *OptionalAttributes;
    OSSC::COssEncOID id;
};

struct _NAME_FORM {
    _OBJECT_CLASS *namedObjectClass;
    struct ObjectSetEntry *MandatoryAttributes;
    struct ObjectSetEntry *OptionalAttributes;
    OSSC::COssEncOID id;
};

struct _CONTEXT {
    OSS_UINT32 bit_mask;
    unsigned short Type;
    OSSC::COssOpen defaultValue;
    unsigned short Assertion;
    ossBoolean absentMatch;
    OSSC::COssEncOID id;
};
static void _eOssEncOID(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epOssEncOID(OssGlobal * _g, void * _inbuf);
static void * _dOssEncOID(OssGlobal * _g);
static void * _dpOssEncOID(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fOssEncOID(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pOssEncOID(OssGlobal * _g, void * _data);
#endif
static void _eACSE_apdu(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epACSE_apdu(OssGlobal * _g, void * _inbuf);
static void * _dACSE_apdu(OssGlobal * _g);
static void * _dpACSE_apdu(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fACSE_apdu(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pACSE_apdu(OssGlobal * _g, void * _data);
#endif
static void _eAE_title(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epAE_title(OssGlobal * _g, void * _inbuf);
static void * _dAE_title(OssGlobal * _g);
static void * _dpAE_title(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAE_title(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAE_title(OssGlobal * _g, void * _data);
#endif
static void _eCP_type(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epCP_type(OssGlobal * _g, void * _inbuf);
static void * _dCP_type(OssGlobal * _g);
static void * _dpCP_type(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fCP_type(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pCP_type(OssGlobal * _g, void * _data);
#endif
static void _eCPC_type(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epCPC_type(OssGlobal * _g, void * _inbuf);
static void * _dCPC_type(OssGlobal * _g);
static void * _dpCPC_type(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fCPC_type(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pCPC_type(OssGlobal * _g, void * _data);
#endif
static void _eCPA_PPDU(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epCPA_PPDU(OssGlobal * _g, void * _inbuf);
static void * _dCPA_PPDU(OssGlobal * _g);
static void * _dpCPA_PPDU(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fCPA_PPDU(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pCPA_PPDU(OssGlobal * _g, void * _data);
#endif
static void _eCPR_PPDU(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epCPR_PPDU(OssGlobal * _g, void * _inbuf);
static void * _dCPR_PPDU(OssGlobal * _g);
static void * _dpCPR_PPDU(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fCPR_PPDU(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pCPR_PPDU(OssGlobal * _g, void * _data);
#endif
static void _eAbort_type(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epAbort_type(OssGlobal * _g, void * _inbuf);
static void * _dAbort_type(OssGlobal * _g);
static void * _dpAbort_type(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAbort_type(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAbort_type(OssGlobal * _g, void * _data);
#endif
static void _eTyped_data_type(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epTyped_data_type(OssGlobal * _g, void * _inbuf);
static void * _dTyped_data_type(OssGlobal * _g);
static void * _dpTyped_data_type(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fTyped_data_type(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pTyped_data_type(OssGlobal * _g, void * _data);
#endif
static void _eRS_PPDU(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epRS_PPDU(OssGlobal * _g, void * _inbuf);
static void * _dRS_PPDU(OssGlobal * _g);
static void * _dpRS_PPDU(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fRS_PPDU(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pRS_PPDU(OssGlobal * _g, void * _data);
#endif
static void _eRSA_PPDU(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epRSA_PPDU(OssGlobal * _g, void * _inbuf);
static void * _dRSA_PPDU(OssGlobal * _g);
static void * _dpRSA_PPDU(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fRSA_PPDU(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pRSA_PPDU(OssGlobal * _g, void * _data);
#endif
static void _e0Reliable_Transfer_APDU_RTSE(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep0Reliable_Transfer_APDU_RTSE(OssGlobal * _g, void * _inbuf);
static void * _d0Reliable_Transfer_APDU_RTSE(OssGlobal * _g);
static void * _dp0Reliable_Transfer_APDU_RTSE(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f0Reliable_Transfer_APDU_RTSE(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p0Reliable_Transfer_APDU_RTSE(OssGlobal * _g, void * _data);
#endif
static void _e1Remote_Operations_Abstract_(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep1Remote_Operations_Abstract_(OssGlobal * _g, void * _inbuf);
static void * _d1Remote_Operations_Abstract_(OssGlobal * _g);
static void * _dp1Remote_Operations_Abstract_(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f1Remote_Operations_Abstract_(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p1Remote_Operations_Abstract_(OssGlobal * _g, void * _data);
#endif
static void _eROSEInvokeIds(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epROSEInvokeIds(OssGlobal * _g, void * _inbuf);
static void * _dROSEInvokeIds(OssGlobal * _g);
static void * _dpROSEInvokeIds(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fROSEInvokeIds(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pROSEInvokeIds(OssGlobal * _g, void * _data);
#endif
static void _eReject(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epReject(OssGlobal * _g, void * _inbuf);
static void * _dReject(OssGlobal * _g);
static void * _dpReject(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fReject(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pReject(OssGlobal * _g, void * _data);
#endif
static void _eNoInvokeId(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epNoInvokeId(OssGlobal * _g, void * _inbuf);
static void * _dNoInvokeId(OssGlobal * _g);
static void * _dpNoInvokeId(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fNoInvokeId(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pNoInvokeId(OssGlobal * _g, void * _data);
#endif
static void _eUnboundedDirectoryString(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epUnboundedDirectoryString(OssGlobal * _g, void * _inbuf);
static void * _dUnboundedDirectoryString(OssGlobal * _g);
static void * _dpUnboundedDirectoryString(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fUnboundedDirectoryString(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pUnboundedDirectoryString(OssGlobal * _g, void * _data);
#endif
static void _eUniqueIdentifier(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epUniqueIdentifier(OssGlobal * _g, void * _inbuf);
static void * _dUniqueIdentifier(OssGlobal * _g);
static void * _dpUniqueIdentifier(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fUniqueIdentifier(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pUniqueIdentifier(OssGlobal * _g, void * _data);
#endif
static void _eUUIDPair(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epUUIDPair(OssGlobal * _g, void * _inbuf);
static void * _dUUIDPair(OssGlobal * _g);
static void * _dpUUIDPair(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fUUIDPair(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pUUIDPair(OssGlobal * _g, void * _data);
#endif
static void _eCountryName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epCountryName(OssGlobal * _g, void * _inbuf);
static void * _dCountryName(OssGlobal * _g);
static void * _dpCountryName(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fCountryName(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pCountryName(OssGlobal * _g, void * _data);
#endif
static void _eGuide(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epGuide(OssGlobal * _g, void * _inbuf);
static void * _dGuide(OssGlobal * _g);
static void * _dpGuide(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fGuide(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pGuide(OssGlobal * _g, void * _data);
#endif
static void _eEnhancedGuide(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epEnhancedGuide(OssGlobal * _g, void * _inbuf);
static void * _dEnhancedGuide(OssGlobal * _g);
static void * _dpEnhancedGuide(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fEnhancedGuide(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pEnhancedGuide(OssGlobal * _g, void * _data);
#endif
static void _ePostalAddress(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epPostalAddress(OssGlobal * _g, void * _inbuf);
static void * _dPostalAddress(OssGlobal * _g);
static void * _dpPostalAddress(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPostalAddress(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPostalAddress(OssGlobal * _g, void * _data);
#endif
static void _eTelephoneNumber(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epTelephoneNumber(OssGlobal * _g, void * _inbuf);
static void * _dTelephoneNumber(OssGlobal * _g);
static void * _dpTelephoneNumber(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fTelephoneNumber(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pTelephoneNumber(OssGlobal * _g, void * _data);
#endif
static void _eTelexNumber(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epTelexNumber(OssGlobal * _g, void * _inbuf);
static void * _dTelexNumber(OssGlobal * _g);
static void * _dpTelexNumber(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fTelexNumber(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pTelexNumber(OssGlobal * _g, void * _data);
#endif
static void _eX121Address(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epX121Address(OssGlobal * _g, void * _inbuf);
static void * _dX121Address(OssGlobal * _g);
static void * _dpX121Address(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fX121Address(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pX121Address(OssGlobal * _g, void * _data);
#endif
static void _eInternationalISDNNumber(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epInternationalISDNNumber(OssGlobal * _g, void * _inbuf);
static void * _dInternationalISDNNumber(OssGlobal * _g);
static void * _dpInternationalISDNNumber(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fInternationalISDNNumber(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pInternationalISDNNumber(OssGlobal * _g, void * _data);
#endif
static void _eDestinationIndicator(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epDestinationIndicator(OssGlobal * _g, void * _inbuf);
static void * _dDestinationIndicator(OssGlobal * _g);
static void * _dpDestinationIndicator(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fDestinationIndicator(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pDestinationIndicator(OssGlobal * _g, void * _data);
#endif
static void _eCommunicationsService(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epCommunicationsService(OssGlobal * _g, void * _inbuf);
static void * _dCommunicationsService(OssGlobal * _g);
static void * _dpCommunicationsService(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fCommunicationsService(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pCommunicationsService(OssGlobal * _g, void * _data);
#endif
static void _eCommunicationsNetwork(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epCommunicationsNetwork(OssGlobal * _g, void * _inbuf);
static void * _dCommunicationsNetwork(OssGlobal * _g);
static void * _dpCommunicationsNetwork(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fCommunicationsNetwork(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pCommunicationsNetwork(OssGlobal * _g, void * _data);
#endif
static void _ePreferredDeliveryMethod(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epPreferredDeliveryMethod(OssGlobal * _g, void * _inbuf);
static void * _dPreferredDeliveryMethod(OssGlobal * _g);
static void * _dpPreferredDeliveryMethod(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPreferredDeliveryMethod(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPreferredDeliveryMethod(OssGlobal * _g, void * _data);
#endif
static void _ePresentationAddress(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epPresentationAddress(OssGlobal * _g, void * _inbuf);
static void * _dPresentationAddress(OssGlobal * _g);
static void * _dpPresentationAddress(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPresentationAddress(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPresentationAddress(OssGlobal * _g, void * _data);
#endif
static void _eProtocolInformation(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epProtocolInformation(OssGlobal * _g, void * _inbuf);
static void * _dProtocolInformation(OssGlobal * _g);
static void * _dpProtocolInformation(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fProtocolInformation(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pProtocolInformation(OssGlobal * _g, void * _data);
#endif
static void _eNameAndOptionalUID(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epNameAndOptionalUID(OssGlobal * _g, void * _inbuf);
static void * _dNameAndOptionalUID(OssGlobal * _g);
static void * _dpNameAndOptionalUID(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fNameAndOptionalUID(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pNameAndOptionalUID(OssGlobal * _g, void * _data);
#endif
static void _eMultipleMatchingLocalities(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epMultipleMatchingLocalities(OssGlobal * _g, void * _inbuf);
static void * _dMultipleMatchingLocalities(OssGlobal * _g);
static void * _dpMultipleMatchingLocalities(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fMultipleMatchingLocalities(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pMultipleMatchingLocalities(OssGlobal * _g, void * _data);
#endif
static void _eSubstringAssertion(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epSubstringAssertion(OssGlobal * _g, void * _inbuf);
static void * _dSubstringAssertion(OssGlobal * _g);
static void * _dpSubstringAssertion(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fSubstringAssertion(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pSubstringAssertion(OssGlobal * _g, void * _data);
#endif
static void _eCaseIgnoreList(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epCaseIgnoreList(OssGlobal * _g, void * _inbuf);
static void * _dCaseIgnoreList(OssGlobal * _g);
static void * _dpCaseIgnoreList(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fCaseIgnoreList(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pCaseIgnoreList(OssGlobal * _g, void * _data);
#endif
static void _eOctetSubstringAssertion(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epOctetSubstringAssertion(OssGlobal * _g, void * _inbuf);
static void * _dOctetSubstringAssertion(OssGlobal * _g);
static void * _dpOctetSubstringAssertion(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fOctetSubstringAssertion(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pOctetSubstringAssertion(OssGlobal * _g, void * _data);
#endif
static void _eSequenceMatchType(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epSequenceMatchType(OssGlobal * _g, void * _inbuf);
static void * _dSequenceMatchType(OssGlobal * _g);
static void * _dpSequenceMatchType(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fSequenceMatchType(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pSequenceMatchType(OssGlobal * _g, void * _data);
#endif
static void _eWordMatchTypes(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epWordMatchTypes(OssGlobal * _g, void * _inbuf);
static void * _dWordMatchTypes(OssGlobal * _g);
static void * _dpWordMatchTypes(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fWordMatchTypes(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pWordMatchTypes(OssGlobal * _g, void * _data);
#endif
static void _eCharacterMatchTypes(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epCharacterMatchTypes(OssGlobal * _g, void * _inbuf);
static void * _dCharacterMatchTypes(OssGlobal * _g);
static void * _dpCharacterMatchTypes(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fCharacterMatchTypes(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pCharacterMatchTypes(OssGlobal * _g, void * _data);
#endif
static void _eLanguageContextSyntax(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epLanguageContextSyntax(OssGlobal * _g, void * _inbuf);
static void * _dLanguageContextSyntax(OssGlobal * _g);
static void * _dpLanguageContextSyntax(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fLanguageContextSyntax(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pLanguageContextSyntax(OssGlobal * _g, void * _data);
#endif
static void _eTimeSpecification(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epTimeSpecification(OssGlobal * _g, void * _inbuf);
static void * _dTimeSpecification(OssGlobal * _g);
static void * _dpTimeSpecification(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fTimeSpecification(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pTimeSpecification(OssGlobal * _g, void * _data);
#endif
static void _eTimeAssertion(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epTimeAssertion(OssGlobal * _g, void * _inbuf);
static void * _dTimeAssertion(OssGlobal * _g);
static void * _dpTimeAssertion(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fTimeAssertion(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pTimeAssertion(OssGlobal * _g, void * _data);
#endif
static void _eLocaleContextSyntax(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epLocaleContextSyntax(OssGlobal * _g, void * _inbuf);
static void * _dLocaleContextSyntax(OssGlobal * _g);
static void * _dpLocaleContextSyntax(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fLocaleContextSyntax(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pLocaleContextSyntax(OssGlobal * _g, void * _data);
#endif
static void _eAttributeOptionList(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epAttributeOptionList(OssGlobal * _g, void * _inbuf);
static void * _dAttributeOptionList(OssGlobal * _g);
static void * _dpAttributeOptionList(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAttributeOptionList(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAttributeOptionList(OssGlobal * _g, void * _data);
#endif
static void _eID(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epID(OssGlobal * _g, void * _inbuf);
static void * _dID(OssGlobal * _g);
static void * _dpID(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fID(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pID(OssGlobal * _g, void * _data);
#endif
static void _eAttributeValue(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epAttributeValue(OssGlobal * _g, void * _inbuf);
static void * _dAttributeValue(OssGlobal * _g);
static void * _dpAttributeValue(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAttributeValue(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAttributeValue(OssGlobal * _g, void * _data);
#endif
static void _eContextAssertion(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epContextAssertion(OssGlobal * _g, void * _inbuf);
static void * _dContextAssertion(OssGlobal * _g);
static void * _dpContextAssertion(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fContextAssertion(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pContextAssertion(OssGlobal * _g, void * _data);
#endif
static void _eAttributeTypeAssertion(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epAttributeTypeAssertion(OssGlobal * _g, void * _inbuf);
static void * _dAttributeTypeAssertion(OssGlobal * _g);
static void * _dpAttributeTypeAssertion(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAttributeTypeAssertion(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAttributeTypeAssertion(OssGlobal * _g, void * _data);
#endif
static void _eDistinguishedName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epDistinguishedName(OssGlobal * _g, void * _inbuf);
static void * _dDistinguishedName(OssGlobal * _g);
static void * _dpDistinguishedName(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fDistinguishedName(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pDistinguishedName(OssGlobal * _g, void * _data);
#endif
static void _eSubtreeSpecification(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epSubtreeSpecification(OssGlobal * _g, void * _inbuf);
static void * _dSubtreeSpecification(OssGlobal * _g);
static void * _dpSubtreeSpecification(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fSubtreeSpecification(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pSubtreeSpecification(OssGlobal * _g, void * _data);
#endif
static void _eDITStructureRule(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epDITStructureRule(OssGlobal * _g, void * _inbuf);
static void * _dDITStructureRule(OssGlobal * _g);
static void * _dpDITStructureRule(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fDITStructureRule(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pDITStructureRule(OssGlobal * _g, void * _data);
#endif
static void _eDITContentRule(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epDITContentRule(OssGlobal * _g, void * _inbuf);
static void * _dDITContentRule(OssGlobal * _g);
static void * _dpDITContentRule(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fDITContentRule(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pDITContentRule(OssGlobal * _g, void * _data);
#endif
static void _eDITContextUse(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epDITContextUse(OssGlobal * _g, void * _inbuf);
static void * _dDITContextUse(OssGlobal * _g);
static void * _dpDITContextUse(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fDITContextUse(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pDITContextUse(OssGlobal * _g, void * _data);
#endif
static void _eHierarchyLevel(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epHierarchyLevel(OssGlobal * _g, void * _inbuf);
static void * _dHierarchyLevel(OssGlobal * _g);
static void * _dpHierarchyLevel(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fHierarchyLevel(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pHierarchyLevel(OssGlobal * _g, void * _data);
#endif
static void _eHierarchyBelow(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epHierarchyBelow(OssGlobal * _g, void * _inbuf);
static void * _dHierarchyBelow(OssGlobal * _g);
static void * _dpHierarchyBelow(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fHierarchyBelow(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pHierarchyBelow(OssGlobal * _g, void * _data);
#endif
static void _eAcse_RealizationParameter(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epAcse_RealizationParameter(OssGlobal * _g, void * _inbuf);
static void * _dAcse_RealizationParameter(OssGlobal * _g);
static void * _dpAcse_RealizationParameter(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAcse_RealizationParameter(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAcse_RealizationParameter(OssGlobal * _g, void * _data);
#endif
static void _e2Acse_with_concatenation_Rea(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep2Acse_with_concatenation_Rea(OssGlobal * _g, void * _inbuf);
static void * _d2Acse_with_concatenation_Rea(OssGlobal * _g);
static void * _dp2Acse_with_concatenation_Rea(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f2Acse_with_concatenation_Rea(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p2Acse_with_concatenation_Rea(OssGlobal * _g, void * _data);
#endif
static void _e3Association_by_RTSE_Realiza(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep3Association_by_RTSE_Realiza(OssGlobal * _g, void * _inbuf);
static void * _d3Association_by_RTSE_Realiza(OssGlobal * _g);
static void * _dp3Association_by_RTSE_Realiza(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f3Association_by_RTSE_Realiza(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p3Association_by_RTSE_Realiza(OssGlobal * _g, void * _data);
#endif
static void _ePData_RealizationParameter(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epPData_RealizationParameter(OssGlobal * _g, void * _inbuf);
static void * _dPData_RealizationParameter(OssGlobal * _g);
static void * _dpPData_RealizationParameter(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPData_RealizationParameter(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPData_RealizationParameter(OssGlobal * _g, void * _data);
#endif
static void _e4PData_with_concatenation_Re(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep4PData_with_concatenation_Re(OssGlobal * _g, void * _inbuf);
static void * _d4PData_with_concatenation_Re(OssGlobal * _g);
static void * _dp4PData_with_concatenation_Re(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f4PData_with_concatenation_Re(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p4PData_with_concatenation_Re(OssGlobal * _g, void * _data);
#endif
static void _e5Transfer_by_RTSE_Realizatio(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep5Transfer_by_RTSE_Realizatio(OssGlobal * _g, void * _inbuf);
static void * _d5Transfer_by_RTSE_Realizatio(OssGlobal * _g);
static void * _dp5Transfer_by_RTSE_Realizatio(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f5Transfer_by_RTSE_Realizatio(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p5Transfer_by_RTSE_Realizatio(OssGlobal * _g, void * _data);
#endif
static void _eBitStringMatch_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epBitStringMatch_SYNTAX(OssGlobal * _g, void * _inbuf);
static void * _dBitStringMatch_SYNTAX(OssGlobal * _g);
static void * _dpBitStringMatch_SYNTAX(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fBitStringMatch_SYNTAX(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pBitStringMatch_SYNTAX(OssGlobal * _g, void * _data);
#endif
static void _eDnQualifier_WITH_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epDnQualifier_WITH_SYNTAX(OssGlobal * _g, void * _inbuf);
static void * _dDnQualifier_WITH_SYNTAX(OssGlobal * _g);
static void * _dpDnQualifier_WITH_SYNTAX(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fDnQualifier_WITH_SYNTAX(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pDnQualifier_WITH_SYNTAX(OssGlobal * _g, void * _data);
#endif
static void _eSerialNumber_WITH_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epSerialNumber_WITH_SYNTAX(OssGlobal * _g, void * _inbuf);
static void * _dSerialNumber_WITH_SYNTAX(OssGlobal * _g);
static void * _dpSerialNumber_WITH_SYNTAX(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fSerialNumber_WITH_SYNTAX(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pSerialNumber_WITH_SYNTAX(OssGlobal * _g, void * _data);
#endif
static void _eNumericStringMatch_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epNumericStringMatch_SYNTAX(OssGlobal * _g, void * _inbuf);
static void * _dNumericStringMatch_SYNTAX(OssGlobal * _g);
static void * _dpNumericStringMatch_SYNTAX(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fNumericStringMatch_SYNTAX(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pNumericStringMatch_SYNTAX(OssGlobal * _g, void * _data);
#endif
static void _e6ProtocolInformationMatch_SY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep6ProtocolInformationMatch_SY(OssGlobal * _g, void * _inbuf);
static void * _d6ProtocolInformationMatch_SY(OssGlobal * _g);
static void * _dp6ProtocolInformationMatch_SY(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f6ProtocolInformationMatch_SY(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p6ProtocolInformationMatch_SY(OssGlobal * _g, void * _data);
#endif
static void _eUiiInUrn_WITH_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epUiiInUrn_WITH_SYNTAX(OssGlobal * _g, void * _inbuf);
static void * _dUiiInUrn_WITH_SYNTAX(OssGlobal * _g);
static void * _dpUiiInUrn_WITH_SYNTAX(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fUiiInUrn_WITH_SYNTAX(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pUiiInUrn_WITH_SYNTAX(OssGlobal * _g, void * _data);
#endif
static void _e7NumericStringOrderingMatch_(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep7NumericStringOrderingMatch_(OssGlobal * _g, void * _inbuf);
static void * _d7NumericStringOrderingMatch_(OssGlobal * _g);
static void * _dp7NumericStringOrderingMatch_(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f7NumericStringOrderingMatch_(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p7NumericStringOrderingMatch_(OssGlobal * _g, void * _data);
#endif
static void _eBooleanMatch_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epBooleanMatch_SYNTAX(OssGlobal * _g, void * _inbuf);
static void * _dBooleanMatch_SYNTAX(OssGlobal * _g);
static void * _dpBooleanMatch_SYNTAX(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fBooleanMatch_SYNTAX(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pBooleanMatch_SYNTAX(OssGlobal * _g, void * _data);
#endif
static void _eIntegerMatch_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epIntegerMatch_SYNTAX(OssGlobal * _g, void * _inbuf);
static void * _dIntegerMatch_SYNTAX(OssGlobal * _g);
static void * _dpIntegerMatch_SYNTAX(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fIntegerMatch_SYNTAX(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pIntegerMatch_SYNTAX(OssGlobal * _g, void * _data);
#endif
static void _eIntegerOrderingMatch_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epIntegerOrderingMatch_SYNTAX(OssGlobal * _g, void * _inbuf);
static void * _dIntegerOrderingMatch_SYNTAX(OssGlobal * _g);
static void * _dpIntegerOrderingMatch_SYNTAX(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fIntegerOrderingMatch_SYNTAX(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pIntegerOrderingMatch_SYNTAX(OssGlobal * _g, void * _data);
#endif
static void _eOctetStringMatch_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epOctetStringMatch_SYNTAX(OssGlobal * _g, void * _inbuf);
static void * _dOctetStringMatch_SYNTAX(OssGlobal * _g);
static void * _dpOctetStringMatch_SYNTAX(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fOctetStringMatch_SYNTAX(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pOctetStringMatch_SYNTAX(OssGlobal * _g, void * _data);
#endif
static void _e8OctetStringOrderingMatch_SY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep8OctetStringOrderingMatch_SY(OssGlobal * _g, void * _inbuf);
static void * _d8OctetStringOrderingMatch_SY(OssGlobal * _g);
static void * _dp8OctetStringOrderingMatch_SY(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f8OctetStringOrderingMatch_SY(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p8OctetStringOrderingMatch_SY(OssGlobal * _g, void * _data);
#endif
static void _eUTCTimeMatch_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epUTCTimeMatch_SYNTAX(OssGlobal * _g, void * _inbuf);
static void * _dUTCTimeMatch_SYNTAX(OssGlobal * _g);
static void * _dpUTCTimeMatch_SYNTAX(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fUTCTimeMatch_SYNTAX(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pUTCTimeMatch_SYNTAX(OssGlobal * _g, void * _data);
#endif
static void _eUTCTimeOrderingMatch_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epUTCTimeOrderingMatch_SYNTAX(OssGlobal * _g, void * _inbuf);
static void * _dUTCTimeOrderingMatch_SYNTAX(OssGlobal * _g);
static void * _dpUTCTimeOrderingMatch_SYNTAX(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fUTCTimeOrderingMatch_SYNTAX(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pUTCTimeOrderingMatch_SYNTAX(OssGlobal * _g, void * _data);
#endif
static void _eGeneralizedTimeMatch_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epGeneralizedTimeMatch_SYNTAX(OssGlobal * _g, void * _inbuf);
static void * _dGeneralizedTimeMatch_SYNTAX(OssGlobal * _g);
static void * _dpGeneralizedTimeMatch_SYNTAX(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fGeneralizedTimeMatch_SYNTAX(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pGeneralizedTimeMatch_SYNTAX(OssGlobal * _g, void * _data);
#endif
static void _e9GeneralizedTimeOrderingMatc(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep9GeneralizedTimeOrderingMatc(OssGlobal * _g, void * _inbuf);
static void * _d9GeneralizedTimeOrderingMatc(OssGlobal * _g);
static void * _dp9GeneralizedTimeOrderingMatc(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f9GeneralizedTimeOrderingMatc(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p9GeneralizedTimeOrderingMatc(OssGlobal * _g, void * _data);
#endif
static void _e10IntegerFirstComponentMatch(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep10IntegerFirstComponentMatch(OssGlobal * _g, void * _inbuf);
static void * _d10IntegerFirstComponentMatch(OssGlobal * _g);
static void * _dp10IntegerFirstComponentMatch(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f10IntegerFirstComponentMatch(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p10IntegerFirstComponentMatch(OssGlobal * _g, void * _data);
#endif
static void _e11AdministrativeRole_WITH_SY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep11AdministrativeRole_WITH_SY(OssGlobal * _g, void * _inbuf);
static void * _d11AdministrativeRole_WITH_SY(OssGlobal * _g);
static void * _dp11AdministrativeRole_WITH_SY(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f11AdministrativeRole_WITH_SY(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p11AdministrativeRole_WITH_SY(OssGlobal * _g, void * _data);
#endif
static void _eCreateTimestamp_WITH_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epCreateTimestamp_WITH_SYNTAX(OssGlobal * _g, void * _inbuf);
static void * _dCreateTimestamp_WITH_SYNTAX(OssGlobal * _g);
static void * _dpCreateTimestamp_WITH_SYNTAX(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fCreateTimestamp_WITH_SYNTAX(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pCreateTimestamp_WITH_SYNTAX(OssGlobal * _g, void * _data);
#endif
static void _eModifyTimestamp_WITH_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epModifyTimestamp_WITH_SYNTAX(OssGlobal * _g, void * _inbuf);
static void * _dModifyTimestamp_WITH_SYNTAX(OssGlobal * _g);
static void * _dpModifyTimestamp_WITH_SYNTAX(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fModifyTimestamp_WITH_SYNTAX(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pModifyTimestamp_WITH_SYNTAX(OssGlobal * _g, void * _data);
#endif
static void _e12SubschemaTimestamp_WITH_SY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _ep12SubschemaTimestamp_WITH_SY(OssGlobal * _g, void * _inbuf);
static void * _d12SubschemaTimestamp_WITH_SY(OssGlobal * _g);
static void * _dp12SubschemaTimestamp_WITH_SY(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f12SubschemaTimestamp_WITH_SY(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _p12SubschemaTimestamp_WITH_SY(OssGlobal * _g, void * _data);
#endif
static void _eHasSubordinates_WITH_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epHasSubordinates_WITH_SYNTAX(OssGlobal * _g, void * _inbuf);
static void * _dHasSubordinates_WITH_SYNTAX(OssGlobal * _g);
static void * _dpHasSubordinates_WITH_SYNTAX(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fHasSubordinates_WITH_SYNTAX(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pHasSubordinates_WITH_SYNTAX(OssGlobal * _g, void * _data);
#endif
void DLL_ENTRY _emUpperBounds_(struct ossGlobal * _g, int _pdunum, void * _inbuf);
void DLL_ENTRY _peUpperBounds_(struct ossGlobal * _g, int _pdunum, void * _inbuf);
void DLL_ENTRY _dmUpperBounds_(struct ossGlobal * _g, int * _pdunum, void ** _outbuf);
void DLL_ENTRY _pdUpperBounds_(struct ossGlobal * _g, int * _pdunum, void ** _outbuf);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
int DLL_ENTRY _fmUpperBounds_(struct ossGlobal * _g, int _pdunum, void * _data);
#endif
#ifdef OSSPRINT
int DLL_ENTRY _pmUpperBounds_(struct ossGlobal * _g, int _pdunum, void * _data);
#endif



#ifdef OSS_COPY_VALUE
static _UnboundedDirectoryString  * _cpUnboundedDirectoryString(OssGlobal * _g, _UnboundedDirectoryString  * psVal, _UnboundedDirectoryString  * pdVal);
static _ContextAssertion  * _cpContextAssertion(OssGlobal * _g, _ContextAssertion  * psVal, _ContextAssertion  * pdVal);
static _choice1  * _cp_choice1(OssGlobal * _g, _choice1  * psVal, _choice1  * pdVal);
static _External  * _cpExternal(OssGlobal * _g, _External  * psVal, _External  * pdVal);
static _Name  * _cpName(OssGlobal * _g, _Name  * psVal, _Name  * pdVal);
static _AP_title  * _cpAP_title(OssGlobal * _g, _AP_title  * psVal, _AP_title  * pdVal);
static _AE_qualifier  * _cpAE_qualifier(OssGlobal * _g, _AE_qualifier  * psVal, _AE_qualifier  * pdVal);
static _seq1 * * _cp_seq1(OssGlobal * _g, _seq1 * * psVal, _seq1 * * pdVal);
static _Authentication_value  * _cpAuthentication_value(OssGlobal * _g, _Authentication_value  * psVal, _Authentication_value  * pdVal);
static _Application_context_name_list * * _cp13Application_context_name_l(OssGlobal * _g, _Application_context_name_list * * psVal, _Application_context_name_list * * pdVal);
static _Association_information * * _cpAssociation_information(OssGlobal * _g, _Association_information * * psVal, _Association_information * * pdVal);
static _ConnectionData  * _cpConnectionData(OssGlobal * _g, _ConnectionData  * psVal, _ConnectionData  * pdVal);
static _User_data  * _cpUser_data(OssGlobal * _g, _User_data  * psVal, _User_data  * pdVal);
static _seq7  * _cp_seq7(OssGlobal * _g, _seq7  * psVal, _seq7  * pdVal);
static _Context_list * * _cpContext_list(OssGlobal * _g, _Context_list * * psVal, _Context_list * * pdVal);
static _seq8  * _cp_seq8(OssGlobal * _g, _seq8  * psVal, _seq8  * pdVal);
static _Presentation_context_identifier_list * * _cp14Presentation_context_ident(OssGlobal * _g, _Presentation_context_identifier_list * * psVal, _Presentation_context_identifier_list * * pdVal);
static _seq9  * _cp_seq9(OssGlobal * _g, _seq9  * psVal, _seq9  * pdVal);
static _Result_list * * _cpResult_list(OssGlobal * _g, _Result_list * * psVal, _Result_list * * pdVal);
static _PDV_list  * _cpPDV_list(OssGlobal * _g, _PDV_list  * psVal, _PDV_list  * pdVal);
static _Fully_encoded_data * * _cpFully_encoded_data(OssGlobal * _g, _Fully_encoded_data * * psVal, _Fully_encoded_data * * pdVal);
static _set1  * _cpRTORQapdu(OssGlobal * _g, _set1  * psVal, _set1  * pdVal);
static _set2  * _cpRTOACapdu(OssGlobal * _g, _set2  * psVal, _set2  * pdVal);
static _set3  * _cpRTORJapdu(OssGlobal * _g, _set3  * psVal, _set3  * pdVal);
static _CallingSSuserReference  * _cpCallingSSuserReference(OssGlobal * _g, _CallingSSuserReference  * psVal, _CallingSSuserReference  * pdVal);
static _SessionConnectionIdentifier  * _cpSessionConnectionIdentifier(OssGlobal * _g, _SessionConnectionIdentifier  * psVal, _SessionConnectionIdentifier  * pdVal);
static _Criteria  * _cpCriteria(OssGlobal * _g, _Criteria  * psVal, _Criteria  * pdVal);
static _setof1 * * _cp_setof2(OssGlobal * _g, _setof1 * * psVal, _setof1 * * pdVal);
static _setof1 * * _cp_setof1(OssGlobal * _g, _setof1 * * psVal, _setof1 * * pdVal);
static _CriteriaItem  * _cpCriteriaItem(OssGlobal * _g, _CriteriaItem  * psVal, _CriteriaItem  * pdVal);
static _NamedDay  * _cpNamedDay(OssGlobal * _g, _NamedDay  * psVal, _NamedDay  * pdVal);
static _Context  * _cpContext(OssGlobal * _g, _Context  * psVal, _Context  * pdVal);
static _RDNSequence * * _cpRDNSequence(OssGlobal * _g, _RDNSequence * * psVal, _RDNSequence * * pdVal);
static _AttributeTypeAndDistinguishedValue  * _cp15AttributeTypeAndDistinguis(OssGlobal * _g, _AttributeTypeAndDistinguishedValue  * psVal, _AttributeTypeAndDistinguishedValue  * pdVal);
static _RelativeDistinguishedName * * _cpRelativeDistinguishedName(OssGlobal * _g, _RelativeDistinguishedName * * psVal, _RelativeDistinguishedName * * pdVal);
static _Refinement  * _cpRefinement(OssGlobal * _g, _Refinement  * psVal, _Refinement  * pdVal);
static _setof17 * * _cp_setof18(OssGlobal * _g, _setof17 * * psVal, _setof17 * * pdVal);
static _setof17 * * _cp_setof17(OssGlobal * _g, _setof17 * * psVal, _setof17 * * pdVal);
#endif /* OSS_COPY_VALUE */

#ifdef OSS_COMPARE_VALUE
static int _cmUnboundedDirectoryString(OssGlobal * _g, _UnboundedDirectoryString  * _odata, _UnboundedDirectoryString  * _cdata);
static int _cmContextAssertion(OssGlobal * _g, _ContextAssertion  * _odata, _ContextAssertion  * _cdata);
static int _cm_choice1(OssGlobal * _g, _choice1  * _odata, _choice1  * _cdata);
static int _cmExternal(OssGlobal * _g, _External  * _odata, _External  * _cdata);
static int _cmName(OssGlobal * _g, _Name  * _odata, _Name  * _cdata);
static int _cmAP_title(OssGlobal * _g, _AP_title  * _odata, _AP_title  * _cdata);
static int _cmAE_qualifier(OssGlobal * _g, _AE_qualifier  * _odata, _AE_qualifier  * _cdata);
static int _cmRealizationParameter(OssGlobal * _g, _RealizationParameter  * _odata, _RealizationParameter  * _cdata);
static int _cm_seq1(OssGlobal * _g, _seq1 * * _odata, _seq1 * * _cdata);
static int _cmAuthentication_value(OssGlobal * _g, _Authentication_value  * _odata, _Authentication_value  * _cdata);
static int _cm13Application_context_name_l(OssGlobal * _g, _Application_context_name_list * * _odata, _Application_context_name_list * * _cdata);
static int _cmAssociation_information(OssGlobal * _g, _Association_information * * _odata, _Association_information * * _cdata);
static int _cmMode_selector(OssGlobal * _g, _Mode_selector  * _odata, _Mode_selector  * _cdata);
static int _cmConnectionData(OssGlobal * _g, _ConnectionData  * _odata, _ConnectionData  * _cdata);
static int _cmUser_data(OssGlobal * _g, _User_data  * _odata, _User_data  * _cdata);
static int _cm_seq7(OssGlobal * _g, _seq7  * _odata, _seq7  * _cdata);
static int _cmContext_list(OssGlobal * _g, _Context_list * * _odata, _Context_list * * _cdata);
static int _cm_seq8(OssGlobal * _g, _seq8  * _odata, _seq8  * _cdata);
static int _cm14Presentation_context_ident(OssGlobal * _g, _Presentation_context_identifier_list * * _odata, _Presentation_context_identifier_list * * _cdata);
static int _cm_seq9(OssGlobal * _g, _seq9  * _odata, _seq9  * _cdata);
static int _cmResult_list(OssGlobal * _g, _Result_list * * _odata, _Result_list * * _cdata);
static int _cmPDV_list(OssGlobal * _g, _PDV_list  * _odata, _PDV_list  * _cdata);
static int _cmFully_encoded_data(OssGlobal * _g, _Fully_encoded_data * * _odata, _Fully_encoded_data * * _cdata);
static int _cmRTORQapdu(OssGlobal * _g, _set1  * _odata, _set1  * _cdata);
static int _cmRTOACapdu(OssGlobal * _g, _set2  * _odata, _set2  * _cdata);
static int _cmRTORJapdu(OssGlobal * _g, _set3  * _odata, _set3  * _cdata);
static int _cmCallingSSuserReference(OssGlobal * _g, _CallingSSuserReference  * _odata, _CallingSSuserReference  * _cdata);
static int _cmSessionConnectionIdentifier(OssGlobal * _g, _SessionConnectionIdentifier  * _odata, _SessionConnectionIdentifier  * _cdata);
static int _cmInvokeId(OssGlobal * _g, _InvokeId  * _odata, _InvokeId  * _cdata);
static int _cmCriteria(OssGlobal * _g, _Criteria  * _odata, _Criteria  * _cdata);
static int _cm_setof2(OssGlobal * _g, _setof1 * * _odata, _setof1 * * _cdata);
static int _cm_setof1(OssGlobal * _g, _setof1 * * _odata, _setof1 * * _cdata);
static int _cmCriteriaItem(OssGlobal * _g, _CriteriaItem  * _odata, _CriteriaItem  * _cdata);
static int _cm_setof7(OssGlobal * _g, _Presentation_context_deletion_list * * _odata, _Presentation_context_deletion_list * * _cdata);
static int _cmNamedDay(OssGlobal * _g, _NamedDay  * _odata, _NamedDay  * _cdata);
static int _cmRefinement(OssGlobal * _g, _Refinement  * _odata, _Refinement  * _cdata);
static int _cm_setof18(OssGlobal * _g, _setof17 * * _odata, _setof17 * * _cdata);
static int _cm_setof17(OssGlobal * _g, _setof17 * * _odata, _setof17 * * _cdata);
#endif /* OSS_COMPARE_VALUE */

static void (*_Encoders[85])(OssGlobal *, void *, char **, long *, unsigned int) = {
    _eOssEncOID,
    _eACSE_apdu,
    _eAE_title,
    _eCP_type,
    _eCPC_type,
    _eCPA_PPDU,
    _eCPR_PPDU,
    _eAbort_type,
    _eTyped_data_type,
    _eRS_PPDU,
    _eRSA_PPDU,
    _e0Reliable_Transfer_APDU_RTSE,
    _e1Remote_Operations_Abstract_,
    _eROSEInvokeIds,
    _eReject,
    _eNoInvokeId,
    _eUnboundedDirectoryString,
    _eUniqueIdentifier,
    _eUUIDPair,
    _eCountryName,
    _eGuide,
    _eEnhancedGuide,
    _ePostalAddress,
    _eTelephoneNumber,
    _eTelexNumber,
    _eX121Address,
    _eInternationalISDNNumber,
    _eDestinationIndicator,
    _eCommunicationsService,
    _eCommunicationsNetwork,
    _ePreferredDeliveryMethod,
    _ePresentationAddress,
    _eProtocolInformation,
    _eNameAndOptionalUID,
    _eMultipleMatchingLocalities,
    _eSubstringAssertion,
    _eCaseIgnoreList,
    _eOctetSubstringAssertion,
    _eSequenceMatchType,
    _eWordMatchTypes,
    _eCharacterMatchTypes,
    _eLanguageContextSyntax,
    _eTimeSpecification,
    _eTimeAssertion,
    _eLocaleContextSyntax,
    _eAttributeOptionList,
    _eID,
    _eAttributeValue,
    _eContextAssertion,
    _eAttributeTypeAssertion,
    _eDistinguishedName,
    _eSubtreeSpecification,
    _eDITStructureRule,
    _eDITContentRule,
    _eDITContextUse,
    _eHierarchyLevel,
    _eHierarchyBelow,
    _eAcse_RealizationParameter,
    _e2Acse_with_concatenation_Rea,
    _e3Association_by_RTSE_Realiza,
    _ePData_RealizationParameter,
    _e4PData_with_concatenation_Re,
    _e5Transfer_by_RTSE_Realizatio,
    _eBitStringMatch_SYNTAX,
    _eDnQualifier_WITH_SYNTAX,
    _eSerialNumber_WITH_SYNTAX,
    _eNumericStringMatch_SYNTAX,
    _e6ProtocolInformationMatch_SY,
    _eUiiInUrn_WITH_SYNTAX,
    _e7NumericStringOrderingMatch_,
    _eBooleanMatch_SYNTAX,
    _eIntegerMatch_SYNTAX,
    _eIntegerOrderingMatch_SYNTAX,
    _eOctetStringMatch_SYNTAX,
    _e8OctetStringOrderingMatch_SY,
    _eUTCTimeMatch_SYNTAX,
    _eUTCTimeOrderingMatch_SYNTAX,
    _eGeneralizedTimeMatch_SYNTAX,
    _e9GeneralizedTimeOrderingMatc,
    _e10IntegerFirstComponentMatch,
    _e11AdministrativeRole_WITH_SY,
    _eCreateTimestamp_WITH_SYNTAX,
    _eModifyTimestamp_WITH_SYNTAX,
    _e12SubschemaTimestamp_WITH_SY,
    _eHasSubordinates_WITH_SYNTAX
};
static void (*_pEncoders[85])(OssGlobal *, void *) = {
    _epOssEncOID,
    _epACSE_apdu,
    _epAE_title,
    _epCP_type,
    _epCPC_type,
    _epCPA_PPDU,
    _epCPR_PPDU,
    _epAbort_type,
    _epTyped_data_type,
    _epRS_PPDU,
    _epRSA_PPDU,
    _ep0Reliable_Transfer_APDU_RTSE,
    _ep1Remote_Operations_Abstract_,
    _epROSEInvokeIds,
    _epReject,
    _epNoInvokeId,
    _epUnboundedDirectoryString,
    _epUniqueIdentifier,
    _epUUIDPair,
    _epCountryName,
    _epGuide,
    _epEnhancedGuide,
    _epPostalAddress,
    _epTelephoneNumber,
    _epTelexNumber,
    _epX121Address,
    _epInternationalISDNNumber,
    _epDestinationIndicator,
    _epCommunicationsService,
    _epCommunicationsNetwork,
    _epPreferredDeliveryMethod,
    _epPresentationAddress,
    _epProtocolInformation,
    _epNameAndOptionalUID,
    _epMultipleMatchingLocalities,
    _epSubstringAssertion,
    _epCaseIgnoreList,
    _epOctetSubstringAssertion,
    _epSequenceMatchType,
    _epWordMatchTypes,
    _epCharacterMatchTypes,
    _epLanguageContextSyntax,
    _epTimeSpecification,
    _epTimeAssertion,
    _epLocaleContextSyntax,
    _epAttributeOptionList,
    _epID,
    _epAttributeValue,
    _epContextAssertion,
    _epAttributeTypeAssertion,
    _epDistinguishedName,
    _epSubtreeSpecification,
    _epDITStructureRule,
    _epDITContentRule,
    _epDITContextUse,
    _epHierarchyLevel,
    _epHierarchyBelow,
    _epAcse_RealizationParameter,
    _ep2Acse_with_concatenation_Rea,
    _ep3Association_by_RTSE_Realiza,
    _epPData_RealizationParameter,
    _ep4PData_with_concatenation_Re,
    _ep5Transfer_by_RTSE_Realizatio,
    _epBitStringMatch_SYNTAX,
    _epDnQualifier_WITH_SYNTAX,
    _epSerialNumber_WITH_SYNTAX,
    _epNumericStringMatch_SYNTAX,
    _ep6ProtocolInformationMatch_SY,
    _epUiiInUrn_WITH_SYNTAX,
    _ep7NumericStringOrderingMatch_,
    _epBooleanMatch_SYNTAX,
    _epIntegerMatch_SYNTAX,
    _epIntegerOrderingMatch_SYNTAX,
    _epOctetStringMatch_SYNTAX,
    _ep8OctetStringOrderingMatch_SY,
    _epUTCTimeMatch_SYNTAX,
    _epUTCTimeOrderingMatch_SYNTAX,
    _epGeneralizedTimeMatch_SYNTAX,
    _ep9GeneralizedTimeOrderingMatc,
    _ep10IntegerFirstComponentMatch,
    _ep11AdministrativeRole_WITH_SY,
    _epCreateTimestamp_WITH_SYNTAX,
    _epModifyTimestamp_WITH_SYNTAX,
    _ep12SubschemaTimestamp_WITH_SY,
    _epHasSubordinates_WITH_SYNTAX
};
static void *(*_Decoders[85])(OssGlobal *) = {
    _dOssEncOID,
    _dACSE_apdu,
    _dAE_title,
    _dCP_type,
    _dCPC_type,
    _dCPA_PPDU,
    _dCPR_PPDU,
    _dAbort_type,
    _dTyped_data_type,
    _dRS_PPDU,
    _dRSA_PPDU,
    _d0Reliable_Transfer_APDU_RTSE,
    _d1Remote_Operations_Abstract_,
    _dROSEInvokeIds,
    _dReject,
    _dNoInvokeId,
    _dUnboundedDirectoryString,
    _dUniqueIdentifier,
    _dUUIDPair,
    _dCountryName,
    _dGuide,
    _dEnhancedGuide,
    _dPostalAddress,
    _dTelephoneNumber,
    _dTelexNumber,
    _dX121Address,
    _dInternationalISDNNumber,
    _dDestinationIndicator,
    _dCommunicationsService,
    _dCommunicationsNetwork,
    _dPreferredDeliveryMethod,
    _dPresentationAddress,
    _dProtocolInformation,
    _dNameAndOptionalUID,
    _dMultipleMatchingLocalities,
    _dSubstringAssertion,
    _dCaseIgnoreList,
    _dOctetSubstringAssertion,
    _dSequenceMatchType,
    _dWordMatchTypes,
    _dCharacterMatchTypes,
    _dLanguageContextSyntax,
    _dTimeSpecification,
    _dTimeAssertion,
    _dLocaleContextSyntax,
    _dAttributeOptionList,
    _dID,
    _dAttributeValue,
    _dContextAssertion,
    _dAttributeTypeAssertion,
    _dDistinguishedName,
    _dSubtreeSpecification,
    _dDITStructureRule,
    _dDITContentRule,
    _dDITContextUse,
    _dHierarchyLevel,
    _dHierarchyBelow,
    _dAcse_RealizationParameter,
    _d2Acse_with_concatenation_Rea,
    _d3Association_by_RTSE_Realiza,
    _dPData_RealizationParameter,
    _d4PData_with_concatenation_Re,
    _d5Transfer_by_RTSE_Realizatio,
    _dBitStringMatch_SYNTAX,
    _dDnQualifier_WITH_SYNTAX,
    _dSerialNumber_WITH_SYNTAX,
    _dNumericStringMatch_SYNTAX,
    _d6ProtocolInformationMatch_SY,
    _dUiiInUrn_WITH_SYNTAX,
    _d7NumericStringOrderingMatch_,
    _dBooleanMatch_SYNTAX,
    _dIntegerMatch_SYNTAX,
    _dIntegerOrderingMatch_SYNTAX,
    _dOctetStringMatch_SYNTAX,
    _d8OctetStringOrderingMatch_SY,
    _dUTCTimeMatch_SYNTAX,
    _dUTCTimeOrderingMatch_SYNTAX,
    _dGeneralizedTimeMatch_SYNTAX,
    _d9GeneralizedTimeOrderingMatc,
    _d10IntegerFirstComponentMatch,
    _d11AdministrativeRole_WITH_SY,
    _dCreateTimestamp_WITH_SYNTAX,
    _dModifyTimestamp_WITH_SYNTAX,
    _d12SubschemaTimestamp_WITH_SY,
    _dHasSubordinates_WITH_SYNTAX
};
static void *(*_pDecoders[85])(OssGlobal *) = {
    _dpOssEncOID,
    _dpACSE_apdu,
    _dpAE_title,
    _dpCP_type,
    _dpCPC_type,
    _dpCPA_PPDU,
    _dpCPR_PPDU,
    _dpAbort_type,
    _dpTyped_data_type,
    _dpRS_PPDU,
    _dpRSA_PPDU,
    _dp0Reliable_Transfer_APDU_RTSE,
    _dp1Remote_Operations_Abstract_,
    _dpROSEInvokeIds,
    _dpReject,
    _dpNoInvokeId,
    _dpUnboundedDirectoryString,
    _dpUniqueIdentifier,
    _dpUUIDPair,
    _dpCountryName,
    _dpGuide,
    _dpEnhancedGuide,
    _dpPostalAddress,
    _dpTelephoneNumber,
    _dpTelexNumber,
    _dpX121Address,
    _dpInternationalISDNNumber,
    _dpDestinationIndicator,
    _dpCommunicationsService,
    _dpCommunicationsNetwork,
    _dpPreferredDeliveryMethod,
    _dpPresentationAddress,
    _dpProtocolInformation,
    _dpNameAndOptionalUID,
    _dpMultipleMatchingLocalities,
    _dpSubstringAssertion,
    _dpCaseIgnoreList,
    _dpOctetSubstringAssertion,
    _dpSequenceMatchType,
    _dpWordMatchTypes,
    _dpCharacterMatchTypes,
    _dpLanguageContextSyntax,
    _dpTimeSpecification,
    _dpTimeAssertion,
    _dpLocaleContextSyntax,
    _dpAttributeOptionList,
    _dpID,
    _dpAttributeValue,
    _dpContextAssertion,
    _dpAttributeTypeAssertion,
    _dpDistinguishedName,
    _dpSubtreeSpecification,
    _dpDITStructureRule,
    _dpDITContentRule,
    _dpDITContextUse,
    _dpHierarchyLevel,
    _dpHierarchyBelow,
    _dpAcse_RealizationParameter,
    _dp2Acse_with_concatenation_Rea,
    _dp3Association_by_RTSE_Realiza,
    _dpPData_RealizationParameter,
    _dp4PData_with_concatenation_Re,
    _dp5Transfer_by_RTSE_Realizatio,
    _dpBitStringMatch_SYNTAX,
    _dpDnQualifier_WITH_SYNTAX,
    _dpSerialNumber_WITH_SYNTAX,
    _dpNumericStringMatch_SYNTAX,
    _dp6ProtocolInformationMatch_SY,
    _dpUiiInUrn_WITH_SYNTAX,
    _dp7NumericStringOrderingMatch_,
    _dpBooleanMatch_SYNTAX,
    _dpIntegerMatch_SYNTAX,
    _dpIntegerOrderingMatch_SYNTAX,
    _dpOctetStringMatch_SYNTAX,
    _dp8OctetStringOrderingMatch_SY,
    _dpUTCTimeMatch_SYNTAX,
    _dpUTCTimeOrderingMatch_SYNTAX,
    _dpGeneralizedTimeMatch_SYNTAX,
    _dp9GeneralizedTimeOrderingMatc,
    _dp10IntegerFirstComponentMatch,
    _dp11AdministrativeRole_WITH_SY,
    _dpCreateTimestamp_WITH_SYNTAX,
    _dpModifyTimestamp_WITH_SYNTAX,
    _dp12SubschemaTimestamp_WITH_SY,
    _dpHasSubordinates_WITH_SYNTAX
};
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void (*_FreePDU[85])(OssGlobal *, void *) = {
    _fOssEncOID,
    _fACSE_apdu,
    _fAE_title,
    _fCP_type,
    _fCPC_type,
    _fCPA_PPDU,
    _fCPR_PPDU,
    _fAbort_type,
    _fTyped_data_type,
    _fRS_PPDU,
    _fRSA_PPDU,
    _f0Reliable_Transfer_APDU_RTSE,
    _f1Remote_Operations_Abstract_,
    _fROSEInvokeIds,
    _fReject,
    _fNoInvokeId,
    _fUnboundedDirectoryString,
    _fUniqueIdentifier,
    _fUUIDPair,
    _fCountryName,
    _fGuide,
    _fEnhancedGuide,
    _fPostalAddress,
    _fTelephoneNumber,
    _fTelexNumber,
    _fX121Address,
    _fInternationalISDNNumber,
    _fDestinationIndicator,
    _fCommunicationsService,
    _fCommunicationsNetwork,
    _fPreferredDeliveryMethod,
    _fPresentationAddress,
    _fProtocolInformation,
    _fNameAndOptionalUID,
    _fMultipleMatchingLocalities,
    _fSubstringAssertion,
    _fCaseIgnoreList,
    _fOctetSubstringAssertion,
    _fSequenceMatchType,
    _fWordMatchTypes,
    _fCharacterMatchTypes,
    _fLanguageContextSyntax,
    _fTimeSpecification,
    _fTimeAssertion,
    _fLocaleContextSyntax,
    _fAttributeOptionList,
    _fID,
    _fAttributeValue,
    _fContextAssertion,
    _fAttributeTypeAssertion,
    _fDistinguishedName,
    _fSubtreeSpecification,
    _fDITStructureRule,
    _fDITContentRule,
    _fDITContextUse,
    _fHierarchyLevel,
    _fHierarchyBelow,
    _fAcse_RealizationParameter,
    _f2Acse_with_concatenation_Rea,
    _f3Association_by_RTSE_Realiza,
    _fPData_RealizationParameter,
    _f4PData_with_concatenation_Re,
    _f5Transfer_by_RTSE_Realizatio,
    _fBitStringMatch_SYNTAX,
    _fDnQualifier_WITH_SYNTAX,
    _fSerialNumber_WITH_SYNTAX,
    _fNumericStringMatch_SYNTAX,
    _f6ProtocolInformationMatch_SY,
    _fUiiInUrn_WITH_SYNTAX,
    _f7NumericStringOrderingMatch_,
    _fBooleanMatch_SYNTAX,
    _fIntegerMatch_SYNTAX,
    _fIntegerOrderingMatch_SYNTAX,
    _fOctetStringMatch_SYNTAX,
    _f8OctetStringOrderingMatch_SY,
    _fUTCTimeMatch_SYNTAX,
    _fUTCTimeOrderingMatch_SYNTAX,
    _fGeneralizedTimeMatch_SYNTAX,
    _f9GeneralizedTimeOrderingMatc,
    _f10IntegerFirstComponentMatch,
    _f11AdministrativeRole_WITH_SY,
    _fCreateTimestamp_WITH_SYNTAX,
    _fModifyTimestamp_WITH_SYNTAX,
    _f12SubschemaTimestamp_WITH_SY,
    _fHasSubordinates_WITH_SYNTAX
};
#endif
#ifdef OSSPRINT
static _print_pdu_ _PrintPDU[85] = {
    { _pOssEncOID, (char *)"OSSC::OBJECT_IDENTIFIER" },
    { _pACSE_apdu, (char *)"ACSE-apdu" },
    { _pAE_title, (char *)"AE-title" },
    { _pCP_type, (char *)"CP-type" },
    { _pCPC_type, (char *)"CPC-type" },
    { _pCPA_PPDU, (char *)"CPA-PPDU" },
    { _pCPR_PPDU, (char *)"CPR-PPDU" },
    { _pAbort_type, (char *)"Abort-type" },
    { _pTyped_data_type, (char *)"Typed-data-type" },
    { _pRS_PPDU, (char *)"RS-PPDU" },
    { _pRSA_PPDU, (char *)"RSA-PPDU" },
    { _p0Reliable_Transfer_APDU_RTSE, (char *)"RTSE-apdus" },
    { _p1Remote_Operations_Abstract_, (char *)"RTSE-apdus" },
    { _pROSEInvokeIds, (char *)"ROSEInvokeIds" },
    { _pReject, (char *)"Reject" },
    { _pNoInvokeId, (char *)"NoInvokeId" },
    { _pUnboundedDirectoryString, (char *)"UnboundedDirectoryString" },
    { _pUniqueIdentifier, (char *)"UniqueIdentifier" },
    { _pUUIDPair, (char *)"UUIDPair" },
    { _pCountryName, (char *)"CountryName" },
    { _pGuide, (char *)"Guide" },
    { _pEnhancedGuide, (char *)"EnhancedGuide" },
    { _pPostalAddress, (char *)"PostalAddress" },
    { _pTelephoneNumber, (char *)"TelephoneNumber" },
    { _pTelexNumber, (char *)"TelexNumber" },
    { _pX121Address, (char *)"X121Address" },
    { _pInternationalISDNNumber, (char *)"InternationalISDNNumber" },
    { _pDestinationIndicator, (char *)"DestinationIndicator" },
    { _pCommunicationsService, (char *)"CommunicationsService" },
    { _pCommunicationsNetwork, (char *)"CommunicationsNetwork" },
    { _pPreferredDeliveryMethod, (char *)"PreferredDeliveryMethod" },
    { _pPresentationAddress, (char *)"PresentationAddress" },
    { _pProtocolInformation, (char *)"ProtocolInformation" },
    { _pNameAndOptionalUID, (char *)"NameAndOptionalUID" },
    { _pMultipleMatchingLocalities, (char *)"MultipleMatchingLocalities" },
    { _pSubstringAssertion, (char *)"SubstringAssertion" },
    { _pCaseIgnoreList, (char *)"CaseIgnoreList" },
    { _pOctetSubstringAssertion, (char *)"OctetSubstringAssertion" },
    { _pSequenceMatchType, (char *)"SequenceMatchType" },
    { _pWordMatchTypes, (char *)"WordMatchTypes" },
    { _pCharacterMatchTypes, (char *)"CharacterMatchTypes" },
    { _pLanguageContextSyntax, (char *)"LanguageContextSyntax" },
    { _pTimeSpecification, (char *)"TimeSpecification" },
    { _pTimeAssertion, (char *)"TimeAssertion" },
    { _pLocaleContextSyntax, (char *)"LocaleContextSyntax" },
    { _pAttributeOptionList, (char *)"AttributeOptionList" },
    { _pID, (char *)"ID" },
    { _pAttributeValue, (char *)"AttributeValue" },
    { _pContextAssertion, (char *)"ContextAssertion" },
    { _pAttributeTypeAssertion, (char *)"AttributeTypeAssertion" },
    { _pDistinguishedName, (char *)"DistinguishedName" },
    { _pSubtreeSpecification, (char *)"SubtreeSpecification" },
    { _pDITStructureRule, (char *)"DITStructureRule" },
    { _pDITContentRule, (char *)"DITContentRule" },
    { _pDITContextUse, (char *)"DITContextUse" },
    { _pHierarchyLevel, (char *)"HierarchyLevel" },
    { _pHierarchyBelow, (char *)"HierarchyBelow" },
    { _pAcse_RealizationParameter, (char *)"Acse-RealizationParameter" },
    { _p2Acse_with_concatenation_Rea, (char *)"Acse-with-concatenation-RealizationParameter" },
    { _p3Association_by_RTSE_Realiza, (char *)"Association-by-RTSE-RealizationParameter" },
    { _pPData_RealizationParameter, (char *)"PData-RealizationParameter" },
    { _p4PData_with_concatenation_Re, (char *)"PData-with-concatenation-RealizationParameter" },
    { _p5Transfer_by_RTSE_Realizatio, (char *)"Transfer-by-RTSE-RealizationParameter" },
    { _pBitStringMatch_SYNTAX, (char *)"BitStringMatch-SYNTAX" },
    { _pDnQualifier_WITH_SYNTAX, (char *)"DnQualifier-WITH-SYNTAX" },
    { _pSerialNumber_WITH_SYNTAX, (char *)"SerialNumber-WITH-SYNTAX" },
    { _pNumericStringMatch_SYNTAX, (char *)"NumericStringMatch-SYNTAX" },
    { _p6ProtocolInformationMatch_SY, (char *)"ProtocolInformationMatch-SYNTAX" },
    { _pUiiInUrn_WITH_SYNTAX, (char *)"UiiInUrn-WITH-SYNTAX" },
    { _p7NumericStringOrderingMatch_, (char *)"NumericStringOrderingMatch-SYNTAX" },
    { _pBooleanMatch_SYNTAX, (char *)"BooleanMatch-SYNTAX" },
    { _pIntegerMatch_SYNTAX, (char *)"IntegerMatch-SYNTAX" },
    { _pIntegerOrderingMatch_SYNTAX, (char *)"IntegerOrderingMatch-SYNTAX" },
    { _pOctetStringMatch_SYNTAX, (char *)"OctetStringMatch-SYNTAX" },
    { _p8OctetStringOrderingMatch_SY, (char *)"OctetStringOrderingMatch-SYNTAX" },
    { _pUTCTimeMatch_SYNTAX, (char *)"UTCTimeMatch-SYNTAX" },
    { _pUTCTimeOrderingMatch_SYNTAX, (char *)"UTCTimeOrderingMatch-SYNTAX" },
    { _pGeneralizedTimeMatch_SYNTAX, (char *)"GeneralizedTimeMatch-SYNTAX" },
    { _p9GeneralizedTimeOrderingMatc, (char *)"GeneralizedTimeOrderingMatch-SYNTAX" },
    { _p10IntegerFirstComponentMatch, (char *)"IntegerFirstComponentMatch-SYNTAX" },
    { _p11AdministrativeRole_WITH_SY, (char *)"AdministrativeRole-WITH-SYNTAX" },
    { _pCreateTimestamp_WITH_SYNTAX, (char *)"CreateTimestamp-WITH-SYNTAX" },
    { _pModifyTimestamp_WITH_SYNTAX, (char *)"ModifyTimestamp-WITH-SYNTAX" },
    { _p12SubschemaTimestamp_WITH_SY, (char *)"SubschemaTimestamp-WITH-SYNTAX" },
    { _pHasSubordinates_WITH_SYNTAX, (char *)"HasSubordinates-WITH-SYNTAX" }
};
#endif

/* TOED internal function implementations */

#if OSSDEBUG > 1
static const _Context_Id _context_id[] = {
    {(char *)"uTF8String", (char *)"Character String", _charstring_type},
    {(char *)"printableString", (char *)"Character String", _charstring_type},
    {(char *)"teletexString", (char *)"Character String", _charstring_type},
    {(char *)"universalString", (char *)"Character String", _charstring_type},
    {(char *)"bmpString", (char *)"Character String", _charstring_type},
    {(char *)"contextValues", (char *)"SET OF", _set_of_type},
    {nullptr, (char *)"OpenType", _opentype},
    {(char *)"contextType", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {(char *)"single-ASN1-type", (char *)"OpenType", _opentype},
    {(char *)"octet-aligned", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"arbitrary", (char *)"BIT STRING", _bitstring_type},
    {(char *)"encoding", (char *)"CHOICE", _choice_type},
    {(char *)"data-value-descriptor", (char *)"Character String", _charstring_type},
    {(char *)"indirect-reference", (char *)"INTEGER", _integer_type},
    {(char *)"direct-reference", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {(char *)"rdnSequence", (char *)"RDNSequence", _sequence_of_type},
    {(char *)"ap-title-form2", (char *)"AP-title-form2", _object_identifier_type},
    {(char *)"ap-title-form1", (char *)"AP-title-form1", _choice_type},
    {(char *)"ae-qualifier-form2", (char *)"AE-qualifier-form2", _integer_type},
    {(char *)"ae-qualifier-form1", (char *)"AE-qualifier-form1", _set_of_type},
    {(char *)"concatenation", (char *)"BOOLEAN", _boolean_type},
    {(char *)"realization-type", (char *)"ENUMERATED", _enumerated_type},
    {(char *)"charstring", (char *)"Character String", _charstring_type},
    {(char *)"bitstring", (char *)"BIT STRING", _bitstring_type},
    {(char *)"external", (char *)"SEQUENCE", _sequence_type},
    {(char *)"other", (char *)"SEQUENCE", _sequence_type},
    {(char *)"other-mechanism-value", (char *)"OpenType", _opentype},
    {(char *)"other-mechanism-name", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {nullptr, (char *)"Application-context-name", _object_identifier_type},
    {nullptr, (char *)"SEQUENCE", _sequence_type},
    {(char *)"mode-value", (char *)"INTEGER", _integer_type},
    {(char *)"open", (char *)"OpenType", _opentype},
    {(char *)"recover", (char *)"SessionConnectionIdentifier", _sequence_type},
    {(char *)"simply-encoded-data", (char *)"Simply-encoded-data", _octetstring_type},
    {(char *)"fully-encoded-data", (char *)"Fully-encoded-data", _sequence_of_type},
    {(char *)"transfer-syntax-name-list", (char *)"SEQUENCE OF", _sequence_of_type},
    {nullptr, (char *)"Transfer-syntax-name", _object_identifier_type},
    {(char *)"abstract-syntax-name", (char *)"Abstract-syntax-name", _object_identifier_type},
    {(char *)"presentation-context-identifier", (char *)"Presentation-context-identifier", _integer_type},
    {(char *)"transfer-syntax-name", (char *)"Transfer-syntax-name", _object_identifier_type},
    {(char *)"provider-reason", (char *)"INTEGER", _integer_type},
    {(char *)"result", (char *)"Result", _integer_type},
    {(char *)"presentation-data-values", (char *)"CHOICE", _choice_type},
    {nullptr, (char *)"PDV-list", _sequence_type},
    {(char *)"applicationProtocol", (char *)"INTEGER", _integer_type},
    {(char *)"connectionDataRQ", (char *)"ConnectionData", _choice_type},
    {(char *)"dialogueMode", (char *)"INTEGER", _integer_type},
    {(char *)"windowSize", (char *)"INTEGER", _integer_type},
    {(char *)"checkpointSize", (char *)"INTEGER", _integer_type},
    {(char *)"connectionDataAC", (char *)"ConnectionData", _choice_type},
    {(char *)"userDataRJ", (char *)"OpenType", _opentype},
    {(char *)"refuseReason", (char *)"RefuseReason", _integer_type},
    {(char *)"octetString", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"t61String", (char *)"Character String", _charstring_type},
    {(char *)"additionalReferenceInformation", (char *)"AdditionalReferenceInformation", _charstring_type},
    {(char *)"commonReference", (char *)"CommonReference", _charstring_type},
    {(char *)"callingSSuserReference", (char *)"CallingSSuserReference", _choice_type},
    {(char *)"present", (char *)"INTEGER", _integer_type},
    {(char *)"absent", (char *)"nullptr", _null_type},
    {(char *)"type", (char *)"CriteriaItem", _choice_type},
    {(char *)"and", (char *)"SET OF", _set_of_type},
    {(char *)"or", (char *)"SET OF", _set_of_type},
    {(char *)"not", (char *)"Criteria", _choice_type},
    {nullptr, (char *)"Criteria", _choice_type},
    {(char *)"equality", (char *)"AttributeType", _object_identifier_type},
    {(char *)"substrings", (char *)"AttributeType", _object_identifier_type},
    {(char *)"greaterOrEqual", (char *)"AttributeType", _object_identifier_type},
    {(char *)"lessOrEqual", (char *)"AttributeType", _object_identifier_type},
    {(char *)"approximateMatch", (char *)"AttributeType", _object_identifier_type},
    {(char *)"second", (char *)"INTEGER", _integer_type},
    {(char *)"minute", (char *)"INTEGER", _integer_type},
    {(char *)"hour", (char *)"INTEGER", _integer_type},
    {nullptr, (char *)"INTEGER", _integer_type},
    {(char *)"bitNamedDays", (char *)"BIT STRING", _bitstring_type},
    {(char *)"intNamedDays", (char *)"ENUMERATED", _enumerated_type},
    {(char *)"fallback", (char *)"BOOLEAN", _boolean_type},
    {nullptr, (char *)"RelativeDistinguishedName", _set_of_type},
    {(char *)"valuesWithContext", (char *)"SET OF", _set_of_type},
    {(char *)"contextList", (char *)"SET OF", _set_of_type},
    {nullptr, (char *)"Context", _sequence_type},
    {(char *)"distingAttrValue", (char *)"OpenType", _opentype},
    {(char *)"primaryDistinguished", (char *)"BOOLEAN", _boolean_type},
    {(char *)"value", (char *)"OpenType", _opentype},
    {(char *)"type", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {nullptr, (char *)"AttributeTypeAndDistinguishedValue", _sequence_type},
    {(char *)"item", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {(char *)"not", (char *)"Refinement", _choice_type},
    {nullptr, (char *)"Refinement", _choice_type},
    {(char *)"OSSC::OBJECT_IDENTIFIER", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {(char *)"ACSE-apdu", (char *)"CHOICE", _choice_type},
    {(char *)"aarq", (char *)"AARQ-apdu", _sequence_type},
    {(char *)"user-information", (char *)"Association-information", _sequence_of_type},
    {(char *)"implementation-information", (char *)"Implementation-data", _charstring_type},
    {(char *)"application-context-name-list", (char *)"Application-context-name-list", _sequence_of_type},
    {(char *)"calling-authentication-value", (char *)"Authentication-value", _choice_type},
    {(char *)"mechanism-name", (char *)"Mechanism-name", _object_identifier_type},
    {(char *)"sender-acse-requirements", (char *)"ACSE-requirements", _bitstring_type},
    {(char *)"calling-AE-invocation-identifier", (char *)"AE-invocation-identifier", _integer_type},
    {(char *)"calling-AP-invocation-identifier", (char *)"AP-invocation-identifier", _integer_type},
    {(char *)"calling-AE-qualifier", (char *)"AE-qualifier", _choice_type},
    {(char *)"calling-AP-title", (char *)"AP-title", _choice_type},
    {(char *)"called-AE-invocation-identifier", (char *)"AE-invocation-identifier", _integer_type},
    {(char *)"called-AP-invocation-identifier", (char *)"AP-invocation-identifier", _integer_type},
    {(char *)"called-AE-qualifier", (char *)"AE-qualifier", _choice_type},
    {(char *)"called-AP-title", (char *)"AP-title", _choice_type},
    {(char *)"application-context-name", (char *)"Application-context-name", _object_identifier_type},
    {(char *)"protocol-version", (char *)"BIT STRING", _bitstring_type},
    {(char *)"aare", (char *)"AARE-apdu", _sequence_type},
    {(char *)"responding-authentication-value", (char *)"Authentication-value", _choice_type},
    {(char *)"responder-acse-requirements", (char *)"ACSE-requirements", _bitstring_type},
    {(char *)"responding-AE-invocation-identifier", (char *)"AE-invocation-identifier", _integer_type},
    {(char *)"responding-AP-invocation-identifier", (char *)"AP-invocation-identifier", _integer_type},
    {(char *)"responding-AE-qualifier", (char *)"AE-qualifier", _choice_type},
    {(char *)"responding-AP-title", (char *)"AP-title", _choice_type},
    {(char *)"result-source-diagnostic", (char *)"Associate-source-diagnostic", _choice_type},
    {(char *)"acse-service-user", (char *)"INTEGER", _integer_type},
    {(char *)"acse-service-provider", (char *)"INTEGER", _integer_type},
    {(char *)"result", (char *)"Associate-result", _integer_type},
    {(char *)"rlrq", (char *)"RLRQ-apdu", _sequence_type},
    {(char *)"reason", (char *)"Release-request-reason", _integer_type},
    {(char *)"rlre", (char *)"RLRE-apdu", _sequence_type},
    {(char *)"reason", (char *)"Release-response-reason", _integer_type},
    {(char *)"abrt", (char *)"ABRT-apdu", _sequence_type},
    {(char *)"abort-diagnostic", (char *)"ABRT-diagnostic", _enumerated_type},
    {(char *)"abort-source", (char *)"ABRT-source", _integer_type},
    {(char *)"AE-title", (char *)"CHOICE", _choice_type},
    {(char *)"ae-title-form2", (char *)"AE-title-form2", _object_identifier_type},
    {(char *)"ae-title-form1", (char *)"AE-title-form1", _choice_type},
    {(char *)"CP-type", (char *)"SET", _set_type},
    {(char *)"normal-mode-parameters", (char *)"SEQUENCE", _sequence_type},
    {(char *)"user-data", (char *)"User-data", _choice_type},
    {(char *)"extensions", (char *)"SEQUENCE", _sequence_type},
    {(char *)"initiators-nominated-context", (char *)"Presentation-context-identifier", _integer_type},
    {(char *)"protocol-options", (char *)"Protocol-options", _bitstring_type},
    {(char *)"user-session-requirements", (char *)"User-session-requirements", _bitstring_type},
    {(char *)"presentation-requirements", (char *)"Presentation-requirements", _bitstring_type},
    {(char *)"default-context-name", (char *)"Default-context-name", _sequence_type},
    {(char *)"presentation-context-definition-list", (char *)"Presentation-context-definition-list", _sequence_of_type},
    {(char *)"called-presentation-selector", (char *)"Called-presentation-selector", _octetstring_type},
    {(char *)"calling-presentation-selector", (char *)"Calling-presentation-selector", _octetstring_type},
    {(char *)"protocol-version", (char *)"Protocol-version", _bitstring_type},
    {(char *)"x410-mode-parameters", (char *)"SET", _set_type},
    {(char *)"mode-selector", (char *)"Mode-selector", _set_type},
    {(char *)"CPC-type", (char *)"CHOICE", _choice_type},
    {(char *)"CPA-PPDU", (char *)"SET", _set_type},
    {(char *)"responders-nominated-context", (char *)"Presentation-context-identifier", _integer_type},
    {(char *)"presentation-context-definition-result-list", (char *)"Presentation-context-definition-result-list", _sequence_of_type},
    {(char *)"responding-presentation-selector", (char *)"Responding-presentation-selector", _octetstring_type},
    {(char *)"CPR-PPDU", (char *)"CHOICE", _choice_type},
    {(char *)"provider-reason", (char *)"Provider-reason", _integer_type},
    {(char *)"default-context-result", (char *)"Default-context-result", _integer_type},
    {(char *)"x400-mode-parameters", (char *)"SET", _set_type},
    {(char *)"Abort-type", (char *)"CHOICE", _choice_type},
    {(char *)"arp-ppdu", (char *)"ARP-PPDU", _sequence_type},
    {(char *)"event-identifier", (char *)"Event-identifier", _integer_type},
    {(char *)"provider-reason", (char *)"Abort-reason", _integer_type},
    {(char *)"aru-ppdu", (char *)"ARU-PPDU", _choice_type},
    {(char *)"userdataAB", (char *)"OpenType", _opentype},
    {(char *)"reflectedParameter", (char *)"BIT STRING", _bitstring_type},
    {(char *)"abortReason", (char *)"AbortReason", _integer_type},
    {(char *)"presentation-context-identifier-list", (char *)"Presentation-context-identifier-list", _sequence_of_type},
    {(char *)"Typed-data-type", (char *)"CHOICE", _choice_type},
    {(char *)"ttdPPDU", (char *)"User-data", _choice_type},
    {(char *)"acPPDU", (char *)"AC-PPDU", _sequence_type},
    {(char *)"presentation-context-deletion-list", (char *)"Presentation-context-deletion-list", _sequence_of_type},
    {nullptr, (char *)"Presentation-context-identifier", _integer_type},
    {(char *)"presentation-context-addition-list", (char *)"Presentation-context-addition-list", _sequence_of_type},
    {(char *)"acaPPDU", (char *)"ACA-PPDU", _sequence_type},
    {(char *)"presentation-context-deletion-result-list", (char *)"Presentation-context-deletion-result-list", _sequence_of_type},
    {(char *)"presentation-context-addition-result-list", (char *)"Presentation-context-addition-result-list", _sequence_of_type},
    {(char *)"RS-PPDU", (char *)"SEQUENCE", _sequence_type},
    {(char *)"RSA-PPDU", (char *)"SEQUENCE", _sequence_type},
    {(char *)"RTSE-apdus", (char *)"CHOICE", _choice_type},
    {(char *)"rttp-apdu", (char *)"RTTPapdu", _integer_type},
    {(char *)"rttr-apdu", (char *)"RTTRapdu", _octetstring_type},
    {(char *)"rtorq-apdu", (char *)"RTORQapdu", _set_type},
    {(char *)"rtoac-apdu", (char *)"RTOACapdu", _set_type},
    {(char *)"rtorj-apdu", (char *)"RTORJapdu", _set_type},
    {(char *)"rtab-apdu", (char *)"RTABapdu", _set_type},
    {(char *)"ROSEInvokeIds", (char *)"CHOICE", _choice_type},
    {(char *)"Reject", (char *)"SEQUENCE", _sequence_type},
    {(char *)"problem", (char *)"CHOICE", _choice_type},
    {(char *)"general", (char *)"GeneralProblem", _integer_type},
    {(char *)"invoke", (char *)"InvokeProblem", _integer_type},
    {(char *)"returnResult", (char *)"ReturnResultProblem", _integer_type},
    {(char *)"returnError", (char *)"ReturnErrorProblem", _integer_type},
    {(char *)"invokeId", (char *)"InvokeId", _choice_type},
    {(char *)"NoInvokeId", (char *)"CHOICE", _choice_type},
    {(char *)"UnboundedDirectoryString", (char *)"CHOICE", _choice_type},
    {(char *)"UniqueIdentifier", (char *)"BIT STRING", _bitstring_type},
    {(char *)"UUIDPair", (char *)"SEQUENCE", _sequence_type},
    {(char *)"subjectUUID", (char *)"UUID", _octetstring_type},
    {(char *)"issuerUUID", (char *)"UUID", _octetstring_type},
    {(char *)"CountryName", (char *)"Character String", _charstring_type},
    {(char *)"Guide", (char *)"SET", _set_type},
    {(char *)"criteria", (char *)"Criteria", _choice_type},
    {(char *)"objectClass", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {(char *)"EnhancedGuide", (char *)"SEQUENCE", _sequence_type},
    {(char *)"subset", (char *)"INTEGER", _integer_type},
    {(char *)"PostalAddress", (char *)"SEQUENCE OF", _sequence_of_type},
    {nullptr, (char *)"UnboundedDirectoryString", _choice_type},
    {(char *)"TelephoneNumber", (char *)"Character String", _charstring_type},
    {(char *)"TelexNumber", (char *)"SEQUENCE", _sequence_type},
    {(char *)"answerback", (char *)"Character String", _charstring_type},
    {(char *)"countryCode", (char *)"Character String", _charstring_type},
    {(char *)"telexNumber", (char *)"Character String", _charstring_type},
    {(char *)"X121Address", (char *)"Character String", _charstring_type},
    {(char *)"InternationalISDNNumber", (char *)"Character String", _charstring_type},
    {(char *)"DestinationIndicator", (char *)"Character String", _charstring_type},
    {(char *)"CommunicationsService", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {(char *)"CommunicationsNetwork", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {(char *)"PreferredDeliveryMethod", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"PresentationAddress", (char *)"SEQUENCE", _sequence_type},
    {(char *)"nAddresses", (char *)"SET OF", _set_of_type},
    {nullptr, (char *)"OCTET STRING", _octetstring_type},
    {(char *)"tSelector", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"sSelector", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"pSelector", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"ProtocolInformation", (char *)"SEQUENCE", _sequence_type},
    {(char *)"profiles", (char *)"SET OF", _set_of_type},
    {nullptr, (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {(char *)"nAddress", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"NameAndOptionalUID", (char *)"SEQUENCE", _sequence_type},
    {(char *)"uid", (char *)"UniqueIdentifier", _bitstring_type},
    {(char *)"dn", (char *)"DistinguishedName", _sequence_of_type},
    {(char *)"MultipleMatchingLocalities", (char *)"SEQUENCE", _sequence_type},
    {(char *)"attributeList", (char *)"SEQUENCE OF", _sequence_of_type},
    {nullptr, (char *)"AttributeValueAssertion", _sequence_type},
    {(char *)"assertedContexts", (char *)"CHOICE", _choice_type},
    {(char *)"allContexts", (char *)"nullptr", _null_type},
    {(char *)"selectedContexts", (char *)"SET OF", _set_of_type},
    {nullptr, (char *)"ContextAssertion", _sequence_type},
    {(char *)"assertion", (char *)"OpenType", _opentype},
    {(char *)"matchingRuleUsed", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {(char *)"SubstringAssertion", (char *)"SEQUENCE OF", _sequence_of_type},
    {nullptr, (char *)"CHOICE", _choice_type},
    {(char *)"control", (char *)"SEQUENCE", _sequence_type},
    {(char *)"values", (char *)"SET OF", _set_of_type},
    {(char *)"initial", (char *)"UnboundedDirectoryString", _choice_type},
    {(char *)"any", (char *)"UnboundedDirectoryString", _choice_type},
    {(char *)"final", (char *)"UnboundedDirectoryString", _choice_type},
    {(char *)"CaseIgnoreList", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"OctetSubstringAssertion", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"initial", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"any", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"final", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"SequenceMatchType", (char *)"ENUMERATED", _enumerated_type},
    {(char *)"WordMatchTypes", (char *)"ENUMERATED", _enumerated_type},
    {(char *)"CharacterMatchTypes", (char *)"ENUMERATED", _enumerated_type},
    {(char *)"LanguageContextSyntax", (char *)"Character String", _charstring_type},
    {(char *)"TimeSpecification", (char *)"SEQUENCE", _sequence_type},
    {(char *)"timeZone", (char *)"TimeZone", _integer_type},
    {(char *)"notThisTime", (char *)"BOOLEAN", _boolean_type},
    {(char *)"time", (char *)"CHOICE", _choice_type},
    {(char *)"absolute", (char *)"SEQUENCE", _sequence_type},
    {(char *)"endTime", (char *)"Character String", _charstring_type},
    {(char *)"startTime", (char *)"Character String", _charstring_type},
    {(char *)"periodic", (char *)"SET OF", _set_of_type},
    {nullptr, (char *)"Period", _sequence_type},
    {(char *)"years", (char *)"SET OF", _set_of_type},
    {(char *)"months", (char *)"CHOICE", _choice_type},
    {(char *)"bitMonth", (char *)"BIT STRING", _bitstring_type},
    {(char *)"allMonths", (char *)"nullptr", _null_type},
    {(char *)"intMonth", (char *)"SET OF", _set_of_type},
    {(char *)"weeks", (char *)"CHOICE", _choice_type},
    {(char *)"bitWeek", (char *)"BIT STRING", _bitstring_type},
    {(char *)"allWeeks", (char *)"nullptr", _null_type},
    {(char *)"intWeek", (char *)"SET OF", _set_of_type},
    {(char *)"days", (char *)"CHOICE", _choice_type},
    {(char *)"bitDay", (char *)"BIT STRING", _bitstring_type},
    {(char *)"intDay", (char *)"SET OF", _set_of_type},
    {(char *)"dayOf", (char *)"XDayOf", _choice_type},
    {(char *)"first", (char *)"NamedDay", _choice_type},
    {(char *)"second", (char *)"NamedDay", _choice_type},
    {(char *)"third", (char *)"NamedDay", _choice_type},
    {(char *)"fourth", (char *)"NamedDay", _choice_type},
    {(char *)"fifth", (char *)"NamedDay", _choice_type},
    {(char *)"timesOfDay", (char *)"SET OF", _set_of_type},
    {nullptr, (char *)"DayTimeBand", _sequence_type},
    {(char *)"endDayTime", (char *)"DayTime", _sequence_type},
    {(char *)"startDayTime", (char *)"DayTime", _sequence_type},
    {(char *)"TimeAssertion", (char *)"CHOICE", _choice_type},
    {(char *)"now", (char *)"nullptr", _null_type},
    {(char *)"between", (char *)"SEQUENCE", _sequence_type},
    {(char *)"entirely", (char *)"BOOLEAN", _boolean_type},
    {(char *)"at", (char *)"Character String", _charstring_type},
    {(char *)"LocaleContextSyntax", (char *)"CHOICE", _choice_type},
    {(char *)"localeID1", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {(char *)"localeID2", (char *)"UnboundedDirectoryString", _choice_type},
    {(char *)"AttributeOptionList", (char *)"SEQUENCE OF", _sequence_of_type},
    {nullptr, (char *)"Character String", _charstring_type},
    {(char *)"ID", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {(char *)"AttributeValue", (char *)"OpenType", _opentype},
    {(char *)"ContextAssertion", (char *)"SEQUENCE", _sequence_type},
    {(char *)"AttributeTypeAssertion", (char *)"SEQUENCE", _sequence_type},
    {(char *)"assertedContexts", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"DistinguishedName", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"SubtreeSpecification", (char *)"SEQUENCE", _sequence_type},
    {(char *)"specificationFilter", (char *)"Refinement", _choice_type},
    {(char *)"maximum", (char *)"BaseDistance", _integer_type},
    {(char *)"minimum", (char *)"BaseDistance", _integer_type},
    {(char *)"specificExclusions", (char *)"SET OF", _set_of_type},
    {(char *)"chopBefore", (char *)"LocalName", _sequence_of_type},
    {(char *)"chopAfter", (char *)"LocalName", _sequence_of_type},
    {(char *)"base", (char *)"LocalName", _sequence_of_type},
    {(char *)"DITStructureRule", (char *)"SEQUENCE", _sequence_type},
    {(char *)"superiorStructureRules", (char *)"SET OF", _set_of_type},
    {nullptr, (char *)"RuleIdentifier", _integer_type},
    {(char *)"nameForm", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {(char *)"ruleIdentifier", (char *)"RuleIdentifier", _integer_type},
    {(char *)"DITContentRule", (char *)"SEQUENCE", _sequence_type},
    {(char *)"precluded", (char *)"SET OF", _set_of_type},
    {(char *)"optional", (char *)"SET OF", _set_of_type},
    {(char *)"mandatory", (char *)"SET OF", _set_of_type},
    {(char *)"auxiliaries", (char *)"SET OF", _set_of_type},
    {(char *)"structuralObjectClass", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {(char *)"DITContextUse", (char *)"SEQUENCE", _sequence_type},
    {(char *)"optionalContexts", (char *)"SET OF", _set_of_type},
    {(char *)"mandatoryContexts", (char *)"SET OF", _set_of_type},
    {(char *)"attributeType", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {(char *)"HierarchyLevel", (char *)"INTEGER", _integer_type},
    {(char *)"HierarchyBelow", (char *)"BOOLEAN", _boolean_type},
    {(char *)"Acse-RealizationParameter", (char *)"SEQUENCE", _sequence_type},
    {(char *)"Acse-with-concatenation-RealizationParameter", (char *)"SEQUENCE", _sequence_type},
    {(char *)"Association-by-RTSE-RealizationParameter", (char *)"SEQUENCE", _sequence_type},
    {(char *)"PData-RealizationParameter", (char *)"SEQUENCE", _sequence_type},
    {(char *)"PData-with-concatenation-RealizationParameter", (char *)"SEQUENCE", _sequence_type},
    {(char *)"Transfer-by-RTSE-RealizationParameter", (char *)"SEQUENCE", _sequence_type},
    {(char *)"BitStringMatch-SYNTAX", (char *)"BIT STRING", _bitstring_type},
    {(char *)"DnQualifier-WITH-SYNTAX", (char *)"Character String", _charstring_type},
    {(char *)"SerialNumber-WITH-SYNTAX", (char *)"Character String", _charstring_type},
    {(char *)"NumericStringMatch-SYNTAX", (char *)"Character String", _charstring_type},
    {(char *)"ProtocolInformationMatch-SYNTAX", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"UiiInUrn-WITH-SYNTAX", (char *)"Character String", _charstring_type},
    {(char *)"NumericStringOrderingMatch-SYNTAX", (char *)"Character String", _charstring_type},
    {(char *)"BooleanMatch-SYNTAX", (char *)"BOOLEAN", _boolean_type},
    {(char *)"IntegerMatch-SYNTAX", (char *)"INTEGER", _integer_type},
    {(char *)"IntegerOrderingMatch-SYNTAX", (char *)"INTEGER", _integer_type},
    {(char *)"OctetStringMatch-SYNTAX", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"OctetStringOrderingMatch-SYNTAX", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"UTCTimeMatch-SYNTAX", (char *)"Character String", _charstring_type},
    {(char *)"UTCTimeOrderingMatch-SYNTAX", (char *)"Character String", _charstring_type},
    {(char *)"GeneralizedTimeMatch-SYNTAX", (char *)"Character String", _charstring_type},
    {(char *)"GeneralizedTimeOrderingMatch-SYNTAX", (char *)"Character String", _charstring_type},
    {(char *)"IntegerFirstComponentMatch-SYNTAX", (char *)"INTEGER", _integer_type},
    {(char *)"AdministrativeRole-WITH-SYNTAX", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {(char *)"CreateTimestamp-WITH-SYNTAX", (char *)"Character String", _charstring_type},
    {(char *)"ModifyTimestamp-WITH-SYNTAX", (char *)"Character String", _charstring_type},
    {(char *)"SubschemaTimestamp-WITH-SYNTAX", (char *)"Character String", _charstring_type},
    {(char *)"HasSubordinates-WITH-SYNTAX", (char *)"BOOLEAN", _boolean_type}
};
#endif


static OSS_INT32 const _v646[7] = {
  1, 2, 3, 4, 5, 6, 7
};
static OSS_INT32 const _v649[6] = {
  0, 1, 2, 3, 4, 5
};
static OSS_INT32 const _v648[1] = {INT_MAX};

static struct _enum_data const _enums[] = {
	    { 2, (OSS_INT32 *)_v649 },
	    { 7, (OSS_INT32 *)_v646 },
	    { 6, (OSS_INT32 *)_v646 }, { 1, (OSS_INT32 *)_v648 },
	    { 6, (OSS_INT32 *)_v649 },
	    { 4, (OSS_INT32 *)_v649 },
	    { 3, (OSS_INT32 *)_v649 }
};
static const char _v652[] = " '()+,-./0123456789:=?ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijkl"
    "mnopqrstuvwxyz";
static const unsigned char _v653[128] =
{
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01,
    0x02, 0x03, 0xff, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
    0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0xff,
    0xff, 0x14, 0xff, 0x15, 0xff, 0x16, 0x17, 0x18, 0x19, 0x1a,
    0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24,
    0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e,
    0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x30, 0x31, 0x32,
    0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c,
    0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,
    0x47, 0x48, 0x49, 0xff, 0xff, 0xff, 0xff, 0xff
};
static const char _v654[] = " 0123456789";
static const unsigned char _v655[128] =
{
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x02,
    0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};
static const struct st_char_data _v656 = { 74, _v652, _v653 };
static const struct st_char_data _v657 = { 11, _v654, _v655 };
static const struct st_PER_String_Data _chars[13] = {
    { &_v656, 1, 0, UINT_MAX, 0x8788 },
    { nullptr, 1, 0, UINT_MAX, 0xA0A0 },
    { nullptr, 1, 0, UINT_MAX, 0x9090 },
    { nullptr, 1, 0, UINT_MAX, 0x18788 },
    { &_v656, 2, 2, UINT_MAX, 0x8788 },
    { &_v656, 1, 32, UINT_MAX, 0x8788 },
    { &_v656, 1, 14, UINT_MAX, 0x8788 },
    { &_v656, 1, 4, UINT_MAX, 0x8788 },
    { &_v656, 1, 8, UINT_MAX, 0x8788 },
    { &_v657, 1, 15, UINT_MAX, 0x404 },
    { &_v657, 1, 16, UINT_MAX, 0x404 },
    { &_v656, 2, 3, UINT_MAX, 0x8788 },
    { &_v657, 1, 0, UINT_MAX, 0x404 }
};

#ifdef OSSPRINT
static struct _string_data const _sd1[] = {
    {"association-service", 19, 0x02, 0},
    {"transfer-service", 16, 0x02, 1}
};

static struct _string_data const _sd2[] = {
    {"wednesday", 9, 0x02, 4},
    {"saturday", 8, 0x02, 7},
    {"sunday", 6, 0x02, 1},
    {"monday", 6, 0x02, 2},
    {"thursday", 8, 0x02, 5},
    {"tuesday", 7, 0x02, 3},
    {"friday", 6, 0x02, 6}
};

static struct _string_data const _sd3[] = {
    {"protocol-error", 14, 0x02, 2},
    {"authentication-required", 23, 0x02, 6},
    {"no-reason-given", 15, 0x02, 1},
    {"authentication-mechanism-name-required", 38, 0x02, 4},
    {"authentication-mechanism-name-not-recognized", 44, 0x02, 3},
    {"authentication-failure", 22, 0x02, 5}
};

static struct _string_data const _sd4[] = {
    {"sequenceRestrictedDeletion", 26, 0x02, 2},
    {"sequencePermutation", 19, 0x02, 3},
    {"sequencePermutationAndDeletion", 30, 0x02, 4},
    {"sequenceExact", 13, 0x02, 0},
    {"sequenceProviderDefined", 23, 0x02, 5},
    {"sequenceDeletion", 16, 0x02, 1}
};

static struct _string_data const _sd5[] = {
    {"wordTruncated", 13, 0x02, 1},
    {"wordPhonetic", 12, 0x02, 2},
    {"wordExact", 9, 0x02, 0},
    {"wordProviderDefined", 19, 0x02, 3}
};

static struct _string_data const _sd6[] = {
    {"characterCaseIgnore", 19, 0x02, 1},
    {"characterExact", 14, 0x02, 0},
    {"characterMapped", 15, 0x02, 2}
};

#endif

#ifdef OSSPRINT
static struct _string_search_data const _ssd[] = {
    {2, 0, _sd1, nullptr},
    {7, 0, _sd2, nullptr},
    {6, INT_MAX, _sd3, nullptr},
    {6, 0, _sd4, nullptr},
    {4, 0, _sd5, nullptr},
    {3, 0, _sd6, nullptr}
};
#endif


#define _VARY_OFFSET_0 (int)((char *)&((OSSC::COssBitString *)nullptr)->value - (char *)nullptr)

static int _cmDayTime(OssGlobal * _g, _DayTime  * _odata, _DayTime  * _cdata);
static int _nDDayTime(OssGlobal * _g, _DayTime  * _odata, _DayTime  * _cdata);
static int _cmContext(OssGlobal * _g, _Context  * _odata, _Context  * _cdata);
static int _cmRDNSequence(OssGlobal * _g, _RDNSequence * * _odata, _RDNSequence * * _cdata);
static int _nDRDNSequence(OssGlobal * _g, _RDNSequence * * _odata, _RDNSequence * _cdata);
static int _cm15AttributeTypeAndDistinguis(OssGlobal * _g, _AttributeTypeAndDistinguishedValue  * _odata, _AttributeTypeAndDistinguishedValue  * _cdata);
static int _cmRelativeDistinguishedName(OssGlobal * _g, _RelativeDistinguishedName * * _odata, _RelativeDistinguishedName * * _cdata);

#ifdef OSS_COPY_VALUE
static void _oss_cpy_new_open_type (OssGlobal *_g, int *_pduNum,
		OssBuf *_obuf, OssBuf *_cbuf, void *_odecoded, void **_cdecoded);
#endif /* OSS_COPY_VALUE */

static int _oss_cmp_new_open_type (OssGlobal *_g, int _pduNum1, int _pduNum2,
		OssBuf *_obuf1, OssBuf *_obuf2, void *_decoded1, void *_decoded2);
#if OSS_TOED_API_LEVEL >= 31
void DLL_ENTRY_FDEF _oeUpperBounds_(OssGlobal * _g, int _pdunum, void * _inbuf)
{
    _oss_toed_api_error(_g, _null_fcn, 0);
    _pdunum = _pdunum;	/* to avoid C-compilation warning */
    _inbuf = _inbuf;	/* to avoid C-compilation warning */
}

void * DLL_ENTRY_FDEF _odUpperBounds_(OssGlobal * _g, int _pdunum)
{
    _oss_toed_api_error(_g, _null_fcn, 0);
    _pdunum = _pdunum;	/* to avoid C-compilation warning */
    return nullptr;
}

#endif
static long _edUnboundedDirectoryString(OssGlobal * _g, char ** _out_pos, long * _max_len, _UnboundedDirectoryString * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 0)
	    _data_len = _oss_encd_utf8unbound_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->u.uTF8String.value, _in_data->u.uTF8String.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x2C : 0xC);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 1)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.printableString.value, _in_data->u.printableString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 2)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.teletexString.value, _in_data->u.teletexString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x34 : 0x14);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 3)
	    _data_len = _oss_encd_unistr_ia(_g, _out_pos, &_out_len, (int *)_in_data->u.universalString.value, _in_data->u.universalString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3C : 0x1C);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 4)
	    _data_len = _oss_encd_bmpstr_ia(_g, _out_pos, &_out_len, _in_data->u.bmpString.value, _in_data->u.bmpString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x3E : 0x1E);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_UnboundedDirectoryString(OssGlobal * _g, _UnboundedDirectoryString * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 5) {

	    _oss_penc_nonneg_3int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 0)
	    _oss_penc_nkmstr_l(_g, _in_data->u.uTF8String.value, _in_data->u.uTF8String.length);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 1)
	    _oss_penc_kmstr(_g, _in_data->u.printableString.value, _in_data->u.printableString.length, _chars + 0, 0);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 2)
	    _oss_penc_nkmstr_l(_g, _in_data->u.teletexString.value, _in_data->u.teletexString.length);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 3)
	    _oss_penc_unistr(_g, (OSS_INT32 *)_in_data->u.universalString.value, _in_data->u.universalString.length, _chars + 1, 0);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 4)
	    _oss_penc_bmpstr(_g, _in_data->u.bmpString.value, _in_data->u.bmpString.length, _chars + 2, 0);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _edContextAssertion(OssGlobal * _g, char ** _out_pos, long * _max_len, _ContextAssertion * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 5)
	{
	    _setof11 * _temp;
	    unsigned long count;
	    unsigned long _lindex;
	    long _total_len = 0;
	    OSS_UINT32 _sp;
	    void **_st = _oss_load_enc_stack(_g, &_sp);
	    OSS_CNTX_NEW(_oss_c, 6)
	    for (_temp = _in_data->contextValues, count = 0; _temp; _temp = _temp->next) {
		OSS_CNTX_SETOCC(count + 1)
		if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		_st[_sp++] = _temp;
		count++;
	    }
	    if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
	    for (_lindex = 0; _lindex < count; _lindex++) {
		OSS_CNTX_SETOCC(count - _lindex)
		_temp = (_setof11 *)_st[--_sp];
		if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		if (count > 1) _oss_nextItem(_g, &_out_len);
		_oss_save_enc_stack(_g, _sp);
		if (_temp->value.encoded.length == 0)
		    _oss_enc_error(_g, _zero_length_OpenType, 0);
		_data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _temp->value.encoded.value, _temp->value.encoded.length);
		_st = _oss_load_enc_stack(_g, &_sp);
		_total_len += _data_len;
	    }
	    if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
	_total_len += _data_len;
	OSS_CNTX_SET(7)
	_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->contextType.value, _in_data->contextType.length, -1);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_ContextAssertion(OssGlobal * _g, _ContextAssertion * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 7)
	_oss_penc_eobjid_ia(_g, _in_data->contextType.value, _in_data->contextType.length, -1);
	OSS_CNTX_SET(5)
	{
	    _setof11 * _temp;
	    unsigned int _fragm_cnt;
	    unsigned int _cnt;
	    int _ext;
	    OSS_CNTX_INIT

	    for (_cnt = 0, _temp = _in_data->contextValues; _temp; _temp = _temp->next)
		++_cnt;

	    OSS_CNTX_PUSH(_oss_c, 6)
	    _ext = (_cnt >= 16384) ? 2 : 0;
	    for (_temp = _in_data->contextValues;; _cnt -= _fragm_cnt) {
		unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
		_fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		_fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
		for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		    OSS_CNTX_INCOCC
		    if (_temp->value.encoded.length == 0)
			_oss_enc_error(_g, _zero_length_OpenType, 0);
		    _oss_penc_unconstr_oct_l(_g, _temp->value.encoded.value, _temp->value.encoded.length);
		}
		if (_cnt == _fragm_cnt) {
		    if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
			_oss_append_8bit_aligned(_g, 0);
		    break;
		}
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _ed_choice1(OssGlobal * _g, char ** _out_pos, long * _max_len, _choice1 * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 8)
	    _data_len = _oss_encd_opentype(_g, _out_pos, &_out_len, &_in_data->u.single_ASN1_type);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 9)
	    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->u.octet_aligned.value, _in_data->u.octet_aligned.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA1 : 0x81);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 10)
	    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->u.arbitrary.value, _in_data->u.arbitrary.length, -1, FALSE);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA2 : 0x82);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep__choice1(OssGlobal * _g, _choice1 * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 3) {

	    _oss_penc_nonneg_2int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 8)
	    _oss_penc_opentype(_g, &_in_data->u.single_ASN1_type);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 9)
#if OSS_TOED_API_LEVEL >= 27
	    _oss_penc_uncon_oct(_g, (unsigned char *)_in_data->u.octet_aligned.value, _in_data->u.octet_aligned.length);
#else
	    _oss_penc_unconstr_oct_l(_g, (unsigned char *)_in_data->u.octet_aligned.value, _in_data->u.octet_aligned.length);
#endif
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 10)
#if OSS_TOED_API_LEVEL >= 27
	    _oss_penc_uncon_bit(_g, _in_data->u.arbitrary.value, _in_data->u.arbitrary.length);
#else
	    _oss_penc_unconstr_bit_l(_g, _in_data->u.arbitrary.value, _in_data->u.arbitrary.length, FALSE);
#endif
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _edExternal(OssGlobal * _g, char ** _out_pos, long * _max_len, _External * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 11)
	_data_len = _ed_choice1(_g, _out_pos, &_out_len, &_in_data->encoding);
	_total_len += _data_len;
	OSS_CNTX_SET(12)
	if (_in_data->bit_mask & 0x20000000) {
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->data_value_descriptor.value, _in_data->data_value_descriptor.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x27 : 0x7);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(13)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->indirect_reference, 0x2);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(14)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->direct_reference.value, _in_data->direct_reference.length, -1);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_External(OssGlobal * _g, _External * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	_oss_append_3bit_unaligned(_g, (unsigned char)(_in_data->bit_mask >> 24));
	OSS_CNTX_PUSH(_oss_c, 14)
	if (_in_data->bit_mask & 0x80000000) {
	    _oss_penc_eobjid_ia(_g, _in_data->direct_reference.value, _in_data->direct_reference.length, -1);
	}
	OSS_CNTX_SET(13)
	if (_in_data->bit_mask & 0x40000000) {
	    _oss_penc_unconstr_int_l(_g, _in_data->indirect_reference);
	}
	OSS_CNTX_SET(12)
	if (_in_data->bit_mask & 0x20000000) {
	    _oss_penc_nkmstr_l(_g, _in_data->data_value_descriptor.value, _in_data->data_value_descriptor.length);
	}
	OSS_CNTX_SET(11)
	_ep__choice1(_g, &_in_data->encoding);
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edName(OssGlobal * _g, char ** _out_pos, long * _max_len, _Name * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 15)
	    _data_len = _edRDNSequence(_g, _out_pos, &_out_len, &_in_data->u.rdnSequence);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_Name(OssGlobal * _g, _Name * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 15)
	    _ep_RDNSequence(_g, &_in_data->u.rdnSequence);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _edAP_title(OssGlobal * _g, char ** _out_pos, long * _max_len, _AP_title * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 16)
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->u.ap_title_form2.value, _in_data->u.ap_title_form2.length, -1);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 17)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.ap_title_form1 == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edName(_g, _out_pos, &_out_len, _in_data->u.ap_title_form1);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_AP_title(OssGlobal * _g, _AP_title * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 2) {

	    _oss_append_1bit_unaligned(_g, 0x00);
	    _oss_penc_nonneg_1int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 16)
	    _oss_penc_eobjid_ia(_g, _in_data->u.ap_title_form2.value, _in_data->u.ap_title_form2.length, -1);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 17)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.ap_title_form1 == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_Name(_g, _in_data->u.ap_title_form1);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _edAE_qualifier(OssGlobal * _g, char ** _out_pos, long * _max_len, _AE_qualifier * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 18)
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.ae_qualifier_form2, 0x2);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 19)
	    _data_len = _edRelativeDistinguishedName(_g, _out_pos, &_out_len, &_in_data->u.ae_qualifier_form1);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_AE_qualifier(OssGlobal * _g, _AE_qualifier * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 2) {

	    _oss_append_1bit_unaligned(_g, 0x00);
	    _oss_penc_nonneg_1int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 18)
	    _oss_penc_unconstr_int_l(_g, _in_data->u.ae_qualifier_form2);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 19)
	    _ep_RelativeDistinguishedName(_g, &_in_data->u.ae_qualifier_form1);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _edRealizationParameter(OssGlobal * _g, char ** _out_pos, long * _max_len, _RealizationParameter * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 20)
	if (_in_data->bit_mask & 0x80000000 &&
	    _oss_not_dflt_ia(_g, &_in_data->concatenation, (ossBoolean  *)&Context::default_fallback, sizeof(ossBoolean ), 0, -1, 8)) {
	    _data_len = _oss_encd_bool_tl(_g, _out_pos, &_out_len, 0x1, _in_data->concatenation);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(21)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->realization_type, 0xA);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_RealizationParameter(OssGlobal * _g, _RealizationParameter * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_UINT32 _bitmask = _in_data->bit_mask;
	OSS_CNTX_INIT

#ifdef OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES
	if (_g->encodingFlags & STRICT_PER_ENCODING_OF_DEFAULT_VALUES) {
	    if ((_bitmask & 0x80000000) &&
		!_oss_not_dflt_ia(_g, &_in_data->concatenation, (ossBoolean  *)&Context::default_fallback, sizeof(ossBoolean ), 0, -1, 8))
		_bitmask ^= 0x80000000;
	}
#endif /* OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES */
	_oss_append_1bit_unaligned(_g, (unsigned char)(_bitmask >> 24));
	OSS_CNTX_PUSH(_oss_c, 21)
	_oss_penc_uenum(_g, _in_data->realization_type, (struct _enum_data *)&_enums[0], nullptr);
	OSS_CNTX_SET(20)
	if (_bitmask & 0x80000000) {
	    _oss_append_1bit_unaligned(_g, (unsigned char)((_in_data->concatenation) ? 0x80 : 0x00) );
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edAuthentication_value(OssGlobal * _g, char ** _out_pos, long * _max_len, _Authentication_value * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 22)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.charstring.value, _in_data->u.charstring.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA0 : 0x80);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 23)
	    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->u.bitstring.value, _in_data->u.bitstring.length, -1, FALSE);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA1 : 0x81);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 24)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.external == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edExternal(_g, _out_pos, &_out_len, _in_data->u.external);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 25)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.other == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 26)
		if (_in_data->u.other->other_mechanism_value.encoded.length == 0)
		    _oss_enc_error(_g, _zero_length_OpenType, 0);
		_data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _in_data->u.other->other_mechanism_value.encoded.value, _in_data->u.other->other_mechanism_value.encoded.length);
		_total_len += _data_len;
		OSS_CNTX_SET(27)
		_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->u.other->other_mechanism_name.value, _in_data->u.other->other_mechanism_name.length, -1);
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
		_total_len += _data_len;
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA3);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_Authentication_value(OssGlobal * _g, _Authentication_value * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 4) {

	    _oss_penc_nonneg_2int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 22)
	    _oss_penc_nkmstr_l(_g, _in_data->u.charstring.value, _in_data->u.charstring.length);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 23)
#if OSS_TOED_API_LEVEL >= 27
	    _oss_penc_uncon_bit(_g, _in_data->u.bitstring.value, _in_data->u.bitstring.length);
#else
	    _oss_penc_unconstr_bit_l(_g, _in_data->u.bitstring.value, _in_data->u.bitstring.length, FALSE);
#endif
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 24)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.external == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_External(_g, _in_data->u.external);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 25)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.other == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 27)
		_oss_penc_eobjid_ia(_g, _in_data->u.other->other_mechanism_name.value, _in_data->u.other->other_mechanism_name.length, -1);
		OSS_CNTX_SET(26)
		if (_in_data->u.other->other_mechanism_value.encoded.length == 0)
		    _oss_enc_error(_g, _zero_length_OpenType, 0);
		_oss_penc_unconstr_oct_l(_g, _in_data->u.other->other_mechanism_value.encoded.value, _in_data->u.other->other_mechanism_value.encoded.length);
		OSS_CNTX_POP(_oss_c)
	    }
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _ed13Application_context_name_l(OssGlobal * _g, char ** _out_pos, long * _max_len, _Application_context_name_list ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_Application_context_name_list * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 28)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_Application_context_name_list *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _temp->value.value, _temp->value.length, -1);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_13Application_context_name_l(OssGlobal * _g, _Application_context_name_list ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	_Application_context_name_list * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	OSS_CNTX_PUSH(_oss_c, 28)
	_ext = (_cnt >= 16384) ? 2 : 0;
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
	    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
	    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		_oss_penc_eobjid_ia(_g, _temp->value.value, _temp->value.length, -1);
	    }
	    if (_cnt == _fragm_cnt) {
		if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
		    _oss_append_8bit_aligned(_g, 0);
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edAssociation_information(OssGlobal * _g, char ** _out_pos, long * _max_len, _Association_information ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_Association_information * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 29)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_Association_information *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _oss_save_enc_stack(_g, _sp);
	    _data_len = _edExternal(_g, _out_pos, &_out_len, &_temp->value);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x28);
	    _st = _oss_load_enc_stack(_g, &_sp);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_Association_information(OssGlobal * _g, _Association_information ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	_Association_information * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	if (_cnt == 1) {
	    _oss_append_1bit_unaligned(_g, 0);
	    _ext = 0;
	} else {
	    _oss_append_1bit_unaligned(_g, 0x80);
	    _ext = 1;
	}
	OSS_CNTX_PUSH(_oss_c, 29)
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

	    if (_ext)
#if OSS_TOED_API_LEVEL >= 27
		_fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		_fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    else
		_fragm_cnt = _cnt;
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		_ep_External(_g, &_temp->value);
	    }
	    if (_cnt == _fragm_cnt) {
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edMode_selector(OssGlobal * _g, char ** _out_pos, long * _max_len, _Mode_selector * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 30)
	_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->mode_value, 0x80);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_Mode_selector(OssGlobal * _g, _Mode_selector * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 30)
	_oss_penc_unconstr_int_l(_g, _in_data->mode_value);
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edConnectionData(OssGlobal * _g, char ** _out_pos, long * _max_len, _ConnectionData * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 31)
	    _data_len = _oss_encd_opentype(_g, _out_pos, &_out_len, &_in_data->u.open);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 32)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.recover == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edSessionConnectionIdentifier(_g, _out_pos, &_out_len, _in_data->u.recover);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_ConnectionData(OssGlobal * _g, _ConnectionData * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 2) {

	    _oss_penc_nonneg_1int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 31)
	    _oss_penc_opentype(_g, &_in_data->u.open);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 32)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.recover == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_SessionConnectionIdentifier(_g, _in_data->u.recover);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _edUser_data(OssGlobal * _g, char ** _out_pos, long * _max_len, _User_data * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 33)
	    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->u.simply_encoded_data.value, _in_data->u.simply_encoded_data.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x60 : 0x40);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 34)
	    _data_len = _edFully_encoded_data(_g, _out_pos, &_out_len, &_in_data->u.fully_encoded_data);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x61);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_User_data(OssGlobal * _g, _User_data * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 2) {

	    _oss_append_1bit_unaligned(_g, 0x00);
	    _oss_penc_nonneg_1int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 33)
#if OSS_TOED_API_LEVEL >= 27
	    _oss_penc_uncon_oct(_g, (unsigned char *)_in_data->u.simply_encoded_data.value, _in_data->u.simply_encoded_data.length);
#else
	    _oss_penc_unconstr_oct_l(_g, (unsigned char *)_in_data->u.simply_encoded_data.value, _in_data->u.simply_encoded_data.length);
#endif
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 34)
	    _ep_Fully_encoded_data(_g, &_in_data->u.fully_encoded_data);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _ed_seq7(OssGlobal * _g, char ** _out_pos, long * _max_len, _seq7 * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 35)
	{
	    _Application_context_name_list * _temp;
	    unsigned long count;
	    unsigned long _lindex;
	    long _total_len = 0;
	    OSS_UINT32 _sp;
	    void **_st = _oss_load_enc_stack(_g, &_sp);
	    OSS_CNTX_NEW(_oss_c, 36)
	    for (_temp = _in_data->transfer_syntax_name_list, count = 0; _temp; _temp = _temp->next) {
		OSS_CNTX_SETOCC(count + 1)
		if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		_st[_sp++] = _temp;
		count++;
	    }
	    for (_lindex = 0; _lindex < count; _lindex++) {
		OSS_CNTX_SETOCC(count - _lindex)
		_temp = (_Application_context_name_list *)_st[--_sp];
		if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _temp->value.value, _temp->value.length, -1);
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
		_total_len += _data_len;
	    }
	    _oss_save_enc_stack(_g, _sp);
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_SET(37)
	_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->abstract_syntax_name.value, _in_data->abstract_syntax_name.length, -1);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	_total_len += _data_len;
	OSS_CNTX_SET(38)
	_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->presentation_context_identifier, 0x2);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep__seq7(OssGlobal * _g, _seq7 * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 38)
	if (_in_data->presentation_context_identifier >= 1 && _in_data->presentation_context_identifier <= 127) {
	    _oss_append_1bit_unaligned(_g, 0x00);
	    _oss_penc_nonneg_7int(_g, _in_data->presentation_context_identifier - 1);
	} else {
	    _oss_append_1bit_unaligned(_g, 0x80);
	    _oss_penc_unconstr_int_l(_g, _in_data->presentation_context_identifier);
	}
	OSS_CNTX_SET(37)
	_oss_penc_eobjid_ia(_g, _in_data->abstract_syntax_name.value, _in_data->abstract_syntax_name.length, -1);
	OSS_CNTX_SET(35)
	{
	    _Application_context_name_list * _temp;
	    unsigned int _fragm_cnt;
	    unsigned int _cnt;
	    int _ext;
	    OSS_CNTX_INIT

	    for (_cnt = 0, _temp = _in_data->transfer_syntax_name_list; _temp; _temp = _temp->next)
		++_cnt;

	    OSS_CNTX_PUSH(_oss_c, 36)
	    _ext = (_cnt >= 16384) ? 2 : 0;
	    for (_temp = _in_data->transfer_syntax_name_list;; _cnt -= _fragm_cnt) {
		unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
		_fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		_fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
		for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		    OSS_CNTX_INCOCC
		    _oss_penc_eobjid_ia(_g, _temp->value.value, _temp->value.length, -1);
		}
		if (_cnt == _fragm_cnt) {
		    if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
			_oss_append_8bit_aligned(_g, 0);
		    break;
		}
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edContext_list(OssGlobal * _g, char ** _out_pos, long * _max_len, _Context_list ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_Context_list * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 29)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_Context_list *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _oss_save_enc_stack(_g, _sp);
	    _data_len = _ed_seq7(_g, _out_pos, &_out_len, &_temp->value);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _st = _oss_load_enc_stack(_g, &_sp);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_Context_list(OssGlobal * _g, _Context_list ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	_Context_list * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	if (_cnt <= 7) {
	    _oss_append_1bit_unaligned(_g, 0);
	    _ext = 0;
	} else {
	    _oss_append_1bit_unaligned(_g, 0x80);
	    _ext = 1;
	}
	OSS_CNTX_PUSH(_oss_c, 29)
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

	    if (_ext)
#if OSS_TOED_API_LEVEL >= 27
		_fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		_fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    else
#if OSS_TOED_API_LEVEL >= 27
		_oss_penc_lrang(_g, _fragm_cnt = _cnt, 0, 7);
#else
		_fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 7, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		_ep__seq7(_g, &_temp->value);
	    }
	    if (_cnt == _fragm_cnt) {
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _ed_seq8(OssGlobal * _g, char ** _out_pos, long * _max_len, _seq8 * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 39)
	_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->transfer_syntax_name.value, _in_data->transfer_syntax_name.length, -1);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	_total_len += _data_len;
	OSS_CNTX_SET(38)
	_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->presentation_context_identifier, 0x2);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep__seq8(OssGlobal * _g, _seq8 * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 38)
	if (_in_data->presentation_context_identifier >= 1 && _in_data->presentation_context_identifier <= 127) {
	    _oss_append_1bit_unaligned(_g, 0x00);
	    _oss_penc_nonneg_7int(_g, _in_data->presentation_context_identifier - 1);
	} else {
	    _oss_append_1bit_unaligned(_g, 0x80);
	    _oss_penc_unconstr_int_l(_g, _in_data->presentation_context_identifier);
	}
	OSS_CNTX_SET(39)
	_oss_penc_eobjid_ia(_g, _in_data->transfer_syntax_name.value, _in_data->transfer_syntax_name.length, -1);
	OSS_CNTX_POP(_oss_c)
    }
}

static long _ed14Presentation_context_ident(OssGlobal * _g, char ** _out_pos, long * _max_len, _Presentation_context_identifier_list ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_Presentation_context_identifier_list * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 29)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_Presentation_context_identifier_list *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _data_len = _ed_seq8(_g, _out_pos, &_out_len, &_temp->value);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_14Presentation_context_ident(OssGlobal * _g, _Presentation_context_identifier_list ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	_Presentation_context_identifier_list * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	if (_cnt <= 7) {
	    _oss_append_1bit_unaligned(_g, 0);
	    _ext = 0;
	} else {
	    _oss_append_1bit_unaligned(_g, 0x80);
	    _ext = 1;
	}
	OSS_CNTX_PUSH(_oss_c, 29)
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

	    if (_ext)
#if OSS_TOED_API_LEVEL >= 27
		_fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		_fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    else
#if OSS_TOED_API_LEVEL >= 27
		_oss_penc_lrang(_g, _fragm_cnt = _cnt, 0, 7);
#else
		_fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 7, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		_ep__seq8(_g, &_temp->value);
	    }
	    if (_cnt == _fragm_cnt) {
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _ed_seq9(OssGlobal * _g, char ** _out_pos, long * _max_len, _seq9 * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 40)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->provider_reason, 0x82);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(39)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->transfer_syntax_name.value, _in_data->transfer_syntax_name.length, -1);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x81);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(41)
	_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->result, 0x80);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep__seq9(OssGlobal * _g, _seq9 * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	_oss_append_2bit_unaligned(_g, (unsigned char)(_in_data->bit_mask >> 24));
	OSS_CNTX_PUSH(_oss_c, 41)
	_oss_penc_unconstr_int_l(_g, _in_data->result);
	OSS_CNTX_SET(39)
	if (_in_data->bit_mask & 0x80000000) {
	    _oss_penc_eobjid_ia(_g, _in_data->transfer_syntax_name.value, _in_data->transfer_syntax_name.length, -1);
	}
	OSS_CNTX_SET(40)
	if (_in_data->bit_mask & 0x40000000) {
	    _oss_penc_unconstr_int_l(_g, _in_data->provider_reason);
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edResult_list(OssGlobal * _g, char ** _out_pos, long * _max_len, _Result_list ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_Result_list * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 29)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_Result_list *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _data_len = _ed_seq9(_g, _out_pos, &_out_len, &_temp->value);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_Result_list(OssGlobal * _g, _Result_list ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	_Result_list * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	if (_cnt <= 7) {
	    _oss_append_1bit_unaligned(_g, 0);
	    _ext = 0;
	} else {
	    _oss_append_1bit_unaligned(_g, 0x80);
	    _ext = 1;
	}
	OSS_CNTX_PUSH(_oss_c, 29)
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

	    if (_ext)
#if OSS_TOED_API_LEVEL >= 27
		_fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		_fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    else
#if OSS_TOED_API_LEVEL >= 27
		_oss_penc_lrang(_g, _fragm_cnt = _cnt, 0, 7);
#else
		_fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 7, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		_ep__seq9(_g, &_temp->value);
	    }
	    if (_cnt == _fragm_cnt) {
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edPDV_list(OssGlobal * _g, char ** _out_pos, long * _max_len, _PDV_list * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 42)
	{
	    OSS_CNTX_INIT

	    switch (_in_data->presentation_data_values.choice) {
	    case 1:
		OSS_CNTX_PUSH(_oss_c, 8)
		_data_len = _oss_encd_opentype(_g, _out_pos, &_out_len, &_in_data->presentation_data_values.u.single_ASN1_type);
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
		break;
	    case 2:
		OSS_CNTX_PUSH(_oss_c, 9)
		_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->presentation_data_values.u.octet_aligned.value, _in_data->presentation_data_values.u.octet_aligned.length, -1);
		if (_data_len < 0) {
		    _constructed = TRUE;
		    _data_len = -_data_len;
		} else
		    _constructed = FALSE;
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA1 : 0x81);
		break;
	    case 3:
		OSS_CNTX_PUSH(_oss_c, 10)
		_data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->presentation_data_values.u.arbitrary.value, _in_data->presentation_data_values.u.arbitrary.length, -1, FALSE);
		if (_data_len < 0) {
		    _constructed = TRUE;
		    _data_len = -_data_len;
		} else
		    _constructed = FALSE;
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA2 : 0x82);
		break;
	    default:
		_oss_enc_error(_g, _bad_choice, _in_data->presentation_data_values.choice);	/* Bad choice selector. */
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_total_len += _data_len;
	OSS_CNTX_SET(38)
	_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->presentation_context_identifier, 0x2);
	_total_len += _data_len;
	OSS_CNTX_SET(39)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->transfer_syntax_name.value, _in_data->transfer_syntax_name.length, -1);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_PDV_list(OssGlobal * _g, _PDV_list * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	_oss_append_1bit_unaligned(_g, (unsigned char)(_in_data->bit_mask >> 24));
	OSS_CNTX_PUSH(_oss_c, 39)
	if (_in_data->bit_mask & 0x80000000) {
	    _oss_penc_eobjid_ia(_g, _in_data->transfer_syntax_name.value, _in_data->transfer_syntax_name.length, -1);
	}
	OSS_CNTX_SET(38)
	if (_in_data->presentation_context_identifier >= 1 && _in_data->presentation_context_identifier <= 127) {
	    _oss_append_1bit_unaligned(_g, 0x00);
	    _oss_penc_nonneg_7int(_g, _in_data->presentation_context_identifier - 1);
	} else {
	    _oss_append_1bit_unaligned(_g, 0x80);
	    _oss_penc_unconstr_int_l(_g, _in_data->presentation_context_identifier);
	}
	OSS_CNTX_SET(42)
	{
	    OSS_CNTX_INIT

	    if (_in_data->presentation_data_values.choice <= 3) {

		_oss_penc_nonneg_2int(_g, _in_data->presentation_data_values.choice - 1);
	    }
	    switch (_in_data->presentation_data_values.choice) {
	    case 1:
		OSS_CNTX_PUSH(_oss_c, 8)
		_oss_penc_opentype(_g, &_in_data->presentation_data_values.u.single_ASN1_type);
		break;
	    case 2:
		OSS_CNTX_PUSH(_oss_c, 9)
#if OSS_TOED_API_LEVEL >= 27
		_oss_penc_uncon_oct(_g, (unsigned char *)_in_data->presentation_data_values.u.octet_aligned.value, _in_data->presentation_data_values.u.octet_aligned.length);
#else
		_oss_penc_unconstr_oct_l(_g, (unsigned char *)_in_data->presentation_data_values.u.octet_aligned.value, _in_data->presentation_data_values.u.octet_aligned.length);
#endif
		break;
	    case 3:
		OSS_CNTX_PUSH(_oss_c, 10)
#if OSS_TOED_API_LEVEL >= 27
		_oss_penc_uncon_bit(_g, _in_data->presentation_data_values.u.arbitrary.value, _in_data->presentation_data_values.u.arbitrary.length);
#else
		_oss_penc_unconstr_bit_l(_g, _in_data->presentation_data_values.u.arbitrary.value, _in_data->presentation_data_values.u.arbitrary.length, FALSE);
#endif
		break;
	    default:
		_oss_enc_error(_g, _bad_choice, _in_data->presentation_data_values.choice);	/* Bad choice selector. */
	    }
	    OSS_CNTX_POP(_oss_c)
	}

	OSS_CNTX_POP(_oss_c)
    }
}

static long _edFully_encoded_data(OssGlobal * _g, char ** _out_pos, long * _max_len, _Fully_encoded_data ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_Fully_encoded_data * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 43)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_Fully_encoded_data *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _oss_save_enc_stack(_g, _sp);
	    _data_len = _edPDV_list(_g, _out_pos, &_out_len, &_temp->value);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _st = _oss_load_enc_stack(_g, &_sp);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_Fully_encoded_data(OssGlobal * _g, _Fully_encoded_data ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	_Fully_encoded_data * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	if (_cnt == 1) {
	    _oss_append_1bit_unaligned(_g, 0);
	    _ext = 0;
	} else {
	    _oss_append_1bit_unaligned(_g, 0x80);
	    _ext = 1;
	}
	OSS_CNTX_PUSH(_oss_c, 43)
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

	    if (_ext)
#if OSS_TOED_API_LEVEL >= 27
		_fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		_fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    else
		_fragm_cnt = _cnt;
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		_ep_PDV_list(_g, &_temp->value);
	    }
	    if (_cnt == _fragm_cnt) {
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edRTORQapdu(OssGlobal * _g, char ** _out_pos, long * _max_len, _set1 * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 44)
	if (_in_data->bit_mask & 0x10000000) {
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->applicationProtocol, 0x84);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(45)
	_data_len = _edConnectionData(_g, _out_pos, &_out_len, &_in_data->connectionDataRQ);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA3);
	_total_len += _data_len;
	OSS_CNTX_SET(46)
	if (_in_data->bit_mask & 0x20000000 &&
	    _oss_not_dflt_ia(_g, &_in_data->dialogueMode, (OSS_INT32  *)&__shared15::default_checkpointSize, sizeof(OSS_INT32 ), 0, -1, 0)) {
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->dialogueMode, 0x82);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(47)
	if (_in_data->bit_mask & 0x40000000 &&
	    _oss_not_dflt_ia(_g, &_in_data->windowSize, (OSS_INT32  *)&__shared15::default_windowSize, sizeof(OSS_INT32 ), 0, -1, 0)) {
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->windowSize, 0x81);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(48)
	if (_in_data->bit_mask & 0x80000000 &&
	    _oss_not_dflt_ia(_g, &_in_data->checkpointSize, (OSS_INT32  *)&__shared15::default_checkpointSize, sizeof(OSS_INT32 ), 0, -1, 0)) {
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->checkpointSize, 0x80);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_RTORQapdu(OssGlobal * _g, _set1 * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_UINT32 _bitmask = _in_data->bit_mask;
	OSS_CNTX_INIT

#ifdef OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES
	if (_g->encodingFlags & STRICT_PER_ENCODING_OF_DEFAULT_VALUES) {
	    if ((_bitmask & 0x80000000) &&
		!_oss_not_dflt_ia(_g, &_in_data->checkpointSize, (OSS_INT32  *)&__shared15::default_checkpointSize, sizeof(OSS_INT32 ), 0, -1, 0))
		_bitmask ^= 0x80000000;
	    if ((_bitmask & 0x40000000) &&
		!_oss_not_dflt_ia(_g, &_in_data->windowSize, (OSS_INT32  *)&__shared15::default_windowSize, sizeof(OSS_INT32 ), 0, -1, 0))
		_bitmask ^= 0x40000000;
	    if ((_bitmask & 0x20000000) &&
		!_oss_not_dflt_ia(_g, &_in_data->dialogueMode, (OSS_INT32  *)&__shared15::default_checkpointSize, sizeof(OSS_INT32 ), 0, -1, 0))
		_bitmask ^= 0x20000000;
	}
#endif /* OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES */
	_oss_append_4bit_unaligned(_g, (unsigned char)(_bitmask >> 24));
	OSS_CNTX_PUSH(_oss_c, 48)
	if (_bitmask & 0x80000000) {
	    _oss_penc_unconstr_int_l(_g, _in_data->checkpointSize);
	}
	OSS_CNTX_SET(47)
	if (_bitmask & 0x40000000) {
	    _oss_penc_unconstr_int_l(_g, _in_data->windowSize);
	}
	OSS_CNTX_SET(46)
	if (_bitmask & 0x20000000) {
	    _oss_penc_unconstr_int_l(_g, _in_data->dialogueMode);
	}
	OSS_CNTX_SET(45)
	_ep_ConnectionData(_g, &_in_data->connectionDataRQ);
	OSS_CNTX_SET(44)
	if (_bitmask & 0x10000000) {
	    _oss_penc_unconstr_int_l(_g, _in_data->applicationProtocol);
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edRTOACapdu(OssGlobal * _g, char ** _out_pos, long * _max_len, _set2 * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 49)
	_data_len = _edConnectionData(_g, _out_pos, &_out_len, &_in_data->connectionDataAC);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
	_total_len += _data_len;
	OSS_CNTX_SET(47)
	if (_in_data->bit_mask & 0x40000000 &&
	    _oss_not_dflt_ia(_g, &_in_data->windowSize, (OSS_INT32  *)&__shared15::default_windowSize, sizeof(OSS_INT32 ), 0, -1, 0)) {
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->windowSize, 0x81);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(48)
	if (_in_data->bit_mask & 0x80000000 &&
	    _oss_not_dflt_ia(_g, &_in_data->checkpointSize, (OSS_INT32  *)&__shared15::default_checkpointSize, sizeof(OSS_INT32 ), 0, -1, 0)) {
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->checkpointSize, 0x80);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_RTOACapdu(OssGlobal * _g, _set2 * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_UINT32 _bitmask = _in_data->bit_mask;
	OSS_CNTX_INIT

#ifdef OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES
	if (_g->encodingFlags & STRICT_PER_ENCODING_OF_DEFAULT_VALUES) {
	    if ((_bitmask & 0x80000000) &&
		!_oss_not_dflt_ia(_g, &_in_data->checkpointSize, (OSS_INT32  *)&__shared15::default_checkpointSize, sizeof(OSS_INT32 ), 0, -1, 0))
		_bitmask ^= 0x80000000;
	    if ((_bitmask & 0x40000000) &&
		!_oss_not_dflt_ia(_g, &_in_data->windowSize, (OSS_INT32  *)&__shared15::default_windowSize, sizeof(OSS_INT32 ), 0, -1, 0))
		_bitmask ^= 0x40000000;
	}
#endif /* OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES */
	_oss_append_2bit_unaligned(_g, (unsigned char)(_bitmask >> 24));
	OSS_CNTX_PUSH(_oss_c, 48)
	if (_bitmask & 0x80000000) {
	    _oss_penc_unconstr_int_l(_g, _in_data->checkpointSize);
	}
	OSS_CNTX_SET(47)
	if (_bitmask & 0x40000000) {
	    _oss_penc_unconstr_int_l(_g, _in_data->windowSize);
	}
	OSS_CNTX_SET(49)
	_ep_ConnectionData(_g, &_in_data->connectionDataAC);
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edRTORJapdu(OssGlobal * _g, char ** _out_pos, long * _max_len, _set3 * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 50)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _oss_encd_opentype(_g, _out_pos, &_out_len, &_in_data->userDataRJ);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(51)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->refuseReason, 0x80);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_RTORJapdu(OssGlobal * _g, _set3 * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	_oss_append_2bit_unaligned(_g, (unsigned char)(_in_data->bit_mask >> 24));
	OSS_CNTX_PUSH(_oss_c, 51)
	if (_in_data->bit_mask & 0x80000000) {
	    _oss_penc_unconstr_int_l(_g, _in_data->refuseReason);
	}
	OSS_CNTX_SET(50)
	if (_in_data->bit_mask & 0x40000000) {
	    _oss_penc_opentype(_g, &_in_data->userDataRJ);
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edCallingSSuserReference(OssGlobal * _g, char ** _out_pos, long * _max_len, _CallingSSuserReference * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 52)
	    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->u.octetString.value, _in_data->u.octetString.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 53)
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.t61String.value, _in_data->u.t61String.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x34 : 0x14);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_CallingSSuserReference(OssGlobal * _g, _CallingSSuserReference * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 2) {

	    _oss_penc_nonneg_1int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 52)
#if OSS_TOED_API_LEVEL >= 27
	    _oss_penc_uncon_oct(_g, (unsigned char *)_in_data->u.octetString.value, _in_data->u.octetString.length);
#else
	    _oss_penc_unconstr_oct_l(_g, (unsigned char *)_in_data->u.octetString.value, _in_data->u.octetString.length);
#endif
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 53)
	    _oss_penc_nkmstr_l(_g, _in_data->u.t61String.value, _in_data->u.t61String.length);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _edSessionConnectionIdentifier(OssGlobal * _g, char ** _out_pos, long * _max_len, _SessionConnectionIdentifier * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 54)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->additionalReferenceInformation.value, _in_data->additionalReferenceInformation.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA0 : 0x80);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(55)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_in_data->commonReference == nullptr)
	    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
	_data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->commonReference, -1, 1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x37 : 0x17);
	_total_len += _data_len;
	OSS_CNTX_SET(56)
	_data_len = _edCallingSSuserReference(_g, _out_pos, &_out_len, &_in_data->callingSSuserReference);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_SessionConnectionIdentifier(OssGlobal * _g, _SessionConnectionIdentifier * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	_oss_append_1bit_unaligned(_g, (unsigned char)(_in_data->bit_mask >> 24));
	OSS_CNTX_PUSH(_oss_c, 56)
	_ep_CallingSSuserReference(_g, &_in_data->callingSSuserReference);
	OSS_CNTX_SET(55)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_in_data->commonReference == nullptr)
	    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
	if(!(_g->encodingFlags & NOCONSTRAIN))
	    _oss_check_nullterm_time(_g, _in_data->commonReference, 1);
	_oss_penc_kmstr(_g, _in_data->commonReference, (unsigned long)strlen(_in_data->commonReference), _chars + 3, 0);
	OSS_CNTX_SET(54)
	if (_in_data->bit_mask & 0x80000000) {
	    _oss_penc_nkmstr_l(_g, _in_data->additionalReferenceInformation.value, _in_data->additionalReferenceInformation.length);
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edInvokeId(OssGlobal * _g, char ** _out_pos, long * _max_len, _InvokeId * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 57)
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.present, 0x2);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 58)
	    _data_len = 0;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x5);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_InvokeId(OssGlobal * _g, _InvokeId * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 2) {

	    _oss_penc_nonneg_1int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 57)
	    _oss_penc_unconstr_int_l(_g, _in_data->u.present);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 58)
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _edCriteria(OssGlobal * _g, char ** _out_pos, long * _max_len, _Criteria * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 59)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.type == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edCriteriaItem(_g, _out_pos, &_out_len, _in_data->u.type);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 60)
	    _data_len = _ed_setof1(_g, _out_pos, &_out_len, &_in_data->u.Criteria_and);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x31, 0xA1);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 61)
	    _data_len = _ed_setof2(_g, _out_pos, &_out_len, &_in_data->u.Criteria_or);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x31, 0xA2);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 62)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.Criteria_not == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edCriteria(_g, _out_pos, &_out_len, _in_data->u.Criteria_not);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA3);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_Criteria(OssGlobal * _g, _Criteria * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 4) {

	    _oss_penc_nonneg_2int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 59)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.type == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_CriteriaItem(_g, _in_data->u.type);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 60)
	    _ep__setof1(_g, &_in_data->u.Criteria_and);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 61)
	    _ep__setof2(_g, &_in_data->u.Criteria_or);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 62)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.Criteria_not == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_Criteria(_g, _in_data->u.Criteria_not);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _ed_setof2(OssGlobal * _g, char ** _out_pos, long * _max_len, _setof1 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_setof1 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 63)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_setof1 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    if (count > 1) _oss_nextItem(_g, &_out_len);
	    _oss_save_enc_stack(_g, _sp);
	    _data_len = _edCriteria(_g, _out_pos, &_out_len, &_temp->value);
	    _st = _oss_load_enc_stack(_g, &_sp);
	    _total_len += _data_len;
	}
	if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep__setof2(OssGlobal * _g, _setof1 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	_setof1 * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	OSS_CNTX_PUSH(_oss_c, 63)
	_ext = (_cnt >= 16384) ? 2 : 0;
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
	    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
	    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		_ep_Criteria(_g, &_temp->value);
	    }
	    if (_cnt == _fragm_cnt) {
		if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
		    _oss_append_8bit_aligned(_g, 0);
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _ed_setof1(OssGlobal * _g, char ** _out_pos, long * _max_len, _setof1 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_setof1 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 63)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_setof1 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    if (count > 1) _oss_nextItem(_g, &_out_len);
	    _oss_save_enc_stack(_g, _sp);
	    _data_len = _edCriteria(_g, _out_pos, &_out_len, &_temp->value);
	    _st = _oss_load_enc_stack(_g, &_sp);
	    _total_len += _data_len;
	}
	if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep__setof1(OssGlobal * _g, _setof1 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	_setof1 * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	OSS_CNTX_PUSH(_oss_c, 63)
	_ext = (_cnt >= 16384) ? 2 : 0;
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
	    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
	    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		_ep_Criteria(_g, &_temp->value);
	    }
	    if (_cnt == _fragm_cnt) {
		if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
		    _oss_append_8bit_aligned(_g, 0);
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edCriteriaItem(OssGlobal * _g, char ** _out_pos, long * _max_len, _CriteriaItem * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 64)
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->u.equality.value, _in_data->u.equality.length, -1);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x6, 0xA0);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 65)
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->u.substrings.value, _in_data->u.substrings.length, -1);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x6, 0xA1);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 66)
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->u.greaterOrEqual.value, _in_data->u.greaterOrEqual.length, -1);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x6, 0xA2);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 67)
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->u.lessOrEqual.value, _in_data->u.lessOrEqual.length, -1);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x6, 0xA3);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 68)
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->u.approximateMatch.value, _in_data->u.approximateMatch.length, -1);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x6, 0xA4);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_CriteriaItem(OssGlobal * _g, _CriteriaItem * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 5) {

	    _oss_penc_nonneg_3int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 64)
	    _oss_penc_eobjid_ia(_g, _in_data->u.equality.value, _in_data->u.equality.length, -1);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 65)
	    _oss_penc_eobjid_ia(_g, _in_data->u.substrings.value, _in_data->u.substrings.length, -1);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 66)
	    _oss_penc_eobjid_ia(_g, _in_data->u.greaterOrEqual.value, _in_data->u.greaterOrEqual.length, -1);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 67)
	    _oss_penc_eobjid_ia(_g, _in_data->u.lessOrEqual.value, _in_data->u.lessOrEqual.length, -1);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 68)
	    _oss_penc_eobjid_ia(_g, _in_data->u.approximateMatch.value, _in_data->u.approximateMatch.length, -1);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _edDayTime(OssGlobal * _g, char ** _out_pos, long * _max_len, _DayTime * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 69)
	if (_in_data->bit_mask & 0x40000000 &&
	    _oss_not_dflt_ia(_g, &_in_data->second, (OSS_UINT32  *)&DayTime::default_second, sizeof(OSS_UINT32 ), 0, -1, 55)) {
	    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->second, 0x2);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(70)
	if (_in_data->bit_mask & 0x80000000 &&
	    _oss_not_dflt_ia(_g, &_in_data->minute, (OSS_UINT32  *)&DayTime::default_minute, sizeof(OSS_UINT32 ), 0, -1, 55)) {
	    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->minute, 0x2);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(71)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->hour, 0x2);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_DayTime(OssGlobal * _g, _DayTime * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_UINT32 _bitmask = _in_data->bit_mask;
	OSS_CNTX_INIT

#ifdef OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES
	if (_g->encodingFlags & STRICT_PER_ENCODING_OF_DEFAULT_VALUES) {
	    if ((_bitmask & 0x80000000) &&
		!_oss_not_dflt_ia(_g, &_in_data->minute, (OSS_UINT32  *)&DayTime::default_minute, sizeof(OSS_UINT32 ), 0, -1, 55))
		_bitmask ^= 0x80000000;
	    if ((_bitmask & 0x40000000) &&
		!_oss_not_dflt_ia(_g, &_in_data->second, (OSS_UINT32  *)&DayTime::default_second, sizeof(OSS_UINT32 ), 0, -1, 55))
		_bitmask ^= 0x40000000;
	}
#endif /* OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES */
	_oss_append_2bit_unaligned(_g, (unsigned char)(_bitmask >> 24));
	OSS_CNTX_PUSH(_oss_c, 71)
	if (_in_data->hour <= 23) {
	    _oss_penc_nonneg_5int(_g, _in_data->hour);
	} else {
	    _oss_enc_error(_g, _valueRange_uinteger, _in_data->hour);
	}
	OSS_CNTX_SET(70)
	if (_bitmask & 0x80000000) {
	    if (_in_data->minute <= 59) {
		_oss_penc_nonneg_6int(_g, _in_data->minute);
	    } else {
		_oss_enc_error(_g, _valueRange_uinteger, _in_data->minute);
	    }
	}
	OSS_CNTX_SET(69)
	if (_bitmask & 0x40000000) {
	    if (_in_data->second <= 59) {
		_oss_penc_nonneg_6int(_g, _in_data->second);
	    } else {
		_oss_enc_error(_g, _valueRange_uinteger, _in_data->second);
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _ed_setof7(OssGlobal * _g, char ** _out_pos, long * _max_len, _Presentation_context_deletion_list ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_Presentation_context_deletion_list * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 72)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_Presentation_context_deletion_list *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    if (count > 1) _oss_nextItem(_g, &_out_len);
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _temp->value, 0x2);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep__setof7(OssGlobal * _g, _Presentation_context_deletion_list ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	_Presentation_context_deletion_list * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	OSS_CNTX_PUSH(_oss_c, 72)
	_ext = (_cnt >= 16384) ? 2 : 0;
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
	    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
	    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		_oss_penc_unconstr_int_l(_g, _temp->value);
	    }
	    if (_cnt == _fragm_cnt) {
		if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
		    _oss_append_8bit_aligned(_g, 0);
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edNamedDay(OssGlobal * _g, char ** _out_pos, long * _max_len, _NamedDay * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 73)
	    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->u.bitNamedDays.value, _in_data->u.bitNamedDays.length, -1, TRUE);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x23 : 0x3);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 74)
	    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->u.intNamedDays, 0xA);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_NamedDay(OssGlobal * _g, _NamedDay * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 2) {

	    _oss_penc_nonneg_1int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 73)
#if OSS_TOED_API_LEVEL >= 27
	    _oss_penc_uncon_bit(_g, _in_data->u.bitNamedDays.value, _in_data->u.bitNamedDays.length ? _oss_chop_zero_bits(_in_data->u.bitNamedDays.value, _in_data->u.bitNamedDays.length, 0) : _in_data->u.bitNamedDays.length);
#else
	    _oss_penc_unconstr_bit_l(_g, _in_data->u.bitNamedDays.value, _in_data->u.bitNamedDays.length, TRUE);
#endif
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 74)
	    _oss_penc_uenum(_g, _in_data->u.intNamedDays, (struct _enum_data *)&_enums[1], nullptr);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _edContext(OssGlobal * _g, char ** _out_pos, long * _max_len, _Context * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 75)
	if (_in_data->bit_mask & 0x80000000 &&
	    _oss_not_dflt_ia(_g, &_in_data->fallback, (ossBoolean  *)&Context::default_fallback, sizeof(ossBoolean ), 0, -1, 8)) {
	    _data_len = _oss_encd_bool_tl(_g, _out_pos, &_out_len, 0x1, _in_data->fallback);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(5)
	{
	    _setof11 * _temp;
	    unsigned long count;
	    unsigned long _lindex;
	    long _total_len = 0;
	    OSS_UINT32 _sp;
	    void **_st = _oss_load_enc_stack(_g, &_sp);
	    OSS_CNTX_NEW(_oss_c, 6)
	    for (_temp = _in_data->contextValues, count = 0; _temp; _temp = _temp->next) {
		OSS_CNTX_SETOCC(count + 1)
		if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		_st[_sp++] = _temp;
		count++;
	    }
	    if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
	    for (_lindex = 0; _lindex < count; _lindex++) {
		OSS_CNTX_SETOCC(count - _lindex)
		_temp = (_setof11 *)_st[--_sp];
		if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		if (count > 1) _oss_nextItem(_g, &_out_len);
		_oss_save_enc_stack(_g, _sp);
		if (_temp->value.encoded.length == 0)
		    _oss_enc_error(_g, _zero_length_OpenType, 0);
		_data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _temp->value.encoded.value, _temp->value.encoded.length);
		_st = _oss_load_enc_stack(_g, &_sp);
		_total_len += _data_len;
	    }
	    if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
	_total_len += _data_len;
	OSS_CNTX_SET(7)
	_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->contextType.value, _in_data->contextType.length, -1);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_Context(OssGlobal * _g, _Context * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_UINT32 _bitmask = _in_data->bit_mask;
	OSS_CNTX_INIT

#ifdef OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES
	if (_g->encodingFlags & STRICT_PER_ENCODING_OF_DEFAULT_VALUES) {
	    if ((_bitmask & 0x80000000) &&
		!_oss_not_dflt_ia(_g, &_in_data->fallback, (ossBoolean  *)&Context::default_fallback, sizeof(ossBoolean ), 0, -1, 8))
		_bitmask ^= 0x80000000;
	}
#endif /* OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES */
	_oss_append_1bit_unaligned(_g, (unsigned char)(_bitmask >> 24));
	OSS_CNTX_PUSH(_oss_c, 7)
	_oss_penc_eobjid_ia(_g, _in_data->contextType.value, _in_data->contextType.length, -1);
	OSS_CNTX_SET(5)
	{
	    _setof11 * _temp;
	    unsigned int _fragm_cnt;
	    unsigned int _cnt;
	    int _ext;
	    OSS_CNTX_INIT

	    for (_cnt = 0, _temp = _in_data->contextValues; _temp; _temp = _temp->next)
		++_cnt;

	    OSS_CNTX_PUSH(_oss_c, 6)
	    _ext = (_cnt >= 16384) ? 2 : 0;
	    for (_temp = _in_data->contextValues;; _cnt -= _fragm_cnt) {
		unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
		_fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		_fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
		for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		    OSS_CNTX_INCOCC
		    if (_temp->value.encoded.length == 0)
			_oss_enc_error(_g, _zero_length_OpenType, 0);
		    _oss_penc_unconstr_oct_l(_g, _temp->value.encoded.value, _temp->value.encoded.length);
		}
		if (_cnt == _fragm_cnt) {
		    if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
			_oss_append_8bit_aligned(_g, 0);
		    break;
		}
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_SET(75)
	if (_bitmask & 0x80000000) {
	    _oss_append_1bit_unaligned(_g, (unsigned char)((_in_data->fallback) ? 0x80 : 0x00) );
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edRDNSequence(OssGlobal * _g, char ** _out_pos, long * _max_len, _RDNSequence ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_RDNSequence * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 76)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_RDNSequence *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _oss_save_enc_stack(_g, _sp);
	    _data_len = _edRelativeDistinguishedName(_g, _out_pos, &_out_len, &_temp->value);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
	    _st = _oss_load_enc_stack(_g, &_sp);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_RDNSequence(OssGlobal * _g, _RDNSequence ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	_RDNSequence * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	OSS_CNTX_PUSH(_oss_c, 76)
	_ext = (_cnt >= 16384) ? 2 : 0;
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
	    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
	    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		_ep_RelativeDistinguishedName(_g, &_temp->value);
	    }
	    if (_cnt == _fragm_cnt) {
		if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
		    _oss_append_8bit_aligned(_g, 0);
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _ed15AttributeTypeAndDistinguis(OssGlobal * _g, char ** _out_pos, long * _max_len, _AttributeTypeAndDistinguishedValue * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 77)
	if (_in_data->bit_mask & 0x40000000) {
	    {
		_setof16 * _temp;
		unsigned long count;
		unsigned long _lindex;
		long _total_len = 0;
		OSS_UINT32 _sp;
		void **_st = _oss_load_enc_stack(_g, &_sp);
		OSS_CNTX_NEW(_oss_c, 29)
		for (_temp = _in_data->valuesWithContext, count = 0; _temp; _temp = _temp->next) {
		    OSS_CNTX_SETOCC(count + 1)
		    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		    _st[_sp++] = _temp;
		    count++;
		}
		if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
		for (_lindex = 0; _lindex < count; _lindex++) {
		    OSS_CNTX_SETOCC(count - _lindex)
		    _temp = (_setof16 *)_st[--_sp];
		    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		    if (count > 1) _oss_nextItem(_g, &_out_len);
		    _oss_save_enc_stack(_g, _sp);
		    {
			long _total_len = 0;
			OSS_CNTX_INIT

			OSS_CNTX_PUSH(_oss_c, 78)
			{
			    _setof15 * _temp1;
			    unsigned long count;
			    unsigned long _lindex;
			    long _total_len = 0;
			    OSS_CNTX_NEW(_oss_c, 79)
			    for (_temp1 = _temp->value.contextList, count = 0; _temp1; _temp1 = _temp1->next) {
				OSS_CNTX_SETOCC(count + 1)
				if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
				_st[_sp++] = _temp1;
				count++;
			    }
			    if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
			    for (_lindex = 0; _lindex < count; _lindex++) {
				OSS_CNTX_SETOCC(count - _lindex)
				_temp1 = (_setof15 *)_st[--_sp];
				if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
				if (count > 1) _oss_nextItem(_g, &_out_len);
				_oss_save_enc_stack(_g, _sp);
				_data_len = _edContext(_g, _out_pos, &_out_len, &_temp1->value);
				_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
				_st = _oss_load_enc_stack(_g, &_sp);
				_total_len += _data_len;
			    }
			    if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
			    OSS_CNTX_POP(_oss_c)
			    _data_len = _total_len;
			}
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
			_total_len += _data_len;
			OSS_CNTX_SET(80)
			if (_temp->value.bit_mask & 0x80000000) {
			    if (_temp->value.distingAttrValue.encoded.length == 0)
				_oss_enc_error(_g, _zero_length_OpenType, 0);
			    _data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _temp->value.distingAttrValue.encoded.value, _temp->value.distingAttrValue.encoded.length);
			    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
			    _total_len += _data_len;
			}
			OSS_CNTX_POP(_oss_c)
			_data_len = _total_len;
		    }
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
		    _st = _oss_load_enc_stack(_g, &_sp);
		    _total_len += _data_len;
		}
		if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(81)
	if (_in_data->bit_mask & 0x80000000 &&
	    _oss_not_dflt_ia(_g, &_in_data->primaryDistinguished, (ossBoolean  *)&AttributeTypeAndDistinguishedValue::default_primaryDistinguished, sizeof(ossBoolean ), 0, -1, 8)) {
	    _data_len = _oss_encd_bool_tl(_g, _out_pos, &_out_len, 0x1, _in_data->primaryDistinguished);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(82)
	if (_in_data->value.encoded.length == 0)
	    _oss_enc_error(_g, _zero_length_OpenType, 0);
	_data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _in_data->value.encoded.value, _in_data->value.encoded.length);
	_total_len += _data_len;
	OSS_CNTX_SET(83)
	_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->type.value, _in_data->type.length, -1);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_15AttributeTypeAndDistinguis(OssGlobal * _g, _AttributeTypeAndDistinguishedValue * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_UINT32 _bitmask = _in_data->bit_mask;
	OSS_CNTX_INIT

#ifdef OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES
	if (_g->encodingFlags & STRICT_PER_ENCODING_OF_DEFAULT_VALUES) {
	    if ((_bitmask & 0x80000000) &&
		!_oss_not_dflt_ia(_g, &_in_data->primaryDistinguished, (ossBoolean  *)&AttributeTypeAndDistinguishedValue::default_primaryDistinguished, sizeof(ossBoolean ), 0, -1, 8))
		_bitmask ^= 0x80000000;
	}
#endif /* OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES */
	_oss_append_2bit_unaligned(_g, (unsigned char)(_bitmask >> 24));
	OSS_CNTX_PUSH(_oss_c, 83)
	_oss_penc_eobjid_ia(_g, _in_data->type.value, _in_data->type.length, -1);
	OSS_CNTX_SET(82)
	if (_in_data->value.encoded.length == 0)
	    _oss_enc_error(_g, _zero_length_OpenType, 0);
	_oss_penc_unconstr_oct_l(_g, _in_data->value.encoded.value, _in_data->value.encoded.length);
	OSS_CNTX_SET(81)
	if (_bitmask & 0x80000000) {
	    _oss_append_1bit_unaligned(_g, (unsigned char)((_in_data->primaryDistinguished) ? 0x80 : 0x00) );
	}
	OSS_CNTX_SET(77)
	if (_bitmask & 0x40000000) {
	    {
		_setof16 * _temp;
		unsigned int _fragm_cnt;
		unsigned int _cnt;
		int _ext;
		OSS_CNTX_INIT

		for (_cnt = 0, _temp = _in_data->valuesWithContext; _temp; _temp = _temp->next)
		    ++_cnt;

		OSS_CNTX_PUSH(_oss_c, 29)
		_ext = (_cnt >= 16384) ? 2 : 0;
		for (_temp = _in_data->valuesWithContext;; _cnt -= _fragm_cnt) {
		    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
		    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
		    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
			OSS_CNTX_INCOCC
			{
			    OSS_CNTX_INIT

			    _oss_append_1bit_unaligned(_g, (unsigned char)(_temp->value.bit_mask >> 24));
			    OSS_CNTX_PUSH(_oss_c, 80)
			    if (_temp->value.bit_mask & 0x80000000) {
				if (_temp->value.distingAttrValue.encoded.length == 0)
				    _oss_enc_error(_g, _zero_length_OpenType, 0);
				_oss_penc_unconstr_oct_l(_g, _temp->value.distingAttrValue.encoded.value, _temp->value.distingAttrValue.encoded.length);
			    }
			    OSS_CNTX_SET(78)
			    {
				_setof15 * _temp1;
				unsigned int _fragm_cnt1;
				unsigned int _cnt1;
				int _ext1;
				OSS_CNTX_INIT

				for (_cnt1 = 0, _temp1 = _temp->value.contextList; _temp1; _temp1 = _temp1->next)
				    ++_cnt1;

				OSS_CNTX_PUSH(_oss_c, 79)
				_ext1 = (_cnt1 >= 16384) ? 2 : 0;
				for (_temp1 = _temp->value.contextList;; _cnt1 -= _fragm_cnt1) {
				    unsigned int _idx1;

#if OSS_TOED_API_LEVEL >= 27
				    _fragm_cnt1 = _oss_penc_lfrag(_g, _cnt1);
#else
				    _fragm_cnt1 = (unsigned int)_oss_penc_length_l(_g, _cnt1, 0, 0, 0);
#endif
				    for (_idx1 = 0; _idx1 < _fragm_cnt1; ++_idx1, _temp1 = _temp1->next) {
					OSS_CNTX_INCOCC
					_ep_Context(_g, &_temp1->value);
				    }
				    if (_cnt1 == _fragm_cnt1) {
					if ((_ext1 & 2) && (_fragm_cnt1 & 0x3FFF) == 0)
					    _oss_append_8bit_aligned(_g, 0);
					break;
				    }
				}
				OSS_CNTX_POP(_oss_c)
			    }
			    OSS_CNTX_POP(_oss_c)
			}
		    }
		    if (_cnt == _fragm_cnt) {
			if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
			    _oss_append_8bit_aligned(_g, 0);
			break;
		    }
		}
		OSS_CNTX_POP(_oss_c)
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edRelativeDistinguishedName(OssGlobal * _g, char ** _out_pos, long * _max_len, _RelativeDistinguishedName ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_RelativeDistinguishedName * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 84)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_RelativeDistinguishedName *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    if (count > 1) _oss_nextItem(_g, &_out_len);
	    _oss_save_enc_stack(_g, _sp);
	    _data_len = _ed15AttributeTypeAndDistinguis(_g, _out_pos, &_out_len, &_temp->value);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _st = _oss_load_enc_stack(_g, &_sp);
	    _total_len += _data_len;
	}
	if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_RelativeDistinguishedName(OssGlobal * _g, _RelativeDistinguishedName ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	_RelativeDistinguishedName * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	OSS_CNTX_PUSH(_oss_c, 84)
	_ext = (_cnt >= 16384) ? 2 : 0;
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
	    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
	    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		_ep_15AttributeTypeAndDistinguis(_g, &_temp->value);
	    }
	    if (_cnt == _fragm_cnt) {
		if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
		    _oss_append_8bit_aligned(_g, 0);
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _edRefinement(OssGlobal * _g, char ** _out_pos, long * _max_len, _Refinement * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 85)
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->u.item.value, _in_data->u.item.length, -1);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x6, 0xA0);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 60)
	    _data_len = _ed_setof17(_g, _out_pos, &_out_len, &_in_data->u.Refinement_and);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x31, 0xA1);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 61)
	    _data_len = _ed_setof18(_g, _out_pos, &_out_len, &_in_data->u.Refinement_or);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x31, 0xA2);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 86)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.Refinement_not == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edRefinement(_g, _out_pos, &_out_len, _in_data->u.Refinement_not);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA3);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep_Refinement(OssGlobal * _g, _Refinement * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 4) {

	    _oss_penc_nonneg_2int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 85)
	    _oss_penc_eobjid_ia(_g, _in_data->u.item.value, _in_data->u.item.length, -1);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 60)
	    _ep__setof17(_g, &_in_data->u.Refinement_and);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 61)
	    _ep__setof18(_g, &_in_data->u.Refinement_or);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 86)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.Refinement_not == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_Refinement(_g, _in_data->u.Refinement_not);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

}

static long _ed_setof18(OssGlobal * _g, char ** _out_pos, long * _max_len, _setof17 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_setof17 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 87)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_setof17 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    if (count > 1) _oss_nextItem(_g, &_out_len);
	    _oss_save_enc_stack(_g, _sp);
	    _data_len = _edRefinement(_g, _out_pos, &_out_len, &_temp->value);
	    _st = _oss_load_enc_stack(_g, &_sp);
	    _total_len += _data_len;
	}
	if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep__setof18(OssGlobal * _g, _setof17 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	_setof17 * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	OSS_CNTX_PUSH(_oss_c, 87)
	_ext = (_cnt >= 16384) ? 2 : 0;
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
	    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
	    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		_ep_Refinement(_g, &_temp->value);
	    }
	    if (_cnt == _fragm_cnt) {
		if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
		    _oss_append_8bit_aligned(_g, 0);
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static long _ed_setof17(OssGlobal * _g, char ** _out_pos, long * _max_len, _setof17 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_setof17 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 87)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_setof17 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    if (count > 1) _oss_nextItem(_g, &_out_len);
	    _oss_save_enc_stack(_g, _sp);
	    _data_len = _edRefinement(_g, _out_pos, &_out_len, &_temp->value);
	    _st = _oss_load_enc_stack(_g, &_sp);
	    _total_len += _data_len;
	}
	if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _ep__setof17(OssGlobal * _g, _setof17 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    {
	_setof17 * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	OSS_CNTX_PUSH(_oss_c, 87)
	_ext = (_cnt >= 16384) ? 2 : 0;
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
	    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
	    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		_ep_Refinement(_g, &_temp->value);
	    }
	    if (_cnt == _fragm_cnt) {
		if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
		    _oss_append_8bit_aligned(_g, 0);
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
}

static void _eOssEncOID(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssEncOID	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssEncOID *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(1,88)
    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epOssEncOID(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssEncOID	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssEncOID *) _inbuf;
    OSS_CNTX_ANCHOR_SET(1,88)
    _oss_penc_eobjid_ia(_g, _in_data->value, _in_data->length, -1);
    OSS_CNTX_POP(_oss_c)
}

static void _eACSE_apdu(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ACSE_apdu	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_ACSE_apdu *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(2,89)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 90)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.aarq == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 91)
		if (_in_data->u.aarq->bit_mask & 0x20000) {
		    _data_len = _edAssociation_information(_g, _out_pos, &_out_len, &_in_data->u.aarq->user_information);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xBE);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(92)
		if (_in_data->u.aarq->bit_mask & 0x40000) {
		    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.aarq->implementation_information.value, _in_data->u.aarq->implementation_information.length, -1);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xBD : 0x9D);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(93)
		if (_in_data->u.aarq->bit_mask & 0x80000) {
		    _data_len = _ed13Application_context_name_l(_g, _out_pos, &_out_len, &_in_data->u.aarq->application_context_name_list);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xAD);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(94)
		if (_in_data->u.aarq->bit_mask & 0x100000) {
		    _data_len = _edAuthentication_value(_g, _out_pos, &_out_len, &_in_data->u.aarq->calling_authentication_value);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xAC);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(95)
		if (_in_data->u.aarq->bit_mask & 0x200000) {
		    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->u.aarq->mechanism_name.value, _in_data->u.aarq->mechanism_name.length, -1);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x8B);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(96)
		if (_in_data->u.aarq->bit_mask & 0x400000) {
		    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->u.aarq->sender_acse_requirements.value, _in_data->u.aarq->sender_acse_requirements.length, -1, TRUE);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xAA : 0x8A);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(97)
		if (_in_data->u.aarq->bit_mask & 0x800000) {
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.aarq->calling_AE_invocation_identifier, 0x2);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA9);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(98)
		if (_in_data->u.aarq->bit_mask & 0x1000000) {
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.aarq->calling_AP_invocation_identifier, 0x2);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA8);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(99)
		if (_in_data->u.aarq->bit_mask & 0x2000000) {
		    _data_len = _edAE_qualifier(_g, _out_pos, &_out_len, &_in_data->u.aarq->calling_AE_qualifier);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA7);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(100)
		if (_in_data->u.aarq->bit_mask & 0x4000000) {
		    _data_len = _edAP_title(_g, _out_pos, &_out_len, &_in_data->u.aarq->calling_AP_title);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA6);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(101)
		if (_in_data->u.aarq->bit_mask & 0x8000000) {
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.aarq->called_AE_invocation_identifier, 0x2);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA5);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(102)
		if (_in_data->u.aarq->bit_mask & 0x10000000) {
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.aarq->called_AP_invocation_identifier, 0x2);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA4);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(103)
		if (_in_data->u.aarq->bit_mask & 0x20000000) {
		    _data_len = _edAE_qualifier(_g, _out_pos, &_out_len, &_in_data->u.aarq->called_AE_qualifier);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA3);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(104)
		if (_in_data->u.aarq->bit_mask & 0x40000000) {
		    _data_len = _edAP_title(_g, _out_pos, &_out_len, &_in_data->u.aarq->called_AP_title);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(105)
		_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->u.aarq->application_context_name.value, _in_data->u.aarq->application_context_name.length, -1);
		_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x6, 0xA1);
		_total_len += _data_len;
		OSS_CNTX_SET(106)
		if (_in_data->u.aarq->bit_mask & 0x80000000 &&
		    _oss_not_dflt_ia(_g, &_in_data->u.aarq->protocol_version, (OSSC::COssBitString  *)&_v628, 4, _VARY_OFFSET_0, -1, 3)) {
		    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->u.aarq->protocol_version.value, _in_data->u.aarq->protocol_version.length, -1, TRUE);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA0 : 0x80);
		    _total_len += _data_len;
		}
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x60);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 107)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.aare == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 91)
		if (_in_data->u.aare->bit_mask & 0x200000) {
		    _data_len = _edAssociation_information(_g, _out_pos, &_out_len, &_in_data->u.aare->user_information);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xBE);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(92)
		if (_in_data->u.aare->bit_mask & 0x400000) {
		    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->u.aare->implementation_information.value, _in_data->u.aare->implementation_information.length, -1);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xBD : 0x9D);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(93)
		if (_in_data->u.aare->bit_mask & 0x800000) {
		    _data_len = _ed13Application_context_name_l(_g, _out_pos, &_out_len, &_in_data->u.aare->application_context_name_list);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xAB);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(108)
		if (_in_data->u.aare->bit_mask & 0x1000000) {
		    _data_len = _edAuthentication_value(_g, _out_pos, &_out_len, &_in_data->u.aare->responding_authentication_value);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xAA);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(95)
		if (_in_data->u.aare->bit_mask & 0x2000000) {
		    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->u.aare->mechanism_name.value, _in_data->u.aare->mechanism_name.length, -1);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x89);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(109)
		if (_in_data->u.aare->bit_mask & 0x4000000) {
		    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->u.aare->responder_acse_requirements.value, _in_data->u.aare->responder_acse_requirements.length, -1, TRUE);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA8 : 0x88);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(110)
		if (_in_data->u.aare->bit_mask & 0x8000000) {
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.aare->responding_AE_invocation_identifier, 0x2);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA7);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(111)
		if (_in_data->u.aare->bit_mask & 0x10000000) {
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.aare->responding_AP_invocation_identifier, 0x2);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA6);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(112)
		if (_in_data->u.aare->bit_mask & 0x20000000) {
		    _data_len = _edAE_qualifier(_g, _out_pos, &_out_len, &_in_data->u.aare->responding_AE_qualifier);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA5);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(113)
		if (_in_data->u.aare->bit_mask & 0x40000000) {
		    _data_len = _edAP_title(_g, _out_pos, &_out_len, &_in_data->u.aare->responding_AP_title);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA4);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(114)
		{
		    OSS_CNTX_INIT

		    switch (_in_data->u.aare->result_source_diagnostic.choice) {
		    case 1:
			OSS_CNTX_PUSH(_oss_c, 115)
			_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.aare->result_source_diagnostic.u.acse_service_user, 0x2);
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
			break;
		    case 2:
			OSS_CNTX_PUSH(_oss_c, 116)
			_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.aare->result_source_diagnostic.u.acse_service_provider, 0x2);
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
			break;
		    default:
			_oss_enc_error(_g, _bad_choice, _in_data->u.aare->result_source_diagnostic.choice);	/* Bad choice selector. */
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA3);
		_total_len += _data_len;
		OSS_CNTX_SET(117)
		_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.aare->result, 0x2);
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
		_total_len += _data_len;
		OSS_CNTX_SET(105)
		_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->u.aare->application_context_name.value, _in_data->u.aare->application_context_name.length, -1);
		_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x6, 0xA1);
		_total_len += _data_len;
		OSS_CNTX_SET(106)
		if (_in_data->u.aare->bit_mask & 0x80000000 &&
		    _oss_not_dflt_ia(_g, &_in_data->u.aare->protocol_version, (OSSC::COssBitString  *)&_v630, 4, _VARY_OFFSET_0, -1, 3)) {
		    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->u.aare->protocol_version.value, _in_data->u.aare->protocol_version.length, -1, TRUE);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA0 : 0x80);
		    _total_len += _data_len;
		}
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x61);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 118)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.rlrq == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 91)
		if (_in_data->u.rlrq->bit_mask & 0x40000000) {
		    _data_len = _edAssociation_information(_g, _out_pos, &_out_len, &_in_data->u.rlrq->user_information);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xBE);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(119)
		if (_in_data->u.rlrq->bit_mask & 0x80000000) {
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.rlrq->reason, 0x80);
		    _total_len += _data_len;
		}
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x62);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 120)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.rlre == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 91)
		if (_in_data->u.rlre->bit_mask & 0x40000000) {
		    _data_len = _edAssociation_information(_g, _out_pos, &_out_len, &_in_data->u.rlre->user_information);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xBE);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(121)
		if (_in_data->u.rlre->bit_mask & 0x80000000) {
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.rlre->reason, 0x80);
		    _total_len += _data_len;
		}
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x63);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 122)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.abrt == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 91)
		if (_in_data->u.abrt->bit_mask & 0x40000000) {
		    _data_len = _edAssociation_information(_g, _out_pos, &_out_len, &_in_data->u.abrt->user_information);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xBE);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(123)
		if (_in_data->u.abrt->bit_mask & 0x80000000) {
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, (int)_in_data->u.abrt->abort_diagnostic, 0x81);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(124)
		_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.abrt->abort_source, 0x80);
		_total_len += _data_len;
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x64);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epACSE_apdu(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ACSE_apdu	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_ACSE_apdu *) _inbuf;
    OSS_CNTX_ANCHOR_SET(2,89)
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 5) {

	    _oss_append_1bit_unaligned(_g, 0x00);
	    _oss_penc_nonneg_3int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 90)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.aarq == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		unsigned char _extPres = 0x00;
		OSS_UINT32 _bitmask = _in_data->u.aarq->bit_mask;
		OSS_CNTX_INIT

#ifdef OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES
		if (_g->encodingFlags & STRICT_PER_ENCODING_OF_DEFAULT_VALUES) {
		    if ((_bitmask & 0x80000000) &&
			!_oss_not_dflt_ia(_g, &_in_data->u.aarq->protocol_version, (OSSC::COssBitString  *)&_v628, 4, _VARY_OFFSET_0, -1, 3))
			_bitmask ^= 0x80000000;
		}
#endif /* OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES */
		_oss_append_1bit_unaligned(_g, _extPres);
		_oss_penc_nonneg_int_l(_g, (unsigned long)_bitmask >> 17, 15);
		OSS_CNTX_PUSH(_oss_c, 106)
		if (_bitmask & 0x80000000) {
#if OSS_TOED_API_LEVEL >= 27
		    _oss_penc_uncon_bit(_g, _in_data->u.aarq->protocol_version.value, _in_data->u.aarq->protocol_version.length ? _oss_chop_zero_bits(_in_data->u.aarq->protocol_version.value, _in_data->u.aarq->protocol_version.length, 0) : _in_data->u.aarq->protocol_version.length);
#else
		    _oss_penc_unconstr_bit_l(_g, _in_data->u.aarq->protocol_version.value, _in_data->u.aarq->protocol_version.length, TRUE);
#endif
		}
		OSS_CNTX_SET(105)
		_oss_penc_eobjid_ia(_g, _in_data->u.aarq->application_context_name.value, _in_data->u.aarq->application_context_name.length, -1);
		OSS_CNTX_SET(104)
		if (_bitmask & 0x40000000) {
		    _ep_AP_title(_g, &_in_data->u.aarq->called_AP_title);
		}
		OSS_CNTX_SET(103)
		if (_bitmask & 0x20000000) {
		    _ep_AE_qualifier(_g, &_in_data->u.aarq->called_AE_qualifier);
		}
		OSS_CNTX_SET(102)
		if (_bitmask & 0x10000000) {
		    _oss_penc_unconstr_int_l(_g, _in_data->u.aarq->called_AP_invocation_identifier);
		}
		OSS_CNTX_SET(101)
		if (_bitmask & 0x8000000) {
		    _oss_penc_unconstr_int_l(_g, _in_data->u.aarq->called_AE_invocation_identifier);
		}
		OSS_CNTX_SET(100)
		if (_bitmask & 0x4000000) {
		    _ep_AP_title(_g, &_in_data->u.aarq->calling_AP_title);
		}
		OSS_CNTX_SET(99)
		if (_bitmask & 0x2000000) {
		    _ep_AE_qualifier(_g, &_in_data->u.aarq->calling_AE_qualifier);
		}
		OSS_CNTX_SET(98)
		if (_bitmask & 0x1000000) {
		    _oss_penc_unconstr_int_l(_g, _in_data->u.aarq->calling_AP_invocation_identifier);
		}
		OSS_CNTX_SET(97)
		if (_bitmask & 0x800000) {
		    _oss_penc_unconstr_int_l(_g, _in_data->u.aarq->calling_AE_invocation_identifier);
		}
		OSS_CNTX_SET(96)
		if (_bitmask & 0x400000) {
#if OSS_TOED_API_LEVEL >= 27
		    _oss_penc_uncon_bit(_g, _in_data->u.aarq->sender_acse_requirements.value, _in_data->u.aarq->sender_acse_requirements.length ? _oss_chop_zero_bits(_in_data->u.aarq->sender_acse_requirements.value, _in_data->u.aarq->sender_acse_requirements.length, 0) : _in_data->u.aarq->sender_acse_requirements.length);
#else
		    _oss_penc_unconstr_bit_l(_g, _in_data->u.aarq->sender_acse_requirements.value, _in_data->u.aarq->sender_acse_requirements.length, TRUE);
#endif
		}
		OSS_CNTX_SET(95)
		if (_bitmask & 0x200000) {
		    _oss_penc_eobjid_ia(_g, _in_data->u.aarq->mechanism_name.value, _in_data->u.aarq->mechanism_name.length, -1);
		}
		OSS_CNTX_SET(94)
		if (_bitmask & 0x100000) {
		    _ep_Authentication_value(_g, &_in_data->u.aarq->calling_authentication_value);
		}
		OSS_CNTX_SET(93)
		if (_bitmask & 0x80000) {
		    _ep_13Application_context_name_l(_g, &_in_data->u.aarq->application_context_name_list);
		}
		OSS_CNTX_SET(92)
		if (_bitmask & 0x40000) {
		    _oss_penc_nkmstr_l(_g, _in_data->u.aarq->implementation_information.value, _in_data->u.aarq->implementation_information.length);
		}
		OSS_CNTX_SET(91)
		if (_bitmask & 0x20000) {
		    _ep_Association_information(_g, &_in_data->u.aarq->user_information);
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 107)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.aare == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		unsigned char _extPres = 0x00;
		OSS_UINT32 _bitmask = _in_data->u.aare->bit_mask;
		OSS_CNTX_INIT

#ifdef OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES
		if (_g->encodingFlags & STRICT_PER_ENCODING_OF_DEFAULT_VALUES) {
		    if ((_bitmask & 0x80000000) &&
			!_oss_not_dflt_ia(_g, &_in_data->u.aare->protocol_version, (OSSC::COssBitString  *)&_v630, 4, _VARY_OFFSET_0, -1, 3))
			_bitmask ^= 0x80000000;
		}
#endif /* OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES */
		_oss_append_1bit_unaligned(_g, _extPres);
		_oss_penc_nonneg_int_l(_g, (unsigned long)_bitmask >> 21, 11);
		OSS_CNTX_PUSH(_oss_c, 106)
		if (_bitmask & 0x80000000) {
#if OSS_TOED_API_LEVEL >= 27
		    _oss_penc_uncon_bit(_g, _in_data->u.aare->protocol_version.value, _in_data->u.aare->protocol_version.length ? _oss_chop_zero_bits(_in_data->u.aare->protocol_version.value, _in_data->u.aare->protocol_version.length, 0) : _in_data->u.aare->protocol_version.length);
#else
		    _oss_penc_unconstr_bit_l(_g, _in_data->u.aare->protocol_version.value, _in_data->u.aare->protocol_version.length, TRUE);
#endif
		}
		OSS_CNTX_SET(105)
		_oss_penc_eobjid_ia(_g, _in_data->u.aare->application_context_name.value, _in_data->u.aare->application_context_name.length, -1);
		OSS_CNTX_SET(117)
		if (_in_data->u.aare->result >= 0 && _in_data->u.aare->result <= 2) {
		    _oss_append_1bit_unaligned(_g, 0x00);
		    _oss_penc_nonneg_2int(_g, _in_data->u.aare->result);
		} else {
		    _oss_append_1bit_unaligned(_g, 0x80);
		    _oss_penc_unconstr_int_l(_g, _in_data->u.aare->result);
		}
		OSS_CNTX_SET(114)
		{
		    OSS_CNTX_INIT

		    if (_in_data->u.aare->result_source_diagnostic.choice <= 2) {

			_oss_penc_nonneg_1int(_g, _in_data->u.aare->result_source_diagnostic.choice - 1);
		    }
		    switch (_in_data->u.aare->result_source_diagnostic.choice) {
		    case 1:
			OSS_CNTX_PUSH(_oss_c, 115)
			if (_in_data->u.aare->result_source_diagnostic.u.acse_service_user >= 0 && _in_data->u.aare->result_source_diagnostic.u.acse_service_user <= 14) {
			    _oss_append_1bit_unaligned(_g, 0x00);
			    _oss_penc_nonneg_4int(_g, _in_data->u.aare->result_source_diagnostic.u.acse_service_user);
			} else {
			    _oss_append_1bit_unaligned(_g, 0x80);
			    _oss_penc_unconstr_int_l(_g, _in_data->u.aare->result_source_diagnostic.u.acse_service_user);
			}
			break;
		    case 2:
			OSS_CNTX_PUSH(_oss_c, 116)
			if (_in_data->u.aare->result_source_diagnostic.u.acse_service_provider >= 0 && _in_data->u.aare->result_source_diagnostic.u.acse_service_provider <= 2) {
			    _oss_append_1bit_unaligned(_g, 0x00);
			    _oss_penc_nonneg_2int(_g, _in_data->u.aare->result_source_diagnostic.u.acse_service_provider);
			} else {
			    _oss_append_1bit_unaligned(_g, 0x80);
			    _oss_penc_unconstr_int_l(_g, _in_data->u.aare->result_source_diagnostic.u.acse_service_provider);
			}
			break;
		    default:
			_oss_enc_error(_g, _bad_choice, _in_data->u.aare->result_source_diagnostic.choice);	/* Bad choice selector. */
		    }
		    OSS_CNTX_POP(_oss_c)
		}

		OSS_CNTX_SET(113)
		if (_bitmask & 0x40000000) {
		    _ep_AP_title(_g, &_in_data->u.aare->responding_AP_title);
		}
		OSS_CNTX_SET(112)
		if (_bitmask & 0x20000000) {
		    _ep_AE_qualifier(_g, &_in_data->u.aare->responding_AE_qualifier);
		}
		OSS_CNTX_SET(111)
		if (_bitmask & 0x10000000) {
		    _oss_penc_unconstr_int_l(_g, _in_data->u.aare->responding_AP_invocation_identifier);
		}
		OSS_CNTX_SET(110)
		if (_bitmask & 0x8000000) {
		    _oss_penc_unconstr_int_l(_g, _in_data->u.aare->responding_AE_invocation_identifier);
		}
		OSS_CNTX_SET(109)
		if (_bitmask & 0x4000000) {
#if OSS_TOED_API_LEVEL >= 27
		    _oss_penc_uncon_bit(_g, _in_data->u.aare->responder_acse_requirements.value, _in_data->u.aare->responder_acse_requirements.length ? _oss_chop_zero_bits(_in_data->u.aare->responder_acse_requirements.value, _in_data->u.aare->responder_acse_requirements.length, 0) : _in_data->u.aare->responder_acse_requirements.length);
#else
		    _oss_penc_unconstr_bit_l(_g, _in_data->u.aare->responder_acse_requirements.value, _in_data->u.aare->responder_acse_requirements.length, TRUE);
#endif
		}
		OSS_CNTX_SET(95)
		if (_bitmask & 0x2000000) {
		    _oss_penc_eobjid_ia(_g, _in_data->u.aare->mechanism_name.value, _in_data->u.aare->mechanism_name.length, -1);
		}
		OSS_CNTX_SET(108)
		if (_bitmask & 0x1000000) {
		    _ep_Authentication_value(_g, &_in_data->u.aare->responding_authentication_value);
		}
		OSS_CNTX_SET(93)
		if (_bitmask & 0x800000) {
		    _ep_13Application_context_name_l(_g, &_in_data->u.aare->application_context_name_list);
		}
		OSS_CNTX_SET(92)
		if (_bitmask & 0x400000) {
		    _oss_penc_nkmstr_l(_g, _in_data->u.aare->implementation_information.value, _in_data->u.aare->implementation_information.length);
		}
		OSS_CNTX_SET(91)
		if (_bitmask & 0x200000) {
		    _ep_Association_information(_g, &_in_data->u.aare->user_information);
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 118)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.rlrq == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		unsigned char _extPres = 0x00;
		OSS_CNTX_INIT

		_oss_append_1bit_unaligned(_g, _extPres);
		_oss_append_2bit_unaligned(_g, (unsigned char)(_in_data->u.rlrq->bit_mask >> 24));
		OSS_CNTX_PUSH(_oss_c, 119)
		if (_in_data->u.rlrq->bit_mask & 0x80000000) {
		    if ((_in_data->u.rlrq->reason >= 0 && _in_data->u.rlrq->reason <= 1) ||
			(_in_data->u.rlrq->reason == 30)) {
			_oss_append_1bit_unaligned(_g, 0x00);
			_oss_penc_nonneg_5int(_g, _in_data->u.rlrq->reason);
		    } else {
			_oss_append_1bit_unaligned(_g, 0x80);
			_oss_penc_unconstr_int_l(_g, _in_data->u.rlrq->reason);
		    }
		}
		OSS_CNTX_SET(91)
		if (_in_data->u.rlrq->bit_mask & 0x40000000) {
		    _ep_Association_information(_g, &_in_data->u.rlrq->user_information);
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 120)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.rlre == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		unsigned char _extPres = 0x00;
		OSS_CNTX_INIT

		_oss_append_1bit_unaligned(_g, _extPres);
		_oss_append_2bit_unaligned(_g, (unsigned char)(_in_data->u.rlre->bit_mask >> 24));
		OSS_CNTX_PUSH(_oss_c, 121)
		if (_in_data->u.rlre->bit_mask & 0x80000000) {
		    if ((_in_data->u.rlre->reason >= 0 && _in_data->u.rlre->reason <= 1) ||
			(_in_data->u.rlre->reason == 30)) {
			_oss_append_1bit_unaligned(_g, 0x00);
			_oss_penc_nonneg_5int(_g, _in_data->u.rlre->reason);
		    } else {
			_oss_append_1bit_unaligned(_g, 0x80);
			_oss_penc_unconstr_int_l(_g, _in_data->u.rlre->reason);
		    }
		}
		OSS_CNTX_SET(91)
		if (_in_data->u.rlre->bit_mask & 0x40000000) {
		    _ep_Association_information(_g, &_in_data->u.rlre->user_information);
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 122)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.abrt == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		unsigned char _extPres = 0x00;
		OSS_CNTX_INIT

		_oss_append_1bit_unaligned(_g, _extPres);
		_oss_append_2bit_unaligned(_g, (unsigned char)(_in_data->u.abrt->bit_mask >> 24));
		OSS_CNTX_PUSH(_oss_c, 124)
		if (_in_data->u.abrt->abort_source >= 0 && _in_data->u.abrt->abort_source <= 1) {
		    _oss_append_1bit_unaligned(_g, 0x00);
		    _oss_penc_nonneg_1int(_g, _in_data->u.abrt->abort_source);
		} else {
		    _oss_append_1bit_unaligned(_g, 0x80);
		    _oss_penc_unconstr_int_l(_g, _in_data->u.abrt->abort_source);
		}
		OSS_CNTX_SET(123)
		if (_in_data->u.abrt->bit_mask & 0x80000000) {
		    _oss_penc_enum(_g, _in_data->u.abrt->abort_diagnostic, (struct _enum_data *)&_enums[2], (struct _enum_data *)&_enums[3]);
		}
		OSS_CNTX_SET(91)
		if (_in_data->u.abrt->bit_mask & 0x40000000) {
		    _ep_Association_information(_g, &_in_data->u.abrt->user_information);
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eAE_title(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AE_title	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_AE_title *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(3,125)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 126)
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->u.ae_title_form2.value, _in_data->u.ae_title_form2.length, -1);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 127)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.ae_title_form1 == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edName(_g, _out_pos, &_out_len, _in_data->u.ae_title_form1);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epAE_title(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AE_title	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_AE_title *) _inbuf;
    OSS_CNTX_ANCHOR_SET(3,125)
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 2) {

	    _oss_append_1bit_unaligned(_g, 0x00);
	    _oss_penc_nonneg_1int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 126)
	    _oss_penc_eobjid_ia(_g, _in_data->u.ae_title_form2.value, _in_data->u.ae_title_form2.length, -1);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 127)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.ae_title_form1 == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_Name(_g, _in_data->u.ae_title_form1);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eCP_type(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CP_type	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_CP_type *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(4,128)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 129)
	if (_in_data->bit_mask & 0x40000000) {
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 130)
		if (_in_data->normal_mode_parameters.bit_mask & 0x200000) {
		    _data_len = _edUser_data(_g, _out_pos, &_out_len, &_in_data->normal_mode_parameters.user_data);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(131)
		if (_in_data->normal_mode_parameters.bit_mask & 0x400000) {
		    {
			long _total_len = 0;
			OSS_CNTX_INIT

			_data_len = _total_len;
		    }
		    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xAE);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(132)
		if (_in_data->normal_mode_parameters.bit_mask & 0x800000) {
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->normal_mode_parameters.initiators_nominated_context, 0x2);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xAC);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(133)
		if (_in_data->normal_mode_parameters.bit_mask & 0x1000000 &&
		    _oss_not_dflt_ia(_g, &_in_data->normal_mode_parameters.protocol_options, (OSSC::COssBitString  *)&_v632, 4, _VARY_OFFSET_0, -1, 3)) {
		    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->normal_mode_parameters.protocol_options.value, _in_data->normal_mode_parameters.protocol_options.length, -1, TRUE);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x23 : 0x3, 0xAB);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(134)
		if (_in_data->normal_mode_parameters.bit_mask & 0x2000000) {
		    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->normal_mode_parameters.user_session_requirements.value, _in_data->normal_mode_parameters.user_session_requirements.length, -1, TRUE);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA9 : 0x89);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(135)
		if (_in_data->normal_mode_parameters.bit_mask & 0x4000000) {
		    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->normal_mode_parameters.presentation_requirements.value, _in_data->normal_mode_parameters.presentation_requirements.length, -1, TRUE);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA8 : 0x88);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(136)
		if (_in_data->normal_mode_parameters.bit_mask & 0x8000000) {
		    {
			long _total_len = 0;
			OSS_CNTX_INIT

			OSS_CNTX_PUSH(_oss_c, 39)
			_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->normal_mode_parameters.default_context_name.transfer_syntax_name.value, _in_data->normal_mode_parameters.default_context_name.transfer_syntax_name.length, -1);
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x81);
			_total_len += _data_len;
			OSS_CNTX_SET(37)
			_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->normal_mode_parameters.default_context_name.abstract_syntax_name.value, _in_data->normal_mode_parameters.default_context_name.abstract_syntax_name.length, -1);
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x80);
			_total_len += _data_len;
			OSS_CNTX_POP(_oss_c)
			_data_len = _total_len;
		    }
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA6);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(137)
		if (_in_data->normal_mode_parameters.bit_mask & 0x10000000) {
		    _data_len = _edContext_list(_g, _out_pos, &_out_len, &_in_data->normal_mode_parameters.presentation_context_definition_list);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA4);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(138)
		if (_in_data->normal_mode_parameters.bit_mask & 0x20000000) {
		    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->normal_mode_parameters.called_presentation_selector.value, _in_data->normal_mode_parameters.called_presentation_selector.length, -1);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA2 : 0x82);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(139)
		if (_in_data->normal_mode_parameters.bit_mask & 0x40000000) {
		    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->normal_mode_parameters.calling_presentation_selector.value, _in_data->normal_mode_parameters.calling_presentation_selector.length, -1);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA1 : 0x81);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(140)
		if (_in_data->normal_mode_parameters.bit_mask & 0x80000000 &&
		    _oss_not_dflt_ia(_g, &_in_data->normal_mode_parameters.protocol_version, (OSSC::COssBitString  *)&_v631, 4, _VARY_OFFSET_0, -1, 3)) {
		    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->normal_mode_parameters.protocol_version.value, _in_data->normal_mode_parameters.protocol_version.length, -1, TRUE);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA0 : 0x80);
		    _total_len += _data_len;
		}
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(141)
	if (_in_data->bit_mask & 0x80000000) {
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 44)
		if (_in_data->x410_mode_parameters.bit_mask & 0x10000000) {
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->x410_mode_parameters.applicationProtocol, 0x84);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(45)
		_data_len = _edConnectionData(_g, _out_pos, &_out_len, &_in_data->x410_mode_parameters.connectionDataRQ);
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA3);
		_total_len += _data_len;
		OSS_CNTX_SET(46)
		if (_in_data->x410_mode_parameters.bit_mask & 0x20000000 &&
		    _oss_not_dflt_ia(_g, &_in_data->x410_mode_parameters.dialogueMode, (OSS_INT32  *)&__shared15::default_checkpointSize, sizeof(OSS_INT32 ), 0, -1, 0)) {
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->x410_mode_parameters.dialogueMode, 0x82);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(47)
		if (_in_data->x410_mode_parameters.bit_mask & 0x40000000 &&
		    _oss_not_dflt_ia(_g, &_in_data->x410_mode_parameters.windowSize, (OSS_INT32  *)&__shared15::default_windowSize, sizeof(OSS_INT32 ), 0, -1, 0)) {
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->x410_mode_parameters.windowSize, 0x81);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(48)
		if (_in_data->x410_mode_parameters.bit_mask & 0x80000000 &&
		    _oss_not_dflt_ia(_g, &_in_data->x410_mode_parameters.checkpointSize, (OSS_INT32  *)&__shared15::default_checkpointSize, sizeof(OSS_INT32 ), 0, -1, 0)) {
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->x410_mode_parameters.checkpointSize, 0x80);
		    _total_len += _data_len;
		}
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(142)
	_data_len = _edMode_selector(_g, _out_pos, &_out_len, &_in_data->mode_selector);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epCP_type(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CP_type	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_CP_type *) _inbuf;
    OSS_CNTX_ANCHOR_SET(4,128)
    {
	OSS_CNTX_INIT

	_oss_append_2bit_unaligned(_g, (unsigned char)(_in_data->bit_mask >> 24));
	OSS_CNTX_PUSH(_oss_c, 142)
	_ep_Mode_selector(_g, &_in_data->mode_selector);
	OSS_CNTX_SET(141)
	if (_in_data->bit_mask & 0x80000000) {
	    {
		OSS_UINT32 _bitmask = _in_data->x410_mode_parameters.bit_mask;
		OSS_CNTX_INIT

#ifdef OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES
		if (_g->encodingFlags & STRICT_PER_ENCODING_OF_DEFAULT_VALUES) {
		    if ((_bitmask & 0x80000000) &&
			!_oss_not_dflt_ia(_g, &_in_data->x410_mode_parameters.checkpointSize, (OSS_INT32  *)&__shared15::default_checkpointSize, sizeof(OSS_INT32 ), 0, -1, 0))
			_bitmask ^= 0x80000000;
		    if ((_bitmask & 0x40000000) &&
			!_oss_not_dflt_ia(_g, &_in_data->x410_mode_parameters.windowSize, (OSS_INT32  *)&__shared15::default_windowSize, sizeof(OSS_INT32 ), 0, -1, 0))
			_bitmask ^= 0x40000000;
		    if ((_bitmask & 0x20000000) &&
			!_oss_not_dflt_ia(_g, &_in_data->x410_mode_parameters.dialogueMode, (OSS_INT32  *)&__shared15::default_checkpointSize, sizeof(OSS_INT32 ), 0, -1, 0))
			_bitmask ^= 0x20000000;
		}
#endif /* OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES */
		_oss_append_4bit_unaligned(_g, (unsigned char)(_bitmask >> 24));
		OSS_CNTX_PUSH(_oss_c, 48)
		if (_bitmask & 0x80000000) {
		    _oss_penc_unconstr_int_l(_g, _in_data->x410_mode_parameters.checkpointSize);
		}
		OSS_CNTX_SET(47)
		if (_bitmask & 0x40000000) {
		    _oss_penc_unconstr_int_l(_g, _in_data->x410_mode_parameters.windowSize);
		}
		OSS_CNTX_SET(46)
		if (_bitmask & 0x20000000) {
		    _oss_penc_unconstr_int_l(_g, _in_data->x410_mode_parameters.dialogueMode);
		}
		OSS_CNTX_SET(45)
		_ep_ConnectionData(_g, &_in_data->x410_mode_parameters.connectionDataRQ);
		OSS_CNTX_SET(44)
		if (_bitmask & 0x10000000) {
		    _oss_penc_unconstr_int_l(_g, _in_data->x410_mode_parameters.applicationProtocol);
		}
		OSS_CNTX_POP(_oss_c)
	    }
	}
	OSS_CNTX_SET(129)
	if (_in_data->bit_mask & 0x40000000) {
	    {
		OSS_UINT32 _bitmask = _in_data->normal_mode_parameters.bit_mask;
		OSS_CNTX_INIT

#ifdef OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES
		if (_g->encodingFlags & STRICT_PER_ENCODING_OF_DEFAULT_VALUES) {
		    if ((_bitmask & 0x80000000) &&
			!_oss_not_dflt_ia(_g, &_in_data->normal_mode_parameters.protocol_version, (OSSC::COssBitString  *)&_v631, 4, _VARY_OFFSET_0, -1, 3))
			_bitmask ^= 0x80000000;
		    if ((_bitmask & 0x1000000) &&
			!_oss_not_dflt_ia(_g, &_in_data->normal_mode_parameters.protocol_options, (OSSC::COssBitString  *)&_v632, 4, _VARY_OFFSET_0, -1, 3))
			_bitmask ^= 0x1000000;
		}
#endif /* OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES */
		_oss_penc_nonneg_int_l(_g, (unsigned long)_bitmask >> 21, 11);
		OSS_CNTX_PUSH(_oss_c, 140)
		if (_bitmask & 0x80000000) {
#if OSS_TOED_API_LEVEL >= 27
		    _oss_penc_uncon_bit(_g, _in_data->normal_mode_parameters.protocol_version.value, _in_data->normal_mode_parameters.protocol_version.length ? _oss_chop_zero_bits(_in_data->normal_mode_parameters.protocol_version.value, _in_data->normal_mode_parameters.protocol_version.length, 0) : _in_data->normal_mode_parameters.protocol_version.length);
#else
		    _oss_penc_unconstr_bit_l(_g, _in_data->normal_mode_parameters.protocol_version.value, _in_data->normal_mode_parameters.protocol_version.length, TRUE);
#endif
		}
		OSS_CNTX_SET(139)
		if (_bitmask & 0x40000000) {
		    if (_in_data->normal_mode_parameters.calling_presentation_selector.length >= 1 && _in_data->normal_mode_parameters.calling_presentation_selector.length <= 4) {
			_oss_append_1bit_unaligned(_g, 0);
#if OSS_TOED_API_LEVEL >= 27
			_oss_penc_lrang(_g, _in_data->normal_mode_parameters.calling_presentation_selector.length, 1, 4);
			_oss_append(_g, (unsigned char *)_in_data->normal_mode_parameters.calling_presentation_selector.value, _in_data->normal_mode_parameters.calling_presentation_selector.length << 3, Aligned);
#else
			_oss_penc_constr_oct_l(_g, (unsigned char *)_in_data->normal_mode_parameters.calling_presentation_selector.value, _in_data->normal_mode_parameters.calling_presentation_selector.length, 1, 4);
#endif
		    } else {
			_oss_append_1bit_unaligned(_g, 0x80);
#if OSS_TOED_API_LEVEL >= 27
			_oss_penc_uncon_oct(_g, (unsigned char *)_in_data->normal_mode_parameters.calling_presentation_selector.value, _in_data->normal_mode_parameters.calling_presentation_selector.length);
#else
			_oss_penc_unconstr_oct_l(_g, (unsigned char *)_in_data->normal_mode_parameters.calling_presentation_selector.value, _in_data->normal_mode_parameters.calling_presentation_selector.length);
#endif
		    }
		}
		OSS_CNTX_SET(138)
		if (_bitmask & 0x20000000) {
		    if (_in_data->normal_mode_parameters.called_presentation_selector.length >= 1 && _in_data->normal_mode_parameters.called_presentation_selector.length <= 4) {
			_oss_append_1bit_unaligned(_g, 0);
#if OSS_TOED_API_LEVEL >= 27
			_oss_penc_lrang(_g, _in_data->normal_mode_parameters.called_presentation_selector.length, 1, 4);
			_oss_append(_g, (unsigned char *)_in_data->normal_mode_parameters.called_presentation_selector.value, _in_data->normal_mode_parameters.called_presentation_selector.length << 3, Aligned);
#else
			_oss_penc_constr_oct_l(_g, (unsigned char *)_in_data->normal_mode_parameters.called_presentation_selector.value, _in_data->normal_mode_parameters.called_presentation_selector.length, 1, 4);
#endif
		    } else {
			_oss_append_1bit_unaligned(_g, 0x80);
#if OSS_TOED_API_LEVEL >= 27
			_oss_penc_uncon_oct(_g, (unsigned char *)_in_data->normal_mode_parameters.called_presentation_selector.value, _in_data->normal_mode_parameters.called_presentation_selector.length);
#else
			_oss_penc_unconstr_oct_l(_g, (unsigned char *)_in_data->normal_mode_parameters.called_presentation_selector.value, _in_data->normal_mode_parameters.called_presentation_selector.length);
#endif
		    }
		}
		OSS_CNTX_SET(137)
		if (_bitmask & 0x10000000) {
		    _ep_Context_list(_g, &_in_data->normal_mode_parameters.presentation_context_definition_list);
		}
		OSS_CNTX_SET(136)
		if (_bitmask & 0x8000000) {
		    {
			OSS_CNTX_INIT

			OSS_CNTX_PUSH(_oss_c, 37)
			_oss_penc_eobjid_ia(_g, _in_data->normal_mode_parameters.default_context_name.abstract_syntax_name.value, _in_data->normal_mode_parameters.default_context_name.abstract_syntax_name.length, -1);
			OSS_CNTX_SET(39)
			_oss_penc_eobjid_ia(_g, _in_data->normal_mode_parameters.default_context_name.transfer_syntax_name.value, _in_data->normal_mode_parameters.default_context_name.transfer_syntax_name.length, -1);
			OSS_CNTX_POP(_oss_c)
		    }
		}
		OSS_CNTX_SET(135)
		if (_bitmask & 0x4000000) {
#if OSS_TOED_API_LEVEL >= 27
		    _oss_penc_uncon_bit(_g, _in_data->normal_mode_parameters.presentation_requirements.value, _in_data->normal_mode_parameters.presentation_requirements.length ? _oss_chop_zero_bits(_in_data->normal_mode_parameters.presentation_requirements.value, _in_data->normal_mode_parameters.presentation_requirements.length, 0) : _in_data->normal_mode_parameters.presentation_requirements.length);
#else
		    _oss_penc_unconstr_bit_l(_g, _in_data->normal_mode_parameters.presentation_requirements.value, _in_data->normal_mode_parameters.presentation_requirements.length, TRUE);
#endif
		}
		OSS_CNTX_SET(134)
		if (_bitmask & 0x2000000) {
#if OSS_TOED_API_LEVEL >= 27
		    _oss_penc_uncon_bit(_g, _in_data->normal_mode_parameters.user_session_requirements.value, _in_data->normal_mode_parameters.user_session_requirements.length ? _oss_chop_zero_bits(_in_data->normal_mode_parameters.user_session_requirements.value, _in_data->normal_mode_parameters.user_session_requirements.length, 0) : _in_data->normal_mode_parameters.user_session_requirements.length);
#else
		    _oss_penc_unconstr_bit_l(_g, _in_data->normal_mode_parameters.user_session_requirements.value, _in_data->normal_mode_parameters.user_session_requirements.length, TRUE);
#endif
		}
		OSS_CNTX_SET(133)
		if (_bitmask & 0x1000000) {
#if OSS_TOED_API_LEVEL >= 27
		    _oss_penc_uncon_bit(_g, _in_data->normal_mode_parameters.protocol_options.value, _in_data->normal_mode_parameters.protocol_options.length ? _oss_chop_zero_bits(_in_data->normal_mode_parameters.protocol_options.value, _in_data->normal_mode_parameters.protocol_options.length, 0) : _in_data->normal_mode_parameters.protocol_options.length);
#else
		    _oss_penc_unconstr_bit_l(_g, _in_data->normal_mode_parameters.protocol_options.value, _in_data->normal_mode_parameters.protocol_options.length, TRUE);
#endif
		}
		OSS_CNTX_SET(132)
		if (_bitmask & 0x800000) {
		    if (_in_data->normal_mode_parameters.initiators_nominated_context >= 1 && _in_data->normal_mode_parameters.initiators_nominated_context <= 127) {
			_oss_append_1bit_unaligned(_g, 0x00);
			_oss_penc_nonneg_7int(_g, _in_data->normal_mode_parameters.initiators_nominated_context - 1);
		    } else {
			_oss_append_1bit_unaligned(_g, 0x80);
			_oss_penc_unconstr_int_l(_g, _in_data->normal_mode_parameters.initiators_nominated_context);
		    }
		}
		OSS_CNTX_SET(131)
		if (_bitmask & 0x400000) {
		    {
			unsigned char _extPres = 0x00;
			OSS_CNTX_INIT

			_oss_append_1bit_unaligned(_g, _extPres);
		    }
		}
		OSS_CNTX_SET(130)
		if (_bitmask & 0x200000) {
		    _ep_User_data(_g, &_in_data->normal_mode_parameters.user_data);
		}
		OSS_CNTX_POP(_oss_c)
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eCPC_type(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _User_data	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_User_data *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(5,143)
    _data_len = _edUser_data(_g, _out_pos, &_out_len, _in_data);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epCPC_type(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _User_data	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_User_data *) _inbuf;
    OSS_CNTX_ANCHOR_SET(5,143)
    _ep_User_data(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eCPA_PPDU(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CPA_PPDU	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_CPA_PPDU *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(6,144)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 129)
	if (_in_data->bit_mask & 0x40000000) {
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 130)
		if (_in_data->normal_mode_parameters.bit_mask & 0x1000000) {
		    _data_len = _edUser_data(_g, _out_pos, &_out_len, &_in_data->normal_mode_parameters.user_data);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(145)
		if (_in_data->normal_mode_parameters.bit_mask & 0x2000000) {
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->normal_mode_parameters.responders_nominated_context, 0x2);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xAD);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(133)
		if (_in_data->normal_mode_parameters.bit_mask & 0x4000000 &&
		    _oss_not_dflt_ia(_g, &_in_data->normal_mode_parameters.protocol_options, (OSSC::COssBitString  *)&_v634, 4, _VARY_OFFSET_0, -1, 3)) {
		    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->normal_mode_parameters.protocol_options.value, _in_data->normal_mode_parameters.protocol_options.length, -1, TRUE);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x23 : 0x3, 0xAB);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(134)
		if (_in_data->normal_mode_parameters.bit_mask & 0x8000000) {
		    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->normal_mode_parameters.user_session_requirements.value, _in_data->normal_mode_parameters.user_session_requirements.length, -1, TRUE);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA9 : 0x89);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(135)
		if (_in_data->normal_mode_parameters.bit_mask & 0x10000000) {
		    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->normal_mode_parameters.presentation_requirements.value, _in_data->normal_mode_parameters.presentation_requirements.length, -1, TRUE);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA8 : 0x88);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(146)
		if (_in_data->normal_mode_parameters.bit_mask & 0x20000000) {
		    _data_len = _edResult_list(_g, _out_pos, &_out_len, &_in_data->normal_mode_parameters.presentation_context_definition_result_list);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA5);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(147)
		if (_in_data->normal_mode_parameters.bit_mask & 0x40000000) {
		    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->normal_mode_parameters.responding_presentation_selector.value, _in_data->normal_mode_parameters.responding_presentation_selector.length, -1);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA3 : 0x83);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(140)
		if (_in_data->normal_mode_parameters.bit_mask & 0x80000000 &&
		    _oss_not_dflt_ia(_g, &_in_data->normal_mode_parameters.protocol_version, (OSSC::COssBitString  *)&_v633, 4, _VARY_OFFSET_0, -1, 3)) {
		    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->normal_mode_parameters.protocol_version.value, _in_data->normal_mode_parameters.protocol_version.length, -1, TRUE);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA0 : 0x80);
		    _total_len += _data_len;
		}
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(141)
	if (_in_data->bit_mask & 0x80000000) {
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 49)
		_data_len = _edConnectionData(_g, _out_pos, &_out_len, &_in_data->x410_mode_parameters.connectionDataAC);
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
		_total_len += _data_len;
		OSS_CNTX_SET(47)
		if (_in_data->x410_mode_parameters.bit_mask & 0x40000000 &&
		    _oss_not_dflt_ia(_g, &_in_data->x410_mode_parameters.windowSize, (OSS_INT32  *)&__shared15::default_windowSize, sizeof(OSS_INT32 ), 0, -1, 0)) {
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->x410_mode_parameters.windowSize, 0x81);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(48)
		if (_in_data->x410_mode_parameters.bit_mask & 0x80000000 &&
		    _oss_not_dflt_ia(_g, &_in_data->x410_mode_parameters.checkpointSize, (OSS_INT32  *)&__shared15::default_checkpointSize, sizeof(OSS_INT32 ), 0, -1, 0)) {
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->x410_mode_parameters.checkpointSize, 0x80);
		    _total_len += _data_len;
		}
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(142)
	_data_len = _edMode_selector(_g, _out_pos, &_out_len, &_in_data->mode_selector);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epCPA_PPDU(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CPA_PPDU	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_CPA_PPDU *) _inbuf;
    OSS_CNTX_ANCHOR_SET(6,144)
    {
	OSS_CNTX_INIT

	_oss_append_2bit_unaligned(_g, (unsigned char)(_in_data->bit_mask >> 24));
	OSS_CNTX_PUSH(_oss_c, 142)
	_ep_Mode_selector(_g, &_in_data->mode_selector);
	OSS_CNTX_SET(141)
	if (_in_data->bit_mask & 0x80000000) {
	    {
		OSS_UINT32 _bitmask = _in_data->x410_mode_parameters.bit_mask;
		OSS_CNTX_INIT

#ifdef OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES
		if (_g->encodingFlags & STRICT_PER_ENCODING_OF_DEFAULT_VALUES) {
		    if ((_bitmask & 0x80000000) &&
			!_oss_not_dflt_ia(_g, &_in_data->x410_mode_parameters.checkpointSize, (OSS_INT32  *)&__shared15::default_checkpointSize, sizeof(OSS_INT32 ), 0, -1, 0))
			_bitmask ^= 0x80000000;
		    if ((_bitmask & 0x40000000) &&
			!_oss_not_dflt_ia(_g, &_in_data->x410_mode_parameters.windowSize, (OSS_INT32  *)&__shared15::default_windowSize, sizeof(OSS_INT32 ), 0, -1, 0))
			_bitmask ^= 0x40000000;
		}
#endif /* OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES */
		_oss_append_2bit_unaligned(_g, (unsigned char)(_bitmask >> 24));
		OSS_CNTX_PUSH(_oss_c, 48)
		if (_bitmask & 0x80000000) {
		    _oss_penc_unconstr_int_l(_g, _in_data->x410_mode_parameters.checkpointSize);
		}
		OSS_CNTX_SET(47)
		if (_bitmask & 0x40000000) {
		    _oss_penc_unconstr_int_l(_g, _in_data->x410_mode_parameters.windowSize);
		}
		OSS_CNTX_SET(49)
		_ep_ConnectionData(_g, &_in_data->x410_mode_parameters.connectionDataAC);
		OSS_CNTX_POP(_oss_c)
	    }
	}
	OSS_CNTX_SET(129)
	if (_in_data->bit_mask & 0x40000000) {
	    {
		OSS_UINT32 _bitmask = _in_data->normal_mode_parameters.bit_mask;
		OSS_CNTX_INIT

#ifdef OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES
		if (_g->encodingFlags & STRICT_PER_ENCODING_OF_DEFAULT_VALUES) {
		    if ((_bitmask & 0x80000000) &&
			!_oss_not_dflt_ia(_g, &_in_data->normal_mode_parameters.protocol_version, (OSSC::COssBitString  *)&_v633, 4, _VARY_OFFSET_0, -1, 3))
			_bitmask ^= 0x80000000;
		    if ((_bitmask & 0x4000000) &&
			!_oss_not_dflt_ia(_g, &_in_data->normal_mode_parameters.protocol_options, (OSSC::COssBitString  *)&_v634, 4, _VARY_OFFSET_0, -1, 3))
			_bitmask ^= 0x4000000;
		}
#endif /* OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES */
		_oss_append_8bit_unaligned(_g, (unsigned char)(_bitmask >> 24));
		OSS_CNTX_PUSH(_oss_c, 140)
		if (_bitmask & 0x80000000) {
#if OSS_TOED_API_LEVEL >= 27
		    _oss_penc_uncon_bit(_g, _in_data->normal_mode_parameters.protocol_version.value, _in_data->normal_mode_parameters.protocol_version.length ? _oss_chop_zero_bits(_in_data->normal_mode_parameters.protocol_version.value, _in_data->normal_mode_parameters.protocol_version.length, 0) : _in_data->normal_mode_parameters.protocol_version.length);
#else
		    _oss_penc_unconstr_bit_l(_g, _in_data->normal_mode_parameters.protocol_version.value, _in_data->normal_mode_parameters.protocol_version.length, TRUE);
#endif
		}
		OSS_CNTX_SET(147)
		if (_bitmask & 0x40000000) {
		    if (_in_data->normal_mode_parameters.responding_presentation_selector.length >= 1 && _in_data->normal_mode_parameters.responding_presentation_selector.length <= 4) {
			_oss_append_1bit_unaligned(_g, 0);
#if OSS_TOED_API_LEVEL >= 27
			_oss_penc_lrang(_g, _in_data->normal_mode_parameters.responding_presentation_selector.length, 1, 4);
			_oss_append(_g, (unsigned char *)_in_data->normal_mode_parameters.responding_presentation_selector.value, _in_data->normal_mode_parameters.responding_presentation_selector.length << 3, Aligned);
#else
			_oss_penc_constr_oct_l(_g, (unsigned char *)_in_data->normal_mode_parameters.responding_presentation_selector.value, _in_data->normal_mode_parameters.responding_presentation_selector.length, 1, 4);
#endif
		    } else {
			_oss_append_1bit_unaligned(_g, 0x80);
#if OSS_TOED_API_LEVEL >= 27
			_oss_penc_uncon_oct(_g, (unsigned char *)_in_data->normal_mode_parameters.responding_presentation_selector.value, _in_data->normal_mode_parameters.responding_presentation_selector.length);
#else
			_oss_penc_unconstr_oct_l(_g, (unsigned char *)_in_data->normal_mode_parameters.responding_presentation_selector.value, _in_data->normal_mode_parameters.responding_presentation_selector.length);
#endif
		    }
		}
		OSS_CNTX_SET(146)
		if (_bitmask & 0x20000000) {
		    _ep_Result_list(_g, &_in_data->normal_mode_parameters.presentation_context_definition_result_list);
		}
		OSS_CNTX_SET(135)
		if (_bitmask & 0x10000000) {
#if OSS_TOED_API_LEVEL >= 27
		    _oss_penc_uncon_bit(_g, _in_data->normal_mode_parameters.presentation_requirements.value, _in_data->normal_mode_parameters.presentation_requirements.length ? _oss_chop_zero_bits(_in_data->normal_mode_parameters.presentation_requirements.value, _in_data->normal_mode_parameters.presentation_requirements.length, 0) : _in_data->normal_mode_parameters.presentation_requirements.length);
#else
		    _oss_penc_unconstr_bit_l(_g, _in_data->normal_mode_parameters.presentation_requirements.value, _in_data->normal_mode_parameters.presentation_requirements.length, TRUE);
#endif
		}
		OSS_CNTX_SET(134)
		if (_bitmask & 0x8000000) {
#if OSS_TOED_API_LEVEL >= 27
		    _oss_penc_uncon_bit(_g, _in_data->normal_mode_parameters.user_session_requirements.value, _in_data->normal_mode_parameters.user_session_requirements.length ? _oss_chop_zero_bits(_in_data->normal_mode_parameters.user_session_requirements.value, _in_data->normal_mode_parameters.user_session_requirements.length, 0) : _in_data->normal_mode_parameters.user_session_requirements.length);
#else
		    _oss_penc_unconstr_bit_l(_g, _in_data->normal_mode_parameters.user_session_requirements.value, _in_data->normal_mode_parameters.user_session_requirements.length, TRUE);
#endif
		}
		OSS_CNTX_SET(133)
		if (_bitmask & 0x4000000) {
#if OSS_TOED_API_LEVEL >= 27
		    _oss_penc_uncon_bit(_g, _in_data->normal_mode_parameters.protocol_options.value, _in_data->normal_mode_parameters.protocol_options.length ? _oss_chop_zero_bits(_in_data->normal_mode_parameters.protocol_options.value, _in_data->normal_mode_parameters.protocol_options.length, 0) : _in_data->normal_mode_parameters.protocol_options.length);
#else
		    _oss_penc_unconstr_bit_l(_g, _in_data->normal_mode_parameters.protocol_options.value, _in_data->normal_mode_parameters.protocol_options.length, TRUE);
#endif
		}
		OSS_CNTX_SET(145)
		if (_bitmask & 0x2000000) {
		    if (_in_data->normal_mode_parameters.responders_nominated_context >= 1 && _in_data->normal_mode_parameters.responders_nominated_context <= 127) {
			_oss_append_1bit_unaligned(_g, 0x00);
			_oss_penc_nonneg_7int(_g, _in_data->normal_mode_parameters.responders_nominated_context - 1);
		    } else {
			_oss_append_1bit_unaligned(_g, 0x80);
			_oss_penc_unconstr_int_l(_g, _in_data->normal_mode_parameters.responders_nominated_context);
		    }
		}
		OSS_CNTX_SET(130)
		if (_bitmask & 0x1000000) {
		    _ep_User_data(_g, &_in_data->normal_mode_parameters.user_data);
		}
		OSS_CNTX_POP(_oss_c)
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eCPR_PPDU(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CPR_PPDU	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_CPR_PPDU *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(7,148)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 129)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.normal_mode_parameters == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 130)
		if (_in_data->u.normal_mode_parameters->bit_mask & 0x4000000) {
		    _data_len = _edUser_data(_g, _out_pos, &_out_len, &_in_data->u.normal_mode_parameters->user_data);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(149)
		if (_in_data->u.normal_mode_parameters->bit_mask & 0x8000000) {
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.normal_mode_parameters->provider_reason, 0x8A);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(150)
		if (_in_data->u.normal_mode_parameters->bit_mask & 0x10000000) {
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.normal_mode_parameters->default_context_result, 0x87);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(146)
		if (_in_data->u.normal_mode_parameters->bit_mask & 0x20000000) {
		    _data_len = _edResult_list(_g, _out_pos, &_out_len, &_in_data->u.normal_mode_parameters->presentation_context_definition_result_list);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA5);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(147)
		if (_in_data->u.normal_mode_parameters->bit_mask & 0x40000000) {
		    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->u.normal_mode_parameters->responding_presentation_selector.value, _in_data->u.normal_mode_parameters->responding_presentation_selector.length, -1);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA3 : 0x83);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(140)
		if (_in_data->u.normal_mode_parameters->bit_mask & 0x80000000 &&
		    _oss_not_dflt_ia(_g, &_in_data->u.normal_mode_parameters->protocol_version, (OSSC::COssBitString  *)&_v635, 4, _VARY_OFFSET_0, -1, 3)) {
		    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->u.normal_mode_parameters->protocol_version.value, _in_data->u.normal_mode_parameters->protocol_version.length, -1, TRUE);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA0 : 0x80);
		    _total_len += _data_len;
		}
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 151)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.x400_mode_parameters == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 50)
		if (_in_data->u.x400_mode_parameters->bit_mask & 0x40000000) {
		    _data_len = _oss_encd_opentype(_g, _out_pos, &_out_len, &_in_data->u.x400_mode_parameters->userDataRJ);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(51)
		if (_in_data->u.x400_mode_parameters->bit_mask & 0x80000000) {
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.x400_mode_parameters->refuseReason, 0x80);
		    _total_len += _data_len;
		}
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epCPR_PPDU(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CPR_PPDU	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_CPR_PPDU *) _inbuf;
    OSS_CNTX_ANCHOR_SET(7,148)
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 2) {

	    _oss_penc_nonneg_1int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 129)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.normal_mode_parameters == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		OSS_UINT32 _bitmask = _in_data->u.normal_mode_parameters->bit_mask;
		OSS_CNTX_INIT

#ifdef OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES
		if (_g->encodingFlags & STRICT_PER_ENCODING_OF_DEFAULT_VALUES) {
		    if ((_bitmask & 0x80000000) &&
			!_oss_not_dflt_ia(_g, &_in_data->u.normal_mode_parameters->protocol_version, (OSSC::COssBitString  *)&_v635, 4, _VARY_OFFSET_0, -1, 3))
			_bitmask ^= 0x80000000;
		}
#endif /* OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES */
		_oss_append_6bit_unaligned(_g, (unsigned char)(_bitmask >> 24));
		OSS_CNTX_PUSH(_oss_c, 140)
		if (_bitmask & 0x80000000) {
#if OSS_TOED_API_LEVEL >= 27
		    _oss_penc_uncon_bit(_g, _in_data->u.normal_mode_parameters->protocol_version.value, _in_data->u.normal_mode_parameters->protocol_version.length ? _oss_chop_zero_bits(_in_data->u.normal_mode_parameters->protocol_version.value, _in_data->u.normal_mode_parameters->protocol_version.length, 0) : _in_data->u.normal_mode_parameters->protocol_version.length);
#else
		    _oss_penc_unconstr_bit_l(_g, _in_data->u.normal_mode_parameters->protocol_version.value, _in_data->u.normal_mode_parameters->protocol_version.length, TRUE);
#endif
		}
		OSS_CNTX_SET(147)
		if (_bitmask & 0x40000000) {
		    if (_in_data->u.normal_mode_parameters->responding_presentation_selector.length >= 1 && _in_data->u.normal_mode_parameters->responding_presentation_selector.length <= 4) {
			_oss_append_1bit_unaligned(_g, 0);
#if OSS_TOED_API_LEVEL >= 27
			_oss_penc_lrang(_g, _in_data->u.normal_mode_parameters->responding_presentation_selector.length, 1, 4);
			_oss_append(_g, (unsigned char *)_in_data->u.normal_mode_parameters->responding_presentation_selector.value, _in_data->u.normal_mode_parameters->responding_presentation_selector.length << 3, Aligned);
#else
			_oss_penc_constr_oct_l(_g, (unsigned char *)_in_data->u.normal_mode_parameters->responding_presentation_selector.value, _in_data->u.normal_mode_parameters->responding_presentation_selector.length, 1, 4);
#endif
		    } else {
			_oss_append_1bit_unaligned(_g, 0x80);
#if OSS_TOED_API_LEVEL >= 27
			_oss_penc_uncon_oct(_g, (unsigned char *)_in_data->u.normal_mode_parameters->responding_presentation_selector.value, _in_data->u.normal_mode_parameters->responding_presentation_selector.length);
#else
			_oss_penc_unconstr_oct_l(_g, (unsigned char *)_in_data->u.normal_mode_parameters->responding_presentation_selector.value, _in_data->u.normal_mode_parameters->responding_presentation_selector.length);
#endif
		    }
		}
		OSS_CNTX_SET(146)
		if (_bitmask & 0x20000000) {
		    _ep_Result_list(_g, &_in_data->u.normal_mode_parameters->presentation_context_definition_result_list);
		}
		OSS_CNTX_SET(150)
		if (_bitmask & 0x10000000) {
		    _oss_penc_unconstr_int_l(_g, _in_data->u.normal_mode_parameters->default_context_result);
		}
		OSS_CNTX_SET(149)
		if (_bitmask & 0x8000000) {
		    _oss_penc_unconstr_int_l(_g, _in_data->u.normal_mode_parameters->provider_reason);
		}
		OSS_CNTX_SET(130)
		if (_bitmask & 0x4000000) {
		    _ep_User_data(_g, &_in_data->u.normal_mode_parameters->user_data);
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 151)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.x400_mode_parameters == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_oss_append_2bit_unaligned(_g, (unsigned char)(_in_data->u.x400_mode_parameters->bit_mask >> 24));
		OSS_CNTX_PUSH(_oss_c, 51)
		if (_in_data->u.x400_mode_parameters->bit_mask & 0x80000000) {
		    _oss_penc_unconstr_int_l(_g, _in_data->u.x400_mode_parameters->refuseReason);
		}
		OSS_CNTX_SET(50)
		if (_in_data->u.x400_mode_parameters->bit_mask & 0x40000000) {
		    _oss_penc_opentype(_g, &_in_data->u.x400_mode_parameters->userDataRJ);
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eAbort_type(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Abort_type	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_Abort_type *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(8,152)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 153)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.arp_ppdu == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 154)
		if (_in_data->u.arp_ppdu->bit_mask & 0x40000000) {
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.arp_ppdu->event_identifier, 0x81);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(155)
		if (_in_data->u.arp_ppdu->bit_mask & 0x80000000) {
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.arp_ppdu->provider_reason, 0x80);
		    _total_len += _data_len;
		}
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 156)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.aru_ppdu == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		OSS_CNTX_INIT

		switch (_in_data->u.aru_ppdu->choice) {
		case 1:
		    OSS_CNTX_PUSH(_oss_c, 151)
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_in_data->u.aru_ppdu->u.x400_mode_parameters == nullptr)
			_oss_enc_error(_g, _bad_pointer, 0L);
#endif
		    {
			long _total_len = 0;
			OSS_CNTX_INIT

			OSS_CNTX_PUSH(_oss_c, 157)
			if (_in_data->u.aru_ppdu->u.x400_mode_parameters->bit_mask & 0x20000000) {
			    _data_len = _oss_encd_opentype(_g, _out_pos, &_out_len, &_in_data->u.aru_ppdu->u.x400_mode_parameters->userdataAB);
			    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
			    _total_len += _data_len;
			}
			OSS_CNTX_SET(158)
			if (_in_data->u.aru_ppdu->u.x400_mode_parameters->bit_mask & 0x40000000) {
			    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->u.aru_ppdu->u.x400_mode_parameters->reflectedParameter.value, _in_data->u.aru_ppdu->u.x400_mode_parameters->reflectedParameter.length, -1, FALSE);
			    if (_data_len < 0) {
				_constructed = TRUE;
				_data_len = -_data_len;
			    } else
				_constructed = FALSE;
			    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA1 : 0x81);
			    _total_len += _data_len;
			}
			OSS_CNTX_SET(159)
			if (_in_data->u.aru_ppdu->u.x400_mode_parameters->bit_mask & 0x80000000) {
			    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.aru_ppdu->u.x400_mode_parameters->abortReason, 0x80);
			    _total_len += _data_len;
			}
			OSS_CNTX_POP(_oss_c)
			_data_len = _total_len;
		    }
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
		    break;
		case 2:
		    OSS_CNTX_PUSH(_oss_c, 129)
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_in_data->u.aru_ppdu->u.normal_mode_parameters == nullptr)
			_oss_enc_error(_g, _bad_pointer, 0L);
#endif
		    {
			long _total_len = 0;
			OSS_CNTX_INIT

			OSS_CNTX_PUSH(_oss_c, 130)
			if (_in_data->u.aru_ppdu->u.normal_mode_parameters->bit_mask & 0x40000000) {
			    _data_len = _edUser_data(_g, _out_pos, &_out_len, &_in_data->u.aru_ppdu->u.normal_mode_parameters->user_data);
			    _total_len += _data_len;
			}
			OSS_CNTX_SET(160)
			if (_in_data->u.aru_ppdu->u.normal_mode_parameters->bit_mask & 0x80000000) {
			    _data_len = _ed14Presentation_context_ident(_g, _out_pos, &_out_len, &_in_data->u.aru_ppdu->u.normal_mode_parameters->presentation_context_identifier_list);
			    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
			    _total_len += _data_len;
			}
			OSS_CNTX_POP(_oss_c)
			_data_len = _total_len;
		    }
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
		    break;
		default:
		    _oss_enc_error(_g, _bad_choice, _in_data->u.aru_ppdu->choice);	/* Bad choice selector. */
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epAbort_type(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Abort_type	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_Abort_type *) _inbuf;
    OSS_CNTX_ANCHOR_SET(8,152)
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 2) {

	    _oss_penc_nonneg_1int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 153)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.arp_ppdu == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_oss_append_2bit_unaligned(_g, (unsigned char)(_in_data->u.arp_ppdu->bit_mask >> 24));
		OSS_CNTX_PUSH(_oss_c, 155)
		if (_in_data->u.arp_ppdu->bit_mask & 0x80000000) {
		    _oss_penc_unconstr_int_l(_g, _in_data->u.arp_ppdu->provider_reason);
		}
		OSS_CNTX_SET(154)
		if (_in_data->u.arp_ppdu->bit_mask & 0x40000000) {
		    _oss_penc_unconstr_int_l(_g, _in_data->u.arp_ppdu->event_identifier);
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 156)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.aru_ppdu == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		OSS_CNTX_INIT

		if (_in_data->u.aru_ppdu->choice <= 2) {

		    _oss_penc_nonneg_1int(_g, _in_data->u.aru_ppdu->choice - 1);
		}
		switch (_in_data->u.aru_ppdu->choice) {
		case 1:
		    OSS_CNTX_PUSH(_oss_c, 151)
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_in_data->u.aru_ppdu->u.x400_mode_parameters == nullptr)
			_oss_enc_error(_g, _bad_pointer, 0L);
#endif
		    {
			OSS_CNTX_INIT

			_oss_append_3bit_unaligned(_g, (unsigned char)(_in_data->u.aru_ppdu->u.x400_mode_parameters->bit_mask >> 24));
			OSS_CNTX_PUSH(_oss_c, 159)
			if (_in_data->u.aru_ppdu->u.x400_mode_parameters->bit_mask & 0x80000000) {
			    _oss_penc_unconstr_int_l(_g, _in_data->u.aru_ppdu->u.x400_mode_parameters->abortReason);
			}
			OSS_CNTX_SET(158)
			if (_in_data->u.aru_ppdu->u.x400_mode_parameters->bit_mask & 0x40000000) {
#if OSS_TOED_API_LEVEL >= 27
			    _oss_penc_uncon_bit(_g, _in_data->u.aru_ppdu->u.x400_mode_parameters->reflectedParameter.value, _in_data->u.aru_ppdu->u.x400_mode_parameters->reflectedParameter.length);
#else
			    _oss_penc_unconstr_bit_l(_g, _in_data->u.aru_ppdu->u.x400_mode_parameters->reflectedParameter.value, _in_data->u.aru_ppdu->u.x400_mode_parameters->reflectedParameter.length, FALSE);
#endif
			}
			OSS_CNTX_SET(157)
			if (_in_data->u.aru_ppdu->u.x400_mode_parameters->bit_mask & 0x20000000) {
			    _oss_penc_opentype(_g, &_in_data->u.aru_ppdu->u.x400_mode_parameters->userdataAB);
			}
			OSS_CNTX_POP(_oss_c)
		    }
		    break;
		case 2:
		    OSS_CNTX_PUSH(_oss_c, 129)
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_in_data->u.aru_ppdu->u.normal_mode_parameters == nullptr)
			_oss_enc_error(_g, _bad_pointer, 0L);
#endif
		    {
			OSS_CNTX_INIT

			_oss_append_2bit_unaligned(_g, (unsigned char)(_in_data->u.aru_ppdu->u.normal_mode_parameters->bit_mask >> 24));
			OSS_CNTX_PUSH(_oss_c, 160)
			if (_in_data->u.aru_ppdu->u.normal_mode_parameters->bit_mask & 0x80000000) {
			    _ep_14Presentation_context_ident(_g, &_in_data->u.aru_ppdu->u.normal_mode_parameters->presentation_context_identifier_list);
			}
			OSS_CNTX_SET(130)
			if (_in_data->u.aru_ppdu->u.normal_mode_parameters->bit_mask & 0x40000000) {
			    _ep_User_data(_g, &_in_data->u.aru_ppdu->u.normal_mode_parameters->user_data);
			}
			OSS_CNTX_POP(_oss_c)
		    }
		    break;
		default:
		    _oss_enc_error(_g, _bad_choice, _in_data->u.aru_ppdu->choice);	/* Bad choice selector. */
		}
		OSS_CNTX_POP(_oss_c)
	    }

	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eTyped_data_type(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Typed_data_type	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_Typed_data_type *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(9,161)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 162)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.ttdPPDU == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edUser_data(_g, _out_pos, &_out_len, _in_data->u.ttdPPDU);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 163)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.acPPDU == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 130)
		if (_in_data->u.acPPDU->bit_mask & 0x20000000) {
		    _data_len = _edUser_data(_g, _out_pos, &_out_len, &_in_data->u.acPPDU->user_data);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(164)
		if (_in_data->u.acPPDU->bit_mask & 0x40000000) {
		    {
			_Presentation_context_deletion_list * _temp;
			unsigned long count;
			unsigned long _lindex;
			long _total_len = 0;
			OSS_UINT32 _sp;
			void **_st = _oss_load_enc_stack(_g, &_sp);
			OSS_CNTX_NEW(_oss_c, 165)
			for (_temp = _in_data->u.acPPDU->presentation_context_deletion_list, count = 0; _temp; _temp = _temp->next) {
			    OSS_CNTX_SETOCC(count + 1)
			    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
			    _st[_sp++] = _temp;
			    count++;
			}
			for (_lindex = 0; _lindex < count; _lindex++) {
			    OSS_CNTX_SETOCC(count - _lindex)
			    _temp = (_Presentation_context_deletion_list *)_st[--_sp];
			    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
			    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _temp->value, 0x2);
			    _total_len += _data_len;
			}
			_oss_save_enc_stack(_g, _sp);
			OSS_CNTX_POP(_oss_c)
			_data_len = _total_len;
		    }
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(166)
		if (_in_data->u.acPPDU->bit_mask & 0x80000000) {
		    _data_len = _edContext_list(_g, _out_pos, &_out_len, &_in_data->u.acPPDU->presentation_context_addition_list);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
		    _total_len += _data_len;
		}
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 167)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.acaPPDU == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 130)
		if (_in_data->u.acaPPDU->bit_mask & 0x20000000) {
		    _data_len = _edUser_data(_g, _out_pos, &_out_len, &_in_data->u.acaPPDU->user_data);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(168)
		if (_in_data->u.acaPPDU->bit_mask & 0x40000000) {
		    {
			_Presentation_context_deletion_list * _temp;
			unsigned long count;
			unsigned long _lindex;
			long _total_len = 0;
			OSS_UINT32 _sp;
			void **_st = _oss_load_enc_stack(_g, &_sp);
			OSS_CNTX_NEW(_oss_c, 72)
			for (_temp = _in_data->u.acaPPDU->presentation_context_deletion_result_list, count = 0; _temp; _temp = _temp->next) {
			    OSS_CNTX_SETOCC(count + 1)
			    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
			    _st[_sp++] = _temp;
			    count++;
			}
			for (_lindex = 0; _lindex < count; _lindex++) {
			    OSS_CNTX_SETOCC(count - _lindex)
			    _temp = (_Presentation_context_deletion_list *)_st[--_sp];
			    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
			    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _temp->value, 0x2);
			    _total_len += _data_len;
			}
			_oss_save_enc_stack(_g, _sp);
			OSS_CNTX_POP(_oss_c)
			_data_len = _total_len;
		    }
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(169)
		if (_in_data->u.acaPPDU->bit_mask & 0x80000000) {
		    _data_len = _edResult_list(_g, _out_pos, &_out_len, &_in_data->u.acaPPDU->presentation_context_addition_result_list);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
		    _total_len += _data_len;
		}
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epTyped_data_type(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Typed_data_type	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_Typed_data_type *) _inbuf;
    OSS_CNTX_ANCHOR_SET(9,161)
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 3) {

	    _oss_penc_nonneg_2int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 162)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.ttdPPDU == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_User_data(_g, _in_data->u.ttdPPDU);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 163)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.acPPDU == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_oss_append_3bit_unaligned(_g, (unsigned char)(_in_data->u.acPPDU->bit_mask >> 24));
		OSS_CNTX_PUSH(_oss_c, 166)
		if (_in_data->u.acPPDU->bit_mask & 0x80000000) {
		    _ep_Context_list(_g, &_in_data->u.acPPDU->presentation_context_addition_list);
		}
		OSS_CNTX_SET(164)
		if (_in_data->u.acPPDU->bit_mask & 0x40000000) {
		    {
			_Presentation_context_deletion_list * _temp;
			unsigned int _fragm_cnt;
			unsigned int _cnt;
			int _ext;
			OSS_CNTX_INIT

			for (_cnt = 0, _temp = _in_data->u.acPPDU->presentation_context_deletion_list; _temp; _temp = _temp->next)
			    ++_cnt;

			if (_cnt <= 7) {
			    _oss_append_1bit_unaligned(_g, 0);
			    _ext = 0;
			} else {
			    _oss_append_1bit_unaligned(_g, 0x80);
			    _ext = 1;
			}
			OSS_CNTX_PUSH(_oss_c, 165)
			for (_temp = _in_data->u.acPPDU->presentation_context_deletion_list;; _cnt -= _fragm_cnt) {
			    unsigned int _idx;

			    if (_ext)
#if OSS_TOED_API_LEVEL >= 27
				_fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
				_fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
			    else
#if OSS_TOED_API_LEVEL >= 27
				_oss_penc_lrang(_g, _fragm_cnt = _cnt, 0, 7);
#else
				_fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 7, 0);
#endif
			    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
				OSS_CNTX_INCOCC
				if (_temp->value >= 1 && _temp->value <= 127) {
				    _oss_append_1bit_unaligned(_g, 0x00);
				    _oss_penc_nonneg_7int(_g, _temp->value - 1);
				} else {
				    _oss_append_1bit_unaligned(_g, 0x80);
				    _oss_penc_unconstr_int_l(_g, _temp->value);
				}
			    }
			    if (_cnt == _fragm_cnt) {
				break;
			    }
			}
			OSS_CNTX_POP(_oss_c)
		    }
		}
		OSS_CNTX_SET(130)
		if (_in_data->u.acPPDU->bit_mask & 0x20000000) {
		    _ep_User_data(_g, &_in_data->u.acPPDU->user_data);
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 167)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.acaPPDU == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_oss_append_3bit_unaligned(_g, (unsigned char)(_in_data->u.acaPPDU->bit_mask >> 24));
		OSS_CNTX_PUSH(_oss_c, 169)
		if (_in_data->u.acaPPDU->bit_mask & 0x80000000) {
		    _ep_Result_list(_g, &_in_data->u.acaPPDU->presentation_context_addition_result_list);
		}
		OSS_CNTX_SET(168)
		if (_in_data->u.acaPPDU->bit_mask & 0x40000000) {
		    {
			_Presentation_context_deletion_list * _temp;
			unsigned int _fragm_cnt;
			unsigned int _cnt;
			int _ext;
			OSS_CNTX_INIT

			for (_cnt = 0, _temp = _in_data->u.acaPPDU->presentation_context_deletion_result_list; _temp; _temp = _temp->next)
			    ++_cnt;

			if (_cnt <= 7) {
			    _oss_append_1bit_unaligned(_g, 0);
			    _ext = 0;
			} else {
			    _oss_append_1bit_unaligned(_g, 0x80);
			    _ext = 1;
			}
			OSS_CNTX_PUSH(_oss_c, 72)
			for (_temp = _in_data->u.acaPPDU->presentation_context_deletion_result_list;; _cnt -= _fragm_cnt) {
			    unsigned int _idx;

			    if (_ext)
#if OSS_TOED_API_LEVEL >= 27
				_fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
				_fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
			    else
#if OSS_TOED_API_LEVEL >= 27
				_oss_penc_lrang(_g, _fragm_cnt = _cnt, 0, 7);
#else
				_fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 7, 0);
#endif
			    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
				OSS_CNTX_INCOCC
				_oss_penc_unconstr_int_l(_g, _temp->value);
			    }
			    if (_cnt == _fragm_cnt) {
				break;
			    }
			}
			OSS_CNTX_POP(_oss_c)
		    }
		}
		OSS_CNTX_SET(130)
		if (_in_data->u.acaPPDU->bit_mask & 0x20000000) {
		    _ep_User_data(_g, &_in_data->u.acaPPDU->user_data);
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eRS_PPDU(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _seq6	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_seq6 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(10,170)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 130)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _edUser_data(_g, _out_pos, &_out_len, &_in_data->user_data);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(160)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _ed14Presentation_context_ident(_g, _out_pos, &_out_len, &_in_data->presentation_context_identifier_list);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epRS_PPDU(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _seq6	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_seq6 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(10,170)
    {
	OSS_CNTX_INIT

	_oss_append_2bit_unaligned(_g, (unsigned char)(_in_data->bit_mask >> 24));
	OSS_CNTX_PUSH(_oss_c, 160)
	if (_in_data->bit_mask & 0x80000000) {
	    _ep_14Presentation_context_ident(_g, &_in_data->presentation_context_identifier_list);
	}
	OSS_CNTX_SET(130)
	if (_in_data->bit_mask & 0x40000000) {
	    _ep_User_data(_g, &_in_data->user_data);
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eRSA_PPDU(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _seq6	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_seq6 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(11,171)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 130)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _edUser_data(_g, _out_pos, &_out_len, &_in_data->user_data);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(160)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _ed14Presentation_context_ident(_g, _out_pos, &_out_len, &_in_data->presentation_context_identifier_list);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epRSA_PPDU(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _seq6	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_seq6 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(11,171)
    {
	OSS_CNTX_INIT

	_oss_append_2bit_unaligned(_g, (unsigned char)(_in_data->bit_mask >> 24));
	OSS_CNTX_PUSH(_oss_c, 160)
	if (_in_data->bit_mask & 0x80000000) {
	    _ep_14Presentation_context_ident(_g, &_in_data->presentation_context_identifier_list);
	}
	OSS_CNTX_SET(130)
	if (_in_data->bit_mask & 0x40000000) {
	    _ep_User_data(_g, &_in_data->user_data);
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _e0Reliable_Transfer_APDU_RTSE(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Reliable_Transfer_APDU_RTSE_apdus	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_Reliable_Transfer_APDU_RTSE_apdus *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(12,172)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 173)
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.rttp_apdu, 0x2);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 174)
	    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->u.rttr_apdu.value, _in_data->u.rttr_apdu.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 175)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.rtorq_apdu == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edRTORQapdu(_g, _out_pos, &_out_len, _in_data->u.rtorq_apdu);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xB0);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 176)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.rtoac_apdu == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edRTOACapdu(_g, _out_pos, &_out_len, _in_data->u.rtoac_apdu);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xB1);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 177)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.rtorj_apdu == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edRTORJapdu(_g, _out_pos, &_out_len, _in_data->u.rtorj_apdu);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xB2);
	    break;
	case 6:
	    OSS_CNTX_PUSH(_oss_c, 178)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.rtab_apdu == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 157)
		if (_in_data->u.rtab_apdu->bit_mask & 0x20000000) {
		    _data_len = _oss_encd_opentype(_g, _out_pos, &_out_len, &_in_data->u.rtab_apdu->userdataAB);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(158)
		if (_in_data->u.rtab_apdu->bit_mask & 0x40000000) {
		    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->u.rtab_apdu->reflectedParameter.value, _in_data->u.rtab_apdu->reflectedParameter.length, -1, FALSE);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA1 : 0x81);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(159)
		if (_in_data->u.rtab_apdu->bit_mask & 0x80000000) {
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.rtab_apdu->abortReason, 0x80);
		    _total_len += _data_len;
		}
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xB6);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep0Reliable_Transfer_APDU_RTSE(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Reliable_Transfer_APDU_RTSE_apdus	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_Reliable_Transfer_APDU_RTSE_apdus *) _inbuf;
    OSS_CNTX_ANCHOR_SET(12,172)
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 6) {

	    _oss_penc_nonneg_3int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 173)
	    _oss_penc_unconstr_int_l(_g, _in_data->u.rttp_apdu);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 174)
#if OSS_TOED_API_LEVEL >= 27
	    _oss_penc_uncon_oct(_g, (unsigned char *)_in_data->u.rttr_apdu.value, _in_data->u.rttr_apdu.length);
#else
	    _oss_penc_unconstr_oct_l(_g, (unsigned char *)_in_data->u.rttr_apdu.value, _in_data->u.rttr_apdu.length);
#endif
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 175)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.rtorq_apdu == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_RTORQapdu(_g, _in_data->u.rtorq_apdu);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 176)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.rtoac_apdu == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_RTOACapdu(_g, _in_data->u.rtoac_apdu);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 177)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.rtorj_apdu == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_RTORJapdu(_g, _in_data->u.rtorj_apdu);
	    break;
	case 6:
	    OSS_CNTX_PUSH(_oss_c, 178)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.rtab_apdu == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_oss_append_3bit_unaligned(_g, (unsigned char)(_in_data->u.rtab_apdu->bit_mask >> 24));
		OSS_CNTX_PUSH(_oss_c, 159)
		if (_in_data->u.rtab_apdu->bit_mask & 0x80000000) {
		    _oss_penc_unconstr_int_l(_g, _in_data->u.rtab_apdu->abortReason);
		}
		OSS_CNTX_SET(158)
		if (_in_data->u.rtab_apdu->bit_mask & 0x40000000) {
#if OSS_TOED_API_LEVEL >= 27
		    _oss_penc_uncon_bit(_g, _in_data->u.rtab_apdu->reflectedParameter.value, _in_data->u.rtab_apdu->reflectedParameter.length);
#else
		    _oss_penc_unconstr_bit_l(_g, _in_data->u.rtab_apdu->reflectedParameter.value, _in_data->u.rtab_apdu->reflectedParameter.length, FALSE);
#endif
		}
		OSS_CNTX_SET(157)
		if (_in_data->u.rtab_apdu->bit_mask & 0x20000000) {
		    _oss_penc_opentype(_g, &_in_data->u.rtab_apdu->userdataAB);
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

    OSS_CNTX_POP(_oss_c)
}

static void _e1Remote_Operations_Abstract_(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Reliable_Transfer_APDU_RTSE_apdus	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_Reliable_Transfer_APDU_RTSE_apdus *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(13,172)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 173)
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.rttp_apdu, 0x2);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 174)
	    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->u.rttr_apdu.value, _in_data->u.rttr_apdu.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 175)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.rtorq_apdu == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edRTORQapdu(_g, _out_pos, &_out_len, _in_data->u.rtorq_apdu);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xB0);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 176)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.rtoac_apdu == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edRTOACapdu(_g, _out_pos, &_out_len, _in_data->u.rtoac_apdu);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xB1);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 177)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.rtorj_apdu == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edRTORJapdu(_g, _out_pos, &_out_len, _in_data->u.rtorj_apdu);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xB2);
	    break;
	case 6:
	    OSS_CNTX_PUSH(_oss_c, 178)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.rtab_apdu == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 157)
		if (_in_data->u.rtab_apdu->bit_mask & 0x20000000) {
		    _data_len = _oss_encd_opentype(_g, _out_pos, &_out_len, &_in_data->u.rtab_apdu->userdataAB);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(158)
		if (_in_data->u.rtab_apdu->bit_mask & 0x40000000) {
		    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->u.rtab_apdu->reflectedParameter.value, _in_data->u.rtab_apdu->reflectedParameter.length, -1, FALSE);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0xA1 : 0x81);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(159)
		if (_in_data->u.rtab_apdu->bit_mask & 0x80000000) {
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->u.rtab_apdu->abortReason, 0x80);
		    _total_len += _data_len;
		}
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xB6);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep1Remote_Operations_Abstract_(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Reliable_Transfer_APDU_RTSE_apdus	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_Reliable_Transfer_APDU_RTSE_apdus *) _inbuf;
    OSS_CNTX_ANCHOR_SET(13,172)
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 6) {

	    _oss_penc_nonneg_3int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 173)
	    _oss_penc_unconstr_int_l(_g, _in_data->u.rttp_apdu);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 174)
#if OSS_TOED_API_LEVEL >= 27
	    _oss_penc_uncon_oct(_g, (unsigned char *)_in_data->u.rttr_apdu.value, _in_data->u.rttr_apdu.length);
#else
	    _oss_penc_unconstr_oct_l(_g, (unsigned char *)_in_data->u.rttr_apdu.value, _in_data->u.rttr_apdu.length);
#endif
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 175)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.rtorq_apdu == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_RTORQapdu(_g, _in_data->u.rtorq_apdu);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 176)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.rtoac_apdu == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_RTOACapdu(_g, _in_data->u.rtoac_apdu);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 177)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.rtorj_apdu == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_RTORJapdu(_g, _in_data->u.rtorj_apdu);
	    break;
	case 6:
	    OSS_CNTX_PUSH(_oss_c, 178)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.rtab_apdu == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_oss_append_3bit_unaligned(_g, (unsigned char)(_in_data->u.rtab_apdu->bit_mask >> 24));
		OSS_CNTX_PUSH(_oss_c, 159)
		if (_in_data->u.rtab_apdu->bit_mask & 0x80000000) {
		    _oss_penc_unconstr_int_l(_g, _in_data->u.rtab_apdu->abortReason);
		}
		OSS_CNTX_SET(158)
		if (_in_data->u.rtab_apdu->bit_mask & 0x40000000) {
#if OSS_TOED_API_LEVEL >= 27
		    _oss_penc_uncon_bit(_g, _in_data->u.rtab_apdu->reflectedParameter.value, _in_data->u.rtab_apdu->reflectedParameter.length);
#else
		    _oss_penc_unconstr_bit_l(_g, _in_data->u.rtab_apdu->reflectedParameter.value, _in_data->u.rtab_apdu->reflectedParameter.length, FALSE);
#endif
		}
		OSS_CNTX_SET(157)
		if (_in_data->u.rtab_apdu->bit_mask & 0x20000000) {
		    _oss_penc_opentype(_g, &_in_data->u.rtab_apdu->userdataAB);
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eROSEInvokeIds(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeId	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_InvokeId *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(14,179)
    _data_len = _edInvokeId(_g, _out_pos, &_out_len, _in_data);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epROSEInvokeIds(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeId	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_InvokeId *) _inbuf;
    OSS_CNTX_ANCHOR_SET(14,179)
    _ep_InvokeId(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eReject(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Reject	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_Reject *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(15,180)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 181)
	{
	    OSS_CNTX_INIT

	    switch (_in_data->problem.choice) {
	    case 1:
		OSS_CNTX_PUSH(_oss_c, 182)
		_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->problem.u.general, 0x80);
		break;
	    case 2:
		OSS_CNTX_PUSH(_oss_c, 183)
		_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->problem.u.invoke, 0x81);
		break;
	    case 3:
		OSS_CNTX_PUSH(_oss_c, 184)
		_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->problem.u.returnResult, 0x82);
		break;
	    case 4:
		OSS_CNTX_PUSH(_oss_c, 185)
		_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->problem.u.returnError, 0x83);
		break;
	    default:
		_oss_enc_error(_g, _bad_choice, _in_data->problem.choice);	/* Bad choice selector. */
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_total_len += _data_len;
	OSS_CNTX_SET(186)
	_data_len = _edInvokeId(_g, _out_pos, &_out_len, &_in_data->invokeId);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epReject(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Reject	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_Reject *) _inbuf;
    OSS_CNTX_ANCHOR_SET(15,180)
    {
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 186)
	_ep_InvokeId(_g, &_in_data->invokeId);
	OSS_CNTX_SET(181)
	{
	    OSS_CNTX_INIT

	    if (_in_data->problem.choice <= 4) {

		_oss_penc_nonneg_2int(_g, _in_data->problem.choice - 1);
	    }
	    switch (_in_data->problem.choice) {
	    case 1:
		OSS_CNTX_PUSH(_oss_c, 182)
		_oss_penc_unconstr_int_l(_g, _in_data->problem.u.general);
		break;
	    case 2:
		OSS_CNTX_PUSH(_oss_c, 183)
		_oss_penc_unconstr_int_l(_g, _in_data->problem.u.invoke);
		break;
	    case 3:
		OSS_CNTX_PUSH(_oss_c, 184)
		_oss_penc_unconstr_int_l(_g, _in_data->problem.u.returnResult);
		break;
	    case 4:
		OSS_CNTX_PUSH(_oss_c, 185)
		_oss_penc_unconstr_int_l(_g, _in_data->problem.u.returnError);
		break;
	    default:
		_oss_enc_error(_g, _bad_choice, _in_data->problem.choice);	/* Bad choice selector. */
	    }
	    OSS_CNTX_POP(_oss_c)
	}

	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eNoInvokeId(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeId	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_InvokeId *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(16,187)
    _data_len = _edInvokeId(_g, _out_pos, &_out_len, _in_data);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epNoInvokeId(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeId	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_InvokeId *) _inbuf;
    OSS_CNTX_ANCHOR_SET(16,187)
    _ep_InvokeId(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eUnboundedDirectoryString(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _UnboundedDirectoryString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_UnboundedDirectoryString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(17,188)
    _data_len = _edUnboundedDirectoryString(_g, _out_pos, &_out_len, _in_data);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epUnboundedDirectoryString(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _UnboundedDirectoryString	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_UnboundedDirectoryString *) _inbuf;
    OSS_CNTX_ANCHOR_SET(17,188)
    _ep_UnboundedDirectoryString(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eUniqueIdentifier(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssBitString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(18,189)
    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1, FALSE);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x23 : 0x3);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epUniqueIdentifier(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssBitString *) _inbuf;
    OSS_CNTX_ANCHOR_SET(18,189)
#if OSS_TOED_API_LEVEL >= 27
    _oss_penc_uncon_bit(_g, _in_data->value, _in_data->length);
#else
    _oss_penc_unconstr_bit_l(_g, _in_data->value, _in_data->length, FALSE);
#endif
    OSS_CNTX_POP(_oss_c)
}

static void _eUUIDPair(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _UUIDPair	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_UUIDPair *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(19,190)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 191)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->subjectUUID.value, _in_data->subjectUUID.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	_total_len += _data_len;
	OSS_CNTX_SET(192)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->issuerUUID.value, _in_data->issuerUUID.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epUUIDPair(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _UUIDPair	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_UUIDPair *) _inbuf;
    OSS_CNTX_ANCHOR_SET(19,190)
    {
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 192)
	if (_in_data->issuerUUID.length == 16) {
#if OSS_TOED_API_LEVEL >= 27
	    _oss_penc_fix_bit(_g, (unsigned char *)_in_data->issuerUUID.value, 128);
#else
	    _oss_append(_g, (unsigned char *)_in_data->issuerUUID.value, 16*8, Aligned);
#endif
	} else {
	    _oss_enc_error(_g, _sizeConstraint_length, _in_data->issuerUUID.length);
	}
	OSS_CNTX_SET(191)
	if (_in_data->subjectUUID.length == 16) {
#if OSS_TOED_API_LEVEL >= 27
	    _oss_penc_fix_bit(_g, (unsigned char *)_in_data->subjectUUID.value, 128);
#else
	    _oss_append(_g, (unsigned char *)_in_data->subjectUUID.value, 16*8, Aligned);
#endif
	} else {
	    _oss_enc_error(_g, _sizeConstraint_length, _in_data->subjectUUID.length);
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eCountryName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(20,193)
    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epCountryName(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    OSS_CNTX_ANCHOR_SET(20,193)
    _oss_penc_kmstr(_g, _in_data->value, _in_data->length, _chars + 4, 0);
    OSS_CNTX_POP(_oss_c)
}

static void _eGuide(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Guide	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_Guide *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(21,194)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 195)
	_data_len = _edCriteria(_g, _out_pos, &_out_len, &_in_data->criteria);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(196)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->objectClass.value, _in_data->objectClass.length, -1);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x6, 0xA0);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epGuide(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Guide	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_Guide *) _inbuf;
    OSS_CNTX_ANCHOR_SET(21,194)
    {
	OSS_CNTX_INIT

	_oss_append_1bit_unaligned(_g, (unsigned char)(_in_data->bit_mask >> 24));
	OSS_CNTX_PUSH(_oss_c, 196)
	if (_in_data->bit_mask & 0x80000000) {
	    _oss_penc_eobjid_ia(_g, _in_data->objectClass.value, _in_data->objectClass.length, -1);
	}
	OSS_CNTX_SET(195)
	_ep_Criteria(_g, &_in_data->criteria);
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eEnhancedGuide(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EnhancedGuide	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_EnhancedGuide *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(22,197)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 198)
	if (_in_data->bit_mask & 0x80000000 &&
	    _oss_not_dflt_ia(_g, &_in_data->subset, (OSS_INT32  *)&EnhancedGuide::default_subset, sizeof(OSS_INT32 ), 0, -1, 0)) {
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->subset, 0x2);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(195)
	_data_len = _edCriteria(_g, _out_pos, &_out_len, &_in_data->criteria);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
	_total_len += _data_len;
	OSS_CNTX_SET(196)
	_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->objectClass.value, _in_data->objectClass.length, -1);
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x6, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epEnhancedGuide(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EnhancedGuide	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_EnhancedGuide *) _inbuf;
    OSS_CNTX_ANCHOR_SET(22,197)
    {
	OSS_UINT32 _bitmask = _in_data->bit_mask;
	OSS_CNTX_INIT

#ifdef OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES
	if (_g->encodingFlags & STRICT_PER_ENCODING_OF_DEFAULT_VALUES) {
	    if ((_bitmask & 0x80000000) &&
		!_oss_not_dflt_ia(_g, &_in_data->subset, (OSS_INT32  *)&EnhancedGuide::default_subset, sizeof(OSS_INT32 ), 0, -1, 0))
		_bitmask ^= 0x80000000;
	}
#endif /* OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES */
	_oss_append_1bit_unaligned(_g, (unsigned char)(_bitmask >> 24));
	OSS_CNTX_PUSH(_oss_c, 196)
	_oss_penc_eobjid_ia(_g, _in_data->objectClass.value, _in_data->objectClass.length, -1);
	OSS_CNTX_SET(195)
	_ep_Criteria(_g, &_in_data->criteria);
	OSS_CNTX_SET(198)
	if (_bitmask & 0x80000000) {
	    _oss_penc_unconstr_int_l(_g, _in_data->subset);
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _ePostalAddress(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PostalAddress	**_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_PostalAddress **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(23,199)
    {
	_PostalAddress * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 200)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_PostalAddress *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _data_len = _edUnboundedDirectoryString(_g, _out_pos, &_out_len, &_temp->value);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epPostalAddress(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PostalAddress	**_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_PostalAddress **) _inbuf;
    OSS_CNTX_ANCHOR_SET(23,199)
    {
	_PostalAddress * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	OSS_CNTX_PUSH(_oss_c, 200)
	_ext = (_cnt >= 16384) ? 2 : 0;
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
	    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
	    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		_ep_UnboundedDirectoryString(_g, &_temp->value);
	    }
	    if (_cnt == _fragm_cnt) {
		if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
		    _oss_append_8bit_aligned(_g, 0);
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eTelephoneNumber(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(24,201)
    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epTelephoneNumber(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    OSS_CNTX_ANCHOR_SET(24,201)
    _oss_penc_kmstr(_g, _in_data->value, _in_data->length, _chars + 5, 0);
    OSS_CNTX_POP(_oss_c)
}

static void _eTelexNumber(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _TelexNumber	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_TelexNumber *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(25,202)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 203)
	_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->answerback.value, _in_data->answerback.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
	_total_len += _data_len;
	OSS_CNTX_SET(204)
	_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->countryCode.value, _in_data->countryCode.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
	_total_len += _data_len;
	OSS_CNTX_SET(205)
	_data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->telexNumber.value, _in_data->telexNumber.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epTelexNumber(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _TelexNumber	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_TelexNumber *) _inbuf;
    OSS_CNTX_ANCHOR_SET(25,202)
    {
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 205)
	_oss_penc_kmstr(_g, _in_data->telexNumber.value, _in_data->telexNumber.length, _chars + 6, 0);
	OSS_CNTX_SET(204)
	_oss_penc_kmstr(_g, _in_data->countryCode.value, _in_data->countryCode.length, _chars + 7, 0);
	OSS_CNTX_SET(203)
	_oss_penc_kmstr(_g, _in_data->answerback.value, _in_data->answerback.length, _chars + 8, 0);
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eX121Address(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(26,206)
    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x32 : 0x12);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epX121Address(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    OSS_CNTX_ANCHOR_SET(26,206)
    _oss_penc_kmstr(_g, _in_data->value, _in_data->length, _chars + 9, 0);
    OSS_CNTX_POP(_oss_c)
}

static void _eInternationalISDNNumber(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(27,207)
    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x32 : 0x12);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epInternationalISDNNumber(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    OSS_CNTX_ANCHOR_SET(27,207)
    _oss_penc_kmstr(_g, _in_data->value, _in_data->length, _chars + 10, 0);
    OSS_CNTX_POP(_oss_c)
}

static void _eDestinationIndicator(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(28,208)
    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epDestinationIndicator(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    OSS_CNTX_ANCHOR_SET(28,208)
    _oss_penc_kmstr(_g, _in_data->value, _in_data->length, _chars + 0, 0);
    OSS_CNTX_POP(_oss_c)
}

static void _eCommunicationsService(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssEncOID	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssEncOID *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(29,209)
    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epCommunicationsService(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssEncOID	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssEncOID *) _inbuf;
    OSS_CNTX_ANCHOR_SET(29,209)
    _oss_penc_eobjid_ia(_g, _in_data->value, _in_data->length, -1);
    OSS_CNTX_POP(_oss_c)
}

static void _eCommunicationsNetwork(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssEncOID	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssEncOID *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(30,210)
    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epCommunicationsNetwork(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssEncOID	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssEncOID *) _inbuf;
    OSS_CNTX_ANCHOR_SET(30,210)
    _oss_penc_eobjid_ia(_g, _in_data->value, _in_data->length, -1);
    OSS_CNTX_POP(_oss_c)
}

static void _ePreferredDeliveryMethod(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Presentation_context_deletion_list	**_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_Presentation_context_deletion_list **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(31,211)
    {
	_Presentation_context_deletion_list * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 72)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_Presentation_context_deletion_list *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _temp->value, 0x2);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epPreferredDeliveryMethod(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Presentation_context_deletion_list	**_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_Presentation_context_deletion_list **) _inbuf;
    OSS_CNTX_ANCHOR_SET(31,211)
    {
	_Presentation_context_deletion_list * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	OSS_CNTX_PUSH(_oss_c, 72)
	_ext = (_cnt >= 16384) ? 2 : 0;
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
	    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
	    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		_oss_penc_unconstr_int_l(_g, _temp->value);
	    }
	    if (_cnt == _fragm_cnt) {
		if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
		    _oss_append_8bit_aligned(_g, 0);
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _ePresentationAddress(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PresentationAddress	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_PresentationAddress *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(32,212)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 213)
	{
	    _setof3 * _temp;
	    unsigned long count;
	    unsigned long _lindex;
	    long _total_len = 0;
	    OSS_UINT32 _sp;
	    void **_st = _oss_load_enc_stack(_g, &_sp);
	    OSS_CNTX_NEW(_oss_c, 214)
	    for (_temp = _in_data->nAddresses, count = 0; _temp; _temp = _temp->next) {
		OSS_CNTX_SETOCC(count + 1)
		if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		_st[_sp++] = _temp;
		count++;
	    }
	    if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
	    for (_lindex = 0; _lindex < count; _lindex++) {
		OSS_CNTX_SETOCC(count - _lindex)
		_temp = (_setof3 *)_st[--_sp];
		if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		if (count > 1) _oss_nextItem(_g, &_out_len);
		_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_temp->value.value, _temp->value.length, -1);
		if (_data_len < 0) {
		    _constructed = TRUE;
		    _data_len = -_data_len;
		} else
		    _constructed = FALSE;
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
		_total_len += _data_len;
	    }
	    _oss_save_enc_stack(_g, _sp);
	    if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x31, 0xA3);
	_total_len += _data_len;
	OSS_CNTX_SET(215)
	if (_in_data->bit_mask & 0x20000000) {
	    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->tSelector.value, _in_data->tSelector.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA2);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(216)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->sSelector.value, _in_data->sSelector.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA1);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(217)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->pSelector.value, _in_data->pSelector.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA0);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epPresentationAddress(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PresentationAddress	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_PresentationAddress *) _inbuf;
    OSS_CNTX_ANCHOR_SET(32,212)
    {
	OSS_CNTX_INIT

	_oss_append_3bit_unaligned(_g, (unsigned char)(_in_data->bit_mask >> 24));
	OSS_CNTX_PUSH(_oss_c, 217)
	if (_in_data->bit_mask & 0x80000000) {
#if OSS_TOED_API_LEVEL >= 27
	    _oss_penc_uncon_oct(_g, (unsigned char *)_in_data->pSelector.value, _in_data->pSelector.length);
#else
	    _oss_penc_unconstr_oct_l(_g, (unsigned char *)_in_data->pSelector.value, _in_data->pSelector.length);
#endif
	}
	OSS_CNTX_SET(216)
	if (_in_data->bit_mask & 0x40000000) {
#if OSS_TOED_API_LEVEL >= 27
	    _oss_penc_uncon_oct(_g, (unsigned char *)_in_data->sSelector.value, _in_data->sSelector.length);
#else
	    _oss_penc_unconstr_oct_l(_g, (unsigned char *)_in_data->sSelector.value, _in_data->sSelector.length);
#endif
	}
	OSS_CNTX_SET(215)
	if (_in_data->bit_mask & 0x20000000) {
#if OSS_TOED_API_LEVEL >= 27
	    _oss_penc_uncon_oct(_g, (unsigned char *)_in_data->tSelector.value, _in_data->tSelector.length);
#else
	    _oss_penc_unconstr_oct_l(_g, (unsigned char *)_in_data->tSelector.value, _in_data->tSelector.length);
#endif
	}
	OSS_CNTX_SET(213)
	{
	    _setof3 * _temp;
	    unsigned int _fragm_cnt;
	    unsigned int _cnt;
	    int _ext;
	    OSS_CNTX_INIT

	    for (_cnt = 0, _temp = _in_data->nAddresses; _temp; _temp = _temp->next)
		++_cnt;

	    OSS_CNTX_PUSH(_oss_c, 214)
	    _ext = (_cnt >= 16384) ? 2 : 0;
	    for (_temp = _in_data->nAddresses;; _cnt -= _fragm_cnt) {
		unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
		_fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		_fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
		for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		    OSS_CNTX_INCOCC
#if OSS_TOED_API_LEVEL >= 27
		    _oss_penc_uncon_oct(_g, (unsigned char *)_temp->value.value, _temp->value.length);
#else
		    _oss_penc_unconstr_oct_l(_g, (unsigned char *)_temp->value.value, _temp->value.length);
#endif
		}
		if (_cnt == _fragm_cnt) {
		    if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
			_oss_append_8bit_aligned(_g, 0);
		    break;
		}
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eProtocolInformation(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ProtocolInformation	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_ProtocolInformation *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(33,218)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 219)
	{
	    _Application_context_name_list * _temp;
	    unsigned long count;
	    unsigned long _lindex;
	    long _total_len = 0;
	    OSS_UINT32 _sp;
	    void **_st = _oss_load_enc_stack(_g, &_sp);
	    OSS_CNTX_NEW(_oss_c, 220)
	    for (_temp = _in_data->profiles, count = 0; _temp; _temp = _temp->next) {
		OSS_CNTX_SETOCC(count + 1)
		if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		_st[_sp++] = _temp;
		count++;
	    }
	    if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
	    for (_lindex = 0; _lindex < count; _lindex++) {
		OSS_CNTX_SETOCC(count - _lindex)
		_temp = (_Application_context_name_list *)_st[--_sp];
		if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		if (count > 1) _oss_nextItem(_g, &_out_len);
		_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _temp->value.value, _temp->value.length, -1);
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
		_total_len += _data_len;
	    }
	    _oss_save_enc_stack(_g, _sp);
	    if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
	_total_len += _data_len;
	OSS_CNTX_SET(221)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->nAddress.value, _in_data->nAddress.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epProtocolInformation(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ProtocolInformation	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_ProtocolInformation *) _inbuf;
    OSS_CNTX_ANCHOR_SET(33,218)
    {
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 221)
#if OSS_TOED_API_LEVEL >= 27
	_oss_penc_uncon_oct(_g, (unsigned char *)_in_data->nAddress.value, _in_data->nAddress.length);
#else
	_oss_penc_unconstr_oct_l(_g, (unsigned char *)_in_data->nAddress.value, _in_data->nAddress.length);
#endif
	OSS_CNTX_SET(219)
	{
	    _Application_context_name_list * _temp;
	    unsigned int _fragm_cnt;
	    unsigned int _cnt;
	    int _ext;
	    OSS_CNTX_INIT

	    for (_cnt = 0, _temp = _in_data->profiles; _temp; _temp = _temp->next)
		++_cnt;

	    OSS_CNTX_PUSH(_oss_c, 220)
	    _ext = (_cnt >= 16384) ? 2 : 0;
	    for (_temp = _in_data->profiles;; _cnt -= _fragm_cnt) {
		unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
		_fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		_fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
		for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		    OSS_CNTX_INCOCC
		    _oss_penc_eobjid_ia(_g, _temp->value.value, _temp->value.length, -1);
		}
		if (_cnt == _fragm_cnt) {
		    if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
			_oss_append_8bit_aligned(_g, 0);
		    break;
		}
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eNameAndOptionalUID(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _NameAndOptionalUID	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_NameAndOptionalUID *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(34,222)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 223)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->uid.value, _in_data->uid.length, -1, FALSE);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x23 : 0x3);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(224)
	_data_len = _edRDNSequence(_g, _out_pos, &_out_len, &_in_data->dn);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epNameAndOptionalUID(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _NameAndOptionalUID	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_NameAndOptionalUID *) _inbuf;
    OSS_CNTX_ANCHOR_SET(34,222)
    {
	OSS_CNTX_INIT

	_oss_append_1bit_unaligned(_g, (unsigned char)(_in_data->bit_mask >> 24));
	OSS_CNTX_PUSH(_oss_c, 224)
	_ep_RDNSequence(_g, &_in_data->dn);
	OSS_CNTX_SET(223)
	if (_in_data->bit_mask & 0x80000000) {
#if OSS_TOED_API_LEVEL >= 27
	    _oss_penc_uncon_bit(_g, _in_data->uid.value, _in_data->uid.length);
#else
	    _oss_penc_unconstr_bit_l(_g, _in_data->uid.value, _in_data->uid.length, FALSE);
#endif
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eMultipleMatchingLocalities(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _MultipleMatchingLocalities	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_MultipleMatchingLocalities *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(35,225)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 226)
	{
	    _seqof2 * _temp;
	    unsigned long count;
	    unsigned long _lindex;
	    long _total_len = 0;
	    OSS_UINT32 _sp;
	    void **_st = _oss_load_enc_stack(_g, &_sp);
	    OSS_CNTX_NEW(_oss_c, 227)
	    for (_temp = _in_data->attributeList, count = 0; _temp; _temp = _temp->next) {
		OSS_CNTX_SETOCC(count + 1)
		if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		_st[_sp++] = _temp;
		count++;
	    }
	    for (_lindex = 0; _lindex < count; _lindex++) {
		OSS_CNTX_SETOCC(count - _lindex)
		_temp = (_seqof2 *)_st[--_sp];
		if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		_oss_save_enc_stack(_g, _sp);
		{
		    long _total_len = 0;
		    OSS_CNTX_INIT

		    OSS_CNTX_PUSH(_oss_c, 228)
		    if (_temp->value.bit_mask & 0x80000000) {
			{
			    OSS_CNTX_INIT

			    switch (_temp->value.assertedContexts.choice) {
			    case 1:
				OSS_CNTX_PUSH(_oss_c, 229)
				_data_len = 0;
				_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x5, 0xA0);
				break;
			    case 2:
				OSS_CNTX_PUSH(_oss_c, 230)
				{
				    _setof6 * _temp1;
				    unsigned long count;
				    unsigned long _lindex;
				    long _total_len = 0;
				    OSS_CNTX_NEW(_oss_c, 231)
				    for (_temp1 = _temp->value.assertedContexts.u.selectedContexts, count = 0; _temp1; _temp1 = _temp1->next) {
					OSS_CNTX_SETOCC(count + 1)
					if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
					_st[_sp++] = _temp1;
					count++;
				    }
				    if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
				    for (_lindex = 0; _lindex < count; _lindex++) {
					OSS_CNTX_SETOCC(count - _lindex)
					_temp1 = (_setof6 *)_st[--_sp];
					if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
					if (count > 1) _oss_nextItem(_g, &_out_len);
					_oss_save_enc_stack(_g, _sp);
					_data_len = _edContextAssertion(_g, _out_pos, &_out_len, &_temp1->value);
					_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
					_st = _oss_load_enc_stack(_g, &_sp);
					_total_len += _data_len;
				    }
				    if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
				    OSS_CNTX_POP(_oss_c)
				    _data_len = _total_len;
				}
				_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x31, 0xA1);
				break;
			    default:
				_oss_enc_error(_g, _bad_choice, _temp->value.assertedContexts.choice);	/* Bad choice selector. */
			    }
			    OSS_CNTX_POP(_oss_c)
			}
			_total_len += _data_len;
		    }
		    OSS_CNTX_SET(232)
		    if (_temp->value.assertion.encoded.length == 0)
			_oss_enc_error(_g, _zero_length_OpenType, 0);
		    _data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _temp->value.assertion.encoded.value, _temp->value.assertion.encoded.length);
		    _total_len += _data_len;
		    OSS_CNTX_SET(83)
		    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _temp->value.type.value, _temp->value.type.length, -1);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
		    _total_len += _data_len;
		    OSS_CNTX_POP(_oss_c)
		    _data_len = _total_len;
		}
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
		_st = _oss_load_enc_stack(_g, &_sp);
		_total_len += _data_len;
	    }
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_SET(233)
	if (_in_data->bit_mask & 0x80000000) {
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->matchingRuleUsed.value, _in_data->matchingRuleUsed.length, -1);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epMultipleMatchingLocalities(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _MultipleMatchingLocalities	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_MultipleMatchingLocalities *) _inbuf;
    OSS_CNTX_ANCHOR_SET(35,225)
    {
	OSS_CNTX_INIT

	_oss_append_1bit_unaligned(_g, (unsigned char)(_in_data->bit_mask >> 24));
	OSS_CNTX_PUSH(_oss_c, 233)
	if (_in_data->bit_mask & 0x80000000) {
	    _oss_penc_eobjid_ia(_g, _in_data->matchingRuleUsed.value, _in_data->matchingRuleUsed.length, -1);
	}
	OSS_CNTX_SET(226)
	{
	    _seqof2 * _temp;
	    unsigned int _fragm_cnt;
	    unsigned int _cnt;
	    int _ext;
	    OSS_CNTX_INIT

	    for (_cnt = 0, _temp = _in_data->attributeList; _temp; _temp = _temp->next)
		++_cnt;

	    OSS_CNTX_PUSH(_oss_c, 227)
	    _ext = (_cnt >= 16384) ? 2 : 0;
	    for (_temp = _in_data->attributeList;; _cnt -= _fragm_cnt) {
		unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
		_fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		_fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
		for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		    OSS_CNTX_INCOCC
		    {
			OSS_CNTX_INIT

			_oss_append_1bit_unaligned(_g, (unsigned char)(_temp->value.bit_mask >> 24));
			OSS_CNTX_PUSH(_oss_c, 83)
			_oss_penc_eobjid_ia(_g, _temp->value.type.value, _temp->value.type.length, -1);
			OSS_CNTX_SET(232)
			if (_temp->value.assertion.encoded.length == 0)
			    _oss_enc_error(_g, _zero_length_OpenType, 0);
			_oss_penc_unconstr_oct_l(_g, _temp->value.assertion.encoded.value, _temp->value.assertion.encoded.length);
			OSS_CNTX_SET(228)
			if (_temp->value.bit_mask & 0x80000000) {
			    {
				OSS_CNTX_INIT

				if (_temp->value.assertedContexts.choice <= 2) {

				    _oss_penc_nonneg_1int(_g, _temp->value.assertedContexts.choice - 1);
				}
				switch (_temp->value.assertedContexts.choice) {
				case 1:
				    OSS_CNTX_PUSH(_oss_c, 229)
				    break;
				case 2:
				    OSS_CNTX_PUSH(_oss_c, 230)
				    {
					_setof6 * _temp1;
					unsigned int _fragm_cnt1;
					unsigned int _cnt1;
					int _ext1;
					OSS_CNTX_INIT

					for (_cnt1 = 0, _temp1 = _temp->value.assertedContexts.u.selectedContexts; _temp1; _temp1 = _temp1->next)
					    ++_cnt1;

					OSS_CNTX_PUSH(_oss_c, 231)
					_ext1 = (_cnt1 >= 16384) ? 2 : 0;
					for (_temp1 = _temp->value.assertedContexts.u.selectedContexts;; _cnt1 -= _fragm_cnt1) {
					    unsigned int _idx1;

#if OSS_TOED_API_LEVEL >= 27
					    _fragm_cnt1 = _oss_penc_lfrag(_g, _cnt1);
#else
					    _fragm_cnt1 = (unsigned int)_oss_penc_length_l(_g, _cnt1, 0, 0, 0);
#endif
					    for (_idx1 = 0; _idx1 < _fragm_cnt1; ++_idx1, _temp1 = _temp1->next) {
						OSS_CNTX_INCOCC
						_ep_ContextAssertion(_g, &_temp1->value);
					    }
					    if (_cnt1 == _fragm_cnt1) {
						if ((_ext1 & 2) && (_fragm_cnt1 & 0x3FFF) == 0)
						    _oss_append_8bit_aligned(_g, 0);
						break;
					    }
					}
					OSS_CNTX_POP(_oss_c)
				    }
				    break;
				default:
				    _oss_enc_error(_g, _bad_choice, _temp->value.assertedContexts.choice);	/* Bad choice selector. */
				}
				OSS_CNTX_POP(_oss_c)
			    }

			}
			OSS_CNTX_POP(_oss_c)
		    }
		}
		if (_cnt == _fragm_cnt) {
		    if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
			_oss_append_8bit_aligned(_g, 0);
		    break;
		}
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eSubstringAssertion(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SubstringAssertion	**_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_SubstringAssertion **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(36,234)
    {
	_SubstringAssertion * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 235)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_SubstringAssertion *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    {
		OSS_CNTX_INIT

		switch (_temp->value.choice) {
		case 1:
		    OSS_CNTX_PUSH(_oss_c, 236)
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_temp->value.u.control == nullptr)
			_oss_enc_error(_g, _bad_pointer, 0L);
#endif
		    {
			long _total_len = 0;
			OSS_CNTX_INIT

			OSS_CNTX_PUSH(_oss_c, 77)
			if (_temp->value.u.control->bit_mask & 0x80000000) {
			    {
				_setof14 * _temp1;
				unsigned long count;
				unsigned long _lindex;
				long _total_len = 0;
				OSS_CNTX_NEW(_oss_c, 29)
				for (_temp1 = _temp->value.u.control->valuesWithContext, count = 0; _temp1; _temp1 = _temp1->next) {
				    OSS_CNTX_SETOCC(count + 1)
				    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
				    _st[_sp++] = _temp1;
				    count++;
				}
				if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
				for (_lindex = 0; _lindex < count; _lindex++) {
				    OSS_CNTX_SETOCC(count - _lindex)
				    _temp1 = (_setof14 *)_st[--_sp];
				    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
				    if (count > 1) _oss_nextItem(_g, &_out_len);
				    _oss_save_enc_stack(_g, _sp);
				    {
					long _total_len = 0;
					OSS_CNTX_INIT

					OSS_CNTX_PUSH(_oss_c, 78)
					{
					    _setof15 * _temp2;
					    unsigned long count;
					    unsigned long _lindex;
					    long _total_len = 0;
					    OSS_CNTX_NEW(_oss_c, 79)
					    for (_temp2 = _temp1->value.contextList, count = 0; _temp2; _temp2 = _temp2->next) {
						OSS_CNTX_SETOCC(count + 1)
						if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
						_st[_sp++] = _temp2;
						count++;
					    }
					    if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
					    for (_lindex = 0; _lindex < count; _lindex++) {
						OSS_CNTX_SETOCC(count - _lindex)
						_temp2 = (_setof15 *)_st[--_sp];
						if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
						if (count > 1) _oss_nextItem(_g, &_out_len);
						_oss_save_enc_stack(_g, _sp);
						_data_len = _edContext(_g, _out_pos, &_out_len, &_temp2->value);
						_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
						_st = _oss_load_enc_stack(_g, &_sp);
						_total_len += _data_len;
					    }
					    if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
					    OSS_CNTX_POP(_oss_c)
					    _data_len = _total_len;
					}
					_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
					_total_len += _data_len;
					OSS_CNTX_SET(82)
					if (_temp1->value.value.encoded.length == 0)
					    _oss_enc_error(_g, _zero_length_OpenType, 0);
					_data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _temp1->value.value.encoded.value, _temp1->value.value.encoded.length);
					_total_len += _data_len;
					OSS_CNTX_POP(_oss_c)
					_data_len = _total_len;
				    }
				    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
				    _st = _oss_load_enc_stack(_g, &_sp);
				    _total_len += _data_len;
				}
				if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
				OSS_CNTX_POP(_oss_c)
				_data_len = _total_len;
			    }
			    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
			    _total_len += _data_len;
			}
			OSS_CNTX_SET(237)
			{
			    _setof13 * _temp1;
			    unsigned long count;
			    unsigned long _lindex;
			    long _total_len = 0;
			    OSS_CNTX_NEW(_oss_c, 6)
			    for (_temp1 = _temp->value.u.control->values, count = 0; _temp1; _temp1 = _temp1->next) {
				OSS_CNTX_SETOCC(count + 1)
				if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
				_st[_sp++] = _temp1;
				count++;
			    }
			    if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
			    for (_lindex = 0; _lindex < count; _lindex++) {
				OSS_CNTX_SETOCC(count - _lindex)
				_temp1 = (_setof13 *)_st[--_sp];
				if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
				if (count > 1) _oss_nextItem(_g, &_out_len);
				_oss_save_enc_stack(_g, _sp);
				if (_temp1->value.encoded.length == 0)
				    _oss_enc_error(_g, _zero_length_OpenType, 0);
				_data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _temp1->value.encoded.value, _temp1->value.encoded.length);
				_st = _oss_load_enc_stack(_g, &_sp);
				_total_len += _data_len;
			    }
			    if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
			    OSS_CNTX_POP(_oss_c)
			    _data_len = _total_len;
			}
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
			_total_len += _data_len;
			OSS_CNTX_SET(83)
			_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _temp->value.u.control->type.value, _temp->value.u.control->type.length, -1);
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
			_total_len += _data_len;
			OSS_CNTX_POP(_oss_c)
			_data_len = _total_len;
		    }
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
		    break;
		case 2:
		    OSS_CNTX_PUSH(_oss_c, 238)
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_temp->value.u.initial == nullptr)
			_oss_enc_error(_g, _bad_pointer, 0L);
#endif
		    _data_len = _edUnboundedDirectoryString(_g, _out_pos, &_out_len, _temp->value.u.initial);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
		    break;
		case 3:
		    OSS_CNTX_PUSH(_oss_c, 239)
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_temp->value.u.any == nullptr)
			_oss_enc_error(_g, _bad_pointer, 0L);
#endif
		    _data_len = _edUnboundedDirectoryString(_g, _out_pos, &_out_len, _temp->value.u.any);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
		    break;
		case 4:
		    OSS_CNTX_PUSH(_oss_c, 240)
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_temp->value.u.final == nullptr)
			_oss_enc_error(_g, _bad_pointer, 0L);
#endif
		    _data_len = _edUnboundedDirectoryString(_g, _out_pos, &_out_len, _temp->value.u.final);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
		    break;
		default:
		    _oss_enc_error(_g, _bad_choice, _temp->value.choice);	/* Bad choice selector. */
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epSubstringAssertion(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SubstringAssertion	**_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_SubstringAssertion **) _inbuf;
    OSS_CNTX_ANCHOR_SET(36,234)
    {
	_SubstringAssertion * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	OSS_CNTX_PUSH(_oss_c, 235)
	_ext = (_cnt >= 16384) ? 2 : 0;
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
	    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
	    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		{
		    OSS_CNTX_INIT

		    if (_temp->value.choice <= 4) {

			_oss_penc_nonneg_2int(_g, _temp->value.choice - 1);
		    }
		    switch (_temp->value.choice) {
		    case 1:
			OSS_CNTX_PUSH(_oss_c, 236)
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_temp->value.u.control == nullptr)
			    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
			{
			    OSS_CNTX_INIT

			    _oss_append_1bit_unaligned(_g, (unsigned char)(_temp->value.u.control->bit_mask >> 24));
			    OSS_CNTX_PUSH(_oss_c, 83)
			    _oss_penc_eobjid_ia(_g, _temp->value.u.control->type.value, _temp->value.u.control->type.length, -1);
			    OSS_CNTX_SET(237)
			    {
				_setof13 * _temp1;
				unsigned int _fragm_cnt1;
				unsigned int _cnt1;
				int _ext1;
				OSS_CNTX_INIT

				for (_cnt1 = 0, _temp1 = _temp->value.u.control->values; _temp1; _temp1 = _temp1->next)
				    ++_cnt1;

				OSS_CNTX_PUSH(_oss_c, 6)
				_ext1 = (_cnt1 >= 16384) ? 2 : 0;
				for (_temp1 = _temp->value.u.control->values;; _cnt1 -= _fragm_cnt1) {
				    unsigned int _idx1;

#if OSS_TOED_API_LEVEL >= 27
				    _fragm_cnt1 = _oss_penc_lfrag(_g, _cnt1);
#else
				    _fragm_cnt1 = (unsigned int)_oss_penc_length_l(_g, _cnt1, 0, 0, 0);
#endif
				    for (_idx1 = 0; _idx1 < _fragm_cnt1; ++_idx1, _temp1 = _temp1->next) {
					OSS_CNTX_INCOCC
					if (_temp1->value.encoded.length == 0)
					    _oss_enc_error(_g, _zero_length_OpenType, 0);
					_oss_penc_unconstr_oct_l(_g, _temp1->value.encoded.value, _temp1->value.encoded.length);
				    }
				    if (_cnt1 == _fragm_cnt1) {
					if ((_ext1 & 2) && (_fragm_cnt1 & 0x3FFF) == 0)
					    _oss_append_8bit_aligned(_g, 0);
					break;
				    }
				}
				OSS_CNTX_POP(_oss_c)
			    }
			    OSS_CNTX_SET(77)
			    if (_temp->value.u.control->bit_mask & 0x80000000) {
				{
				    _setof14 * _temp1;
				    unsigned int _fragm_cnt1;
				    unsigned int _cnt1;
				    int _ext1;
				    OSS_CNTX_INIT

				    for (_cnt1 = 0, _temp1 = _temp->value.u.control->valuesWithContext; _temp1; _temp1 = _temp1->next)
					++_cnt1;

				    OSS_CNTX_PUSH(_oss_c, 29)
				    _ext1 = (_cnt1 >= 16384) ? 2 : 0;
				    for (_temp1 = _temp->value.u.control->valuesWithContext;; _cnt1 -= _fragm_cnt1) {
					unsigned int _idx1;

#if OSS_TOED_API_LEVEL >= 27
					_fragm_cnt1 = _oss_penc_lfrag(_g, _cnt1);
#else
					_fragm_cnt1 = (unsigned int)_oss_penc_length_l(_g, _cnt1, 0, 0, 0);
#endif
					for (_idx1 = 0; _idx1 < _fragm_cnt1; ++_idx1, _temp1 = _temp1->next) {
					    OSS_CNTX_INCOCC
					    {
						OSS_CNTX_INIT

						OSS_CNTX_PUSH(_oss_c, 82)
						if (_temp1->value.value.encoded.length == 0)
						    _oss_enc_error(_g, _zero_length_OpenType, 0);
						_oss_penc_unconstr_oct_l(_g, _temp1->value.value.encoded.value, _temp1->value.value.encoded.length);
						OSS_CNTX_SET(78)
						{
						    _setof15 * _temp2;
						    unsigned int _fragm_cnt2;
						    unsigned int _cnt2;
						    int _ext2;
						    OSS_CNTX_INIT

						    for (_cnt2 = 0, _temp2 = _temp1->value.contextList; _temp2; _temp2 = _temp2->next)
							++_cnt2;

						    OSS_CNTX_PUSH(_oss_c, 79)
						    _ext2 = (_cnt2 >= 16384) ? 2 : 0;
						    for (_temp2 = _temp1->value.contextList;; _cnt2 -= _fragm_cnt2) {
							unsigned int _idx2;

#if OSS_TOED_API_LEVEL >= 27
							_fragm_cnt2 = _oss_penc_lfrag(_g, _cnt2);
#else
							_fragm_cnt2 = (unsigned int)_oss_penc_length_l(_g, _cnt2, 0, 0, 0);
#endif
							for (_idx2 = 0; _idx2 < _fragm_cnt2; ++_idx2, _temp2 = _temp2->next) {
							    OSS_CNTX_INCOCC
							    _ep_Context(_g, &_temp2->value);
							}
							if (_cnt2 == _fragm_cnt2) {
							    if ((_ext2 & 2) && (_fragm_cnt2 & 0x3FFF) == 0)
								_oss_append_8bit_aligned(_g, 0);
							    break;
							}
						    }
						    OSS_CNTX_POP(_oss_c)
						}
						OSS_CNTX_POP(_oss_c)
					    }
					}
					if (_cnt1 == _fragm_cnt1) {
					    if ((_ext1 & 2) && (_fragm_cnt1 & 0x3FFF) == 0)
						_oss_append_8bit_aligned(_g, 0);
					    break;
					}
				    }
				    OSS_CNTX_POP(_oss_c)
				}
			    }
			    OSS_CNTX_POP(_oss_c)
			}
			break;
		    case 2:
			OSS_CNTX_PUSH(_oss_c, 238)
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_temp->value.u.initial == nullptr)
			    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
			_ep_UnboundedDirectoryString(_g, _temp->value.u.initial);
			break;
		    case 3:
			OSS_CNTX_PUSH(_oss_c, 239)
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_temp->value.u.any == nullptr)
			    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
			_ep_UnboundedDirectoryString(_g, _temp->value.u.any);
			break;
		    case 4:
			OSS_CNTX_PUSH(_oss_c, 240)
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_temp->value.u.final == nullptr)
			    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
			_ep_UnboundedDirectoryString(_g, _temp->value.u.final);
			break;
		    default:
			_oss_enc_error(_g, _bad_choice, _temp->value.choice);	/* Bad choice selector. */
		    }
		    OSS_CNTX_POP(_oss_c)
		}

	    }
	    if (_cnt == _fragm_cnt) {
		if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
		    _oss_append_8bit_aligned(_g, 0);
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eCaseIgnoreList(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PostalAddress	**_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_PostalAddress **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(37,241)
    {
	_PostalAddress * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 200)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_PostalAddress *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _data_len = _edUnboundedDirectoryString(_g, _out_pos, &_out_len, &_temp->value);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epCaseIgnoreList(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PostalAddress	**_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_PostalAddress **) _inbuf;
    OSS_CNTX_ANCHOR_SET(37,241)
    {
	_PostalAddress * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	OSS_CNTX_PUSH(_oss_c, 200)
	_ext = (_cnt >= 16384) ? 2 : 0;
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
	    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
	    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		_ep_UnboundedDirectoryString(_g, &_temp->value);
	    }
	    if (_cnt == _fragm_cnt) {
		if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
		    _oss_append_8bit_aligned(_g, 0);
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eOctetSubstringAssertion(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _OctetSubstringAssertion	**_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_OctetSubstringAssertion **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(38,242)
    {
	_OctetSubstringAssertion * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 235)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_OctetSubstringAssertion *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    {
		OSS_CNTX_INIT

		switch (_temp->value.choice) {
		case 1:
		    OSS_CNTX_PUSH(_oss_c, 243)
		    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_temp->value.u.initial.value, _temp->value.u.initial.length, -1);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA0);
		    break;
		case 2:
		    OSS_CNTX_PUSH(_oss_c, 244)
		    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_temp->value.u.any.value, _temp->value.u.any.length, -1);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA1);
		    break;
		case 3:
		    OSS_CNTX_PUSH(_oss_c, 245)
		    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_temp->value.u.final.value, _temp->value.u.final.length, -1);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA2);
		    break;
		default:
		    _oss_enc_error(_g, _bad_choice, _temp->value.choice);	/* Bad choice selector. */
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epOctetSubstringAssertion(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _OctetSubstringAssertion	**_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_OctetSubstringAssertion **) _inbuf;
    OSS_CNTX_ANCHOR_SET(38,242)
    {
	_OctetSubstringAssertion * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	OSS_CNTX_PUSH(_oss_c, 235)
	_ext = (_cnt >= 16384) ? 2 : 0;
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
	    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
	    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		{
		    OSS_CNTX_INIT

		    if (_temp->value.choice <= 3) {

			_oss_penc_nonneg_2int(_g, _temp->value.choice - 1);
		    }
		    switch (_temp->value.choice) {
		    case 1:
			OSS_CNTX_PUSH(_oss_c, 243)
#if OSS_TOED_API_LEVEL >= 27
			_oss_penc_uncon_oct(_g, (unsigned char *)_temp->value.u.initial.value, _temp->value.u.initial.length);
#else
			_oss_penc_unconstr_oct_l(_g, (unsigned char *)_temp->value.u.initial.value, _temp->value.u.initial.length);
#endif
			break;
		    case 2:
			OSS_CNTX_PUSH(_oss_c, 244)
#if OSS_TOED_API_LEVEL >= 27
			_oss_penc_uncon_oct(_g, (unsigned char *)_temp->value.u.any.value, _temp->value.u.any.length);
#else
			_oss_penc_unconstr_oct_l(_g, (unsigned char *)_temp->value.u.any.value, _temp->value.u.any.length);
#endif
			break;
		    case 3:
			OSS_CNTX_PUSH(_oss_c, 245)
#if OSS_TOED_API_LEVEL >= 27
			_oss_penc_uncon_oct(_g, (unsigned char *)_temp->value.u.final.value, _temp->value.u.final.length);
#else
			_oss_penc_unconstr_oct_l(_g, (unsigned char *)_temp->value.u.final.value, _temp->value.u.final.length);
#endif
			break;
		    default:
			_oss_enc_error(_g, _bad_choice, _temp->value.choice);	/* Bad choice selector. */
		    }
		    OSS_CNTX_POP(_oss_c)
		}

	    }
	    if (_cnt == _fragm_cnt) {
		if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
		    _oss_append_8bit_aligned(_g, 0);
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eSequenceMatchType(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    enum SequenceMatchType	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (enum SequenceMatchType *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(39,246)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0xA);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epSequenceMatchType(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    enum SequenceMatchType	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (enum SequenceMatchType *) _inbuf;
    OSS_CNTX_ANCHOR_SET(39,246)
    _oss_penc_uenum(_g, *_in_data, (struct _enum_data *)&_enums[4], nullptr);
    OSS_CNTX_POP(_oss_c)
}

static void _eWordMatchTypes(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    enum WordMatchTypes	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (enum WordMatchTypes *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(40,247)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0xA);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epWordMatchTypes(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    enum WordMatchTypes	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (enum WordMatchTypes *) _inbuf;
    OSS_CNTX_ANCHOR_SET(40,247)
    _oss_penc_uenum(_g, *_in_data, (struct _enum_data *)&_enums[5], nullptr);
    OSS_CNTX_POP(_oss_c)
}

static void _eCharacterMatchTypes(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    enum CharacterMatchTypes	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (enum CharacterMatchTypes *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(41,248)
    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, *_in_data, 0xA);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epCharacterMatchTypes(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    enum CharacterMatchTypes	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (enum CharacterMatchTypes *) _inbuf;
    OSS_CNTX_ANCHOR_SET(41,248)
    _oss_penc_uenum(_g, *_in_data, (struct _enum_data *)&_enums[6], nullptr);
    OSS_CNTX_POP(_oss_c)
}

static void _eLanguageContextSyntax(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(42,249)
    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epLanguageContextSyntax(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    OSS_CNTX_ANCHOR_SET(42,249)
    _oss_penc_kmstr(_g, _in_data->value, _in_data->length, _chars + 11, 0);
    OSS_CNTX_POP(_oss_c)
}

static void _eTimeSpecification(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _TimeSpecification	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_TimeSpecification *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(43,250)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 251)
	if (_in_data->bit_mask & 0x40000000) {
	    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->timeZone, 0x2);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(252)
	if (_in_data->bit_mask & 0x80000000 &&
	    _oss_not_dflt_ia(_g, &_in_data->notThisTime, (ossBoolean  *)&Context::default_fallback, sizeof(ossBoolean ), 0, -1, 8)) {
	    _data_len = _oss_encd_bool_tl(_g, _out_pos, &_out_len, 0x1, _in_data->notThisTime);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(253)
	{
	    OSS_CNTX_INIT

	    switch (_in_data->time.choice) {
	    case 1:
		OSS_CNTX_PUSH(_oss_c, 254)
#ifndef OSS_DO_NOT_CHECK_POINTERS
		if (_in_data->time.u.absolute == nullptr)
		    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
		{
		    long _total_len = 0;
		    OSS_CNTX_INIT

		    OSS_CNTX_PUSH(_oss_c, 255)
		    if (_in_data->time.u.absolute->endTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_in_data->time.u.absolute->endTime == nullptr)
			    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
			_data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->time.u.absolute->endTime, -1, 0);
			if (_data_len < 0) {
			    _constructed = TRUE;
			    _data_len = -_data_len;
			} else
			    _constructed = FALSE;
			_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA1);
			_total_len += _data_len;
		    }
		    OSS_CNTX_SET(256)
		    if (_in_data->time.u.absolute->startTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_in_data->time.u.absolute->startTime == nullptr)
			    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
			_data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->time.u.absolute->startTime, -1, 0);
			if (_data_len < 0) {
			    _constructed = TRUE;
			    _data_len = -_data_len;
			} else
			    _constructed = FALSE;
			_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA0);
			_total_len += _data_len;
		    }
		    OSS_CNTX_POP(_oss_c)
		    _data_len = _total_len;
		}
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
		break;
	    case 2:
		OSS_CNTX_PUSH(_oss_c, 257)
		{
		    _setof10 * _temp;
		    unsigned long count;
		    unsigned long _lindex;
		    long _total_len = 0;
		    OSS_UINT32 _sp;
		    void **_st = _oss_load_enc_stack(_g, &_sp);
		    OSS_CNTX_NEW(_oss_c, 258)
		    for (_temp = _in_data->time.u.periodic, count = 0; _temp; _temp = _temp->next) {
			OSS_CNTX_SETOCC(count + 1)
			if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
			_st[_sp++] = _temp;
			count++;
		    }
		    if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
		    for (_lindex = 0; _lindex < count; _lindex++) {
			OSS_CNTX_SETOCC(count - _lindex)
			_temp = (_setof10 *)_st[--_sp];
			if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
			if (count > 1) _oss_nextItem(_g, &_out_len);
			_oss_save_enc_stack(_g, _sp);
			{
			    long _total_len = 0;
			    OSS_CNTX_INIT

			    OSS_CNTX_PUSH(_oss_c, 259)
			    if (_temp->value.bit_mask & 0x8000000) {
				{
				    _setof9 * _temp1;
				    unsigned long count;
				    unsigned long _lindex;
				    long _total_len = 0;
				    OSS_CNTX_NEW(_oss_c, 72)
				    for (_temp1 = _temp->value.years, count = 0; _temp1; _temp1 = _temp1->next) {
					OSS_CNTX_SETOCC(count + 1)
					if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
					_st[_sp++] = _temp1;
					count++;
				    }
				    if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
				    for (_lindex = 0; _lindex < count; _lindex++) {
					OSS_CNTX_SETOCC(count - _lindex)
					_temp1 = (_setof9 *)_st[--_sp];
					if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
					if (count > 1) _oss_nextItem(_g, &_out_len);
					_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _temp1->value, 0x2);
					_total_len += _data_len;
				    }
				    if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
				    OSS_CNTX_POP(_oss_c)
				    _data_len = _total_len;
				}
				_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x31, 0xA4);
				_total_len += _data_len;
			    }
			    OSS_CNTX_SET(260)
			    if (_temp->value.bit_mask & 0x10000000) {
				{
				    OSS_CNTX_INIT

				    switch (_temp->value.months.choice) {
				    case 1:
					OSS_CNTX_PUSH(_oss_c, 261)
					_data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _temp->value.months.u.bitMonth.value, _temp->value.months.u.bitMonth.length, -1, TRUE);
					if (_data_len < 0) {
					    _constructed = TRUE;
					    _data_len = -_data_len;
					} else
					    _constructed = FALSE;
					_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x23 : 0x3);
					break;
				    case 2:
					OSS_CNTX_PUSH(_oss_c, 262)
					_data_len = 0;
					_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x5);
					break;
				    case 3:
					OSS_CNTX_PUSH(_oss_c, 263)
					_data_len = _ed_setof7(_g, _out_pos, &_out_len, &_temp->value.months.u.intMonth);
					_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
					break;
				    default:
					_oss_enc_error(_g, _bad_choice, _temp->value.months.choice);	/* Bad choice selector. */
				    }
				    OSS_CNTX_POP(_oss_c)
				}
				_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA3);
				_total_len += _data_len;
			    }
			    OSS_CNTX_SET(264)
			    if (_temp->value.bit_mask & 0x20000000) {
				{
				    OSS_CNTX_INIT

				    switch (_temp->value.weeks.choice) {
				    case 1:
					OSS_CNTX_PUSH(_oss_c, 265)
					_data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _temp->value.weeks.u.bitWeek.value, _temp->value.weeks.u.bitWeek.length, -1, TRUE);
					if (_data_len < 0) {
					    _constructed = TRUE;
					    _data_len = -_data_len;
					} else
					    _constructed = FALSE;
					_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x23 : 0x3);
					break;
				    case 2:
					OSS_CNTX_PUSH(_oss_c, 266)
					_data_len = 0;
					_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x5);
					break;
				    case 3:
					OSS_CNTX_PUSH(_oss_c, 267)
					_data_len = _ed_setof7(_g, _out_pos, &_out_len, &_temp->value.weeks.u.intWeek);
					_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
					break;
				    default:
					_oss_enc_error(_g, _bad_choice, _temp->value.weeks.choice);	/* Bad choice selector. */
				    }
				    OSS_CNTX_POP(_oss_c)
				}
				_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
				_total_len += _data_len;
			    }
			    OSS_CNTX_SET(268)
			    if (_temp->value.bit_mask & 0x40000000) {
				{
				    OSS_CNTX_INIT

				    switch (_temp->value.days.choice) {
				    case 1:
					OSS_CNTX_PUSH(_oss_c, 269)
					_data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _temp->value.days.u.bitDay.value, _temp->value.days.u.bitDay.length, -1, TRUE);
					if (_data_len < 0) {
					    _constructed = TRUE;
					    _data_len = -_data_len;
					} else
					    _constructed = FALSE;
					_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x23 : 0x3);
					break;
				    case 2:
					OSS_CNTX_PUSH(_oss_c, 270)
					_data_len = _ed_setof7(_g, _out_pos, &_out_len, &_temp->value.days.u.intDay);
					_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
					break;
				    case 3:
					OSS_CNTX_PUSH(_oss_c, 271)
#ifndef OSS_DO_NOT_CHECK_POINTERS
					if (_temp->value.days.u.dayOf == nullptr)
					    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
					{
					    OSS_CNTX_INIT

					    switch (_temp->value.days.u.dayOf->choice) {
					    case 1:
						OSS_CNTX_PUSH(_oss_c, 272)
#ifndef OSS_DO_NOT_CHECK_POINTERS
						if (_temp->value.days.u.dayOf->u.first == nullptr)
						    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
						_data_len = _edNamedDay(_g, _out_pos, &_out_len, _temp->value.days.u.dayOf->u.first);
						_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
						break;
					    case 2:
						OSS_CNTX_PUSH(_oss_c, 273)
#ifndef OSS_DO_NOT_CHECK_POINTERS
						if (_temp->value.days.u.dayOf->u.second == nullptr)
						    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
						_data_len = _edNamedDay(_g, _out_pos, &_out_len, _temp->value.days.u.dayOf->u.second);
						_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
						break;
					    case 3:
						OSS_CNTX_PUSH(_oss_c, 274)
#ifndef OSS_DO_NOT_CHECK_POINTERS
						if (_temp->value.days.u.dayOf->u.third == nullptr)
						    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
						_data_len = _edNamedDay(_g, _out_pos, &_out_len, _temp->value.days.u.dayOf->u.third);
						_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA3);
						break;
					    case 4:
						OSS_CNTX_PUSH(_oss_c, 275)
#ifndef OSS_DO_NOT_CHECK_POINTERS
						if (_temp->value.days.u.dayOf->u.fourth == nullptr)
						    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
						_data_len = _edNamedDay(_g, _out_pos, &_out_len, _temp->value.days.u.dayOf->u.fourth);
						_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA4);
						break;
					    case 5:
						OSS_CNTX_PUSH(_oss_c, 276)
#ifndef OSS_DO_NOT_CHECK_POINTERS
						if (_temp->value.days.u.dayOf->u.fifth == nullptr)
						    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
						_data_len = _edNamedDay(_g, _out_pos, &_out_len, _temp->value.days.u.dayOf->u.fifth);
						_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA5);
						break;
					    default:
						_oss_enc_error(_g, _bad_choice, _temp->value.days.u.dayOf->choice);	/* Bad choice selector. */
					    }
					    OSS_CNTX_POP(_oss_c)
					}
					break;
				    default:
					_oss_enc_error(_g, _bad_choice, _temp->value.days.choice);	/* Bad choice selector. */
				    }
				    OSS_CNTX_POP(_oss_c)
				}
				_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA1);
				_total_len += _data_len;
			    }
			    OSS_CNTX_SET(277)
			    if (_temp->value.bit_mask & 0x80000000) {
				{
				    _setof8 * _temp1;
				    unsigned long count;
				    unsigned long _lindex;
				    long _total_len = 0;
				    OSS_CNTX_NEW(_oss_c, 278)
				    for (_temp1 = _temp->value.timesOfDay, count = 0; _temp1; _temp1 = _temp1->next) {
					OSS_CNTX_SETOCC(count + 1)
					if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
					_st[_sp++] = _temp1;
					count++;
				    }
				    if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
				    for (_lindex = 0; _lindex < count; _lindex++) {
					OSS_CNTX_SETOCC(count - _lindex)
					_temp1 = (_setof8 *)_st[--_sp];
					if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
					if (count > 1) _oss_nextItem(_g, &_out_len);
					{
					    long _total_len = 0;
					    OSS_CNTX_INIT

					    OSS_CNTX_PUSH(_oss_c, 279)
					    if (_temp1->value.bit_mask & 0x40000000 &&
						(_g->encRules != OSS_DER ||
						_nDDayTime(_g, (_DayTime  *) &_temp1->value.endDayTime, (_DayTime  *)&_v637))) {
						_data_len = _edDayTime(_g, _out_pos, &_out_len, &_temp1->value.endDayTime);
						_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA1);
						_total_len += _data_len;
					    }
					    OSS_CNTX_SET(280)
					    if (_temp1->value.bit_mask & 0x80000000 &&
						(_g->encRules != OSS_DER ||
						_nDDayTime(_g, (_DayTime  *) &_temp1->value.startDayTime, (_DayTime  *)&_v636))) {
						_data_len = _edDayTime(_g, _out_pos, &_out_len, &_temp1->value.startDayTime);
						_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA0);
						_total_len += _data_len;
					    }
					    OSS_CNTX_POP(_oss_c)
					    _data_len = _total_len;
					}
					_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
					_total_len += _data_len;
				    }
				    if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
				    OSS_CNTX_POP(_oss_c)
				    _data_len = _total_len;
				}
				_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x31, 0xA0);
				_total_len += _data_len;
			    }
			    OSS_CNTX_POP(_oss_c)
			    _data_len = _total_len;
			}
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
			_st = _oss_load_enc_stack(_g, &_sp);
			_total_len += _data_len;
		    }
		    if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
		    OSS_CNTX_POP(_oss_c)
		    _data_len = _total_len;
		}
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
		break;
	    default:
		_oss_enc_error(_g, _bad_choice, _in_data->time.choice);	/* Bad choice selector. */
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epTimeSpecification(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _TimeSpecification	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_TimeSpecification *) _inbuf;
    OSS_CNTX_ANCHOR_SET(43,250)
    {
	OSS_UINT32 _bitmask = _in_data->bit_mask;
	OSS_CNTX_INIT

#ifdef OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES
	if (_g->encodingFlags & STRICT_PER_ENCODING_OF_DEFAULT_VALUES) {
	    if ((_bitmask & 0x80000000) &&
		!_oss_not_dflt_ia(_g, &_in_data->notThisTime, (ossBoolean  *)&Context::default_fallback, sizeof(ossBoolean ), 0, -1, 8))
		_bitmask ^= 0x80000000;
	}
#endif /* OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES */
	_oss_append_2bit_unaligned(_g, (unsigned char)(_bitmask >> 24));
	OSS_CNTX_PUSH(_oss_c, 253)
	{
	    OSS_CNTX_INIT

	    if (_in_data->time.choice <= 2) {

		_oss_penc_nonneg_1int(_g, _in_data->time.choice - 1);
	    }
	    switch (_in_data->time.choice) {
	    case 1:
		OSS_CNTX_PUSH(_oss_c, 254)
#ifndef OSS_DO_NOT_CHECK_POINTERS
		if (_in_data->time.u.absolute == nullptr)
		    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
		{
		    unsigned char _pbase[1];
		    OSS_CNTX_INIT

		    _pbase[0] = 0;
		    if (_in_data->time.u.absolute->startTime) {
			_pbase[0] |= 0x80;
		    }
		    if (_in_data->time.u.absolute->endTime) {
			_pbase[0] |= 0x40;
		    }
		    _oss_append_2bit_unaligned(_g, *_pbase);
		    OSS_CNTX_PUSH(_oss_c, 256)
		    if (_in_data->time.u.absolute->startTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_in_data->time.u.absolute->startTime == nullptr)
			    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
			if(!(_g->encodingFlags & NOCONSTRAIN))
			    _oss_check_nullterm_time(_g, _in_data->time.u.absolute->startTime, 0);
			_oss_penc_kmstr(_g, _in_data->time.u.absolute->startTime, (unsigned long)strlen(_in_data->time.u.absolute->startTime), _chars + 3, 0);
		    }
		    OSS_CNTX_SET(255)
		    if (_in_data->time.u.absolute->endTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_in_data->time.u.absolute->endTime == nullptr)
			    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
			if(!(_g->encodingFlags & NOCONSTRAIN))
			    _oss_check_nullterm_time(_g, _in_data->time.u.absolute->endTime, 0);
			_oss_penc_kmstr(_g, _in_data->time.u.absolute->endTime, (unsigned long)strlen(_in_data->time.u.absolute->endTime), _chars + 3, 0);
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		break;
	    case 2:
		OSS_CNTX_PUSH(_oss_c, 257)
		{
		    _setof10 * _temp;
		    unsigned int _fragm_cnt;
		    unsigned int _cnt;
		    int _ext;
		    OSS_CNTX_INIT

		    for (_cnt = 0, _temp = _in_data->time.u.periodic; _temp; _temp = _temp->next)
			++_cnt;

		    OSS_CNTX_PUSH(_oss_c, 258)
		    _ext = (_cnt >= 16384) ? 2 : 0;
		    for (_temp = _in_data->time.u.periodic;; _cnt -= _fragm_cnt) {
			unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
			_fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
			_fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
			for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
			    OSS_CNTX_INCOCC
			    {
				OSS_CNTX_INIT

				_oss_append_5bit_unaligned(_g, (unsigned char)(_temp->value.bit_mask >> 24));
				OSS_CNTX_PUSH(_oss_c, 277)
				if (_temp->value.bit_mask & 0x80000000) {
				    {
					_setof8 * _temp1;
					unsigned int _fragm_cnt1;
					unsigned int _cnt1;
					int _ext1;
					OSS_CNTX_INIT

					for (_cnt1 = 0, _temp1 = _temp->value.timesOfDay; _temp1; _temp1 = _temp1->next)
					    ++_cnt1;

					OSS_CNTX_PUSH(_oss_c, 278)
					_ext1 = (_cnt1 >= 16384) ? 2 : 0;
					for (_temp1 = _temp->value.timesOfDay;; _cnt1 -= _fragm_cnt1) {
					    unsigned int _idx1;

#if OSS_TOED_API_LEVEL >= 27
					    _fragm_cnt1 = _oss_penc_lfrag(_g, _cnt1);
#else
					    _fragm_cnt1 = (unsigned int)_oss_penc_length_l(_g, _cnt1, 0, 0, 0);
#endif
					    for (_idx1 = 0; _idx1 < _fragm_cnt1; ++_idx1, _temp1 = _temp1->next) {
						OSS_CNTX_INCOCC
						{
						    OSS_CNTX_INIT

						    _oss_append_2bit_unaligned(_g, (unsigned char)(_temp1->value.bit_mask >> 24));
						    OSS_CNTX_PUSH(_oss_c, 280)
						    if (_temp1->value.bit_mask & 0x80000000) {
							_ep_DayTime(_g, &_temp1->value.startDayTime);
						    }
						    OSS_CNTX_SET(279)
						    if (_temp1->value.bit_mask & 0x40000000) {
							_ep_DayTime(_g, &_temp1->value.endDayTime);
						    }
						    OSS_CNTX_POP(_oss_c)
						}
					    }
					    if (_cnt1 == _fragm_cnt1) {
						if ((_ext1 & 2) && (_fragm_cnt1 & 0x3FFF) == 0)
						    _oss_append_8bit_aligned(_g, 0);
						break;
					    }
					}
					OSS_CNTX_POP(_oss_c)
				    }
				}
				OSS_CNTX_SET(268)
				if (_temp->value.bit_mask & 0x40000000) {
				    {
					OSS_CNTX_INIT

					if (_temp->value.days.choice <= 3) {

					    _oss_penc_nonneg_2int(_g, _temp->value.days.choice - 1);
					}
					switch (_temp->value.days.choice) {
					case 1:
					    OSS_CNTX_PUSH(_oss_c, 269)
#if OSS_TOED_API_LEVEL >= 27
					    _oss_penc_uncon_bit(_g, _temp->value.days.u.bitDay.value, _temp->value.days.u.bitDay.length ? _oss_chop_zero_bits(_temp->value.days.u.bitDay.value, _temp->value.days.u.bitDay.length, 0) : _temp->value.days.u.bitDay.length);
#else
					    _oss_penc_unconstr_bit_l(_g, _temp->value.days.u.bitDay.value, _temp->value.days.u.bitDay.length, TRUE);
#endif
					    break;
					case 2:
					    OSS_CNTX_PUSH(_oss_c, 270)
					    _ep__setof7(_g, &_temp->value.days.u.intDay);
					    break;
					case 3:
					    OSS_CNTX_PUSH(_oss_c, 271)
#ifndef OSS_DO_NOT_CHECK_POINTERS
					    if (_temp->value.days.u.dayOf == nullptr)
						_oss_enc_error(_g, _bad_pointer, 0L);
#endif
					    {
						OSS_CNTX_INIT

						if (_temp->value.days.u.dayOf->choice <= 5) {

						    _oss_penc_nonneg_3int(_g, _temp->value.days.u.dayOf->choice - 1);
						}
						switch (_temp->value.days.u.dayOf->choice) {
						case 1:
						    OSS_CNTX_PUSH(_oss_c, 272)
#ifndef OSS_DO_NOT_CHECK_POINTERS
						    if (_temp->value.days.u.dayOf->u.first == nullptr)
							_oss_enc_error(_g, _bad_pointer, 0L);
#endif
						    _ep_NamedDay(_g, _temp->value.days.u.dayOf->u.first);
						    break;
						case 2:
						    OSS_CNTX_PUSH(_oss_c, 273)
#ifndef OSS_DO_NOT_CHECK_POINTERS
						    if (_temp->value.days.u.dayOf->u.second == nullptr)
							_oss_enc_error(_g, _bad_pointer, 0L);
#endif
						    _ep_NamedDay(_g, _temp->value.days.u.dayOf->u.second);
						    break;
						case 3:
						    OSS_CNTX_PUSH(_oss_c, 274)
#ifndef OSS_DO_NOT_CHECK_POINTERS
						    if (_temp->value.days.u.dayOf->u.third == nullptr)
							_oss_enc_error(_g, _bad_pointer, 0L);
#endif
						    _ep_NamedDay(_g, _temp->value.days.u.dayOf->u.third);
						    break;
						case 4:
						    OSS_CNTX_PUSH(_oss_c, 275)
#ifndef OSS_DO_NOT_CHECK_POINTERS
						    if (_temp->value.days.u.dayOf->u.fourth == nullptr)
							_oss_enc_error(_g, _bad_pointer, 0L);
#endif
						    _ep_NamedDay(_g, _temp->value.days.u.dayOf->u.fourth);
						    break;
						case 5:
						    OSS_CNTX_PUSH(_oss_c, 276)
#ifndef OSS_DO_NOT_CHECK_POINTERS
						    if (_temp->value.days.u.dayOf->u.fifth == nullptr)
							_oss_enc_error(_g, _bad_pointer, 0L);
#endif
						    _ep_NamedDay(_g, _temp->value.days.u.dayOf->u.fifth);
						    break;
						default:
						    _oss_enc_error(_g, _bad_choice, _temp->value.days.u.dayOf->choice);	/* Bad choice selector. */
						}
						OSS_CNTX_POP(_oss_c)
					    }

					    break;
					default:
					    _oss_enc_error(_g, _bad_choice, _temp->value.days.choice);	/* Bad choice selector. */
					}
					OSS_CNTX_POP(_oss_c)
				    }

				}
				OSS_CNTX_SET(264)
				if (_temp->value.bit_mask & 0x20000000) {
				    {
					OSS_CNTX_INIT

					if (_temp->value.weeks.choice <= 3) {

					    _oss_penc_nonneg_2int(_g, _temp->value.weeks.choice - 1);
					}
					switch (_temp->value.weeks.choice) {
					case 1:
					    OSS_CNTX_PUSH(_oss_c, 265)
#if OSS_TOED_API_LEVEL >= 27
					    _oss_penc_uncon_bit(_g, _temp->value.weeks.u.bitWeek.value, _temp->value.weeks.u.bitWeek.length ? _oss_chop_zero_bits(_temp->value.weeks.u.bitWeek.value, _temp->value.weeks.u.bitWeek.length, 0) : _temp->value.weeks.u.bitWeek.length);
#else
					    _oss_penc_unconstr_bit_l(_g, _temp->value.weeks.u.bitWeek.value, _temp->value.weeks.u.bitWeek.length, TRUE);
#endif
					    break;
					case 2:
					    OSS_CNTX_PUSH(_oss_c, 266)
					    break;
					case 3:
					    OSS_CNTX_PUSH(_oss_c, 267)
					    _ep__setof7(_g, &_temp->value.weeks.u.intWeek);
					    break;
					default:
					    _oss_enc_error(_g, _bad_choice, _temp->value.weeks.choice);	/* Bad choice selector. */
					}
					OSS_CNTX_POP(_oss_c)
				    }

				}
				OSS_CNTX_SET(260)
				if (_temp->value.bit_mask & 0x10000000) {
				    {
					OSS_CNTX_INIT

					if (_temp->value.months.choice <= 3) {

					    _oss_penc_nonneg_2int(_g, _temp->value.months.choice - 1);
					}
					switch (_temp->value.months.choice) {
					case 1:
					    OSS_CNTX_PUSH(_oss_c, 261)
#if OSS_TOED_API_LEVEL >= 27
					    _oss_penc_uncon_bit(_g, _temp->value.months.u.bitMonth.value, _temp->value.months.u.bitMonth.length ? _oss_chop_zero_bits(_temp->value.months.u.bitMonth.value, _temp->value.months.u.bitMonth.length, 0) : _temp->value.months.u.bitMonth.length);
#else
					    _oss_penc_unconstr_bit_l(_g, _temp->value.months.u.bitMonth.value, _temp->value.months.u.bitMonth.length, TRUE);
#endif
					    break;
					case 2:
					    OSS_CNTX_PUSH(_oss_c, 262)
					    break;
					case 3:
					    OSS_CNTX_PUSH(_oss_c, 263)
					    _ep__setof7(_g, &_temp->value.months.u.intMonth);
					    break;
					default:
					    _oss_enc_error(_g, _bad_choice, _temp->value.months.choice);	/* Bad choice selector. */
					}
					OSS_CNTX_POP(_oss_c)
				    }

				}
				OSS_CNTX_SET(259)
				if (_temp->value.bit_mask & 0x8000000) {
				    {
					_setof9 * _temp1;
					unsigned int _fragm_cnt1;
					unsigned int _cnt1;
					int _ext1;
					OSS_CNTX_INIT

					for (_cnt1 = 0, _temp1 = _temp->value.years; _temp1; _temp1 = _temp1->next)
					    ++_cnt1;

					OSS_CNTX_PUSH(_oss_c, 72)
					_ext1 = (_cnt1 >= 16384) ? 2 : 0;
					for (_temp1 = _temp->value.years;; _cnt1 -= _fragm_cnt1) {
					    unsigned int _idx1;

#if OSS_TOED_API_LEVEL >= 27
					    _fragm_cnt1 = _oss_penc_lfrag(_g, _cnt1);
#else
					    _fragm_cnt1 = (unsigned int)_oss_penc_length_l(_g, _cnt1, 0, 0, 0);
#endif
					    for (_idx1 = 0; _idx1 < _fragm_cnt1; ++_idx1, _temp1 = _temp1->next) {
						OSS_CNTX_INCOCC
						if (_temp1->value >= 1000) {
						    _oss_penc_semicon_uint_l(_g, _temp1->value, 1000);
						} else {
						    _oss_enc_error(_g, _valueRange_uinteger, _temp1->value);
						}
					    }
					    if (_cnt1 == _fragm_cnt1) {
						if ((_ext1 & 2) && (_fragm_cnt1 & 0x3FFF) == 0)
						    _oss_append_8bit_aligned(_g, 0);
						break;
					    }
					}
					OSS_CNTX_POP(_oss_c)
				    }
				}
				OSS_CNTX_POP(_oss_c)
			    }
			}
			if (_cnt == _fragm_cnt) {
			    if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
				_oss_append_8bit_aligned(_g, 0);
			    break;
			}
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		break;
	    default:
		_oss_enc_error(_g, _bad_choice, _in_data->time.choice);	/* Bad choice selector. */
	    }
	    OSS_CNTX_POP(_oss_c)
	}

	OSS_CNTX_SET(252)
	if (_bitmask & 0x80000000) {
	    _oss_append_1bit_unaligned(_g, (unsigned char)((_in_data->notThisTime) ? 0x80 : 0x00) );
	}
	OSS_CNTX_SET(251)
	if (_bitmask & 0x40000000) {
	    if (_in_data->timeZone >= -12 && _in_data->timeZone <= 12) {
		_oss_penc_nonneg_5int(_g, _in_data->timeZone - -12);
	    } else {
		_oss_enc_error(_g, _valueRange_integer, _in_data->timeZone);
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eTimeAssertion(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _TimeAssertion	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_TimeAssertion *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(44,281)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 282)
	    _data_len = 0;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x5);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 283)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.between == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 284)
		if (_in_data->u.between->bit_mask & 0x80000000 &&
		    _oss_not_dflt_ia(_g, &_in_data->u.between->entirely, (ossBoolean  *)&Context::default_fallback, sizeof(ossBoolean ), 0, -1, 8)) {
		    _data_len = _oss_encd_bool_tl(_g, _out_pos, &_out_len, 0x1, _in_data->u.between->entirely);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(255)
		if (_in_data->u.between->endTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_in_data->u.between->endTime == nullptr)
			_oss_enc_error(_g, _bad_pointer, 0L);
#endif
		    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->u.between->endTime, -1, 0);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA1);
		    _total_len += _data_len;
		}
		OSS_CNTX_SET(256)
#ifndef OSS_DO_NOT_CHECK_POINTERS
		if (_in_data->u.between->startTime == nullptr)
		    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
		_data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->u.between->startTime, -1, 0);
		if (_data_len < 0) {
		    _constructed = TRUE;
		    _data_len = -_data_len;
		} else
		    _constructed = FALSE;
		_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18, 0xA0);
		_total_len += _data_len;
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 285)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.at == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->u.at, -1, 0);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epTimeAssertion(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _TimeAssertion	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_TimeAssertion *) _inbuf;
    OSS_CNTX_ANCHOR_SET(44,281)
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 3) {

	    _oss_penc_nonneg_2int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 282)
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 283)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.between == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    {
		unsigned char _pbase[1];
		OSS_UINT32 _bitmask = _in_data->u.between->bit_mask;
		OSS_CNTX_INIT

		_pbase[0] = 0;
#ifdef OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES
		if (_g->encodingFlags & STRICT_PER_ENCODING_OF_DEFAULT_VALUES) {
		    if ((_bitmask & 0x80000000) &&
			!_oss_not_dflt_ia(_g, &_in_data->u.between->entirely, (ossBoolean  *)&Context::default_fallback, sizeof(ossBoolean ), 0, -1, 8))
			_bitmask ^= 0x80000000;
		}
#endif /* OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES */
		if (_in_data->u.between->endTime) {
		    _pbase[0] |= 0x80;
		}
		if (_bitmask & 0x80000000) {
		    _pbase[0] |= 0x40;
		}
		_oss_append_2bit_unaligned(_g, *_pbase);
		OSS_CNTX_PUSH(_oss_c, 256)
#ifndef OSS_DO_NOT_CHECK_POINTERS
		if (_in_data->u.between->startTime == nullptr)
		    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
		if(!(_g->encodingFlags & NOCONSTRAIN))
		    _oss_check_nullterm_time(_g, _in_data->u.between->startTime, 0);
		_oss_penc_kmstr(_g, _in_data->u.between->startTime, (unsigned long)strlen(_in_data->u.between->startTime), _chars + 3, 0);
		OSS_CNTX_SET(255)
		if (_in_data->u.between->endTime) {
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_in_data->u.between->endTime == nullptr)
			_oss_enc_error(_g, _bad_pointer, 0L);
#endif
		    if(!(_g->encodingFlags & NOCONSTRAIN))
			_oss_check_nullterm_time(_g, _in_data->u.between->endTime, 0);
		    _oss_penc_kmstr(_g, _in_data->u.between->endTime, (unsigned long)strlen(_in_data->u.between->endTime), _chars + 3, 0);
		}
		OSS_CNTX_SET(284)
		if (_bitmask & 0x80000000) {
		    _oss_append_1bit_unaligned(_g, (unsigned char)((_in_data->u.between->entirely) ? 0x80 : 0x00) );
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 285)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.at == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    if(!(_g->encodingFlags & NOCONSTRAIN))
		_oss_check_nullterm_time(_g, _in_data->u.at, 0);
	    _oss_penc_kmstr(_g, _in_data->u.at, (unsigned long)strlen(_in_data->u.at), _chars + 3, 0);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eLocaleContextSyntax(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _LocaleContextSyntax	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_LocaleContextSyntax *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(45,286)
    {
	OSS_CNTX_INIT

	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 287)
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->u.localeID1.value, _in_data->u.localeID1.length, -1);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 288)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.localeID2 == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _data_len = _edUnboundedDirectoryString(_g, _out_pos, &_out_len, _in_data->u.localeID2);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epLocaleContextSyntax(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _LocaleContextSyntax	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_LocaleContextSyntax *) _inbuf;
    OSS_CNTX_ANCHOR_SET(45,286)
    {
	OSS_CNTX_INIT

	if (_in_data->choice <= 2) {

	    _oss_penc_nonneg_1int(_g, _in_data->choice - 1);
	}
	switch (_in_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 287)
	    _oss_penc_eobjid_ia(_g, _in_data->u.localeID1.value, _in_data->u.localeID1.length, -1);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 288)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_in_data->u.localeID2 == nullptr)
		_oss_enc_error(_g, _bad_pointer, 0L);
#endif
	    _ep_UnboundedDirectoryString(_g, _in_data->u.localeID2);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _in_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eAttributeOptionList(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _setof3	**_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_setof3 **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(46,289)
    {
	_setof3 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 290)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_setof3 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _data_len = _oss_encd_utf8unbound_ia(_g, _out_pos, &_out_len, (unsigned char *)_temp->value.value, _temp->value.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x2C : 0xC);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epAttributeOptionList(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _setof3	**_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_setof3 **) _inbuf;
    OSS_CNTX_ANCHOR_SET(46,289)
    {
	_setof3 * _temp;
	unsigned int _fragm_cnt;
	unsigned int _cnt;
	int _ext;
	OSS_CNTX_INIT

	for (_cnt = 0, _temp = *_in_data; _temp; _temp = _temp->next)
	    ++_cnt;

	OSS_CNTX_PUSH(_oss_c, 290)
	_ext = (_cnt >= 16384) ? 2 : 0;
	for (_temp = *_in_data;; _cnt -= _fragm_cnt) {
	    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
	    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
	    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
	    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		OSS_CNTX_INCOCC
		_oss_penc_nkmstr_l(_g, _temp->value.value, _temp->value.length);
	    }
	    if (_cnt == _fragm_cnt) {
		if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
		    _oss_append_8bit_aligned(_g, 0);
		break;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eID(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssEncOID	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssEncOID *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(47,291)
    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epID(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssEncOID	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssEncOID *) _inbuf;
    OSS_CNTX_ANCHOR_SET(47,291)
    _oss_penc_eobjid_ia(_g, _in_data->value, _in_data->length, -1);
    OSS_CNTX_POP(_oss_c)
}

static void _eAttributeValue(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssOpen	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssOpen *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(48,292)
    _data_len = _oss_encd_opentype(_g, _out_pos, &_out_len, _in_data);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epAttributeValue(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssOpen	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssOpen *) _inbuf;
    OSS_CNTX_ANCHOR_SET(48,292)
    _oss_penc_opentype(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eContextAssertion(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ContextAssertion	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_ContextAssertion *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(49,293)
    _data_len = _edContextAssertion(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epContextAssertion(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ContextAssertion	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_ContextAssertion *) _inbuf;
    OSS_CNTX_ANCHOR_SET(49,293)
    _ep_ContextAssertion(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eAttributeTypeAssertion(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AttributeTypeAssertion	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_AttributeTypeAssertion *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(50,294)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 295)
	if (_in_data->bit_mask & 0x80000000) {
	    {
		_setof6 * _temp;
		unsigned long count;
		unsigned long _lindex;
		long _total_len = 0;
		OSS_UINT32 _sp;
		void **_st = _oss_load_enc_stack(_g, &_sp);
		OSS_CNTX_NEW(_oss_c, 231)
		for (_temp = _in_data->assertedContexts, count = 0; _temp; _temp = _temp->next) {
		    OSS_CNTX_SETOCC(count + 1)
		    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		    _st[_sp++] = _temp;
		    count++;
		}
		for (_lindex = 0; _lindex < count; _lindex++) {
		    OSS_CNTX_SETOCC(count - _lindex)
		    _temp = (_setof6 *)_st[--_sp];
		    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		    _oss_save_enc_stack(_g, _sp);
		    _data_len = _edContextAssertion(_g, _out_pos, &_out_len, &_temp->value);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
		    _st = _oss_load_enc_stack(_g, &_sp);
		    _total_len += _data_len;
		}
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(83)
	_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->type.value, _in_data->type.length, -1);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epAttributeTypeAssertion(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AttributeTypeAssertion	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_AttributeTypeAssertion *) _inbuf;
    OSS_CNTX_ANCHOR_SET(50,294)
    {
	OSS_CNTX_INIT

	_oss_append_1bit_unaligned(_g, (unsigned char)(_in_data->bit_mask >> 24));
	OSS_CNTX_PUSH(_oss_c, 83)
	_oss_penc_eobjid_ia(_g, _in_data->type.value, _in_data->type.length, -1);
	OSS_CNTX_SET(295)
	if (_in_data->bit_mask & 0x80000000) {
	    {
		_setof6 * _temp;
		unsigned int _fragm_cnt;
		unsigned int _cnt;
		int _ext;
		OSS_CNTX_INIT

		for (_cnt = 0, _temp = _in_data->assertedContexts; _temp; _temp = _temp->next)
		    ++_cnt;

		OSS_CNTX_PUSH(_oss_c, 231)
		_ext = (_cnt >= 16384) ? 2 : 0;
		for (_temp = _in_data->assertedContexts;; _cnt -= _fragm_cnt) {
		    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
		    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
		    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
			OSS_CNTX_INCOCC
			_ep_ContextAssertion(_g, &_temp->value);
		    }
		    if (_cnt == _fragm_cnt) {
			if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
			    _oss_append_8bit_aligned(_g, 0);
			break;
		    }
		}
		OSS_CNTX_POP(_oss_c)
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eDistinguishedName(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RDNSequence	**_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_RDNSequence **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(51,296)
    _data_len = _edRDNSequence(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epDistinguishedName(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RDNSequence	**_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_RDNSequence **) _inbuf;
    OSS_CNTX_ANCHOR_SET(51,296)
    _ep_RDNSequence(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eSubtreeSpecification(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SubtreeSpecification	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_SubtreeSpecification *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(52,297)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 298)
	if (_in_data->bit_mask & 0x8000000) {
	    _data_len = _edRefinement(_g, _out_pos, &_out_len, &_in_data->specificationFilter);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA4);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(299)
	if (_in_data->bit_mask & 0x10000000) {
	    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->maximum, 0x2);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA3);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(300)
	if (_in_data->bit_mask & 0x20000000 &&
	    _oss_not_dflt_ia(_g, &_in_data->minimum, (OSS_UINT32  *)&SubtreeSpecification::default_minimum, sizeof(OSS_UINT32 ), 0, -1, 55)) {
	    _data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->minimum, 0x2);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA2);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(301)
	if (_in_data->bit_mask & 0x40000000) {
	    {
		_setof19 * _temp;
		unsigned long count;
		unsigned long _lindex;
		long _total_len = 0;
		OSS_UINT32 _sp;
		void **_st = _oss_load_enc_stack(_g, &_sp);
		OSS_CNTX_NEW(_oss_c, 235)
		for (_temp = _in_data->specificExclusions, count = 0; _temp; _temp = _temp->next) {
		    OSS_CNTX_SETOCC(count + 1)
		    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		    _st[_sp++] = _temp;
		    count++;
		}
		if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
		for (_lindex = 0; _lindex < count; _lindex++) {
		    OSS_CNTX_SETOCC(count - _lindex)
		    _temp = (_setof19 *)_st[--_sp];
		    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		    if (count > 1) _oss_nextItem(_g, &_out_len);
		    _oss_save_enc_stack(_g, _sp);
		    {
			OSS_CNTX_INIT

			switch (_temp->value.choice) {
			case 1:
			    OSS_CNTX_PUSH(_oss_c, 302)
			    _data_len = _edRDNSequence(_g, _out_pos, &_out_len, &_temp->value.u.chopBefore);
			    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA0);
			    break;
			case 2:
			    OSS_CNTX_PUSH(_oss_c, 303)
			    _data_len = _edRDNSequence(_g, _out_pos, &_out_len, &_temp->value.u.chopAfter);
			    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA1);
			    break;
			default:
			    _oss_enc_error(_g, _bad_choice, _temp->value.choice);	/* Bad choice selector. */
			}
			OSS_CNTX_POP(_oss_c)
		    }
		    _st = _oss_load_enc_stack(_g, &_sp);
		    _total_len += _data_len;
		}
		if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x31, 0xA1);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(304)
	if (_in_data->bit_mask & 0x80000000 &&
	    (_g->encRules != OSS_DER ||
	    _nDRDNSequence(_g, (_RDNSequence * *) &_in_data->base, (_RDNSequence * )_v642))) {
	    _data_len = _edRDNSequence(_g, _out_pos, &_out_len, &_in_data->base);
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA0);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epSubtreeSpecification(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SubtreeSpecification	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_SubtreeSpecification *) _inbuf;
    OSS_CNTX_ANCHOR_SET(52,297)
    {
	OSS_UINT32 _bitmask = _in_data->bit_mask;
	OSS_CNTX_INIT

#ifdef OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES
	if (_g->encodingFlags & STRICT_PER_ENCODING_OF_DEFAULT_VALUES) {
	    if ((_bitmask & 0x20000000) &&
		!_oss_not_dflt_ia(_g, &_in_data->minimum, (OSS_UINT32  *)&SubtreeSpecification::default_minimum, sizeof(OSS_UINT32 ), 0, -1, 55))
		_bitmask ^= 0x20000000;
	}
#endif /* OSS_STRICT_PER_ENCODING_OF_DEFAULT_VALUES */
	_oss_append_5bit_unaligned(_g, (unsigned char)(_bitmask >> 24));
	OSS_CNTX_PUSH(_oss_c, 304)
	if (_bitmask & 0x80000000) {
	    _ep_RDNSequence(_g, &_in_data->base);
	}
	OSS_CNTX_SET(301)
	if (_bitmask & 0x40000000) {
	    {
		_setof19 * _temp;
		unsigned int _fragm_cnt;
		unsigned int _cnt;
		int _ext;
		OSS_CNTX_INIT

		for (_cnt = 0, _temp = _in_data->specificExclusions; _temp; _temp = _temp->next)
		    ++_cnt;

		OSS_CNTX_PUSH(_oss_c, 235)
		_ext = (_cnt >= 16384) ? 2 : 0;
		for (_temp = _in_data->specificExclusions;; _cnt -= _fragm_cnt) {
		    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
		    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
		    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
			OSS_CNTX_INCOCC
			{
			    OSS_CNTX_INIT

			    if (_temp->value.choice <= 2) {

				_oss_penc_nonneg_1int(_g, _temp->value.choice - 1);
			    }
			    switch (_temp->value.choice) {
			    case 1:
				OSS_CNTX_PUSH(_oss_c, 302)
				_ep_RDNSequence(_g, &_temp->value.u.chopBefore);
				break;
			    case 2:
				OSS_CNTX_PUSH(_oss_c, 303)
				_ep_RDNSequence(_g, &_temp->value.u.chopAfter);
				break;
			    default:
				_oss_enc_error(_g, _bad_choice, _temp->value.choice);	/* Bad choice selector. */
			    }
			    OSS_CNTX_POP(_oss_c)
			}

		    }
		    if (_cnt == _fragm_cnt) {
			if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
			    _oss_append_8bit_aligned(_g, 0);
			break;
		    }
		}
		OSS_CNTX_POP(_oss_c)
	    }
	}
	OSS_CNTX_SET(300)
	if (_bitmask & 0x20000000) {
	    _oss_penc_semicon_uint_l(_g, _in_data->minimum, 0);
	}
	OSS_CNTX_SET(299)
	if (_bitmask & 0x10000000) {
	    _oss_penc_semicon_uint_l(_g, _in_data->maximum, 0);
	}
	OSS_CNTX_SET(298)
	if (_bitmask & 0x8000000) {
	    _ep_Refinement(_g, &_in_data->specificationFilter);
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eDITStructureRule(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _DITStructureRule	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_DITStructureRule *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(53,305)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 306)
	if (_in_data->bit_mask & 0x80000000) {
	    {
		_Presentation_context_deletion_list * _temp;
		unsigned long count;
		unsigned long _lindex;
		long _total_len = 0;
		OSS_UINT32 _sp;
		void **_st = _oss_load_enc_stack(_g, &_sp);
		OSS_CNTX_NEW(_oss_c, 307)
		for (_temp = _in_data->superiorStructureRules, count = 0; _temp; _temp = _temp->next) {
		    OSS_CNTX_SETOCC(count + 1)
		    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		    _st[_sp++] = _temp;
		    count++;
		}
		if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
		for (_lindex = 0; _lindex < count; _lindex++) {
		    OSS_CNTX_SETOCC(count - _lindex)
		    _temp = (_Presentation_context_deletion_list *)_st[--_sp];
		    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		    if (count > 1) _oss_nextItem(_g, &_out_len);
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _temp->value, 0x2);
		    _total_len += _data_len;
		}
		_oss_save_enc_stack(_g, _sp);
		if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(308)
	_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->nameForm.value, _in_data->nameForm.length, -1);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	_total_len += _data_len;
	OSS_CNTX_SET(309)
	_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->ruleIdentifier, 0x2);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epDITStructureRule(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _DITStructureRule	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_DITStructureRule *) _inbuf;
    OSS_CNTX_ANCHOR_SET(53,305)
    {
	OSS_CNTX_INIT

	_oss_append_1bit_unaligned(_g, (unsigned char)(_in_data->bit_mask >> 24));
	OSS_CNTX_PUSH(_oss_c, 309)
	_oss_penc_unconstr_int_l(_g, _in_data->ruleIdentifier);
	OSS_CNTX_SET(308)
	_oss_penc_eobjid_ia(_g, _in_data->nameForm.value, _in_data->nameForm.length, -1);
	OSS_CNTX_SET(306)
	if (_in_data->bit_mask & 0x80000000) {
	    {
		_Presentation_context_deletion_list * _temp;
		unsigned int _fragm_cnt;
		unsigned int _cnt;
		int _ext;
		OSS_CNTX_INIT

		for (_cnt = 0, _temp = _in_data->superiorStructureRules; _temp; _temp = _temp->next)
		    ++_cnt;

		OSS_CNTX_PUSH(_oss_c, 307)
		_ext = (_cnt >= 16384) ? 2 : 0;
		for (_temp = _in_data->superiorStructureRules;; _cnt -= _fragm_cnt) {
		    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
		    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
		    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
			OSS_CNTX_INCOCC
			_oss_penc_unconstr_int_l(_g, _temp->value);
		    }
		    if (_cnt == _fragm_cnt) {
			if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
			    _oss_append_8bit_aligned(_g, 0);
			break;
		    }
		}
		OSS_CNTX_POP(_oss_c)
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eDITContentRule(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _DITContentRule	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_DITContentRule *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(54,310)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 311)
	if (_in_data->bit_mask & 0x10000000) {
	    {
		_Application_context_name_list * _temp;
		unsigned long count;
		unsigned long _lindex;
		long _total_len = 0;
		OSS_UINT32 _sp;
		void **_st = _oss_load_enc_stack(_g, &_sp);
		OSS_CNTX_NEW(_oss_c, 220)
		for (_temp = _in_data->precluded, count = 0; _temp; _temp = _temp->next) {
		    OSS_CNTX_SETOCC(count + 1)
		    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		    _st[_sp++] = _temp;
		    count++;
		}
		if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
		for (_lindex = 0; _lindex < count; _lindex++) {
		    OSS_CNTX_SETOCC(count - _lindex)
		    _temp = (_Application_context_name_list *)_st[--_sp];
		    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		    if (count > 1) _oss_nextItem(_g, &_out_len);
		    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _temp->value.value, _temp->value.length, -1);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
		    _total_len += _data_len;
		}
		_oss_save_enc_stack(_g, _sp);
		if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x31, 0xA3);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(312)
	if (_in_data->bit_mask & 0x20000000) {
	    {
		_Application_context_name_list * _temp;
		unsigned long count;
		unsigned long _lindex;
		long _total_len = 0;
		OSS_UINT32 _sp;
		void **_st = _oss_load_enc_stack(_g, &_sp);
		OSS_CNTX_NEW(_oss_c, 220)
		for (_temp = _in_data->optional, count = 0; _temp; _temp = _temp->next) {
		    OSS_CNTX_SETOCC(count + 1)
		    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		    _st[_sp++] = _temp;
		    count++;
		}
		if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
		for (_lindex = 0; _lindex < count; _lindex++) {
		    OSS_CNTX_SETOCC(count - _lindex)
		    _temp = (_Application_context_name_list *)_st[--_sp];
		    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		    if (count > 1) _oss_nextItem(_g, &_out_len);
		    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _temp->value.value, _temp->value.length, -1);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
		    _total_len += _data_len;
		}
		_oss_save_enc_stack(_g, _sp);
		if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x31, 0xA2);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(313)
	if (_in_data->bit_mask & 0x40000000) {
	    {
		_Application_context_name_list * _temp;
		unsigned long count;
		unsigned long _lindex;
		long _total_len = 0;
		OSS_UINT32 _sp;
		void **_st = _oss_load_enc_stack(_g, &_sp);
		OSS_CNTX_NEW(_oss_c, 220)
		for (_temp = _in_data->mandatory, count = 0; _temp; _temp = _temp->next) {
		    OSS_CNTX_SETOCC(count + 1)
		    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		    _st[_sp++] = _temp;
		    count++;
		}
		if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
		for (_lindex = 0; _lindex < count; _lindex++) {
		    OSS_CNTX_SETOCC(count - _lindex)
		    _temp = (_Application_context_name_list *)_st[--_sp];
		    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		    if (count > 1) _oss_nextItem(_g, &_out_len);
		    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _temp->value.value, _temp->value.length, -1);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
		    _total_len += _data_len;
		}
		_oss_save_enc_stack(_g, _sp);
		if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x31, 0xA1);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(314)
	if (_in_data->bit_mask & 0x80000000) {
	    {
		_Application_context_name_list * _temp;
		unsigned long count;
		unsigned long _lindex;
		long _total_len = 0;
		OSS_UINT32 _sp;
		void **_st = _oss_load_enc_stack(_g, &_sp);
		OSS_CNTX_NEW(_oss_c, 220)
		for (_temp = _in_data->auxiliaries, count = 0; _temp; _temp = _temp->next) {
		    OSS_CNTX_SETOCC(count + 1)
		    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		    _st[_sp++] = _temp;
		    count++;
		}
		if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
		for (_lindex = 0; _lindex < count; _lindex++) {
		    OSS_CNTX_SETOCC(count - _lindex)
		    _temp = (_Application_context_name_list *)_st[--_sp];
		    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		    if (count > 1) _oss_nextItem(_g, &_out_len);
		    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _temp->value.value, _temp->value.length, -1);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
		    _total_len += _data_len;
		}
		_oss_save_enc_stack(_g, _sp);
		if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(315)
	_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->structuralObjectClass.value, _in_data->structuralObjectClass.length, -1);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epDITContentRule(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _DITContentRule	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_DITContentRule *) _inbuf;
    OSS_CNTX_ANCHOR_SET(54,310)
    {
	OSS_CNTX_INIT

	_oss_append_4bit_unaligned(_g, (unsigned char)(_in_data->bit_mask >> 24));
	OSS_CNTX_PUSH(_oss_c, 315)
	_oss_penc_eobjid_ia(_g, _in_data->structuralObjectClass.value, _in_data->structuralObjectClass.length, -1);
	OSS_CNTX_SET(314)
	if (_in_data->bit_mask & 0x80000000) {
	    {
		_Application_context_name_list * _temp;
		unsigned int _fragm_cnt;
		unsigned int _cnt;
		int _ext;
		OSS_CNTX_INIT

		for (_cnt = 0, _temp = _in_data->auxiliaries; _temp; _temp = _temp->next)
		    ++_cnt;

		OSS_CNTX_PUSH(_oss_c, 220)
		_ext = (_cnt >= 16384) ? 2 : 0;
		for (_temp = _in_data->auxiliaries;; _cnt -= _fragm_cnt) {
		    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
		    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
		    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
			OSS_CNTX_INCOCC
			_oss_penc_eobjid_ia(_g, _temp->value.value, _temp->value.length, -1);
		    }
		    if (_cnt == _fragm_cnt) {
			if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
			    _oss_append_8bit_aligned(_g, 0);
			break;
		    }
		}
		OSS_CNTX_POP(_oss_c)
	    }
	}
	OSS_CNTX_SET(313)
	if (_in_data->bit_mask & 0x40000000) {
	    {
		_Application_context_name_list * _temp;
		unsigned int _fragm_cnt;
		unsigned int _cnt;
		int _ext;
		OSS_CNTX_INIT

		for (_cnt = 0, _temp = _in_data->mandatory; _temp; _temp = _temp->next)
		    ++_cnt;

		OSS_CNTX_PUSH(_oss_c, 220)
		_ext = (_cnt >= 16384) ? 2 : 0;
		for (_temp = _in_data->mandatory;; _cnt -= _fragm_cnt) {
		    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
		    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
		    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
			OSS_CNTX_INCOCC
			_oss_penc_eobjid_ia(_g, _temp->value.value, _temp->value.length, -1);
		    }
		    if (_cnt == _fragm_cnt) {
			if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
			    _oss_append_8bit_aligned(_g, 0);
			break;
		    }
		}
		OSS_CNTX_POP(_oss_c)
	    }
	}
	OSS_CNTX_SET(312)
	if (_in_data->bit_mask & 0x20000000) {
	    {
		_Application_context_name_list * _temp;
		unsigned int _fragm_cnt;
		unsigned int _cnt;
		int _ext;
		OSS_CNTX_INIT

		for (_cnt = 0, _temp = _in_data->optional; _temp; _temp = _temp->next)
		    ++_cnt;

		OSS_CNTX_PUSH(_oss_c, 220)
		_ext = (_cnt >= 16384) ? 2 : 0;
		for (_temp = _in_data->optional;; _cnt -= _fragm_cnt) {
		    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
		    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
		    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
			OSS_CNTX_INCOCC
			_oss_penc_eobjid_ia(_g, _temp->value.value, _temp->value.length, -1);
		    }
		    if (_cnt == _fragm_cnt) {
			if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
			    _oss_append_8bit_aligned(_g, 0);
			break;
		    }
		}
		OSS_CNTX_POP(_oss_c)
	    }
	}
	OSS_CNTX_SET(311)
	if (_in_data->bit_mask & 0x10000000) {
	    {
		_Application_context_name_list * _temp;
		unsigned int _fragm_cnt;
		unsigned int _cnt;
		int _ext;
		OSS_CNTX_INIT

		for (_cnt = 0, _temp = _in_data->precluded; _temp; _temp = _temp->next)
		    ++_cnt;

		OSS_CNTX_PUSH(_oss_c, 220)
		_ext = (_cnt >= 16384) ? 2 : 0;
		for (_temp = _in_data->precluded;; _cnt -= _fragm_cnt) {
		    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
		    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
		    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
			OSS_CNTX_INCOCC
			_oss_penc_eobjid_ia(_g, _temp->value.value, _temp->value.length, -1);
		    }
		    if (_cnt == _fragm_cnt) {
			if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
			    _oss_append_8bit_aligned(_g, 0);
			break;
		    }
		}
		OSS_CNTX_POP(_oss_c)
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eDITContextUse(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _DITContextUse	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_DITContextUse *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(55,316)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 317)
	if (_in_data->bit_mask & 0x40000000) {
	    {
		_Application_context_name_list * _temp;
		unsigned long count;
		unsigned long _lindex;
		long _total_len = 0;
		OSS_UINT32 _sp;
		void **_st = _oss_load_enc_stack(_g, &_sp);
		OSS_CNTX_NEW(_oss_c, 220)
		for (_temp = _in_data->optionalContexts, count = 0; _temp; _temp = _temp->next) {
		    OSS_CNTX_SETOCC(count + 1)
		    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		    _st[_sp++] = _temp;
		    count++;
		}
		if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
		for (_lindex = 0; _lindex < count; _lindex++) {
		    OSS_CNTX_SETOCC(count - _lindex)
		    _temp = (_Application_context_name_list *)_st[--_sp];
		    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		    if (count > 1) _oss_nextItem(_g, &_out_len);
		    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _temp->value.value, _temp->value.length, -1);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
		    _total_len += _data_len;
		}
		_oss_save_enc_stack(_g, _sp);
		if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x31, 0xA2);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(318)
	if (_in_data->bit_mask & 0x80000000) {
	    {
		_Application_context_name_list * _temp;
		unsigned long count;
		unsigned long _lindex;
		long _total_len = 0;
		OSS_UINT32 _sp;
		void **_st = _oss_load_enc_stack(_g, &_sp);
		OSS_CNTX_NEW(_oss_c, 220)
		for (_temp = _in_data->mandatoryContexts, count = 0; _temp; _temp = _temp->next) {
		    OSS_CNTX_SETOCC(count + 1)
		    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		    _st[_sp++] = _temp;
		    count++;
		}
		if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
		for (_lindex = 0; _lindex < count; _lindex++) {
		    OSS_CNTX_SETOCC(count - _lindex)
		    _temp = (_Application_context_name_list *)_st[--_sp];
		    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		    if (count > 1) _oss_nextItem(_g, &_out_len);
		    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _temp->value.value, _temp->value.length, -1);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
		    _total_len += _data_len;
		}
		_oss_save_enc_stack(_g, _sp);
		if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x31, 0xA1);
	    _total_len += _data_len;
	}
	OSS_CNTX_SET(319)
	_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->attributeType.value, _in_data->attributeType.length, -1);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epDITContextUse(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _DITContextUse	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_DITContextUse *) _inbuf;
    OSS_CNTX_ANCHOR_SET(55,316)
    {
	OSS_CNTX_INIT

	_oss_append_2bit_unaligned(_g, (unsigned char)(_in_data->bit_mask >> 24));
	OSS_CNTX_PUSH(_oss_c, 319)
	_oss_penc_eobjid_ia(_g, _in_data->attributeType.value, _in_data->attributeType.length, -1);
	OSS_CNTX_SET(318)
	if (_in_data->bit_mask & 0x80000000) {
	    {
		_Application_context_name_list * _temp;
		unsigned int _fragm_cnt;
		unsigned int _cnt;
		int _ext;
		OSS_CNTX_INIT

		for (_cnt = 0, _temp = _in_data->mandatoryContexts; _temp; _temp = _temp->next)
		    ++_cnt;

		OSS_CNTX_PUSH(_oss_c, 220)
		_ext = (_cnt >= 16384) ? 2 : 0;
		for (_temp = _in_data->mandatoryContexts;; _cnt -= _fragm_cnt) {
		    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
		    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
		    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
			OSS_CNTX_INCOCC
			_oss_penc_eobjid_ia(_g, _temp->value.value, _temp->value.length, -1);
		    }
		    if (_cnt == _fragm_cnt) {
			if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
			    _oss_append_8bit_aligned(_g, 0);
			break;
		    }
		}
		OSS_CNTX_POP(_oss_c)
	    }
	}
	OSS_CNTX_SET(317)
	if (_in_data->bit_mask & 0x40000000) {
	    {
		_Application_context_name_list * _temp;
		unsigned int _fragm_cnt;
		unsigned int _cnt;
		int _ext;
		OSS_CNTX_INIT

		for (_cnt = 0, _temp = _in_data->optionalContexts; _temp; _temp = _temp->next)
		    ++_cnt;

		OSS_CNTX_PUSH(_oss_c, 220)
		_ext = (_cnt >= 16384) ? 2 : 0;
		for (_temp = _in_data->optionalContexts;; _cnt -= _fragm_cnt) {
		    unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
		    _fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		    _fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
		    for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
			OSS_CNTX_INCOCC
			_oss_penc_eobjid_ia(_g, _temp->value.value, _temp->value.length, -1);
		    }
		    if (_cnt == _fragm_cnt) {
			if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
			    _oss_append_8bit_aligned(_g, 0);
			break;
		    }
		}
		OSS_CNTX_POP(_oss_c)
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _eHierarchyLevel(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_INT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_INT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(56,320)
    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epHierarchyLevel(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_INT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_INT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(56,320)
    _oss_penc_unconstr_int_l(_g, *_in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eHierarchyBelow(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    ossBoolean	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (ossBoolean *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(57,321)
    _data_len = _oss_encd_bool_tl(_g, _out_pos, &_out_len, 0x1, *_in_data);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epHierarchyBelow(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    ossBoolean	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (ossBoolean *) _inbuf;
    OSS_CNTX_ANCHOR_SET(57,321)
    _oss_append_1bit_unaligned(_g, (unsigned char)((*_in_data) ? 0x80 : 0x00) );
    OSS_CNTX_POP(_oss_c)
}

static void _eAcse_RealizationParameter(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_RealizationParameter *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(58,322)
    _data_len = _edRealizationParameter(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epAcse_RealizationParameter(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_RealizationParameter *) _inbuf;
    OSS_CNTX_ANCHOR_SET(58,322)
    _ep_RealizationParameter(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _e2Acse_with_concatenation_Rea(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_RealizationParameter *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(59,323)
    _data_len = _edRealizationParameter(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep2Acse_with_concatenation_Rea(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_RealizationParameter *) _inbuf;
    OSS_CNTX_ANCHOR_SET(59,323)
    _ep_RealizationParameter(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _e3Association_by_RTSE_Realiza(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_RealizationParameter *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(60,324)
    _data_len = _edRealizationParameter(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep3Association_by_RTSE_Realiza(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_RealizationParameter *) _inbuf;
    OSS_CNTX_ANCHOR_SET(60,324)
    _ep_RealizationParameter(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _ePData_RealizationParameter(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_RealizationParameter *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(61,325)
    _data_len = _edRealizationParameter(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epPData_RealizationParameter(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_RealizationParameter *) _inbuf;
    OSS_CNTX_ANCHOR_SET(61,325)
    _ep_RealizationParameter(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _e4PData_with_concatenation_Re(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_RealizationParameter *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(62,326)
    _data_len = _edRealizationParameter(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep4PData_with_concatenation_Re(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_RealizationParameter *) _inbuf;
    OSS_CNTX_ANCHOR_SET(62,326)
    _ep_RealizationParameter(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _e5Transfer_by_RTSE_Realizatio(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_RealizationParameter *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(63,327)
    _data_len = _edRealizationParameter(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep5Transfer_by_RTSE_Realizatio(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_RealizationParameter *) _inbuf;
    OSS_CNTX_ANCHOR_SET(63,327)
    _ep_RealizationParameter(_g, _in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eBitStringMatch_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssBitString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(64,328)
    _data_len = _oss_encd_dubit_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1, FALSE);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x23 : 0x3);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epBitStringMatch_SYNTAX(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssBitString *) _inbuf;
    OSS_CNTX_ANCHOR_SET(64,328)
#if OSS_TOED_API_LEVEL >= 27
    _oss_penc_uncon_bit(_g, _in_data->value, _in_data->length);
#else
    _oss_penc_unconstr_bit_l(_g, _in_data->value, _in_data->length, FALSE);
#endif
    OSS_CNTX_POP(_oss_c)
}

static void _eDnQualifier_WITH_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(65,329)
    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epDnQualifier_WITH_SYNTAX(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    OSS_CNTX_ANCHOR_SET(65,329)
    _oss_penc_kmstr(_g, _in_data->value, _in_data->length, _chars + 0, 0);
    OSS_CNTX_POP(_oss_c)
}

static void _eSerialNumber_WITH_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(66,330)
    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x33 : 0x13);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epSerialNumber_WITH_SYNTAX(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    OSS_CNTX_ANCHOR_SET(66,330)
    _oss_penc_kmstr(_g, _in_data->value, _in_data->length, _chars + 0, 0);
    OSS_CNTX_POP(_oss_c)
}

static void _eNumericStringMatch_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(67,331)
    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x32 : 0x12);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epNumericStringMatch_SYNTAX(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    OSS_CNTX_ANCHOR_SET(67,331)
    _oss_penc_kmstr(_g, _in_data->value, _in_data->length, _chars + 12, 0);
    OSS_CNTX_POP(_oss_c)
}

static void _e6ProtocolInformationMatch_SY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(68,332)
    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep6ProtocolInformationMatch_SY(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    OSS_CNTX_ANCHOR_SET(68,332)
#if OSS_TOED_API_LEVEL >= 27
    _oss_penc_uncon_oct(_g, (unsigned char *)_in_data->value, _in_data->length);
#else
    _oss_penc_unconstr_oct_l(_g, (unsigned char *)_in_data->value, _in_data->length);
#endif
    OSS_CNTX_POP(_oss_c)
}

static void _eUiiInUrn_WITH_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(69,333)
    _data_len = _oss_encd_utf8unbound_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x2C : 0xC);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epUiiInUrn_WITH_SYNTAX(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    OSS_CNTX_ANCHOR_SET(69,333)
    _oss_penc_nkmstr_l(_g, _in_data->value, _in_data->length);
    OSS_CNTX_POP(_oss_c)
}

static void _e7NumericStringOrderingMatch_(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(70,334)
    _data_len = _oss_encd_ustr_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x32 : 0x12);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep7NumericStringOrderingMatch_(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    OSS_CNTX_ANCHOR_SET(70,334)
    _oss_penc_kmstr(_g, _in_data->value, _in_data->length, _chars + 12, 0);
    OSS_CNTX_POP(_oss_c)
}

static void _eBooleanMatch_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    ossBoolean	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (ossBoolean *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(71,335)
    _data_len = _oss_encd_bool_tl(_g, _out_pos, &_out_len, 0x1, *_in_data);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epBooleanMatch_SYNTAX(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    ossBoolean	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (ossBoolean *) _inbuf;
    OSS_CNTX_ANCHOR_SET(71,335)
    _oss_append_1bit_unaligned(_g, (unsigned char)((*_in_data) ? 0x80 : 0x00) );
    OSS_CNTX_POP(_oss_c)
}

static void _eIntegerMatch_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_INT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_INT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(72,336)
    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epIntegerMatch_SYNTAX(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_INT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_INT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(72,336)
    _oss_penc_unconstr_int_l(_g, *_in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eIntegerOrderingMatch_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_INT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_INT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(73,337)
    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epIntegerOrderingMatch_SYNTAX(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_INT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_INT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(73,337)
    _oss_penc_unconstr_int_l(_g, *_in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _eOctetStringMatch_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(74,338)
    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epOctetStringMatch_SYNTAX(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    OSS_CNTX_ANCHOR_SET(74,338)
#if OSS_TOED_API_LEVEL >= 27
    _oss_penc_uncon_oct(_g, (unsigned char *)_in_data->value, _in_data->length);
#else
    _oss_penc_unconstr_oct_l(_g, (unsigned char *)_in_data->value, _in_data->length);
#endif
    OSS_CNTX_POP(_oss_c)
}

static void _e8OctetStringOrderingMatch_SY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(75,339)
    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep8OctetStringOrderingMatch_SY(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    OSS_CNTX_ANCHOR_SET(75,339)
#if OSS_TOED_API_LEVEL >= 27
    _oss_penc_uncon_oct(_g, (unsigned char *)_in_data->value, _in_data->length);
#else
    _oss_penc_unconstr_oct_l(_g, (unsigned char *)_in_data->value, _in_data->length);
#endif
    OSS_CNTX_POP(_oss_c)
}

static void _eUTCTimeMatch_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *	_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (char *) * (void **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(76,340)
#ifndef OSS_DO_NOT_CHECK_POINTERS
    if (_in_data == nullptr)
	_oss_enc_error(_g, _bad_pointer, 0L);
#endif
    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data, -1, 1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x37 : 0x17);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epUTCTimeMatch_SYNTAX(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *	_in_data;
    OSS_CNTX_INITZERO

    _in_data = (char *) * (void **) _inbuf;
    OSS_CNTX_ANCHOR_SET(76,340)
#ifndef OSS_DO_NOT_CHECK_POINTERS
    if (_in_data == nullptr)
	_oss_enc_error(_g, _bad_pointer, 0L);
#endif
    if(!(_g->encodingFlags & NOCONSTRAIN))
	_oss_check_nullterm_time(_g, _in_data, 1);
    _oss_penc_kmstr(_g, _in_data, (unsigned long)strlen(_in_data), _chars + 3, 0);
    OSS_CNTX_POP(_oss_c)
}

static void _eUTCTimeOrderingMatch_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *	_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (char *) * (void **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(77,341)
#ifndef OSS_DO_NOT_CHECK_POINTERS
    if (_in_data == nullptr)
	_oss_enc_error(_g, _bad_pointer, 0L);
#endif
    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data, -1, 1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x37 : 0x17);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epUTCTimeOrderingMatch_SYNTAX(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *	_in_data;
    OSS_CNTX_INITZERO

    _in_data = (char *) * (void **) _inbuf;
    OSS_CNTX_ANCHOR_SET(77,341)
#ifndef OSS_DO_NOT_CHECK_POINTERS
    if (_in_data == nullptr)
	_oss_enc_error(_g, _bad_pointer, 0L);
#endif
    if(!(_g->encodingFlags & NOCONSTRAIN))
	_oss_check_nullterm_time(_g, _in_data, 1);
    _oss_penc_kmstr(_g, _in_data, (unsigned long)strlen(_in_data), _chars + 3, 0);
    OSS_CNTX_POP(_oss_c)
}

static void _eGeneralizedTimeMatch_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *	_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (char *) * (void **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(78,342)
#ifndef OSS_DO_NOT_CHECK_POINTERS
    if (_in_data == nullptr)
	_oss_enc_error(_g, _bad_pointer, 0L);
#endif
    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data, -1, 0);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epGeneralizedTimeMatch_SYNTAX(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *	_in_data;
    OSS_CNTX_INITZERO

    _in_data = (char *) * (void **) _inbuf;
    OSS_CNTX_ANCHOR_SET(78,342)
#ifndef OSS_DO_NOT_CHECK_POINTERS
    if (_in_data == nullptr)
	_oss_enc_error(_g, _bad_pointer, 0L);
#endif
    if(!(_g->encodingFlags & NOCONSTRAIN))
	_oss_check_nullterm_time(_g, _in_data, 0);
    _oss_penc_kmstr(_g, _in_data, (unsigned long)strlen(_in_data), _chars + 3, 0);
    OSS_CNTX_POP(_oss_c)
}

static void _e9GeneralizedTimeOrderingMatc(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *	_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (char *) * (void **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(79,343)
#ifndef OSS_DO_NOT_CHECK_POINTERS
    if (_in_data == nullptr)
	_oss_enc_error(_g, _bad_pointer, 0L);
#endif
    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data, -1, 0);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep9GeneralizedTimeOrderingMatc(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *	_in_data;
    OSS_CNTX_INITZERO

    _in_data = (char *) * (void **) _inbuf;
    OSS_CNTX_ANCHOR_SET(79,343)
#ifndef OSS_DO_NOT_CHECK_POINTERS
    if (_in_data == nullptr)
	_oss_enc_error(_g, _bad_pointer, 0L);
#endif
    if(!(_g->encodingFlags & NOCONSTRAIN))
	_oss_check_nullterm_time(_g, _in_data, 0);
    _oss_penc_kmstr(_g, _in_data, (unsigned long)strlen(_in_data), _chars + 3, 0);
    OSS_CNTX_POP(_oss_c)
}

static void _e10IntegerFirstComponentMatch(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_INT32	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSS_INT32 *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(80,344)
    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, *_in_data, 0x2);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep10IntegerFirstComponentMatch(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_INT32	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSS_INT32 *) _inbuf;
    OSS_CNTX_ANCHOR_SET(80,344)
    _oss_penc_unconstr_int_l(_g, *_in_data);
    OSS_CNTX_POP(_oss_c)
}

static void _e11AdministrativeRole_WITH_SY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssEncOID	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssEncOID *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(81,345)
    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->value, _in_data->length, -1);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep11AdministrativeRole_WITH_SY(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssEncOID	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssEncOID *) _inbuf;
    OSS_CNTX_ANCHOR_SET(81,345)
    _oss_penc_eobjid_ia(_g, _in_data->value, _in_data->length, -1);
    OSS_CNTX_POP(_oss_c)
}

static void _eCreateTimestamp_WITH_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *	_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (char *) * (void **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(82,346)
#ifndef OSS_DO_NOT_CHECK_POINTERS
    if (_in_data == nullptr)
	_oss_enc_error(_g, _bad_pointer, 0L);
#endif
    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data, -1, 0);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epCreateTimestamp_WITH_SYNTAX(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *	_in_data;
    OSS_CNTX_INITZERO

    _in_data = (char *) * (void **) _inbuf;
    OSS_CNTX_ANCHOR_SET(82,346)
#ifndef OSS_DO_NOT_CHECK_POINTERS
    if (_in_data == nullptr)
	_oss_enc_error(_g, _bad_pointer, 0L);
#endif
    if(!(_g->encodingFlags & NOCONSTRAIN))
	_oss_check_nullterm_time(_g, _in_data, 0);
    _oss_penc_kmstr(_g, _in_data, (unsigned long)strlen(_in_data), _chars + 3, 0);
    OSS_CNTX_POP(_oss_c)
}

static void _eModifyTimestamp_WITH_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *	_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (char *) * (void **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(83,347)
#ifndef OSS_DO_NOT_CHECK_POINTERS
    if (_in_data == nullptr)
	_oss_enc_error(_g, _bad_pointer, 0L);
#endif
    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data, -1, 0);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epModifyTimestamp_WITH_SYNTAX(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *	_in_data;
    OSS_CNTX_INITZERO

    _in_data = (char *) * (void **) _inbuf;
    OSS_CNTX_ANCHOR_SET(83,347)
#ifndef OSS_DO_NOT_CHECK_POINTERS
    if (_in_data == nullptr)
	_oss_enc_error(_g, _bad_pointer, 0L);
#endif
    if(!(_g->encodingFlags & NOCONSTRAIN))
	_oss_check_nullterm_time(_g, _in_data, 0);
    _oss_penc_kmstr(_g, _in_data, (unsigned long)strlen(_in_data), _chars + 3, 0);
    OSS_CNTX_POP(_oss_c)
}

static void _e12SubschemaTimestamp_WITH_SY(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *	_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (char *) * (void **) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(84,348)
#ifndef OSS_DO_NOT_CHECK_POINTERS
    if (_in_data == nullptr)
	_oss_enc_error(_g, _bad_pointer, 0L);
#endif
    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data, -1, 0);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x38 : 0x18);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ep12SubschemaTimestamp_WITH_SY(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *	_in_data;
    OSS_CNTX_INITZERO

    _in_data = (char *) * (void **) _inbuf;
    OSS_CNTX_ANCHOR_SET(84,348)
#ifndef OSS_DO_NOT_CHECK_POINTERS
    if (_in_data == nullptr)
	_oss_enc_error(_g, _bad_pointer, 0L);
#endif
    if(!(_g->encodingFlags & NOCONSTRAIN))
	_oss_check_nullterm_time(_g, _in_data, 0);
    _oss_penc_kmstr(_g, _in_data, (unsigned long)strlen(_in_data), _chars + 3, 0);
    OSS_CNTX_POP(_oss_c)
}

static void _eHasSubordinates_WITH_SYNTAX(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    ossBoolean	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (ossBoolean *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = nullptr;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(85,349)
    _data_len = _oss_encd_bool_tl(_g, _out_pos, &_out_len, 0x1, *_in_data);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epHasSubordinates_WITH_SYNTAX(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    ossBoolean	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (ossBoolean *) _inbuf;
    OSS_CNTX_ANCHOR_SET(85,349)
    _oss_append_1bit_unaligned(_g, (unsigned char)((*_in_data) ? 0x80 : 0x00) );
    OSS_CNTX_POP(_oss_c)
}

void DLL_ENTRY_FDEF _emUpperBounds_(struct ossGlobal * _g, int _pdunum, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char **_outbuf = &_oss_c->_oss_outbufpos;
    long *_outlen = &_oss_c->_oss_outbuflen;
    unsigned int _flags = _g->encodingFlags;
    _oss_c->_oss_context_anchor._state = _encoding_data;
    _oss_c->_oss_context_anchor._pdu_number = 0;
#if OSSDEBUG > 0
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_e_pre(_g, _pdunum, _inbuf, nullptr, _oss_c->_oss_outbufpos, _oss_c->_oss_outbuflen);
#else
    _oss_c->_oss_err_msg = nullptr;
#endif

    if (_pdunum < 1 || _pdunum > 85)
	_oss_enc_error(_g, _pdu_range, _pdunum);
    else
	_Encoders[_pdunum - 1](_g, _inbuf, _outbuf, _outlen, _flags);
#if OSSDEBUG > 0
    _oss_c->_oss_err_msg = nullptr;
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_e_post(_g, 0, *_outbuf, *_outlen);
#endif
}

void DLL_ENTRY_FDEF _peUpperBounds_(struct ossGlobal * _g, int _pdunum, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _oss_c->_oss_context_anchor._state = _encoding_data;
    _oss_c->_oss_context_anchor._pdu_number = 0;
#if OSSDEBUG > 0
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_e_pre(_g, _pdunum, _inbuf, nullptr, _oss_c->_oss_outbufpos, _oss_c->_oss_outbuflen);
#else
    _oss_c->_oss_err_msg = nullptr;
#endif

    if (_g->encRules == OSS_PER_ALIGNED)
	_oss_c->_aligned = 1;
    else
	_oss_toed_error(_g, _toed_rules_not_supp_err, "UNALIGNED PER");

    if (_pdunum < 1 || _pdunum > 85)
	_oss_enc_error(_g, _pdu_range, _pdunum);
    else
	_pEncoders[_pdunum - 1](_g, _inbuf);

#if OSSDEBUG > 0
    _oss_c->_oss_err_msg = nullptr;
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_e_post(_g, 0, _oss_c->_oss_outbufpos, _oss_c->_oss_outbuflen);
#endif
}

static void _d_UnboundedDirectoryString(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _UnboundedDirectoryString * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	case 0xC: {
	    OSS_CNTX_PUSH(_oss_c, 0)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if(_data_length) {
		_out_data->u.uTF8String.length = _oss_dec_utf8unbound_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.uTF8String.value, 0);
	    } else {
		_out_data->u.uTF8String.length = 0;
		_out_data->u.uTF8String.value = nullptr;
	    }
	}   break;
	case 0x13: {
	    OSS_CNTX_PUSH(_oss_c, 1)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.printableString.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.printableString.value, 0);
	}   break;
	case 0x14: {
	    OSS_CNTX_PUSH(_oss_c, 2)
	    _out_data->choice = 3;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.teletexString.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.teletexString.value, 0);
	}   break;
	case 0x1C: {
	    OSS_CNTX_PUSH(_oss_c, 3)
	    _out_data->choice = 4;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.universalString.length = _oss_dec_unistr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.universalString.value, 0);
	}   break;
	case 0x1E: {
	    OSS_CNTX_PUSH(_oss_c, 4)
	    _out_data->choice = 5;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.bmpString.length = _oss_dec_bmpstr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.bmpString.value, 0);
	}   break;
	default:
	    _oss_dec_error(_g, _unknown_field, _data_tag);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_UnboundedDirectoryString(OssGlobal * _g, _UnboundedDirectoryString * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_3int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 0)
	    _out_data->u.uTF8String.length = _oss_pdec_ub_nkmstr_ia(_g, &_out_data->u.uTF8String.value);

	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 1)
	    _out_data->u.printableString.length = _oss_pdec_ub_kmstr(_g, &_out_data->u.printableString.value, _chars + 0);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 2)
	    _out_data->u.teletexString.length = _oss_pdec_ub_nkmstr_ia(_g, &_out_data->u.teletexString.value);

	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 3)
	    _out_data->u.universalString.length = _oss_pdec_unistr(_g, (OSS_INT32 **)&_out_data->u.universalString.value, _chars + 1);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 4)
	    _out_data->u.bmpString.length = _oss_pdec_bmpstr(_g, &_out_data->u.bmpString.value, _chars + 2);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_ContextAssertion(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _ContextAssertion * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 7)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x6) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x6 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x60000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x6;
	_out_data->contextType.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->contextType.value, -1);
	OSS_CNTX_SET(5)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
	_data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _setof11 * _temp = (_setof11 *)&_out_data->contextValues;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	    unsigned long count = 0;
#endif
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 6)
	    for (;;) {
		if (_total_len < 0) {
		    char *tmp_pos = _bufpos;
		    long tmp_len = _buflen;

		    if ((_data_tag = _oss_dec_tag(_g, &tmp_pos, &tmp_len)) == 0) {
			if (_oss_dec_length(_g, &tmp_pos, &tmp_len))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			_bufpos = tmp_pos;
			_buflen = tmp_len;
			break;
		    }
		} else
		    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos > _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
#if OSSDEBUG > 1
		count++;
#endif
		_temp->next = (_setof11 *)_oss_dec_const_alloc(_g, sizeof(_setof11));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(count)
#ifdef OSS_OPENTYPE_HAS_USERFIELD
		_temp->value.userField = nullptr;
#endif
		_oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_temp->value.encoded);
		_temp->value.pduNum = 0;
		*(void **)&_temp->value.decoded = nullptr;
	    }
	    _temp->next = nullptr;
	    OSS_CNTX_POP(_oss_c)
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_ContextAssertion(OssGlobal * _g, _ContextAssertion * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 7)
	_out_data->contextType.length = _oss_pdec_eobjid_ia(_g, &_out_data->contextType.value, -1);
	OSS_CNTX_SET(5)
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _setof11 * _temp = (_setof11 *)&_out_data->contextValues;
	    unsigned long count = 0;
	    ossBoolean _last = FALSE;
	    unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    unsigned long _prev_fragm0 = 0;
#endif

	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 6)
	    while (!_last) {
		count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		    if ((!_last) && _index && (_prev_fragm0 < 65536))
			_oss_dec_error(_g, _invalid_fragmentation, 0L);
		    _prev_fragm0 = count - _index;
		}
#endif
		for (; (unsigned long)_index < count; _index++) {
		    _temp->next = (_setof11 *)_oss_dec_const_alloc(_g, sizeof(_setof11));
		    _temp = _temp->next;
		    OSS_CNTX_SETOCC(_index + 1)
#ifdef OSS_OPENTYPE_HAS_USERFIELD
		    _temp->value.userField = nullptr;
#endif
		    _temp->value.encoded.length = _oss_pdec_unconstr_uoct_ia(_g, &_temp->value.encoded.value);
		    if (_temp->value.encoded.length == 0 && ((STRICT_ENCODING_DECODING_RULES | AUTOMATIC_ENCDEC) & _g->decodingFlags))
			_oss_dec_error(_g, _zero_length_OpenType, 0L);
		    _temp->value.pduNum = 0;
		    *(void **)&_temp->value.decoded = nullptr;
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    _temp->next = nullptr;
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d__choice1(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _choice1 * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	default:
	    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
	    switch (_data_tag & 0x7fff) {
	    case 0x0: {
		OSS_CNTX_PUSH(_oss_c, 8)
		_out_data->choice = 1;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
		_out_data->u.single_ASN1_type.userField = nullptr;
#endif
		_oss_dec_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.single_ASN1_type);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
	    }   break;
	    case 0x1: {
		OSS_CNTX_PUSH(_oss_c, 9)
		_out_data->choice = 2;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.octet_aligned.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.octet_aligned.value, 0);
	    }   break;
	    case 0x2: {
		OSS_CNTX_PUSH(_oss_c, 10)
		_out_data->choice = 3;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.arbitrary.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.arbitrary.value, 0, 0);

	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    break;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp__choice1(OssGlobal * _g, _choice1 * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_2int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 8)
#ifdef OSS_OPENTYPE_HAS_USERFIELD
	    _out_data->u.single_ASN1_type.userField = nullptr;
#endif
	    _oss_pdec_opentype(_g, &_out_data->u.single_ASN1_type);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 9)
	    _out_data->u.octet_aligned.length = _oss_pdec_unconstr_uoct_ia(_g, (unsigned char **)&_out_data->u.octet_aligned.value);

	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 10)
	    _out_data->u.arbitrary.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->u.arbitrary.value);

	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_External(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _External * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x6 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->direct_reference, 0, sizeof(_out_data->direct_reference));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 14)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x6) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x6 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x60000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x6;
	    _out_data->direct_reference.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->direct_reference.value, -1);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x2 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 13)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x2) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x2 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x20000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x2;
	    _out_data->indirect_reference = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x7 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x20000000;
	    memset(&_out_data->data_value_descriptor, 0, sizeof(_out_data->data_value_descriptor));
	}
else {
	    _out_data->bit_mask |= 0x20000000;
	    OSS_CNTX_PUSH(_oss_c, 12)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 7 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x7) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x7 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x70000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x7;
	    _out_data->data_value_descriptor.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->data_value_descriptor.value, 0);
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 11)
	_d__choice1(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->encoding);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_External(OssGlobal * _g, _External * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_3bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 14)
	if (_out_data->bit_mask & 0x80000000) {
	    _out_data->direct_reference.length = _oss_pdec_eobjid_ia(_g, &_out_data->direct_reference.value, -1);
	} else {
	    _out_data->direct_reference.length = 0;
	    _out_data->direct_reference.value = nullptr;
	}
	OSS_CNTX_SET(13)
	if (_out_data->bit_mask & 0x40000000) {
	    _out_data->indirect_reference = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	}
	OSS_CNTX_SET(12)
	if (_out_data->bit_mask & 0x20000000) {
	    _out_data->data_value_descriptor.length = _oss_pdec_ub_nkmstr_ia(_g, &_out_data->data_value_descriptor.value);

	} else {
	    _out_data->data_value_descriptor.length = 0;
	    _out_data->data_value_descriptor.value = nullptr;
	}
	OSS_CNTX_SET(11)
	_dp__choice1(_g, &_out_data->encoding);
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_Name(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Name * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	case 0x10: {
	    OSS_CNTX_PUSH(_oss_c, 15)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _d_RDNSequence(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.rdnSequence);
	}   break;
	default:
	    _oss_dec_error(_g, _unknown_field, _data_tag);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_Name(OssGlobal * _g, _Name * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->choice = 1;
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 15)
	    _dp_RDNSequence(_g, &_out_data->u.rdnSequence);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_AP_title(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _AP_title * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag == 0x10) {
	    OSS_CNTX_PUSH(_oss_c, 17)
	    _out_data->choice = 2;
	    _out_data->u.ap_title_form1 = (_Name *)_oss_dec_const_alloc(_g, sizeof(_Name));
	    _d_Name(_g, &_bufpos, &_buflen, 0, _data_tag, _out_data->u.ap_title_form1);
	    OSS_CNTX_POP(_oss_c)
	} else
	switch (_data_tag) {
	case 0x6: {
	    OSS_CNTX_PUSH(_oss_c, 16)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.ap_title_form2.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.ap_title_form2.value, -1);
	}   break;
	default:
	    _oss_c->_tag_decoded = FALSE;
	    _out_data->choice = 0;	/* Unknown choice selector. */
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    OSS_CNTX_PUSH(_oss_c, 0)
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_AP_title(OssGlobal * _g, _AP_title * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_get_1bit_unaligned(_g)) {

	    _out_data->choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
	} else {
	    unsigned long _encode_value;
	    _encode_value = _oss_pdec_small_int_l(_g);
	    if (_encode_value > UINT_MAX - 3)
		_oss_enc_error(_g, _bad_choice, _encode_value);
	    _out_data->choice = _encode_value + 3;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 16)
	    _out_data->u.ap_title_form2.length = _oss_pdec_eobjid_ia(_g, &_out_data->u.ap_title_form2.value, -1);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 17)
	    _out_data->u.ap_title_form1 = (_Name *)_oss_dec_const_alloc(_g, sizeof(_Name));
	    _dp_Name(_g, _out_data->u.ap_title_form1);
	    break;
	default:
	    _out_data->choice = 0;	/* Unknown choice selector. */
	    _oss_pdec_sot(_g);
	    OSS_CNTX_PUSH(_oss_c, 0)
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_AE_qualifier(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _AE_qualifier * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	case 0x2: {
	    OSS_CNTX_PUSH(_oss_c, 18)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.ae_qualifier_form2 = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	}   break;
	case 0x11: {
	    OSS_CNTX_PUSH(_oss_c, 19)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _d_RelativeDistinguishedName(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.ae_qualifier_form1);
	}   break;
	default:
	    _oss_c->_tag_decoded = FALSE;
	    _out_data->choice = 0;	/* Unknown choice selector. */
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    OSS_CNTX_PUSH(_oss_c, 0)
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_AE_qualifier(OssGlobal * _g, _AE_qualifier * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_get_1bit_unaligned(_g)) {

	    _out_data->choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
	} else {
	    unsigned long _encode_value;
	    _encode_value = _oss_pdec_small_int_l(_g);
	    if (_encode_value > UINT_MAX - 3)
		_oss_enc_error(_g, _bad_choice, _encode_value);
	    _out_data->choice = _encode_value + 3;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 18)
	    _out_data->u.ae_qualifier_form2 = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 19)
	    _dp_RelativeDistinguishedName(_g, &_out_data->u.ae_qualifier_form1);
	    break;
	default:
	    _out_data->choice = 0;	/* Unknown choice selector. */
	    _oss_pdec_sot(_g);
	    OSS_CNTX_PUSH(_oss_c, 0)
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_RealizationParameter(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _RealizationParameter * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 21)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 10 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0xA) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0xA : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0xA0000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0xA;
	_out_data->realization_type = (enum _enum1 )_oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x1 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->concatenation, &Context::default_fallback, sizeof(Context::default_fallback));
#else
	    _out_data->concatenation = 0;
#endif
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 20)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 1 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x1) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x1 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x10000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x1;
	    _out_data->concatenation = _oss_dec_bool(_g, &_bufpos, &_buflen, _data_length);
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_RealizationParameter(OssGlobal * _g, _RealizationParameter * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_1bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 21)
	_out_data->realization_type = (enum _enum1)_oss_pdec_uenum(_g, (struct _enum_data*)&_enums[0], nullptr);
	OSS_CNTX_SET(20)
	if (_out_data->bit_mask & 0x80000000) {
	    _out_data->concatenation = _oss_get_1bit_unaligned(_g) ? TRUE : FALSE;
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->concatenation, &Context::default_fallback, sizeof(Context::default_fallback));
#else
	    _out_data->concatenation = 0;
#endif
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_Authentication_value(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Authentication_value * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	default:
	    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
	    switch (_data_tag & 0x7fff) {
	    case 0x0: {
		OSS_CNTX_PUSH(_oss_c, 22)
		_out_data->choice = 1;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.charstring.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.charstring.value, 0);
	    }   break;
	    case 0x1: {
		OSS_CNTX_PUSH(_oss_c, 23)
		_out_data->choice = 2;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.bitstring.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.bitstring.value, 0, 0);

	    }   break;
	    case 0x2: {
		OSS_CNTX_PUSH(_oss_c, 24)
		_out_data->choice = 3;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.external = (_External *)_oss_dec_const_alloc(_g, sizeof(_External));
		_d_External(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.external);
	    }   break;
	    case 0x3: {
		OSS_CNTX_PUSH(_oss_c, 25)
		_out_data->choice = 4;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.other = (_seq1 *)_oss_dec_const_alloc(_g, sizeof(_seq1));
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    OSS_CNTX_INIT

		    OSS_CNTX_PUSH(_oss_c, 27)
		    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
		    _data_tag = 0x6;
		    _out_data->u.other->other_mechanism_name.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.other->other_mechanism_name.value, -1);
		    OSS_CNTX_SET(26)
		    if (_data_length == 0) _data_length = 1;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
		    _out_data->u.other->other_mechanism_value.userField = nullptr;
#endif
		    _oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.other->other_mechanism_value.encoded);
		    _out_data->u.other->other_mechanism_value.pduNum = 0;
		    *(void **)&_out_data->u.other->other_mechanism_value.decoded = nullptr;
		    OSS_CNTX_POP(_oss_c)
		    if (_bufpos != _end_pos) {
			if (_total_len < 0) {
			    if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
				_buflen--;
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			    if (_data_tag)
				_oss_dec_error(_g, _expec_eoc, 0L);
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			} else
			    _oss_dec_error(_g, _inconsis_len, 0L);
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    break;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_Authentication_value(OssGlobal * _g, _Authentication_value * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_2int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 22)
	    _out_data->u.charstring.length = _oss_pdec_ub_nkmstr_ia(_g, &_out_data->u.charstring.value);

	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 23)
	    _out_data->u.bitstring.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->u.bitstring.value);

	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 24)
	    _out_data->u.external = (_External *)_oss_dec_const_alloc(_g, sizeof(_External));
	    _dp_External(_g, _out_data->u.external);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 25)
	    _out_data->u.other = (_seq1 *)_oss_dec_const_alloc(_g, sizeof(_seq1));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 27)
		_out_data->u.other->other_mechanism_name.length = _oss_pdec_eobjid_ia(_g, &_out_data->u.other->other_mechanism_name.value, -1);
		OSS_CNTX_SET(26)
#ifdef OSS_OPENTYPE_HAS_USERFIELD
		_out_data->u.other->other_mechanism_value.userField = nullptr;
#endif
		_out_data->u.other->other_mechanism_value.encoded.length = _oss_pdec_unconstr_uoct_ia(_g, &_out_data->u.other->other_mechanism_value.encoded.value);
		if (_out_data->u.other->other_mechanism_value.encoded.length == 0 && ((STRICT_ENCODING_DECODING_RULES | AUTOMATIC_ENCDEC) & _g->decodingFlags))
		    _oss_dec_error(_g, _zero_length_OpenType, 0L);
		_out_data->u.other->other_mechanism_value.pduNum = 0;
		*(void **)&_out_data->u.other->other_mechanism_value.decoded = nullptr;
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_13Application_context_name_l(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Application_context_name_list ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_Application_context_name_list * _temp = (_Application_context_name_list *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 28)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    if (_data_tag != 0x6)
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x60000);
	    _temp->next = (_Application_context_name_list *)_oss_dec_const_alloc(_g, sizeof(_Application_context_name_list));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _temp->value.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.value, -1);
	}
	_temp->next = nullptr;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_13Application_context_name_l(OssGlobal * _g, _Application_context_name_list ** _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_Application_context_name_list * _temp = (_Application_context_name_list *)_out_data;
	unsigned long count = 0;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 28)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_Application_context_name_list *)_oss_dec_const_alloc(_g, sizeof(_Application_context_name_list));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
		_temp->value.length = _oss_pdec_eobjid_ia(_g, &_temp->value.value, -1);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = nullptr;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_Association_information(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Association_information ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_Association_information * _temp = (_Association_information *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 29)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    if (_data_tag != 0x8)
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000);
	    _temp->next = (_Association_information *)_oss_dec_const_alloc(_g, sizeof(_Association_information));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _d_External(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
	}
	_temp->next = nullptr;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_Association_information(OssGlobal * _g, _Association_information ** _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_Association_information * _temp = (_Association_information *)_out_data;
	unsigned long count = 0;
	unsigned char _ext = 0x00;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	_ext = _oss_get_1bit_unaligned(_g);
	OSS_CNTX_PUSH(_oss_c, 29)
	while (!_last) {
	    count += _oss_pdec_length(_g, 1, _ext ? 0 : 1, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_Association_information *)_oss_dec_const_alloc(_g, sizeof(_Association_information));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
		_dp_External(_g, &_temp->value);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = nullptr;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_Mode_selector(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Mode_selector * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	unsigned short _present_flags = 0;
	OSS_CNTX_DEF
	OSS_CNTX_SETOCC(0)
	OSS_CNTX_PUSH(_oss_c, 30)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 128 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8000;
	_out_data->mode_value = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	_present_flags |= 1;
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
	if ((_present_flags & 0x1) != 0x1)
	    _oss_dec_error(_g, _field_omit, 0L);
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_Mode_selector(OssGlobal * _g, _Mode_selector * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 30)
	_out_data->mode_value = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_ConnectionData(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _ConnectionData * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	default:
	    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
	    switch (_data_tag & 0x7fff) {
	    case 0x0: {
		OSS_CNTX_PUSH(_oss_c, 31)
		_out_data->choice = 1;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
		_out_data->u.open.userField = nullptr;
#endif
		_oss_dec_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.open);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
	    }   break;
	    case 0x1: {
		OSS_CNTX_PUSH(_oss_c, 32)
		_out_data->choice = 2;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.recover = (_SessionConnectionIdentifier *)_oss_dec_const_alloc(_g, sizeof(_SessionConnectionIdentifier));
		_d_SessionConnectionIdentifier(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.recover);
	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    break;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_ConnectionData(OssGlobal * _g, _ConnectionData * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 31)
#ifdef OSS_OPENTYPE_HAS_USERFIELD
	    _out_data->u.open.userField = nullptr;
#endif
	    _oss_pdec_opentype(_g, &_out_data->u.open);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 32)
	    _out_data->u.recover = (_SessionConnectionIdentifier *)_oss_dec_const_alloc(_g, sizeof(_SessionConnectionIdentifier));
	    _dp_SessionConnectionIdentifier(_g, _out_data->u.recover);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_User_data(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _User_data * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	case 0x4000: {
	    OSS_CNTX_PUSH(_oss_c, 33)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.simply_encoded_data.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.simply_encoded_data.value, 0);
	}   break;
	case 0x4001: {
	    OSS_CNTX_PUSH(_oss_c, 34)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _d_Fully_encoded_data(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.fully_encoded_data);
	}   break;
	default:
	    _oss_c->_tag_decoded = FALSE;
	    _out_data->choice = 0;	/* Unknown choice selector. */
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    OSS_CNTX_PUSH(_oss_c, 0)
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_User_data(OssGlobal * _g, _User_data * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_get_1bit_unaligned(_g)) {

	    _out_data->choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
	} else {
	    unsigned long _encode_value;
	    _encode_value = _oss_pdec_small_int_l(_g);
	    if (_encode_value > UINT_MAX - 3)
		_oss_enc_error(_g, _bad_choice, _encode_value);
	    _out_data->choice = _encode_value + 3;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 33)
	    _out_data->u.simply_encoded_data.length = _oss_pdec_unconstr_uoct_ia(_g, (unsigned char **)&_out_data->u.simply_encoded_data.value);

	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 34)
	    _dp_Fully_encoded_data(_g, &_out_data->u.fully_encoded_data);
	    break;
	default:
	    _out_data->choice = 0;	/* Unknown choice selector. */
	    _oss_pdec_sot(_g);
	    OSS_CNTX_PUSH(_oss_c, 0)
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d__seq7(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seq7 * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 38)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x2) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x2 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x20000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x2;
	_out_data->presentation_context_identifier = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	OSS_CNTX_SET(37)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
	_data_tag = 0x6;
	_out_data->abstract_syntax_name.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->abstract_syntax_name.value, -1);
	OSS_CNTX_SET(35)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _Application_context_name_list * _temp = (_Application_context_name_list *)&_out_data->transfer_syntax_name_list;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	    unsigned long count = 0;
#endif
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 36)
	    for (;;) {
		if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos > _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x6)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x60000);
		_temp->next = (_Application_context_name_list *)_oss_dec_const_alloc(_g, sizeof(_Application_context_name_list));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_temp->value.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.value, -1);
	    }
	    _temp->next = nullptr;
	    OSS_CNTX_POP(_oss_c)
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp__seq7(OssGlobal * _g, _seq7 * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 38)
	if (_oss_get_1bit_unaligned(_g)) {
	    _out_data->presentation_context_identifier = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	} else {
	    _out_data->presentation_context_identifier = (OSS_INT32)_oss_pdec_nonneg_7int(_g) + 1;
	}
	OSS_CNTX_SET(37)
	_out_data->abstract_syntax_name.length = _oss_pdec_eobjid_ia(_g, &_out_data->abstract_syntax_name.value, -1);
	OSS_CNTX_SET(35)
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _Application_context_name_list * _temp = (_Application_context_name_list *)&_out_data->transfer_syntax_name_list;
	    unsigned long count = 0;
	    ossBoolean _last = FALSE;
	    unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    unsigned long _prev_fragm0 = 0;
#endif

	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 36)
	    while (!_last) {
		count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		    if ((!_last) && _index && (_prev_fragm0 < 65536))
			_oss_dec_error(_g, _invalid_fragmentation, 0L);
		    _prev_fragm0 = count - _index;
		}
#endif
		for (; (unsigned long)_index < count; _index++) {
		    _temp->next = (_Application_context_name_list *)_oss_dec_const_alloc(_g, sizeof(_Application_context_name_list));
		    _temp = _temp->next;
		    OSS_CNTX_SETOCC(_index + 1)
		    _temp->value.length = _oss_pdec_eobjid_ia(_g, &_temp->value.value, -1);
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    _temp->next = nullptr;
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_Context_list(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Context_list ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_Context_list * _temp = (_Context_list *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 29)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    if (_data_tag != 0x10)
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
	    _temp->next = (_Context_list *)_oss_dec_const_alloc(_g, sizeof(_Context_list));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _d__seq7(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
	}
	_temp->next = nullptr;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_Context_list(OssGlobal * _g, _Context_list ** _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_Context_list * _temp = (_Context_list *)_out_data;
	unsigned long count = 0;
	unsigned char _ext = 0x00;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	_ext = _oss_get_1bit_unaligned(_g);
	OSS_CNTX_PUSH(_oss_c, 29)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, _ext ? 0 : 7, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_Context_list *)_oss_dec_const_alloc(_g, sizeof(_Context_list));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
		_dp__seq7(_g, &_temp->value);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = nullptr;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d__seq8(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seq8 * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 38)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x2) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x2 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x20000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x2;
	_out_data->presentation_context_identifier = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	OSS_CNTX_SET(39)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
	_data_tag = 0x6;
	_out_data->transfer_syntax_name.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->transfer_syntax_name.value, -1);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp__seq8(OssGlobal * _g, _seq8 * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 38)
	if (_oss_get_1bit_unaligned(_g)) {
	    _out_data->presentation_context_identifier = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	} else {
	    _out_data->presentation_context_identifier = (OSS_INT32)_oss_pdec_nonneg_7int(_g) + 1;
	}
	OSS_CNTX_SET(39)
	_out_data->transfer_syntax_name.length = _oss_pdec_eobjid_ia(_g, &_out_data->transfer_syntax_name.value, -1);
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_14Presentation_context_ident(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Presentation_context_identifier_list ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_Presentation_context_identifier_list * _temp = (_Presentation_context_identifier_list *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 29)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    if (_data_tag != 0x10)
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
	    _temp->next = (_Presentation_context_identifier_list *)_oss_dec_const_alloc(_g, sizeof(_Presentation_context_identifier_list));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _d__seq8(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
	}
	_temp->next = nullptr;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_14Presentation_context_ident(OssGlobal * _g, _Presentation_context_identifier_list ** _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_Presentation_context_identifier_list * _temp = (_Presentation_context_identifier_list *)_out_data;
	unsigned long count = 0;
	unsigned char _ext = 0x00;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	_ext = _oss_get_1bit_unaligned(_g);
	OSS_CNTX_PUSH(_oss_c, 29)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, _ext ? 0 : 7, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_Presentation_context_identifier_list *)_oss_dec_const_alloc(_g, sizeof(_Presentation_context_identifier_list));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
		_dp__seq8(_g, &_temp->value);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = nullptr;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d__seq9(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seq9 * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 41)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 128 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8000;
	_out_data->result = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8001 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->transfer_syntax_name, 0, sizeof(_out_data->transfer_syntax_name));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 39)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 129 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8001) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x81 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80010000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8001;
	    _out_data->transfer_syntax_name.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->transfer_syntax_name.value, -1);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8002 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 40)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 130 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8002) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x82 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80020000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8002;
	    _out_data->provider_reason = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp__seq9(OssGlobal * _g, _seq9 * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_2bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 41)
	_out_data->result = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	OSS_CNTX_SET(39)
	if (_out_data->bit_mask & 0x80000000) {
	    _out_data->transfer_syntax_name.length = _oss_pdec_eobjid_ia(_g, &_out_data->transfer_syntax_name.value, -1);
	} else {
	    _out_data->transfer_syntax_name.length = 0;
	    _out_data->transfer_syntax_name.value = nullptr;
	}
	OSS_CNTX_SET(40)
	if (_out_data->bit_mask & 0x40000000) {
	    _out_data->provider_reason = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_Result_list(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Result_list ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_Result_list * _temp = (_Result_list *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 29)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    if (_data_tag != 0x10)
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
	    _temp->next = (_Result_list *)_oss_dec_const_alloc(_g, sizeof(_Result_list));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _d__seq9(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
	}
	_temp->next = nullptr;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_Result_list(OssGlobal * _g, _Result_list ** _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_Result_list * _temp = (_Result_list *)_out_data;
	unsigned long count = 0;
	unsigned char _ext = 0x00;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	_ext = _oss_get_1bit_unaligned(_g);
	OSS_CNTX_PUSH(_oss_c, 29)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, _ext ? 0 : 7, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_Result_list *)_oss_dec_const_alloc(_g, sizeof(_Result_list));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
		_dp__seq9(_g, &_temp->value);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = nullptr;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_PDV_list(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _PDV_list * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x6 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->transfer_syntax_name, 0, sizeof(_out_data->transfer_syntax_name));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 39)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x6) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x6 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x60000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x6;
	    _out_data->transfer_syntax_name.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->transfer_syntax_name.value, -1);
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 38)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x2) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x2 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x20000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x2;
	_out_data->presentation_context_identifier = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	OSS_CNTX_SET(42)
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    int _indef_tags = 0;
	    OSS_CNTX_INIT

	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	    switch (_data_tag) {
	    default:
		if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
		switch (_data_tag & 0x7fff) {
		case 0x0: {
		    OSS_CNTX_PUSH(_oss_c, 8)
		    _out_data->presentation_data_values.choice = 1;

		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
		    _out_data->presentation_data_values.u.single_ASN1_type.userField = nullptr;
#endif
		    _oss_dec_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->presentation_data_values.u.single_ASN1_type);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		}   break;
		case 0x1: {
		    OSS_CNTX_PUSH(_oss_c, 9)
		    _out_data->presentation_data_values.choice = 2;

		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _out_data->presentation_data_values.u.octet_aligned.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->presentation_data_values.u.octet_aligned.value, 0);
		}   break;
		case 0x2: {
		    OSS_CNTX_PUSH(_oss_c, 10)
		    _out_data->presentation_data_values.choice = 3;

		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _out_data->presentation_data_values.u.arbitrary.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->presentation_data_values.u.arbitrary.value, 0, 0);

		}   break;
		default:
		    _oss_dec_error(_g, _unknown_field, _data_tag);
		}
		break;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_PDV_list(OssGlobal * _g, _PDV_list * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_1bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 39)
	if (_out_data->bit_mask & 0x80000000) {
	    _out_data->transfer_syntax_name.length = _oss_pdec_eobjid_ia(_g, &_out_data->transfer_syntax_name.value, -1);
	} else {
	    _out_data->transfer_syntax_name.length = 0;
	    _out_data->transfer_syntax_name.value = nullptr;
	}
	OSS_CNTX_SET(38)
	if (_oss_get_1bit_unaligned(_g)) {
	    _out_data->presentation_context_identifier = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	} else {
	    _out_data->presentation_context_identifier = (OSS_INT32)_oss_pdec_nonneg_7int(_g) + 1;
	}
	OSS_CNTX_SET(42)
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    OSS_CNTX_INIT

	    {

		_out_data->presentation_data_values.choice = (int)_oss_pdec_nonneg_2int(_g) + 1;
	    }
	    switch (_out_data->presentation_data_values.choice) {
	    case 1:
		OSS_CNTX_PUSH(_oss_c, 8)
#ifdef OSS_OPENTYPE_HAS_USERFIELD
		_out_data->presentation_data_values.u.single_ASN1_type.userField = nullptr;
#endif
		_oss_pdec_opentype(_g, &_out_data->presentation_data_values.u.single_ASN1_type);
		break;
	    case 2:
		OSS_CNTX_PUSH(_oss_c, 9)
		_out_data->presentation_data_values.u.octet_aligned.length = _oss_pdec_unconstr_uoct_ia(_g, (unsigned char **)&_out_data->presentation_data_values.u.octet_aligned.value);

		break;
	    case 3:
		OSS_CNTX_PUSH(_oss_c, 10)
		_out_data->presentation_data_values.u.arbitrary.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->presentation_data_values.u.arbitrary.value);

		break;
	    default:
		_oss_enc_error(_g, _bad_choice, _out_data->presentation_data_values.choice);	/* Bad choice selector. */
	    }
	    OSS_CNTX_POP(_oss_c)
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_Fully_encoded_data(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Fully_encoded_data ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_Fully_encoded_data * _temp = (_Fully_encoded_data *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 43)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    if (_data_tag != 0x10)
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
	    _temp->next = (_Fully_encoded_data *)_oss_dec_const_alloc(_g, sizeof(_Fully_encoded_data));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _d_PDV_list(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
	}
	_temp->next = nullptr;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_Fully_encoded_data(OssGlobal * _g, _Fully_encoded_data ** _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_Fully_encoded_data * _temp = (_Fully_encoded_data *)_out_data;
	unsigned long count = 0;
	unsigned char _ext = 0x00;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	_ext = _oss_get_1bit_unaligned(_g);
	OSS_CNTX_PUSH(_oss_c, 43)
	while (!_last) {
	    count += _oss_pdec_length(_g, 1, _ext ? 0 : 1, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_Fully_encoded_data *)_oss_dec_const_alloc(_g, sizeof(_Fully_encoded_data));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
		_dp_PDV_list(_g, &_temp->value);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = nullptr;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_RTORQapdu(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _set1 * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	unsigned short _present_flags = 0;
	OSS_CNTX_DEF
	OSS_CNTX_SETOCC(0)
	_out_data->bit_mask = 0;
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    switch (_data_tag) {
	    default:
		if (!(_data_tag & 0x8000))
		    _oss_dec_error(_g, _unknown_field, _data_tag);
		switch (_data_tag & 0x7fff) {
		case 0x0: {
		    OSS_CNTX_PUSH(_oss_c, 48)
		    if (_out_data->bit_mask & 0x80000000)
			_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		    _out_data->bit_mask |= 0x80000000;
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _out_data->checkpointSize = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		    _present_flags |= 0x1;
		}   break;
		case 0x1: {
		    OSS_CNTX_PUSH(_oss_c, 47)
		    if (_out_data->bit_mask & 0x40000000)
			_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		    _out_data->bit_mask |= 0x40000000;
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _out_data->windowSize = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		    _present_flags |= 0x2;
		}   break;
		case 0x2: {
		    OSS_CNTX_PUSH(_oss_c, 46)
		    if (_out_data->bit_mask & 0x20000000)
			_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		    _out_data->bit_mask |= 0x20000000;
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _out_data->dialogueMode = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		    _present_flags |= 0x4;
		}   break;
		case 0x3: {
		    OSS_CNTX_PUSH(_oss_c, 45)
		    if (_present_flags & 0x8)
			_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    if (_data_length < 0) ++_indef_tags;
		    _d_ConnectionData(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->connectionDataRQ);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    _present_flags |= 0x8;
		}   break;
		case 0x4: {
		    OSS_CNTX_PUSH(_oss_c, 44)
		    if (_out_data->bit_mask & 0x10000000)
			_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		    _out_data->bit_mask |= 0x10000000;
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _out_data->applicationProtocol = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		    _present_flags |= 0x10;
		}   break;
		default:
		    _oss_dec_error(_g, _unknown_field, _data_tag);
		}
		break;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!(_present_flags & 0x1)) {
	    _out_data->bit_mask &= ~0x80000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->checkpointSize, &__shared15::default_checkpointSize, sizeof(__shared15::default_checkpointSize));
#else
	    _out_data->checkpointSize = 0;
#endif
	}
	if (!(_present_flags & 0x2)) {
	    _out_data->bit_mask &= ~0x40000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->windowSize, &__shared15::default_windowSize, sizeof(__shared15::default_windowSize));
#else
	    _out_data->windowSize = 0;
#endif
	}
	if (!(_present_flags & 0x4)) {
	    _out_data->bit_mask &= ~0x20000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->dialogueMode, &__shared15::default_checkpointSize, sizeof(__shared15::default_checkpointSize));
#else
	    _out_data->dialogueMode = 0;
#endif
	}
	if (!(_present_flags & 0x10)) {
	    _out_data->bit_mask &= ~0x10000000;
	}
	if ((_present_flags & 0x8) != 0x8)
	    _oss_dec_error(_g, _field_omit, 0L);
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_RTORQapdu(OssGlobal * _g, _set1 * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_4bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 48)
	if (_out_data->bit_mask & 0x80000000) {
	    _out_data->checkpointSize = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->checkpointSize, &__shared15::default_checkpointSize, sizeof(__shared15::default_checkpointSize));
#else
	    _out_data->checkpointSize = 0;
#endif
	}
	OSS_CNTX_SET(47)
	if (_out_data->bit_mask & 0x40000000) {
	    _out_data->windowSize = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->windowSize, &__shared15::default_windowSize, sizeof(__shared15::default_windowSize));
#else
	    _out_data->windowSize = 0;
#endif
	}
	OSS_CNTX_SET(46)
	if (_out_data->bit_mask & 0x20000000) {
	    _out_data->dialogueMode = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->dialogueMode, &__shared15::default_checkpointSize, sizeof(__shared15::default_checkpointSize));
#else
	    _out_data->dialogueMode = 0;
#endif
	}
	OSS_CNTX_SET(45)
	_dp_ConnectionData(_g, &_out_data->connectionDataRQ);
	OSS_CNTX_SET(44)
	if (_out_data->bit_mask & 0x10000000) {
	    _out_data->applicationProtocol = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_RTOACapdu(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _set2 * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	unsigned short _present_flags = 0;
	OSS_CNTX_DEF
	OSS_CNTX_SETOCC(0)
	_out_data->bit_mask = 0;
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    switch (_data_tag) {
	    default:
		if (!(_data_tag & 0x8000))
		    _oss_dec_error(_g, _unknown_field, _data_tag);
		switch (_data_tag & 0x7fff) {
		case 0x0: {
		    OSS_CNTX_PUSH(_oss_c, 48)
		    if (_out_data->bit_mask & 0x80000000)
			_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		    _out_data->bit_mask |= 0x80000000;
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _out_data->checkpointSize = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		    _present_flags |= 0x1;
		}   break;
		case 0x1: {
		    OSS_CNTX_PUSH(_oss_c, 47)
		    if (_out_data->bit_mask & 0x40000000)
			_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		    _out_data->bit_mask |= 0x40000000;
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _out_data->windowSize = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		    _present_flags |= 0x2;
		}   break;
		case 0x2: {
		    OSS_CNTX_PUSH(_oss_c, 49)
		    if (_present_flags & 0x4)
			_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    if (_data_length < 0) ++_indef_tags;
		    _d_ConnectionData(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->connectionDataAC);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    _present_flags |= 0x4;
		}   break;
		default:
		    _oss_dec_error(_g, _unknown_field, _data_tag);
		}
		break;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!(_present_flags & 0x1)) {
	    _out_data->bit_mask &= ~0x80000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->checkpointSize, &__shared15::default_checkpointSize, sizeof(__shared15::default_checkpointSize));
#else
	    _out_data->checkpointSize = 0;
#endif
	}
	if (!(_present_flags & 0x2)) {
	    _out_data->bit_mask &= ~0x40000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->windowSize, &__shared15::default_windowSize, sizeof(__shared15::default_windowSize));
#else
	    _out_data->windowSize = 0;
#endif
	}
	if ((_present_flags & 0x4) != 0x4)
	    _oss_dec_error(_g, _field_omit, 0L);
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_RTOACapdu(OssGlobal * _g, _set2 * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_2bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 48)
	if (_out_data->bit_mask & 0x80000000) {
	    _out_data->checkpointSize = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->checkpointSize, &__shared15::default_checkpointSize, sizeof(__shared15::default_checkpointSize));
#else
	    _out_data->checkpointSize = 0;
#endif
	}
	OSS_CNTX_SET(47)
	if (_out_data->bit_mask & 0x40000000) {
	    _out_data->windowSize = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->windowSize, &__shared15::default_windowSize, sizeof(__shared15::default_windowSize));
#else
	    _out_data->windowSize = 0;
#endif
	}
	OSS_CNTX_SET(49)
	_dp_ConnectionData(_g, &_out_data->connectionDataAC);
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_RTORJapdu(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _set3 * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	unsigned short _present_flags = 0;
	OSS_CNTX_DEF
	OSS_CNTX_SETOCC(0)
	_out_data->bit_mask = 0;
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    switch (_data_tag) {
	    default:
		if (!(_data_tag & 0x8000))
		    _oss_dec_error(_g, _unknown_field, _data_tag);
		switch (_data_tag & 0x7fff) {
		case 0x0: {
		    OSS_CNTX_PUSH(_oss_c, 51)
		    if (_out_data->bit_mask & 0x80000000)
			_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		    _out_data->bit_mask |= 0x80000000;
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _out_data->refuseReason = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		    _present_flags |= 0x1;
		}   break;
		case 0x1: {
		    OSS_CNTX_PUSH(_oss_c, 50)
		    if (_out_data->bit_mask & 0x40000000)
			_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		    _out_data->bit_mask |= 0x40000000;
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
		    _out_data->userDataRJ.userField = nullptr;
#endif
		    _oss_dec_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->userDataRJ);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    _present_flags |= 0x2;
		}   break;
		default:
		    _oss_dec_error(_g, _unknown_field, _data_tag);
		}
		break;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!(_present_flags & 0x1)) {
	    _out_data->bit_mask &= ~0x80000000;
	}
	if (!(_present_flags & 0x2)) {
	    _out_data->bit_mask &= ~0x40000000;
	    memset(&_out_data->userDataRJ, 0, sizeof(_out_data->userDataRJ));
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_RTORJapdu(OssGlobal * _g, _set3 * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_2bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 51)
	if (_out_data->bit_mask & 0x80000000) {
	    _out_data->refuseReason = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	}
	OSS_CNTX_SET(50)
	if (_out_data->bit_mask & 0x40000000) {
#ifdef OSS_OPENTYPE_HAS_USERFIELD
	    _out_data->userDataRJ.userField = nullptr;
#endif
	    _oss_pdec_opentype(_g, &_out_data->userDataRJ);
	} else {
	    memset(&(_out_data->userDataRJ), 0, sizeof(OSSC::COssOpen ));
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_CallingSSuserReference(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _CallingSSuserReference * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	case 0x4: {
	    OSS_CNTX_PUSH(_oss_c, 52)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.octetString.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.octetString.value, 0);
	}   break;
	case 0x14: {
	    OSS_CNTX_PUSH(_oss_c, 53)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.t61String.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.t61String.value, 0);
	}   break;
	default:
	    _oss_dec_error(_g, _unknown_field, _data_tag);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_CallingSSuserReference(OssGlobal * _g, _CallingSSuserReference * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 52)
	    _out_data->u.octetString.length = _oss_pdec_unconstr_uoct_ia(_g, (unsigned char **)&_out_data->u.octetString.value);

	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 53)
	    _out_data->u.t61String.length = _oss_pdec_ub_nkmstr_ia(_g, &_out_data->u.t61String.value);

	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_SessionConnectionIdentifier(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _SessionConnectionIdentifier * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 56)
	_d_CallingSSuserReference(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->callingSSuserReference);
	OSS_CNTX_SET(55)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 23 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x17);
	_data_tag = 0x17;
	_oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->commonReference, -1, 1);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8000 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->additionalReferenceInformation, 0, sizeof(_out_data->additionalReferenceInformation));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 54)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 128 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8000;
	    _out_data->additionalReferenceInformation.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->additionalReferenceInformation.value, 0);
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_SessionConnectionIdentifier(OssGlobal * _g, _SessionConnectionIdentifier * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_1bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 56)
	_dp_CallingSSuserReference(_g, &_out_data->callingSSuserReference);
	OSS_CNTX_SET(55)
	_oss_pdec_ntp_kmstr(_g, &_out_data->commonReference, _chars + 3);
	OSS_CNTX_SET(54)
	if (_out_data->bit_mask & 0x80000000) {
	    _out_data->additionalReferenceInformation.length = _oss_pdec_ub_nkmstr_ia(_g, &_out_data->additionalReferenceInformation.value);

	} else {
	    _out_data->additionalReferenceInformation.length = 0;
	    _out_data->additionalReferenceInformation.value = nullptr;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_InvokeId(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _InvokeId * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	case 0x2: {
	    OSS_CNTX_PUSH(_oss_c, 57)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.present = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	}   break;
	case 0x5: {
	    OSS_CNTX_PUSH(_oss_c, 58)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.absent = 0;
	    if (_data_length != 0)
		_oss_dec_error(_g, _inval_enc, 0L);
	}   break;
	default:
	    _oss_dec_error(_g, _unknown_field, _data_tag);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_InvokeId(OssGlobal * _g, _InvokeId * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 57)
	    _out_data->u.present = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 58)
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_Criteria(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Criteria * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	default:
	    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
	    switch (_data_tag & 0x7fff) {
	    case 0x0: {
		OSS_CNTX_PUSH(_oss_c, 59)
		_out_data->choice = 1;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		_out_data->u.type = (_CriteriaItem *)_oss_dec_const_alloc(_g, sizeof(_CriteriaItem));
		_d_CriteriaItem(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.type);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
	    }   break;
	    case 0x1: {
		OSS_CNTX_PUSH(_oss_c, 60)
		_out_data->choice = 2;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
		_data_tag = 0x11;
		_d__setof1(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.Criteria_and);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
	    }   break;
	    case 0x2: {
		OSS_CNTX_PUSH(_oss_c, 61)
		_out_data->choice = 3;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
		_data_tag = 0x11;
		_d__setof2(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.Criteria_or);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
	    }   break;
	    case 0x3: {
		OSS_CNTX_PUSH(_oss_c, 62)
		_out_data->choice = 4;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		_out_data->u.Criteria_not = (_Criteria *)_oss_dec_const_alloc(_g, sizeof(_Criteria));
		_d_Criteria(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.Criteria_not);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    break;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_Criteria(OssGlobal * _g, _Criteria * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_2int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 59)
	    _out_data->u.type = (_CriteriaItem *)_oss_dec_const_alloc(_g, sizeof(_CriteriaItem));
	    _dp_CriteriaItem(_g, _out_data->u.type);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 60)
	    _dp__setof1(_g, &_out_data->u.Criteria_and);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 61)
	    _dp__setof2(_g, &_out_data->u.Criteria_or);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 62)
	    _out_data->u.Criteria_not = (_Criteria *)_oss_dec_const_alloc(_g, sizeof(_Criteria));
	    _dp_Criteria(_g, _out_data->u.Criteria_not);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d__setof2(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _setof1 ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_setof1 * _temp = (_setof1 *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 63)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    _temp->next = (_setof1 *)_oss_dec_const_alloc(_g, sizeof(_setof1));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
	    _d_Criteria(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
	}
	_temp->next = nullptr;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp__setof2(OssGlobal * _g, _setof1 ** _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_setof1 * _temp = (_setof1 *)_out_data;
	unsigned long count = 0;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 63)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_setof1 *)_oss_dec_const_alloc(_g, sizeof(_setof1));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
		_dp_Criteria(_g, &_temp->value);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = nullptr;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d__setof1(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _setof1 ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_setof1 * _temp = (_setof1 *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 63)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    _temp->next = (_setof1 *)_oss_dec_const_alloc(_g, sizeof(_setof1));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
	    _d_Criteria(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
	}
	_temp->next = nullptr;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp__setof1(OssGlobal * _g, _setof1 ** _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_setof1 * _temp = (_setof1 *)_out_data;
	unsigned long count = 0;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 63)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_setof1 *)_oss_dec_const_alloc(_g, sizeof(_setof1));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
		_dp_Criteria(_g, &_temp->value);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = nullptr;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_CriteriaItem(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _CriteriaItem * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	default:
	    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
	    switch (_data_tag & 0x7fff) {
	    case 0x0: {
		OSS_CNTX_PUSH(_oss_c, 64)
		_out_data->choice = 1;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
		_data_tag = 0x6;
		_out_data->u.equality.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.equality.value, -1);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
	    }   break;
	    case 0x1: {
		OSS_CNTX_PUSH(_oss_c, 65)
		_out_data->choice = 2;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
		_data_tag = 0x6;
		_out_data->u.substrings.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.substrings.value, -1);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
	    }   break;
	    case 0x2: {
		OSS_CNTX_PUSH(_oss_c, 66)
		_out_data->choice = 3;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
		_data_tag = 0x6;
		_out_data->u.greaterOrEqual.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.greaterOrEqual.value, -1);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
	    }   break;
	    case 0x3: {
		OSS_CNTX_PUSH(_oss_c, 67)
		_out_data->choice = 4;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
		_data_tag = 0x6;
		_out_data->u.lessOrEqual.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.lessOrEqual.value, -1);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
	    }   break;
	    case 0x4: {
		OSS_CNTX_PUSH(_oss_c, 68)
		_out_data->choice = 5;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
		_data_tag = 0x6;
		_out_data->u.approximateMatch.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.approximateMatch.value, -1);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    break;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_CriteriaItem(OssGlobal * _g, _CriteriaItem * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_3int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 64)
	    _out_data->u.equality.length = _oss_pdec_eobjid_ia(_g, &_out_data->u.equality.value, -1);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 65)
	    _out_data->u.substrings.length = _oss_pdec_eobjid_ia(_g, &_out_data->u.substrings.value, -1);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 66)
	    _out_data->u.greaterOrEqual.length = _oss_pdec_eobjid_ia(_g, &_out_data->u.greaterOrEqual.value, -1);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 67)
	    _out_data->u.lessOrEqual.length = _oss_pdec_eobjid_ia(_g, &_out_data->u.lessOrEqual.value, -1);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 68)
	    _out_data->u.approximateMatch.length = _oss_pdec_eobjid_ia(_g, &_out_data->u.approximateMatch.value, -1);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_DayTime(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _DayTime * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 71)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->hour = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8001 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->minute, &DayTime::default_minute, sizeof(DayTime::default_minute));
#else
	    _out_data->minute = 0;
#endif
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 70)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8001) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x81 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80010000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8001;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	    _data_tag = 0x2;
	    _out_data->minute = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8002 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->second, &DayTime::default_second, sizeof(DayTime::default_second));
#else
	    _out_data->second = 0;
#endif
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 69)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8002) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x82 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80020000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8002;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	    _data_tag = 0x2;
	    _out_data->second = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_DayTime(OssGlobal * _g, _DayTime * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_2bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 71)
	{
	    _out_data->hour = (OSS_UINT32)_oss_pdec_nonneg_5int(_g);
	}
	OSS_CNTX_SET(70)
	if (_out_data->bit_mask & 0x80000000) {
	    {
		_out_data->minute = (OSS_UINT32)_oss_pdec_nonneg_6int(_g);
	    }
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->minute, &DayTime::default_minute, sizeof(DayTime::default_minute));
#else
	    _out_data->minute = 0;
#endif
	}
	OSS_CNTX_SET(69)
	if (_out_data->bit_mask & 0x40000000) {
	    {
		_out_data->second = (OSS_UINT32)_oss_pdec_nonneg_6int(_g);
	    }
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->second, &DayTime::default_second, sizeof(DayTime::default_second));
#else
	    _out_data->second = 0;
#endif
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d__setof7(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Presentation_context_deletion_list ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_Presentation_context_deletion_list * _temp = (_Presentation_context_deletion_list *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 72)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    if (_data_tag != 0x2)
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x20000);
	    _temp->next = (_Presentation_context_deletion_list *)_oss_dec_const_alloc(_g, sizeof(_Presentation_context_deletion_list));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _temp->value = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	}
	_temp->next = nullptr;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp__setof7(OssGlobal * _g, _Presentation_context_deletion_list ** _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_Presentation_context_deletion_list * _temp = (_Presentation_context_deletion_list *)_out_data;
	unsigned long count = 0;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 72)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_Presentation_context_deletion_list *)_oss_dec_const_alloc(_g, sizeof(_Presentation_context_deletion_list));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
		_temp->value = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = nullptr;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_NamedDay(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _NamedDay * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	case 0x3: {
	    OSS_CNTX_PUSH(_oss_c, 73)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.bitNamedDays.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.bitNamedDays.value, 0, 128);

	}   break;
	case 0xA: {
	    OSS_CNTX_PUSH(_oss_c, 74)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.intNamedDays = (enum _enum2 )_oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	}   break;
	default:
	    _oss_dec_error(_g, _unknown_field, _data_tag);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_NamedDay(OssGlobal * _g, _NamedDay * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 73)
	    _out_data->u.bitNamedDays.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->u.bitNamedDays.value);

	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 74)
	    _out_data->u.intNamedDays = (enum _enum2)_oss_pdec_uenum(_g, (struct _enum_data*)&_enums[1], nullptr);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_Context(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Context * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 7)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x6) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x6 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x60000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x6;
	_out_data->contextType.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->contextType.value, -1);
	OSS_CNTX_SET(5)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
	_data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _setof11 * _temp = (_setof11 *)&_out_data->contextValues;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	    unsigned long count = 0;
#endif
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 6)
	    for (;;) {
		if (_total_len < 0) {
		    char *tmp_pos = _bufpos;
		    long tmp_len = _buflen;

		    if ((_data_tag = _oss_dec_tag(_g, &tmp_pos, &tmp_len)) == 0) {
			if (_oss_dec_length(_g, &tmp_pos, &tmp_len))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			_bufpos = tmp_pos;
			_buflen = tmp_len;
			break;
		    }
		} else
		    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos > _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
#if OSSDEBUG > 1
		count++;
#endif
		_temp->next = (_setof11 *)_oss_dec_const_alloc(_g, sizeof(_setof11));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(count)
#ifdef OSS_OPENTYPE_HAS_USERFIELD
		_temp->value.userField = nullptr;
#endif
		_oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_temp->value.encoded);
		_temp->value.pduNum = 0;
		*(void **)&_temp->value.decoded = nullptr;
	    }
	    _temp->next = nullptr;
	    OSS_CNTX_POP(_oss_c)
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x1 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->fallback, &Context::default_fallback, sizeof(Context::default_fallback));
#else
	    _out_data->fallback = 0;
#endif
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 75)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 1 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x1) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x1 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x10000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x1;
	    _out_data->fallback = _oss_dec_bool(_g, &_bufpos, &_buflen, _data_length);
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_Context(OssGlobal * _g, _Context * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_1bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 7)
	_out_data->contextType.length = _oss_pdec_eobjid_ia(_g, &_out_data->contextType.value, -1);
	OSS_CNTX_SET(5)
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _setof11 * _temp = (_setof11 *)&_out_data->contextValues;
	    unsigned long count = 0;
	    ossBoolean _last = FALSE;
	    unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    unsigned long _prev_fragm0 = 0;
#endif

	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 6)
	    while (!_last) {
		count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		    if ((!_last) && _index && (_prev_fragm0 < 65536))
			_oss_dec_error(_g, _invalid_fragmentation, 0L);
		    _prev_fragm0 = count - _index;
		}
#endif
		for (; (unsigned long)_index < count; _index++) {
		    _temp->next = (_setof11 *)_oss_dec_const_alloc(_g, sizeof(_setof11));
		    _temp = _temp->next;
		    OSS_CNTX_SETOCC(_index + 1)
#ifdef OSS_OPENTYPE_HAS_USERFIELD
		    _temp->value.userField = nullptr;
#endif
		    _temp->value.encoded.length = _oss_pdec_unconstr_uoct_ia(_g, &_temp->value.encoded.value);
		    if (_temp->value.encoded.length == 0 && ((STRICT_ENCODING_DECODING_RULES | AUTOMATIC_ENCDEC) & _g->decodingFlags))
			_oss_dec_error(_g, _zero_length_OpenType, 0L);
		    _temp->value.pduNum = 0;
		    *(void **)&_temp->value.decoded = nullptr;
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    _temp->next = nullptr;
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_SET(75)
	if (_out_data->bit_mask & 0x80000000) {
	    _out_data->fallback = _oss_get_1bit_unaligned(_g) ? TRUE : FALSE;
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->fallback, &Context::default_fallback, sizeof(Context::default_fallback));
#else
	    _out_data->fallback = 0;
#endif
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_RDNSequence(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _RDNSequence ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_RDNSequence * _temp = (_RDNSequence *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 76)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    if (_data_tag != 0x11)
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x110000);
	    _temp->next = (_RDNSequence *)_oss_dec_const_alloc(_g, sizeof(_RDNSequence));
	    _temp = _temp->next;
	    _temp->value = nullptr;
	    OSS_CNTX_SETOCC(count)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _d_RelativeDistinguishedName(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
	}
	_temp->next = nullptr;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_RDNSequence(OssGlobal * _g, _RDNSequence ** _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_RDNSequence * _temp = (_RDNSequence *)_out_data;
	unsigned long count = 0;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 76)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_RDNSequence *)_oss_dec_const_alloc(_g, sizeof(_RDNSequence));
		_temp = _temp->next;
		_temp->value = nullptr;
		OSS_CNTX_SETOCC(_index + 1)
		_dp_RelativeDistinguishedName(_g, &_temp->value);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = nullptr;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_15AttributeTypeAndDistinguis(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _AttributeTypeAndDistinguishedValue * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 83)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x6) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x6 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x60000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x6;
	_out_data->type.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->type.value, -1);
	OSS_CNTX_SET(82)
	if (_data_length == 0) _data_length = 1;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
	_out_data->value.userField = nullptr;
#endif
	_oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->value.encoded);
	_out_data->value.pduNum = 0;
	*(void **)&_out_data->value.decoded = nullptr;
	OSS_CNTX_POP(_oss_c)
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x1 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->primaryDistinguished, &AttributeTypeAndDistinguishedValue::default_primaryDistinguished, sizeof(AttributeTypeAndDistinguishedValue::default_primaryDistinguished));
#else
	    _out_data->primaryDistinguished = 0;
#endif
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 81)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 1 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x1) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x1 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x10000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x1;
	    _out_data->primaryDistinguished = _oss_dec_bool(_g, &_bufpos, &_buflen, _data_length);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x11 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    memset(&_out_data->valuesWithContext, 0, sizeof(_out_data->valuesWithContext));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 77)
	    _out_data->valuesWithContext = nullptr;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x11) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x11 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x110000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_setof16 * _temp = (_setof16 *)&_out_data->valuesWithContext;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
		unsigned long count = 0;
#endif
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 29)
		for (;;) {
		    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos > _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
		    count++;
#endif
		    if (_data_tag != 0x10)
			_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		    _temp->next = (_setof16 *)_oss_dec_const_alloc(_g, sizeof(_setof16));
		    _temp = _temp->next;
		    OSS_CNTX_SETOCC(count)
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			int _indef_tags = 0;
			long _total_len = _data_length;
			char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
			OSS_CNTX_INIT

			_temp->value.bit_mask = 0;
			if (_bufpos < _end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x8000 || _bufpos >= _end_pos)
			 {
			    _temp->value.bit_mask &= ~0x80000000;
			    memset(&_temp->value.distingAttrValue, 0, sizeof(_temp->value.distingAttrValue));
			}
else {
			    _temp->value.bit_mask |= 0x80000000;
			    OSS_CNTX_PUSH(_oss_c, 80)
			    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				_buflen -= 2;
				_bufpos += 2;
			    } else {
				if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
				} else
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
				_oss_c->_tag_decoded = FALSE;
			    }
			    _data_tag = 0x8000;
			    if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
			    _temp->value.distingAttrValue.userField = nullptr;
#endif
			    _oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_temp->value.distingAttrValue.encoded);
			    _temp->value.distingAttrValue.pduNum = 0;
			    *(void **)&_temp->value.distingAttrValue.decoded = nullptr;
			    while (_indef_tags > 0) {
				if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    if (!_buflen || _bufpos[0])
					_oss_dec_error(_g, _expec_eoc, 0L);
				    else
					_oss_dec_error(_g, _non_std_eoc, 0L);
				_indef_tags--;
			    }
			    OSS_CNTX_POP(_oss_c)
			}
			OSS_CNTX_PUSH(_oss_c, 78)
			if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else {
			    if (!_oss_c->_tag_decoded || _data_tag == 0x11) {
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x11 : 0);
			    } else
				_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x110000);
			    _oss_c->_tag_decoded = FALSE;
			}
			_data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			{
			    _setof15 * _temp1 = (_setof15 *)&_temp->value.contextList;
			    long _total_len = _data_length;
			    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
			    unsigned long count = 0;
#endif
			    OSS_CNTX_INIT

			    OSS_CNTX_PUSH(_oss_c, 79)
			    for (;;) {
				if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
				    if (_bufpos > _end_pos)
					_oss_dec_error(_g, _inconsis_len, 0L);
#endif
				    break;
				}
				if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
				    _buflen--;
				    _oss_c->_bitpos = _bufpos[0] & 0x20;
				    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
				    _bufpos++;
				} else
				    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
					if (_oss_dec_length(_g, &_bufpos, &_buflen))
					    _oss_dec_error(_g, _non_std_eoc, 0L);
					_oss_c->_tag_decoded = FALSE;
					break;
				    }
				_oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
				count++;
#endif
				if (_data_tag != 0x10)
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
				_temp1->next = (_setof15 *)_oss_dec_const_alloc(_g, sizeof(_setof15));
				_temp1 = _temp1->next;
				OSS_CNTX_SETOCC(count)
				_oss_c->_tag_decoded = FALSE;
				if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				    _buflen--;
				    _bufpos++;
				} else
				    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				_d_Context(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp1->value);
			    }
			    _temp1->next = nullptr;
			    OSS_CNTX_POP(_oss_c)
			}
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			OSS_CNTX_POP(_oss_c)
			if (_bufpos != _end_pos) {
			    if (_total_len < 0) {
				if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
				    _buflen--;
				    _bufpos++;
				} else
				    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

				if (_data_tag)
				    _oss_dec_error(_g, _expec_eoc, 0L);
				if (_oss_dec_length(_g, &_bufpos, &_buflen))
				    _oss_dec_error(_g, _non_std_eoc, 0L);
				_oss_c->_tag_decoded = FALSE;
			    } else
				_oss_dec_error(_g, _inconsis_len, 0L);
			}
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		}
		_temp->next = nullptr;
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_15AttributeTypeAndDistinguis(OssGlobal * _g, _AttributeTypeAndDistinguishedValue * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_2bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 83)
	_out_data->type.length = _oss_pdec_eobjid_ia(_g, &_out_data->type.value, -1);
	OSS_CNTX_SET(82)
#ifdef OSS_OPENTYPE_HAS_USERFIELD
	_out_data->value.userField = nullptr;
#endif
	_out_data->value.encoded.length = _oss_pdec_unconstr_uoct_ia(_g, &_out_data->value.encoded.value);
	if (_out_data->value.encoded.length == 0 && ((STRICT_ENCODING_DECODING_RULES | AUTOMATIC_ENCDEC) & _g->decodingFlags))
	    _oss_dec_error(_g, _zero_length_OpenType, 0L);
	_out_data->value.pduNum = 0;
	*(void **)&_out_data->value.decoded = nullptr;
	OSS_CNTX_SET(81)
	if (_out_data->bit_mask & 0x80000000) {
	    _out_data->primaryDistinguished = _oss_get_1bit_unaligned(_g) ? TRUE : FALSE;
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->primaryDistinguished, &AttributeTypeAndDistinguishedValue::default_primaryDistinguished, sizeof(AttributeTypeAndDistinguishedValue::default_primaryDistinguished));
#else
	    _out_data->primaryDistinguished = 0;
#endif
	}
	OSS_CNTX_SET(77)
	_out_data->valuesWithContext = nullptr;
	if (_out_data->bit_mask & 0x40000000) {
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_setof16 * _temp = (_setof16 *)&_out_data->valuesWithContext;
		unsigned long count = 0;
		ossBoolean _last = FALSE;
		unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		unsigned long _prev_fragm0 = 0;
#endif

		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 29)
		while (!_last) {
		    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
			if ((!_last) && _index && (_prev_fragm0 < 65536))
			    _oss_dec_error(_g, _invalid_fragmentation, 0L);
			_prev_fragm0 = count - _index;
		    }
#endif
		    for (; (unsigned long)_index < count; _index++) {
			_temp->next = (_setof16 *)_oss_dec_const_alloc(_g, sizeof(_setof16));
			_temp = _temp->next;
			OSS_CNTX_SETOCC(_index + 1)
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			{
			    OSS_CNTX_INIT

			    _temp->value.bit_mask = (OSS_UINT32)_oss_get_1bit_unaligned(_g) << 24;
			    OSS_CNTX_PUSH(_oss_c, 80)
			    if (_temp->value.bit_mask & 0x80000000) {
#ifdef OSS_OPENTYPE_HAS_USERFIELD
				_temp->value.distingAttrValue.userField = nullptr;
#endif
				_temp->value.distingAttrValue.encoded.length = _oss_pdec_unconstr_uoct_ia(_g, &_temp->value.distingAttrValue.encoded.value);
				if (_temp->value.distingAttrValue.encoded.length == 0 && ((STRICT_ENCODING_DECODING_RULES | AUTOMATIC_ENCDEC) & _g->decodingFlags))
				    _oss_dec_error(_g, _zero_length_OpenType, 0L);
				_temp->value.distingAttrValue.pduNum = 0;
				*(void **)&_temp->value.distingAttrValue.decoded = nullptr;
			    } else {
				memset(&(_temp->value.distingAttrValue), 0, sizeof(OSSC::COssConstrainedOpenType ));
			    }
			    OSS_CNTX_SET(78)
#ifndef OSS_NO_NESTING_CONTROL
			    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				    _oss_c->reserved.fields.ext->seqSetNestingLimit)
				_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			    {
				_setof15 * _temp1 = (_setof15 *)&_temp->value.contextList;
				unsigned long count = 0;
				ossBoolean _last = FALSE;
				unsigned long _index1 = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
				unsigned long _prev_fragm1 = 0;
#endif

				OSS_CNTX_INIT

				OSS_CNTX_PUSH(_oss_c, 79)
				while (!_last) {
				    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
				    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
					if ((!_last) && _index1 && (_prev_fragm1 < 65536))
					    _oss_dec_error(_g, _invalid_fragmentation, 0L);
					_prev_fragm1 = count - _index1;
				    }
#endif
				    for (; (unsigned long)_index1 < count; _index1++) {
					_temp1->next = (_setof15 *)_oss_dec_const_alloc(_g, sizeof(_setof15));
					_temp1 = _temp1->next;
					OSS_CNTX_SETOCC(_index1 + 1)
					_dp_Context(_g, &_temp1->value);
				    }
				    OSS_CNTX_POP(_oss_c)
				}
				_temp1->next = nullptr;
			    }
#ifndef OSS_NO_NESTING_CONTROL
			    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
				_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			    OSS_CNTX_POP(_oss_c)
			}
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		_temp->next = nullptr;
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	} else {
	    _out_data->valuesWithContext = nullptr;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_RelativeDistinguishedName(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _RelativeDistinguishedName ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_RelativeDistinguishedName * _temp = (_RelativeDistinguishedName *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 84)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    if (_data_tag != 0x10)
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
	    _temp->next = (_RelativeDistinguishedName *)_oss_dec_const_alloc(_g, sizeof(_RelativeDistinguishedName));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _d_15AttributeTypeAndDistinguis(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
	}
	_temp->next = nullptr;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_RelativeDistinguishedName(OssGlobal * _g, _RelativeDistinguishedName ** _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_RelativeDistinguishedName * _temp = (_RelativeDistinguishedName *)_out_data;
	unsigned long count = 0;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 84)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_RelativeDistinguishedName *)_oss_dec_const_alloc(_g, sizeof(_RelativeDistinguishedName));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
		_dp_15AttributeTypeAndDistinguis(_g, &_temp->value);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = nullptr;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d_Refinement(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Refinement * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	OSS_CNTX_INIT

	if (!_oss_c->_tag_decoded) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	switch (_data_tag) {
	default:
	    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
	    switch (_data_tag & 0x7fff) {
	    case 0x0: {
		OSS_CNTX_PUSH(_oss_c, 85)
		_out_data->choice = 1;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
		_data_tag = 0x6;
		_out_data->u.item.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.item.value, -1);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
	    }   break;
	    case 0x1: {
		OSS_CNTX_PUSH(_oss_c, 60)
		_out_data->choice = 2;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
		_data_tag = 0x11;
		_d__setof17(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.Refinement_and);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
	    }   break;
	    case 0x2: {
		OSS_CNTX_PUSH(_oss_c, 61)
		_out_data->choice = 3;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
		_data_tag = 0x11;
		_d__setof18(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.Refinement_or);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
	    }   break;
	    case 0x3: {
		OSS_CNTX_PUSH(_oss_c, 86)
		_out_data->choice = 4;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		if (_data_length < 0) ++_indef_tags;
		_out_data->u.Refinement_not = (_Refinement *)_oss_dec_const_alloc(_g, sizeof(_Refinement));
		_d_Refinement(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.Refinement_not);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    break;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp_Refinement(OssGlobal * _g, _Refinement * _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_2int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 85)
	    _out_data->u.item.length = _oss_pdec_eobjid_ia(_g, &_out_data->u.item.value, -1);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 60)
	    _dp__setof17(_g, &_out_data->u.Refinement_and);
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 61)
	    _dp__setof18(_g, &_out_data->u.Refinement_or);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 86)
	    _out_data->u.Refinement_not = (_Refinement *)_oss_dec_const_alloc(_g, sizeof(_Refinement));
	    _dp_Refinement(_g, _out_data->u.Refinement_not);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d__setof18(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _setof17 ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_setof17 * _temp = (_setof17 *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 87)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    _temp->next = (_setof17 *)_oss_dec_const_alloc(_g, sizeof(_setof17));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
	    _d_Refinement(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
	}
	_temp->next = nullptr;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp__setof18(OssGlobal * _g, _setof17 ** _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_setof17 * _temp = (_setof17 *)_out_data;
	unsigned long count = 0;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 87)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_setof17 *)_oss_dec_const_alloc(_g, sizeof(_setof17));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
		_dp_Refinement(_g, &_temp->value);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = nullptr;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void _d__setof17(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _setof17 ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_setof17 * _temp = (_setof17 *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 87)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    _temp->next = (_setof17 *)_oss_dec_const_alloc(_g, sizeof(_setof17));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
	    _d_Refinement(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
	}
	_temp->next = nullptr;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _dp__setof17(OssGlobal * _g, _setof17 ** _out_data)
{
#if OSSDEBUG > 1 || !defined(OSS_NO_NESTING_CONTROL)
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_setof17 * _temp = (_setof17 *)_out_data;
	unsigned long count = 0;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 87)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_setof17 *)_oss_dec_const_alloc(_g, sizeof(_setof17));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
		_dp_Refinement(_g, &_temp->value);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = nullptr;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
}

static void * _dOssEncOID(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssEncOID *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(1,88)
    _out_data = (OSSC::COssEncOID *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssEncOID));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
    _data_tag = 0x6;
    _out_data->length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, -1);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpOssEncOID(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssEncOID	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(1,88)
    _out_data = (OSSC::COssEncOID *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssEncOID));
    _out_data->length = _oss_pdec_eobjid_ia(_g, &_out_data->value, -1);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dACSE_apdu(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ACSE_apdu *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(2,89)
    _out_data = (_ACSE_apdu *)_oss_dec_const_alloc(_g, sizeof(_ACSE_apdu));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	switch (_data_tag) {
	case 0x4000: {
	    OSS_CNTX_PUSH(_oss_c, 90)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.aarq = (_AARQ_apdu *)_oss_dec_const_alloc(_g, sizeof(_AARQ_apdu));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		int _indef_tags = 0;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		OSS_CNTX_INIT

		_out_data->u.aarq->bit_mask = 0;
		if (_bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8000 || _bufpos >= _end_pos)
		 {
		    _out_data->u.aarq->bit_mask &= ~0x80000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
		    memcpy(&_out_data->u.aarq->protocol_version, &_v628, sizeof(_v628));
#else
		    _out_data->u.aarq->protocol_version.length = 0;
		    _out_data->u.aarq->protocol_version.value = nullptr;
#endif
		}
else {
		    _out_data->u.aarq->bit_mask |= 0x80000000;
		    OSS_CNTX_PUSH(_oss_c, 106)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 128 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8000;
		    _out_data->u.aarq->protocol_version.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.aarq->protocol_version.value, 0, 128);

		    OSS_CNTX_POP(_oss_c)
		}
		OSS_CNTX_PUSH(_oss_c, 105)
		if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else {
		    if (!_oss_c->_tag_decoded || _data_tag == 0x8001) {
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x81 : 0);
		    } else
			_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80010000);
		    _oss_c->_tag_decoded = FALSE;
		}
		_data_tag = 0x8001;
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
		_data_tag = 0x6;
		_out_data->u.aarq->application_context_name.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.aarq->application_context_name.value, -1);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
		OSS_CNTX_POP(_oss_c)
		if (_bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8002 || _bufpos >= _end_pos)
		 {
		    _out_data->u.aarq->bit_mask &= ~0x40000000;
		    memset(&_out_data->u.aarq->called_AP_title, 0, sizeof(_out_data->u.aarq->called_AP_title));
		}
else {
		    _out_data->u.aarq->bit_mask |= 0x40000000;
		    OSS_CNTX_PUSH(_oss_c, 104)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8002) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x82 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80020000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8002;
		    if (_data_length < 0) ++_indef_tags;
		    _d_AP_title(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.aarq->called_AP_title);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8003 || _bufpos >= _end_pos)
		 {
		    _out_data->u.aarq->bit_mask &= ~0x20000000;
		    memset(&_out_data->u.aarq->called_AE_qualifier, 0, sizeof(_out_data->u.aarq->called_AE_qualifier));
		}
else {
		    _out_data->u.aarq->bit_mask |= 0x20000000;
		    OSS_CNTX_PUSH(_oss_c, 103)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 163 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8003) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x83 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80030000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8003;
		    if (_data_length < 0) ++_indef_tags;
		    _d_AE_qualifier(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.aarq->called_AE_qualifier);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8004 || _bufpos >= _end_pos)
		 {
		    _out_data->u.aarq->bit_mask &= ~0x10000000;
		}
else {
		    _out_data->u.aarq->bit_mask |= 0x10000000;
		    OSS_CNTX_PUSH(_oss_c, 102)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 164 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8004) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x84 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80040000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8004;
		    if (_data_length < 0) ++_indef_tags;
		    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
		    _data_tag = 0x2;
		    _out_data->u.aarq->called_AP_invocation_identifier = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8005 || _bufpos >= _end_pos)
		 {
		    _out_data->u.aarq->bit_mask &= ~0x8000000;
		}
else {
		    _out_data->u.aarq->bit_mask |= 0x8000000;
		    OSS_CNTX_PUSH(_oss_c, 101)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 165 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8005) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x85 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80050000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8005;
		    if (_data_length < 0) ++_indef_tags;
		    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
		    _data_tag = 0x2;
		    _out_data->u.aarq->called_AE_invocation_identifier = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8006 || _bufpos >= _end_pos)
		 {
		    _out_data->u.aarq->bit_mask &= ~0x4000000;
		    memset(&_out_data->u.aarq->calling_AP_title, 0, sizeof(_out_data->u.aarq->calling_AP_title));
		}
else {
		    _out_data->u.aarq->bit_mask |= 0x4000000;
		    OSS_CNTX_PUSH(_oss_c, 100)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 166 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8006) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x86 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80060000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8006;
		    if (_data_length < 0) ++_indef_tags;
		    _d_AP_title(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.aarq->calling_AP_title);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8007 || _bufpos >= _end_pos)
		 {
		    _out_data->u.aarq->bit_mask &= ~0x2000000;
		    memset(&_out_data->u.aarq->calling_AE_qualifier, 0, sizeof(_out_data->u.aarq->calling_AE_qualifier));
		}
else {
		    _out_data->u.aarq->bit_mask |= 0x2000000;
		    OSS_CNTX_PUSH(_oss_c, 99)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 167 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8007) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x87 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80070000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8007;
		    if (_data_length < 0) ++_indef_tags;
		    _d_AE_qualifier(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.aarq->calling_AE_qualifier);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8008 || _bufpos >= _end_pos)
		 {
		    _out_data->u.aarq->bit_mask &= ~0x1000000;
		}
else {
		    _out_data->u.aarq->bit_mask |= 0x1000000;
		    OSS_CNTX_PUSH(_oss_c, 98)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 168 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8008) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x88 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80080000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8008;
		    if (_data_length < 0) ++_indef_tags;
		    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
		    _data_tag = 0x2;
		    _out_data->u.aarq->calling_AP_invocation_identifier = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8009 || _bufpos >= _end_pos)
		 {
		    _out_data->u.aarq->bit_mask &= ~0x800000;
		}
else {
		    _out_data->u.aarq->bit_mask |= 0x800000;
		    OSS_CNTX_PUSH(_oss_c, 97)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 169 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8009) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x89 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80090000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8009;
		    if (_data_length < 0) ++_indef_tags;
		    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
		    _data_tag = 0x2;
		    _out_data->u.aarq->calling_AE_invocation_identifier = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x800A || _bufpos >= _end_pos)
		 {
		    _out_data->u.aarq->bit_mask &= ~0x400000;
		    memset(&_out_data->u.aarq->sender_acse_requirements, 0, sizeof(_out_data->u.aarq->sender_acse_requirements));
		}
else {
		    _out_data->u.aarq->bit_mask |= 0x400000;
		    OSS_CNTX_PUSH(_oss_c, 96)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 138 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x800A) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x8A : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x800A0000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x800A;
		    _out_data->u.aarq->sender_acse_requirements.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.aarq->sender_acse_requirements.value, 0, 128);

		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x800B || _bufpos >= _end_pos)
		 {
		    _out_data->u.aarq->bit_mask &= ~0x200000;
		    memset(&_out_data->u.aarq->mechanism_name, 0, sizeof(_out_data->u.aarq->mechanism_name));
		}
else {
		    _out_data->u.aarq->bit_mask |= 0x200000;
		    OSS_CNTX_PUSH(_oss_c, 95)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 139 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x800B) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x8B : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x800B0000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x800B;
		    _out_data->u.aarq->mechanism_name.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.aarq->mechanism_name.value, -1);
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x800C || _bufpos >= _end_pos)
		 {
		    _out_data->u.aarq->bit_mask &= ~0x100000;
		    memset(&_out_data->u.aarq->calling_authentication_value, 0, sizeof(_out_data->u.aarq->calling_authentication_value));
		}
else {
		    _out_data->u.aarq->bit_mask |= 0x100000;
		    OSS_CNTX_PUSH(_oss_c, 94)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 172 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x800C) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x8C : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x800C0000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x800C;
		    if (_data_length < 0) ++_indef_tags;
		    _d_Authentication_value(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.aarq->calling_authentication_value);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x800D || _bufpos >= _end_pos)
		 {
		    _out_data->u.aarq->bit_mask &= ~0x80000;
		    memset(&_out_data->u.aarq->application_context_name_list, 0, sizeof(_out_data->u.aarq->application_context_name_list));
		}
else {
		    _out_data->u.aarq->bit_mask |= 0x80000;
		    OSS_CNTX_PUSH(_oss_c, 93)
		    _out_data->u.aarq->application_context_name_list = nullptr;
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 173 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x800D) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x8D : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x800D0000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x800D;
		    _d_13Application_context_name_l(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.aarq->application_context_name_list);
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x801D || _bufpos >= _end_pos)
		 {
		    _out_data->u.aarq->bit_mask &= ~0x40000;
		    memset(&_out_data->u.aarq->implementation_information, 0, sizeof(_out_data->u.aarq->implementation_information));
		}
else {
		    _out_data->u.aarq->bit_mask |= 0x40000;
		    OSS_CNTX_PUSH(_oss_c, 92)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 157 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x801D) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x9D : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x801D0000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x801D;
		    _out_data->u.aarq->implementation_information.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.aarq->implementation_information.value, 0);
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x801E || _bufpos >= _end_pos)
		 {
		    _out_data->u.aarq->bit_mask &= ~0x20000;
		    memset(&_out_data->u.aarq->user_information, 0, sizeof(_out_data->u.aarq->user_information));
		}
else {
		    _out_data->u.aarq->bit_mask |= 0x20000;
		    OSS_CNTX_PUSH(_oss_c, 91)
		    _out_data->u.aarq->user_information = nullptr;
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 190 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x801E) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x9E : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x801E0000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x801E;
		    _d_Association_information(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.aarq->user_information);
		    OSS_CNTX_POP(_oss_c)
		}
		while (_bufpos < _end_pos || _total_len < 0) {
		    if (!_oss_c->_tag_decoded) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if (!_data_tag)
			break;
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
		    _oss_c->_tag_decoded = FALSE;
		}
		if (_total_len < 0 && !_data_tag) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		}
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	}   break;
	case 0x4001: {
	    OSS_CNTX_PUSH(_oss_c, 107)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.aare = (_AARE_apdu *)_oss_dec_const_alloc(_g, sizeof(_AARE_apdu));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		int _indef_tags = 0;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		OSS_CNTX_INIT

		_out_data->u.aare->bit_mask = 0;
		if (_bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8000 || _bufpos >= _end_pos)
		 {
		    _out_data->u.aare->bit_mask &= ~0x80000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
		    memcpy(&_out_data->u.aare->protocol_version, &_v630, sizeof(_v630));
#else
		    _out_data->u.aare->protocol_version.length = 0;
		    _out_data->u.aare->protocol_version.value = nullptr;
#endif
		}
else {
		    _out_data->u.aare->bit_mask |= 0x80000000;
		    OSS_CNTX_PUSH(_oss_c, 106)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 128 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8000;
		    _out_data->u.aare->protocol_version.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.aare->protocol_version.value, 0, 128);

		    OSS_CNTX_POP(_oss_c)
		}
		OSS_CNTX_PUSH(_oss_c, 105)
		if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else {
		    if (!_oss_c->_tag_decoded || _data_tag == 0x8001) {
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x81 : 0);
		    } else
			_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80010000);
		    _oss_c->_tag_decoded = FALSE;
		}
		_data_tag = 0x8001;
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
		_data_tag = 0x6;
		_out_data->u.aare->application_context_name.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.aare->application_context_name.value, -1);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
		OSS_CNTX_SET(117)
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x82);
		_data_tag = 0x8002;
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
		_data_tag = 0x2;
		_out_data->u.aare->result = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
		OSS_CNTX_SET(114)
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 163 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x83);
		_data_tag = 0x8003;
		if (_data_length < 0) ++_indef_tags;
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    int _indef_tags = 0;
		    OSS_CNTX_INIT

		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		    switch (_data_tag) {
		    default:
			if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
			switch (_data_tag & 0x7fff) {
			case 0x1: {
			    OSS_CNTX_PUSH(_oss_c, 115)
			    _out_data->u.aare->result_source_diagnostic.choice = 1;

			    _oss_c->_tag_decoded = FALSE;
			    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				_buflen--;
				_bufpos++;
			    } else
				_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			    if (_data_length < 0) ++_indef_tags;
			    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
			    _data_tag = 0x2;
			    _out_data->u.aare->result_source_diagnostic.u.acse_service_user = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
			    while (_indef_tags > 0) {
				if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    if (!_buflen || _bufpos[0])
					_oss_dec_error(_g, _expec_eoc, 0L);
				    else
					_oss_dec_error(_g, _non_std_eoc, 0L);
				_indef_tags--;
			    }
			}   break;
			case 0x2: {
			    OSS_CNTX_PUSH(_oss_c, 116)
			    _out_data->u.aare->result_source_diagnostic.choice = 2;

			    _oss_c->_tag_decoded = FALSE;
			    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				_buflen--;
				_bufpos++;
			    } else
				_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			    if (_data_length < 0) ++_indef_tags;
			    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
			    _data_tag = 0x2;
			    _out_data->u.aare->result_source_diagnostic.u.acse_service_provider = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
			    while (_indef_tags > 0) {
				if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    if (!_buflen || _bufpos[0])
					_oss_dec_error(_g, _expec_eoc, 0L);
				    else
					_oss_dec_error(_g, _non_std_eoc, 0L);
				_indef_tags--;
			    }
			}   break;
			default:
			    _oss_dec_error(_g, _unknown_field, _data_tag);
			}
			break;
		    }
		    OSS_CNTX_POP(_oss_c)
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
		OSS_CNTX_POP(_oss_c)
		if (_bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8004 || _bufpos >= _end_pos)
		 {
		    _out_data->u.aare->bit_mask &= ~0x40000000;
		    memset(&_out_data->u.aare->responding_AP_title, 0, sizeof(_out_data->u.aare->responding_AP_title));
		}
else {
		    _out_data->u.aare->bit_mask |= 0x40000000;
		    OSS_CNTX_PUSH(_oss_c, 113)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 164 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8004) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x84 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80040000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8004;
		    if (_data_length < 0) ++_indef_tags;
		    _d_AP_title(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.aare->responding_AP_title);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8005 || _bufpos >= _end_pos)
		 {
		    _out_data->u.aare->bit_mask &= ~0x20000000;
		    memset(&_out_data->u.aare->responding_AE_qualifier, 0, sizeof(_out_data->u.aare->responding_AE_qualifier));
		}
else {
		    _out_data->u.aare->bit_mask |= 0x20000000;
		    OSS_CNTX_PUSH(_oss_c, 112)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 165 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8005) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x85 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80050000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8005;
		    if (_data_length < 0) ++_indef_tags;
		    _d_AE_qualifier(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.aare->responding_AE_qualifier);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8006 || _bufpos >= _end_pos)
		 {
		    _out_data->u.aare->bit_mask &= ~0x10000000;
		}
else {
		    _out_data->u.aare->bit_mask |= 0x10000000;
		    OSS_CNTX_PUSH(_oss_c, 111)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 166 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8006) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x86 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80060000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8006;
		    if (_data_length < 0) ++_indef_tags;
		    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
		    _data_tag = 0x2;
		    _out_data->u.aare->responding_AP_invocation_identifier = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8007 || _bufpos >= _end_pos)
		 {
		    _out_data->u.aare->bit_mask &= ~0x8000000;
		}
else {
		    _out_data->u.aare->bit_mask |= 0x8000000;
		    OSS_CNTX_PUSH(_oss_c, 110)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 167 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8007) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x87 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80070000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8007;
		    if (_data_length < 0) ++_indef_tags;
		    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
		    _data_tag = 0x2;
		    _out_data->u.aare->responding_AE_invocation_identifier = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8008 || _bufpos >= _end_pos)
		 {
		    _out_data->u.aare->bit_mask &= ~0x4000000;
		    memset(&_out_data->u.aare->responder_acse_requirements, 0, sizeof(_out_data->u.aare->responder_acse_requirements));
		}
else {
		    _out_data->u.aare->bit_mask |= 0x4000000;
		    OSS_CNTX_PUSH(_oss_c, 109)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 136 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8008) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x88 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80080000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8008;
		    _out_data->u.aare->responder_acse_requirements.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.aare->responder_acse_requirements.value, 0, 128);

		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8009 || _bufpos >= _end_pos)
		 {
		    _out_data->u.aare->bit_mask &= ~0x2000000;
		    memset(&_out_data->u.aare->mechanism_name, 0, sizeof(_out_data->u.aare->mechanism_name));
		}
else {
		    _out_data->u.aare->bit_mask |= 0x2000000;
		    OSS_CNTX_PUSH(_oss_c, 95)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 137 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8009) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x89 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80090000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8009;
		    _out_data->u.aare->mechanism_name.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.aare->mechanism_name.value, -1);
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x800A || _bufpos >= _end_pos)
		 {
		    _out_data->u.aare->bit_mask &= ~0x1000000;
		    memset(&_out_data->u.aare->responding_authentication_value, 0, sizeof(_out_data->u.aare->responding_authentication_value));
		}
else {
		    _out_data->u.aare->bit_mask |= 0x1000000;
		    OSS_CNTX_PUSH(_oss_c, 108)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 170 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x800A) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x8A : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x800A0000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x800A;
		    if (_data_length < 0) ++_indef_tags;
		    _d_Authentication_value(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.aare->responding_authentication_value);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x800B || _bufpos >= _end_pos)
		 {
		    _out_data->u.aare->bit_mask &= ~0x800000;
		    memset(&_out_data->u.aare->application_context_name_list, 0, sizeof(_out_data->u.aare->application_context_name_list));
		}
else {
		    _out_data->u.aare->bit_mask |= 0x800000;
		    OSS_CNTX_PUSH(_oss_c, 93)
		    _out_data->u.aare->application_context_name_list = nullptr;
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 171 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x800B) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x8B : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x800B0000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x800B;
		    _d_13Application_context_name_l(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.aare->application_context_name_list);
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x801D || _bufpos >= _end_pos)
		 {
		    _out_data->u.aare->bit_mask &= ~0x400000;
		    memset(&_out_data->u.aare->implementation_information, 0, sizeof(_out_data->u.aare->implementation_information));
		}
else {
		    _out_data->u.aare->bit_mask |= 0x400000;
		    OSS_CNTX_PUSH(_oss_c, 92)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 157 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x801D) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x9D : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x801D0000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x801D;
		    _out_data->u.aare->implementation_information.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.aare->implementation_information.value, 0);
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x801E || _bufpos >= _end_pos)
		 {
		    _out_data->u.aare->bit_mask &= ~0x200000;
		    memset(&_out_data->u.aare->user_information, 0, sizeof(_out_data->u.aare->user_information));
		}
else {
		    _out_data->u.aare->bit_mask |= 0x200000;
		    OSS_CNTX_PUSH(_oss_c, 91)
		    _out_data->u.aare->user_information = nullptr;
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 190 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x801E) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x9E : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x801E0000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x801E;
		    _d_Association_information(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.aare->user_information);
		    OSS_CNTX_POP(_oss_c)
		}
		while (_bufpos < _end_pos || _total_len < 0) {
		    if (!_oss_c->_tag_decoded) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if (!_data_tag)
			break;
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
		    _oss_c->_tag_decoded = FALSE;
		}
		if (_total_len < 0 && !_data_tag) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		}
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	}   break;
	case 0x4002: {
	    OSS_CNTX_PUSH(_oss_c, 118)
	    _out_data->choice = 3;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.rlrq = (_RLRQ_apdu *)_oss_dec_const_alloc(_g, sizeof(_RLRQ_apdu));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		OSS_CNTX_INIT

		_out_data->u.rlrq->bit_mask = 0;
		if (_bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8000 || _bufpos >= _end_pos)
		 {
		    _out_data->u.rlrq->bit_mask &= ~0x80000000;
		}
else {
		    _out_data->u.rlrq->bit_mask |= 0x80000000;
		    OSS_CNTX_PUSH(_oss_c, 119)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 128 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8000;
		    _out_data->u.rlrq->reason = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x801E || _bufpos >= _end_pos)
		 {
		    _out_data->u.rlrq->bit_mask &= ~0x40000000;
		    memset(&_out_data->u.rlrq->user_information, 0, sizeof(_out_data->u.rlrq->user_information));
		}
else {
		    _out_data->u.rlrq->bit_mask |= 0x40000000;
		    OSS_CNTX_PUSH(_oss_c, 91)
		    _out_data->u.rlrq->user_information = nullptr;
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 190 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x801E) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x9E : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x801E0000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x801E;
		    _d_Association_information(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.rlrq->user_information);
		    OSS_CNTX_POP(_oss_c)
		}
		while (_bufpos < _end_pos || _total_len < 0) {
		    if (!_oss_c->_tag_decoded) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if (!_data_tag)
			break;
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
		    _oss_c->_tag_decoded = FALSE;
		}
		if (_total_len < 0 && !_data_tag) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		}
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	}   break;
	case 0x4003: {
	    OSS_CNTX_PUSH(_oss_c, 120)
	    _out_data->choice = 4;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.rlre = (_RLRQ_apdu *)_oss_dec_const_alloc(_g, sizeof(_RLRQ_apdu));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		OSS_CNTX_INIT

		_out_data->u.rlre->bit_mask = 0;
		if (_bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8000 || _bufpos >= _end_pos)
		 {
		    _out_data->u.rlre->bit_mask &= ~0x80000000;
		}
else {
		    _out_data->u.rlre->bit_mask |= 0x80000000;
		    OSS_CNTX_PUSH(_oss_c, 121)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 128 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8000;
		    _out_data->u.rlre->reason = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x801E || _bufpos >= _end_pos)
		 {
		    _out_data->u.rlre->bit_mask &= ~0x40000000;
		    memset(&_out_data->u.rlre->user_information, 0, sizeof(_out_data->u.rlre->user_information));
		}
else {
		    _out_data->u.rlre->bit_mask |= 0x40000000;
		    OSS_CNTX_PUSH(_oss_c, 91)
		    _out_data->u.rlre->user_information = nullptr;
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 190 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x801E) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x9E : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x801E0000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x801E;
		    _d_Association_information(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.rlre->user_information);
		    OSS_CNTX_POP(_oss_c)
		}
		while (_bufpos < _end_pos || _total_len < 0) {
		    if (!_oss_c->_tag_decoded) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if (!_data_tag)
			break;
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
		    _oss_c->_tag_decoded = FALSE;
		}
		if (_total_len < 0 && !_data_tag) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		}
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	}   break;
	case 0x4004: {
	    OSS_CNTX_PUSH(_oss_c, 122)
	    _out_data->choice = 5;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.abrt = (_ABRT_apdu *)_oss_dec_const_alloc(_g, sizeof(_ABRT_apdu));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		OSS_CNTX_INIT

		_out_data->u.abrt->bit_mask = 0;
		OSS_CNTX_PUSH(_oss_c, 124)
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 128 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
		_data_tag = 0x8000;
		_out_data->u.abrt->abort_source = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		OSS_CNTX_POP(_oss_c)
		if (_bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8001 || _bufpos >= _end_pos)
		 {
		    _out_data->u.abrt->bit_mask &= ~0x80000000;
		}
else {
		    _out_data->u.abrt->bit_mask |= 0x80000000;
		    OSS_CNTX_PUSH(_oss_c, 123)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 129 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8001) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x81 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80010000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8001;
		    _out_data->u.abrt->abort_diagnostic = (enum ABRT_diagnostic )_oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x801E || _bufpos >= _end_pos)
		 {
		    _out_data->u.abrt->bit_mask &= ~0x40000000;
		    memset(&_out_data->u.abrt->user_information, 0, sizeof(_out_data->u.abrt->user_information));
		}
else {
		    _out_data->u.abrt->bit_mask |= 0x40000000;
		    OSS_CNTX_PUSH(_oss_c, 91)
		    _out_data->u.abrt->user_information = nullptr;
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 190 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x801E) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x9E : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x801E0000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x801E;
		    _d_Association_information(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.abrt->user_information);
		    OSS_CNTX_POP(_oss_c)
		}
		while (_bufpos < _end_pos || _total_len < 0) {
		    if (!_oss_c->_tag_decoded) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if (!_data_tag)
			break;
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
		    _oss_c->_tag_decoded = FALSE;
		}
		if (_total_len < 0 && !_data_tag) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		}
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	}   break;
	default:
	    _oss_c->_tag_decoded = FALSE;
	    _out_data->choice = 0;	/* Unknown choice selector. */
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    OSS_CNTX_PUSH(_oss_c, 0)
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpACSE_apdu(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ACSE_apdu	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(2,89)
    _out_data = (_ACSE_apdu *)_oss_dec_const_alloc(_g, sizeof(_ACSE_apdu));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_get_1bit_unaligned(_g)) {

	    _out_data->choice = (int)_oss_pdec_nonneg_3int(_g) + 1;
	    if (_out_data->choice > 5)
		_oss_enc_error(_g, _bad_choice, _out_data->choice);
	} else {
	    unsigned long _encode_value;
	    _encode_value = _oss_pdec_small_int_l(_g);
	    if (_encode_value > UINT_MAX - 6)
		_oss_enc_error(_g, _bad_choice, _encode_value);
	    _out_data->choice = _encode_value + 6;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 90)
	    _out_data->u.aarq = (_AARQ_apdu *)_oss_dec_const_alloc(_g, sizeof(_AARQ_apdu));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		unsigned char *_pext;
		unsigned char _extPres = 0x00;
		unsigned long _ea_count = 0;
		OSS_CNTX_INIT

		_extPres = _oss_get_1bit_unaligned(_g);
		_out_data->u.aarq->bit_mask = (OSS_UINT32)_oss_pdec_nonneg_int_l(_g, 15) << 17;
		OSS_CNTX_PUSH(_oss_c, 106)
		if (_out_data->u.aarq->bit_mask & 0x80000000) {
		    _out_data->u.aarq->protocol_version.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->u.aarq->protocol_version.value);

		} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
		    memcpy(&_out_data->u.aarq->protocol_version, &_v628, sizeof(_v628));
#else
		    _out_data->u.aarq->protocol_version.length = 0;
		    _out_data->u.aarq->protocol_version.value = nullptr;
#endif
		}
		OSS_CNTX_SET(105)
		_out_data->u.aarq->application_context_name.length = _oss_pdec_eobjid_ia(_g, &_out_data->u.aarq->application_context_name.value, -1);
		OSS_CNTX_SET(104)
		if (_out_data->u.aarq->bit_mask & 0x40000000) {
		    _dp_AP_title(_g, &_out_data->u.aarq->called_AP_title);
		} else {
		    memset(&(_out_data->u.aarq->called_AP_title), 0, sizeof(_AP_title ));
		}
		OSS_CNTX_SET(103)
		if (_out_data->u.aarq->bit_mask & 0x20000000) {
		    _dp_AE_qualifier(_g, &_out_data->u.aarq->called_AE_qualifier);
		} else {
		    memset(&(_out_data->u.aarq->called_AE_qualifier), 0, sizeof(_AE_qualifier ));
		}
		OSS_CNTX_SET(102)
		if (_out_data->u.aarq->bit_mask & 0x10000000) {
		    _out_data->u.aarq->called_AP_invocation_identifier = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		}
		OSS_CNTX_SET(101)
		if (_out_data->u.aarq->bit_mask & 0x8000000) {
		    _out_data->u.aarq->called_AE_invocation_identifier = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		}
		OSS_CNTX_SET(100)
		if (_out_data->u.aarq->bit_mask & 0x4000000) {
		    _dp_AP_title(_g, &_out_data->u.aarq->calling_AP_title);
		} else {
		    memset(&(_out_data->u.aarq->calling_AP_title), 0, sizeof(_AP_title ));
		}
		OSS_CNTX_SET(99)
		if (_out_data->u.aarq->bit_mask & 0x2000000) {
		    _dp_AE_qualifier(_g, &_out_data->u.aarq->calling_AE_qualifier);
		} else {
		    memset(&(_out_data->u.aarq->calling_AE_qualifier), 0, sizeof(_AE_qualifier ));
		}
		OSS_CNTX_SET(98)
		if (_out_data->u.aarq->bit_mask & 0x1000000) {
		    _out_data->u.aarq->calling_AP_invocation_identifier = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		}
		OSS_CNTX_SET(97)
		if (_out_data->u.aarq->bit_mask & 0x800000) {
		    _out_data->u.aarq->calling_AE_invocation_identifier = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		}
		OSS_CNTX_SET(96)
		if (_out_data->u.aarq->bit_mask & 0x400000) {
		    _out_data->u.aarq->sender_acse_requirements.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->u.aarq->sender_acse_requirements.value);

		} else {
		    _out_data->u.aarq->sender_acse_requirements.length = 0;
		    _out_data->u.aarq->sender_acse_requirements.value = nullptr;
		}
		OSS_CNTX_SET(95)
		if (_out_data->u.aarq->bit_mask & 0x200000) {
		    _out_data->u.aarq->mechanism_name.length = _oss_pdec_eobjid_ia(_g, &_out_data->u.aarq->mechanism_name.value, -1);
		} else {
		    _out_data->u.aarq->mechanism_name.length = 0;
		    _out_data->u.aarq->mechanism_name.value = nullptr;
		}
		OSS_CNTX_SET(94)
		if (_out_data->u.aarq->bit_mask & 0x100000) {
		    _dp_Authentication_value(_g, &_out_data->u.aarq->calling_authentication_value);
		} else {
		    memset(&(_out_data->u.aarq->calling_authentication_value), 0, sizeof(_Authentication_value ));
		}
		OSS_CNTX_SET(93)
		_out_data->u.aarq->application_context_name_list = nullptr;
		if (_out_data->u.aarq->bit_mask & 0x80000) {
		    _dp_13Application_context_name_l(_g, &_out_data->u.aarq->application_context_name_list);
		} else {
		    _out_data->u.aarq->application_context_name_list = nullptr;
		}
		OSS_CNTX_SET(92)
		if (_out_data->u.aarq->bit_mask & 0x40000) {
		    _out_data->u.aarq->implementation_information.length = _oss_pdec_ub_nkmstr_ia(_g, &_out_data->u.aarq->implementation_information.value);

		} else {
		    _out_data->u.aarq->implementation_information.length = 0;
		    _out_data->u.aarq->implementation_information.value = nullptr;
		}
		OSS_CNTX_SET(91)
		_out_data->u.aarq->user_information = nullptr;
		if (_out_data->u.aarq->bit_mask & 0x20000) {
		    _dp_Association_information(_g, &_out_data->u.aarq->user_information);
		} else {
		    _out_data->u.aarq->user_information = nullptr;
		}
		OSS_CNTX_POP(_oss_c)
		if (_extPres) {
		    _ea_count = _oss_pdec_eap(_g, &_pext);
		    _oss_pdec_eas(_g, _pext, _ea_count, 0);
		}
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 107)
	    _out_data->u.aare = (_AARE_apdu *)_oss_dec_const_alloc(_g, sizeof(_AARE_apdu));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		unsigned char *_pext;
		unsigned char _extPres = 0x00;
		unsigned long _ea_count = 0;
		OSS_CNTX_INIT

		_extPres = _oss_get_1bit_unaligned(_g);
		_out_data->u.aare->bit_mask = (OSS_UINT32)_oss_pdec_nonneg_int_l(_g, 11) << 21;
		OSS_CNTX_PUSH(_oss_c, 106)
		if (_out_data->u.aare->bit_mask & 0x80000000) {
		    _out_data->u.aare->protocol_version.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->u.aare->protocol_version.value);

		} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
		    memcpy(&_out_data->u.aare->protocol_version, &_v630, sizeof(_v630));
#else
		    _out_data->u.aare->protocol_version.length = 0;
		    _out_data->u.aare->protocol_version.value = nullptr;
#endif
		}
		OSS_CNTX_SET(105)
		_out_data->u.aare->application_context_name.length = _oss_pdec_eobjid_ia(_g, &_out_data->u.aare->application_context_name.value, -1);
		OSS_CNTX_SET(117)
		if (_oss_get_1bit_unaligned(_g)) {
		    _out_data->u.aare->result = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		} else {
		    _out_data->u.aare->result = (OSS_INT32)_oss_pdec_nonneg_2int(_g);
		}
		OSS_CNTX_SET(114)
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    OSS_CNTX_INIT

		    {

			_out_data->u.aare->result_source_diagnostic.choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
		    }
		    switch (_out_data->u.aare->result_source_diagnostic.choice) {
		    case 1:
			OSS_CNTX_PUSH(_oss_c, 115)
			if (_oss_get_1bit_unaligned(_g)) {
			    _out_data->u.aare->result_source_diagnostic.u.acse_service_user = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
			} else {
			    _out_data->u.aare->result_source_diagnostic.u.acse_service_user = (OSS_INT32)_oss_pdec_nonneg_4int(_g);
			}
			break;
		    case 2:
			OSS_CNTX_PUSH(_oss_c, 116)
			if (_oss_get_1bit_unaligned(_g)) {
			    _out_data->u.aare->result_source_diagnostic.u.acse_service_provider = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
			} else {
			    _out_data->u.aare->result_source_diagnostic.u.acse_service_provider = (OSS_INT32)_oss_pdec_nonneg_2int(_g);
			}
			break;
		    default:
			_oss_enc_error(_g, _bad_choice, _out_data->u.aare->result_source_diagnostic.choice);	/* Bad choice selector. */
		    }
		    OSS_CNTX_POP(_oss_c)
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		OSS_CNTX_SET(113)
		if (_out_data->u.aare->bit_mask & 0x40000000) {
		    _dp_AP_title(_g, &_out_data->u.aare->responding_AP_title);
		} else {
		    memset(&(_out_data->u.aare->responding_AP_title), 0, sizeof(_AP_title ));
		}
		OSS_CNTX_SET(112)
		if (_out_data->u.aare->bit_mask & 0x20000000) {
		    _dp_AE_qualifier(_g, &_out_data->u.aare->responding_AE_qualifier);
		} else {
		    memset(&(_out_data->u.aare->responding_AE_qualifier), 0, sizeof(_AE_qualifier ));
		}
		OSS_CNTX_SET(111)
		if (_out_data->u.aare->bit_mask & 0x10000000) {
		    _out_data->u.aare->responding_AP_invocation_identifier = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		}
		OSS_CNTX_SET(110)
		if (_out_data->u.aare->bit_mask & 0x8000000) {
		    _out_data->u.aare->responding_AE_invocation_identifier = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		}
		OSS_CNTX_SET(109)
		if (_out_data->u.aare->bit_mask & 0x4000000) {
		    _out_data->u.aare->responder_acse_requirements.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->u.aare->responder_acse_requirements.value);

		} else {
		    _out_data->u.aare->responder_acse_requirements.length = 0;
		    _out_data->u.aare->responder_acse_requirements.value = nullptr;
		}
		OSS_CNTX_SET(95)
		if (_out_data->u.aare->bit_mask & 0x2000000) {
		    _out_data->u.aare->mechanism_name.length = _oss_pdec_eobjid_ia(_g, &_out_data->u.aare->mechanism_name.value, -1);
		} else {
		    _out_data->u.aare->mechanism_name.length = 0;
		    _out_data->u.aare->mechanism_name.value = nullptr;
		}
		OSS_CNTX_SET(108)
		if (_out_data->u.aare->bit_mask & 0x1000000) {
		    _dp_Authentication_value(_g, &_out_data->u.aare->responding_authentication_value);
		} else {
		    memset(&(_out_data->u.aare->responding_authentication_value), 0, sizeof(_Authentication_value ));
		}
		OSS_CNTX_SET(93)
		_out_data->u.aare->application_context_name_list = nullptr;
		if (_out_data->u.aare->bit_mask & 0x800000) {
		    _dp_13Application_context_name_l(_g, &_out_data->u.aare->application_context_name_list);
		} else {
		    _out_data->u.aare->application_context_name_list = nullptr;
		}
		OSS_CNTX_SET(92)
		if (_out_data->u.aare->bit_mask & 0x400000) {
		    _out_data->u.aare->implementation_information.length = _oss_pdec_ub_nkmstr_ia(_g, &_out_data->u.aare->implementation_information.value);

		} else {
		    _out_data->u.aare->implementation_information.length = 0;
		    _out_data->u.aare->implementation_information.value = nullptr;
		}
		OSS_CNTX_SET(91)
		_out_data->u.aare->user_information = nullptr;
		if (_out_data->u.aare->bit_mask & 0x200000) {
		    _dp_Association_information(_g, &_out_data->u.aare->user_information);
		} else {
		    _out_data->u.aare->user_information = nullptr;
		}
		OSS_CNTX_POP(_oss_c)
		if (_extPres) {
		    _ea_count = _oss_pdec_eap(_g, &_pext);
		    _oss_pdec_eas(_g, _pext, _ea_count, 0);
		}
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 118)
	    _out_data->u.rlrq = (_RLRQ_apdu *)_oss_dec_const_alloc(_g, sizeof(_RLRQ_apdu));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		unsigned char *_pext;
		unsigned char _extPres = 0x00;
		unsigned long _ea_count = 0;
		OSS_CNTX_INIT

		_extPres = _oss_get_1bit_unaligned(_g);
		_out_data->u.rlrq->bit_mask = (OSS_UINT32)_oss_get_2bit_unaligned(_g) << 24;
		OSS_CNTX_PUSH(_oss_c, 119)
		if (_out_data->u.rlrq->bit_mask & 0x80000000) {
		    if (_oss_get_1bit_unaligned(_g)) {
			_out_data->u.rlrq->reason = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		    } else {
			_out_data->u.rlrq->reason = (OSS_INT32)_oss_pdec_nonneg_5int(_g);
		    }
		}
		OSS_CNTX_SET(91)
		_out_data->u.rlrq->user_information = nullptr;
		if (_out_data->u.rlrq->bit_mask & 0x40000000) {
		    _dp_Association_information(_g, &_out_data->u.rlrq->user_information);
		} else {
		    _out_data->u.rlrq->user_information = nullptr;
		}
		OSS_CNTX_POP(_oss_c)
		if (_extPres) {
		    _ea_count = _oss_pdec_eap(_g, &_pext);
		    _oss_pdec_eas(_g, _pext, _ea_count, 0);
		}
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 120)
	    _out_data->u.rlre = (_RLRQ_apdu *)_oss_dec_const_alloc(_g, sizeof(_RLRQ_apdu));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		unsigned char *_pext;
		unsigned char _extPres = 0x00;
		unsigned long _ea_count = 0;
		OSS_CNTX_INIT

		_extPres = _oss_get_1bit_unaligned(_g);
		_out_data->u.rlre->bit_mask = (OSS_UINT32)_oss_get_2bit_unaligned(_g) << 24;
		OSS_CNTX_PUSH(_oss_c, 121)
		if (_out_data->u.rlre->bit_mask & 0x80000000) {
		    if (_oss_get_1bit_unaligned(_g)) {
			_out_data->u.rlre->reason = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		    } else {
			_out_data->u.rlre->reason = (OSS_INT32)_oss_pdec_nonneg_5int(_g);
		    }
		}
		OSS_CNTX_SET(91)
		_out_data->u.rlre->user_information = nullptr;
		if (_out_data->u.rlre->bit_mask & 0x40000000) {
		    _dp_Association_information(_g, &_out_data->u.rlre->user_information);
		} else {
		    _out_data->u.rlre->user_information = nullptr;
		}
		OSS_CNTX_POP(_oss_c)
		if (_extPres) {
		    _ea_count = _oss_pdec_eap(_g, &_pext);
		    _oss_pdec_eas(_g, _pext, _ea_count, 0);
		}
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 122)
	    _out_data->u.abrt = (_ABRT_apdu *)_oss_dec_const_alloc(_g, sizeof(_ABRT_apdu));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		unsigned char *_pext;
		unsigned char _extPres = 0x00;
		unsigned long _ea_count = 0;
		OSS_CNTX_INIT

		_extPres = _oss_get_1bit_unaligned(_g);
		_out_data->u.abrt->bit_mask = (OSS_UINT32)_oss_get_2bit_unaligned(_g) << 24;
		OSS_CNTX_PUSH(_oss_c, 124)
		if (_oss_get_1bit_unaligned(_g)) {
		    _out_data->u.abrt->abort_source = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		} else {
		    _out_data->u.abrt->abort_source = (OSS_INT32)_oss_pdec_nonneg_1int(_g);
		}
		OSS_CNTX_SET(123)
		if (_out_data->u.abrt->bit_mask & 0x80000000) {
		    _out_data->u.abrt->abort_diagnostic = (enum ABRT_diagnostic)_oss_pdec_enum(_g, (struct _enum_data*)&_enums[2], (struct _enum_data*)&_enums[3]);
		}
		OSS_CNTX_SET(91)
		_out_data->u.abrt->user_information = nullptr;
		if (_out_data->u.abrt->bit_mask & 0x40000000) {
		    _dp_Association_information(_g, &_out_data->u.abrt->user_information);
		} else {
		    _out_data->u.abrt->user_information = nullptr;
		}
		OSS_CNTX_POP(_oss_c)
		if (_extPres) {
		    _ea_count = _oss_pdec_eap(_g, &_pext);
		    _oss_pdec_eas(_g, _pext, _ea_count, 0);
		}
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    break;
	default:
	    _out_data->choice = 0;	/* Unknown choice selector. */
	    _oss_pdec_sot(_g);
	    OSS_CNTX_PUSH(_oss_c, 0)
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dAE_title(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AE_title *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(3,125)
    _out_data = (_AE_title *)_oss_dec_const_alloc(_g, sizeof(_AE_title));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	if (_data_tag == 0x10) {
	    OSS_CNTX_PUSH(_oss_c, 127)
	    _out_data->choice = 2;
	    _out_data->u.ae_title_form1 = (_Name *)_oss_dec_const_alloc(_g, sizeof(_Name));
	    _d_Name(_g, &_bufpos, &_buflen, 0, _data_tag, _out_data->u.ae_title_form1);
	    OSS_CNTX_POP(_oss_c)
	} else
	switch (_data_tag) {
	case 0x6: {
	    OSS_CNTX_PUSH(_oss_c, 126)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.ae_title_form2.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.ae_title_form2.value, -1);
	}   break;
	default:
	    _oss_c->_tag_decoded = FALSE;
	    _out_data->choice = 0;	/* Unknown choice selector. */
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
	    OSS_CNTX_PUSH(_oss_c, 0)
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpAE_title(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AE_title	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(3,125)
    _out_data = (_AE_title *)_oss_dec_const_alloc(_g, sizeof(_AE_title));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (!_oss_get_1bit_unaligned(_g)) {

	    _out_data->choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
	} else {
	    unsigned long _encode_value;
	    _encode_value = _oss_pdec_small_int_l(_g);
	    if (_encode_value > UINT_MAX - 3)
		_oss_enc_error(_g, _bad_choice, _encode_value);
	    _out_data->choice = _encode_value + 3;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 126)
	    _out_data->u.ae_title_form2.length = _oss_pdec_eobjid_ia(_g, &_out_data->u.ae_title_form2.value, -1);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 127)
	    _out_data->u.ae_title_form1 = (_Name *)_oss_dec_const_alloc(_g, sizeof(_Name));
	    _dp_Name(_g, _out_data->u.ae_title_form1);
	    break;
	default:
	    _out_data->choice = 0;	/* Unknown choice selector. */
	    _oss_pdec_sot(_g);
	    OSS_CNTX_PUSH(_oss_c, 0)
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dCP_type(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CP_type *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(4,128)
    _out_data = (_CP_type *)_oss_dec_const_alloc(_g, sizeof(_CP_type));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
    _data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	unsigned short _present_flags = 0;
	OSS_CNTX_DEF
	OSS_CNTX_SETOCC(0)
	_out_data->bit_mask = 0;
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    switch (_data_tag) {
	    default:
		if (!(_data_tag & 0x8000))
		    _oss_dec_error(_g, _unknown_field, _data_tag);
		switch (_data_tag & 0x7fff) {
		case 0x0: {
		    OSS_CNTX_PUSH(_oss_c, 142)
		    if (_present_flags & 0x1)
			_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _d_Mode_selector(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->mode_selector);
		    _present_flags |= 0x1;
		}   break;
		case 0x1: {
		    OSS_CNTX_PUSH(_oss_c, 141)
		    if (_out_data->bit_mask & 0x80000000)
			_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		    _out_data->bit_mask |= 0x80000000;
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			int _indef_tags = 0;
			long _total_len = _data_length;
			char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
			unsigned short _present_flags = 0;
			OSS_CNTX_DEF
			OSS_CNTX_SETOCC(0)
			_out_data->x410_mode_parameters.bit_mask = 0;
			for (;;) {
			    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
				if (_bufpos > _end_pos)
				    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
				break;
			    }
			    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
				_bufpos++;
			    } else
				if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
				    if (_oss_dec_length(_g, &_bufpos, &_buflen))
					_oss_dec_error(_g, _non_std_eoc, 0L);
				    _oss_c->_tag_decoded = FALSE;
				    break;
				}
			    _oss_c->_tag_decoded = TRUE;
			    switch (_data_tag) {
			    default:
				if (!(_data_tag & 0x8000))
				    _oss_dec_error(_g, _unknown_field, _data_tag);
				switch (_data_tag & 0x7fff) {
				case 0x0: {
				    OSS_CNTX_PUSH(_oss_c, 48)
				    if (_out_data->x410_mode_parameters.bit_mask & 0x80000000)
					_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
				    _out_data->x410_mode_parameters.bit_mask |= 0x80000000;
				    _oss_c->_tag_decoded = FALSE;
				    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					_buflen--;
					_bufpos++;
				    } else
					_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				    _out_data->x410_mode_parameters.checkpointSize = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
				    _present_flags |= 0x1;
				}   break;
				case 0x1: {
				    OSS_CNTX_PUSH(_oss_c, 47)
				    if (_out_data->x410_mode_parameters.bit_mask & 0x40000000)
					_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
				    _out_data->x410_mode_parameters.bit_mask |= 0x40000000;
				    _oss_c->_tag_decoded = FALSE;
				    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					_buflen--;
					_bufpos++;
				    } else
					_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				    _out_data->x410_mode_parameters.windowSize = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
				    _present_flags |= 0x2;
				}   break;
				case 0x2: {
				    OSS_CNTX_PUSH(_oss_c, 46)
				    if (_out_data->x410_mode_parameters.bit_mask & 0x20000000)
					_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
				    _out_data->x410_mode_parameters.bit_mask |= 0x20000000;
				    _oss_c->_tag_decoded = FALSE;
				    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					_buflen--;
					_bufpos++;
				    } else
					_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				    _out_data->x410_mode_parameters.dialogueMode = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
				    _present_flags |= 0x4;
				}   break;
				case 0x3: {
				    OSS_CNTX_PUSH(_oss_c, 45)
				    if (_present_flags & 0x8)
					_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
				    _oss_c->_tag_decoded = FALSE;
				    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					_buflen--;
					_bufpos++;
				    } else
					_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				    if (_data_length < 0) ++_indef_tags;
				    _d_ConnectionData(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->x410_mode_parameters.connectionDataRQ);
				    while (_indef_tags > 0) {
					if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
					    _buflen -= 2;
					    _bufpos += 2;
					} else
					    if (!_buflen || _bufpos[0])
						_oss_dec_error(_g, _expec_eoc, 0L);
					    else
						_oss_dec_error(_g, _non_std_eoc, 0L);
					_indef_tags--;
				    }
				    _present_flags |= 0x8;
				}   break;
				case 0x4: {
				    OSS_CNTX_PUSH(_oss_c, 44)
				    if (_out_data->x410_mode_parameters.bit_mask & 0x10000000)
					_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
				    _out_data->x410_mode_parameters.bit_mask |= 0x10000000;
				    _oss_c->_tag_decoded = FALSE;
				    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					_buflen--;
					_bufpos++;
				    } else
					_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				    _out_data->x410_mode_parameters.applicationProtocol = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
				    _present_flags |= 0x10;
				}   break;
				default:
				    _oss_dec_error(_g, _unknown_field, _data_tag);
				}
				break;
			    }
			    OSS_CNTX_POP(_oss_c)
			}
			if (!(_present_flags & 0x1)) {
			    _out_data->x410_mode_parameters.bit_mask &= ~0x80000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
			    memcpy(&_out_data->x410_mode_parameters.checkpointSize, &__shared15::default_checkpointSize, sizeof(__shared15::default_checkpointSize));
#else
			    _out_data->x410_mode_parameters.checkpointSize = 0;
#endif
			}
			if (!(_present_flags & 0x2)) {
			    _out_data->x410_mode_parameters.bit_mask &= ~0x40000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
			    memcpy(&_out_data->x410_mode_parameters.windowSize, &__shared15::default_windowSize, sizeof(__shared15::default_windowSize));
#else
			    _out_data->x410_mode_parameters.windowSize = 0;
#endif
			}
			if (!(_present_flags & 0x4)) {
			    _out_data->x410_mode_parameters.bit_mask &= ~0x20000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
			    memcpy(&_out_data->x410_mode_parameters.dialogueMode, &__shared15::default_checkpointSize, sizeof(__shared15::default_checkpointSize));
#else
			    _out_data->x410_mode_parameters.dialogueMode = 0;
#endif
			}
			if (!(_present_flags & 0x10)) {
			    _out_data->x410_mode_parameters.bit_mask &= ~0x10000000;
			}
			if ((_present_flags & 0x8) != 0x8)
			    _oss_dec_error(_g, _field_omit, 0L);
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		    _present_flags |= 0x2;
		}   break;
		case 0x2: {
		    OSS_CNTX_PUSH(_oss_c, 129)
		    if (_out_data->bit_mask & 0x40000000)
			_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		    _out_data->bit_mask |= 0x40000000;
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			int _indef_tags = 0;
			long _total_len = _data_length;
			char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
			OSS_CNTX_INIT

			_out_data->normal_mode_parameters.bit_mask = 0;
			if (_bufpos < _end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x8000 || _bufpos >= _end_pos)
			 {
			    _out_data->normal_mode_parameters.bit_mask &= ~0x80000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
			    memcpy(&_out_data->normal_mode_parameters.protocol_version, &_v631, sizeof(_v631));
#else
			    _out_data->normal_mode_parameters.protocol_version.length = 0;
			    _out_data->normal_mode_parameters.protocol_version.value = nullptr;
#endif
			}
else {
			    _out_data->normal_mode_parameters.bit_mask |= 0x80000000;
			    OSS_CNTX_PUSH(_oss_c, 140)
			    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 128 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_bufpos += 2;
			    } else {
				if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
				} else
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
				_oss_c->_tag_decoded = FALSE;
			    }
			    _data_tag = 0x8000;
			    _out_data->normal_mode_parameters.protocol_version.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->normal_mode_parameters.protocol_version.value, 0, 128);

			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x8001 || _bufpos >= _end_pos)
			 {
			    _out_data->normal_mode_parameters.bit_mask &= ~0x40000000;
			    memset(&_out_data->normal_mode_parameters.calling_presentation_selector, 0, sizeof(_out_data->normal_mode_parameters.calling_presentation_selector));
			}
else {
			    _out_data->normal_mode_parameters.bit_mask |= 0x40000000;
			    OSS_CNTX_PUSH(_oss_c, 139)
			    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 129 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_bufpos += 2;
			    } else {
				if (!_oss_c->_tag_decoded || _data_tag == 0x8001) {
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x81 : 0);
				} else
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80010000);
				_oss_c->_tag_decoded = FALSE;
			    }
			    _data_tag = 0x8001;
			    _out_data->normal_mode_parameters.calling_presentation_selector.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->normal_mode_parameters.calling_presentation_selector.value, 0);
			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x8002 || _bufpos >= _end_pos)
			 {
			    _out_data->normal_mode_parameters.bit_mask &= ~0x20000000;
			    memset(&_out_data->normal_mode_parameters.called_presentation_selector, 0, sizeof(_out_data->normal_mode_parameters.called_presentation_selector));
			}
else {
			    _out_data->normal_mode_parameters.bit_mask |= 0x20000000;
			    OSS_CNTX_PUSH(_oss_c, 138)
			    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 130 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_bufpos += 2;
			    } else {
				if (!_oss_c->_tag_decoded || _data_tag == 0x8002) {
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x82 : 0);
				} else
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80020000);
				_oss_c->_tag_decoded = FALSE;
			    }
			    _data_tag = 0x8002;
			    _out_data->normal_mode_parameters.called_presentation_selector.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->normal_mode_parameters.called_presentation_selector.value, 0);
			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x8004 || _bufpos >= _end_pos)
			 {
			    _out_data->normal_mode_parameters.bit_mask &= ~0x10000000;
			    memset(&_out_data->normal_mode_parameters.presentation_context_definition_list, 0, sizeof(_out_data->normal_mode_parameters.presentation_context_definition_list));
			}
else {
			    _out_data->normal_mode_parameters.bit_mask |= 0x10000000;
			    OSS_CNTX_PUSH(_oss_c, 137)
			    _out_data->normal_mode_parameters.presentation_context_definition_list = nullptr;
			    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 164 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				_buflen -= 2;
				_bufpos += 2;
			    } else {
				if (!_oss_c->_tag_decoded || _data_tag == 0x8004) {
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x84 : 0);
				} else
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80040000);
				_oss_c->_tag_decoded = FALSE;
			    }
			    _data_tag = 0x8004;
			    _d_Context_list(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->normal_mode_parameters.presentation_context_definition_list);
			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x8006 || _bufpos >= _end_pos)
			 {
			    _out_data->normal_mode_parameters.bit_mask &= ~0x8000000;
			    memset(&_out_data->normal_mode_parameters.default_context_name, 0, sizeof(_out_data->normal_mode_parameters.default_context_name));
			}
else {
			    _out_data->normal_mode_parameters.bit_mask |= 0x8000000;
			    OSS_CNTX_PUSH(_oss_c, 136)
			    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 166 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				_buflen -= 2;
				_bufpos += 2;
			    } else {
				if (!_oss_c->_tag_decoded || _data_tag == 0x8006) {
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x86 : 0);
				} else
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80060000);
				_oss_c->_tag_decoded = FALSE;
			    }
			    _data_tag = 0x8006;
#ifndef OSS_NO_NESTING_CONTROL
			    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				    _oss_c->reserved.fields.ext->seqSetNestingLimit)
				_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			    {
				long _total_len = _data_length;
				char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
				OSS_CNTX_INIT

				OSS_CNTX_PUSH(_oss_c, 37)
				if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 128 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else {
				    if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
					_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
				    } else
					_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
				    _oss_c->_tag_decoded = FALSE;
				}
				_data_tag = 0x8000;
				_out_data->normal_mode_parameters.default_context_name.abstract_syntax_name.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->normal_mode_parameters.default_context_name.abstract_syntax_name.value, -1);
				OSS_CNTX_SET(39)
				if (_buflen >= 2 && (unsigned char)_bufpos[0] == 129 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
				_data_tag = 0x8001;
				_out_data->normal_mode_parameters.default_context_name.transfer_syntax_name.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->normal_mode_parameters.default_context_name.transfer_syntax_name.value, -1);
				OSS_CNTX_POP(_oss_c)
				if (_bufpos != _end_pos) {
				    if (_total_len < 0) {
					if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
					    _buflen--;
					    _bufpos++;
					} else
					    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

					if (_data_tag)
					    _oss_dec_error(_g, _expec_eoc, 0L);
					if (_oss_dec_length(_g, &_bufpos, &_buflen))
					    _oss_dec_error(_g, _non_std_eoc, 0L);
					_oss_c->_tag_decoded = FALSE;
				    } else
					_oss_dec_error(_g, _inconsis_len, 0L);
				}
			    }
#ifndef OSS_NO_NESTING_CONTROL
			    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
				_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x8008 || _bufpos >= _end_pos)
			 {
			    _out_data->normal_mode_parameters.bit_mask &= ~0x4000000;
			    memset(&_out_data->normal_mode_parameters.presentation_requirements, 0, sizeof(_out_data->normal_mode_parameters.presentation_requirements));
			}
else {
			    _out_data->normal_mode_parameters.bit_mask |= 0x4000000;
			    OSS_CNTX_PUSH(_oss_c, 135)
			    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 136 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_bufpos += 2;
			    } else {
				if (!_oss_c->_tag_decoded || _data_tag == 0x8008) {
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x88 : 0);
				} else
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80080000);
				_oss_c->_tag_decoded = FALSE;
			    }
			    _data_tag = 0x8008;
			    _out_data->normal_mode_parameters.presentation_requirements.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->normal_mode_parameters.presentation_requirements.value, 0, 128);

			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x8009 || _bufpos >= _end_pos)
			 {
			    _out_data->normal_mode_parameters.bit_mask &= ~0x2000000;
			    memset(&_out_data->normal_mode_parameters.user_session_requirements, 0, sizeof(_out_data->normal_mode_parameters.user_session_requirements));
			}
else {
			    _out_data->normal_mode_parameters.bit_mask |= 0x2000000;
			    OSS_CNTX_PUSH(_oss_c, 134)
			    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 137 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_bufpos += 2;
			    } else {
				if (!_oss_c->_tag_decoded || _data_tag == 0x8009) {
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x89 : 0);
				} else
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80090000);
				_oss_c->_tag_decoded = FALSE;
			    }
			    _data_tag = 0x8009;
			    _out_data->normal_mode_parameters.user_session_requirements.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->normal_mode_parameters.user_session_requirements.value, 0, 128);

			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x800B || _bufpos >= _end_pos)
			 {
			    _out_data->normal_mode_parameters.bit_mask &= ~0x1000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
			    memcpy(&_out_data->normal_mode_parameters.protocol_options, &_v632, sizeof(_v632));
#else
			    _out_data->normal_mode_parameters.protocol_options.length = 0;
			    _out_data->normal_mode_parameters.protocol_options.value = nullptr;
#endif
			}
else {
			    _out_data->normal_mode_parameters.bit_mask |= 0x1000000;
			    OSS_CNTX_PUSH(_oss_c, 133)
			    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 171 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				_buflen -= 2;
				_bufpos += 2;
			    } else {
				if (!_oss_c->_tag_decoded || _data_tag == 0x800B) {
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x8B : 0);
				} else
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x800B0000);
				_oss_c->_tag_decoded = FALSE;
			    }
			    _data_tag = 0x800B;
			    if (_data_length < 0) ++_indef_tags;
			    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 3 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_bufpos += 2;
			    } else
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x3);
			    _data_tag = 0x3;
			    _out_data->normal_mode_parameters.protocol_options.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->normal_mode_parameters.protocol_options.value, 0, 128);

			    while (_indef_tags > 0) {
				if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    if (!_buflen || _bufpos[0])
					_oss_dec_error(_g, _expec_eoc, 0L);
				    else
					_oss_dec_error(_g, _non_std_eoc, 0L);
				_indef_tags--;
			    }
			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x800C || _bufpos >= _end_pos)
			 {
			    _out_data->normal_mode_parameters.bit_mask &= ~0x800000;
			}
else {
			    _out_data->normal_mode_parameters.bit_mask |= 0x800000;
			    OSS_CNTX_PUSH(_oss_c, 132)
			    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 172 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				_buflen -= 2;
				_bufpos += 2;
			    } else {
				if (!_oss_c->_tag_decoded || _data_tag == 0x800C) {
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x8C : 0);
				} else
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x800C0000);
				_oss_c->_tag_decoded = FALSE;
			    }
			    _data_tag = 0x800C;
			    if (_data_length < 0) ++_indef_tags;
			    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
			    _data_tag = 0x2;
			    _out_data->normal_mode_parameters.initiators_nominated_context = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
			    while (_indef_tags > 0) {
				if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    if (!_buflen || _bufpos[0])
					_oss_dec_error(_g, _expec_eoc, 0L);
				    else
					_oss_dec_error(_g, _non_std_eoc, 0L);
				_indef_tags--;
			    }
			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x800E || _bufpos >= _end_pos)
			 {
			    _out_data->normal_mode_parameters.bit_mask &= ~0x400000;
			    memset(&_out_data->normal_mode_parameters.extensions, 0, sizeof(_out_data->normal_mode_parameters.extensions));
			}
else {
			    _out_data->normal_mode_parameters.bit_mask |= 0x400000;
			    OSS_CNTX_PUSH(_oss_c, 131)
			    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 174 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				_buflen -= 2;
				_bufpos += 2;
			    } else {
				if (!_oss_c->_tag_decoded || _data_tag == 0x800E) {
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x8E : 0);
				} else
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x800E0000);
				_oss_c->_tag_decoded = FALSE;
			    }
			    _data_tag = 0x800E;
			    if (_data_length < 0) ++_indef_tags;
			    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
			    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
			    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				    _oss_c->reserved.fields.ext->seqSetNestingLimit)
				_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			    {
				long _total_len = _data_length;
				char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
				OSS_CNTX_INIT

				while (_bufpos < _end_pos || _total_len < 0) {
				    if (!_oss_c->_tag_decoded) {
					if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
					    _buflen--;
					    _oss_c->_bitpos = _bufpos[0] & 0x20;
					    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
					    _bufpos++;
					} else
					    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
					_oss_c->_tag_decoded = TRUE;
				    }
				    if (!_data_tag)
					break;
				    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				    _oss_skip_past_item(_g, &_bufpos, &_buflen, _data_length);
				    _oss_c->_tag_decoded = FALSE;
				}
				if (_total_len < 0 && !_data_tag) {
				    if (_oss_dec_length(_g, &_bufpos, &_buflen))
					_oss_dec_error(_g, _non_std_eoc, 0L);
				    _oss_c->_tag_decoded = FALSE;
				}
			    }
#ifndef OSS_NO_NESTING_CONTROL
			    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
				_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			    while (_indef_tags > 0) {
				if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    if (!_buflen || _bufpos[0])
					_oss_dec_error(_g, _expec_eoc, 0L);
				    else
					_oss_dec_error(_g, _non_std_eoc, 0L);
				_indef_tags--;
			    }
			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if ((FALSE)
			    || (_total_len >= 0 && _bufpos >= _end_pos))
			 {
			    _out_data->normal_mode_parameters.bit_mask &= ~0x200000;
			    memset(&_out_data->normal_mode_parameters.user_data, 0, sizeof(_out_data->normal_mode_parameters.user_data));
			}
else {
			    _out_data->normal_mode_parameters.bit_mask |= 0x200000;
			    OSS_CNTX_PUSH(_oss_c, 130)
			    _d_User_data(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->normal_mode_parameters.user_data);
			    OSS_CNTX_POP(_oss_c)
			}
			if (_bufpos != _end_pos) {
			    if (_total_len < 0) {
				if (!_oss_c->_tag_decoded)
				    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

				if (_data_tag)
				    _oss_dec_error(_g, _expec_eoc, 0L);
				if (_oss_dec_length(_g, &_bufpos, &_buflen))
				    _oss_dec_error(_g, _non_std_eoc, 0L);
				_oss_c->_tag_decoded = FALSE;
			    } else
				_oss_dec_error(_g, _inconsis_len, 0L);
			}
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		    _present_flags |= 0x4;
		}   break;
		default:
		    _oss_dec_error(_g, _unknown_field, _data_tag);
		}
		break;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!(_present_flags & 0x2)) {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->x410_mode_parameters, 0, sizeof(_out_data->x410_mode_parameters));
	}
	if (!(_present_flags & 0x4)) {
	    _out_data->bit_mask &= ~0x40000000;
	    memset(&_out_data->normal_mode_parameters, 0, sizeof(_out_data->normal_mode_parameters));
	}
	if ((_present_flags & 0x1) != 0x1)
	    _oss_dec_error(_g, _field_omit, 0L);
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpCP_type(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CP_type	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(4,128)
    _out_data = (_CP_type *)_oss_dec_const_alloc(_g, sizeof(_CP_type));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_2bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 142)
	_dp_Mode_selector(_g, &_out_data->mode_selector);
	OSS_CNTX_SET(141)
	if (_out_data->bit_mask & 0x80000000) {
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_out_data->x410_mode_parameters.bit_mask = (OSS_UINT32)_oss_get_4bit_unaligned(_g) << 24;
		OSS_CNTX_PUSH(_oss_c, 48)
		if (_out_data->x410_mode_parameters.bit_mask & 0x80000000) {
		    _out_data->x410_mode_parameters.checkpointSize = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
		    memcpy(&_out_data->x410_mode_parameters.checkpointSize, &__shared15::default_checkpointSize, sizeof(__shared15::default_checkpointSize));
#else
		    _out_data->x410_mode_parameters.checkpointSize = 0;
#endif
		}
		OSS_CNTX_SET(47)
		if (_out_data->x410_mode_parameters.bit_mask & 0x40000000) {
		    _out_data->x410_mode_parameters.windowSize = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
		    memcpy(&_out_data->x410_mode_parameters.windowSize, &__shared15::default_windowSize, sizeof(__shared15::default_windowSize));
#else
		    _out_data->x410_mode_parameters.windowSize = 0;
#endif
		}
		OSS_CNTX_SET(46)
		if (_out_data->x410_mode_parameters.bit_mask & 0x20000000) {
		    _out_data->x410_mode_parameters.dialogueMode = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
		    memcpy(&_out_data->x410_mode_parameters.dialogueMode, &__shared15::default_checkpointSize, sizeof(__shared15::default_checkpointSize));
#else
		    _out_data->x410_mode_parameters.dialogueMode = 0;
#endif
		}
		OSS_CNTX_SET(45)
		_dp_ConnectionData(_g, &_out_data->x410_mode_parameters.connectionDataRQ);
		OSS_CNTX_SET(44)
		if (_out_data->x410_mode_parameters.bit_mask & 0x10000000) {
		    _out_data->x410_mode_parameters.applicationProtocol = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		}
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	} else {
	    memset(&(_out_data->x410_mode_parameters), 0, sizeof(_set1 ));
	}
	OSS_CNTX_SET(129)
	if (_out_data->bit_mask & 0x40000000) {
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_out_data->normal_mode_parameters.bit_mask = (OSS_UINT32)_oss_pdec_nonneg_int_l(_g, 11) << 21;
		OSS_CNTX_PUSH(_oss_c, 140)
		if (_out_data->normal_mode_parameters.bit_mask & 0x80000000) {
		    _out_data->normal_mode_parameters.protocol_version.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->normal_mode_parameters.protocol_version.value);

		} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
		    memcpy(&_out_data->normal_mode_parameters.protocol_version, &_v631, sizeof(_v631));
#else
		    _out_data->normal_mode_parameters.protocol_version.length = 0;
		    _out_data->normal_mode_parameters.protocol_version.value = nullptr;
#endif
		}
		OSS_CNTX_SET(139)
		if (_out_data->normal_mode_parameters.bit_mask & 0x40000000) {
		    if (_oss_get_1bit_unaligned(_g)) {
			_out_data->normal_mode_parameters.calling_presentation_selector.length = _oss_pdec_unconstr_uoct_ia(_g, (unsigned char **)&_out_data->normal_mode_parameters.calling_presentation_selector.value);

		    } else {
			_out_data->normal_mode_parameters.calling_presentation_selector.length = _oss_pdec_constr_uoct_ia(_g, (unsigned char **)&_out_data->normal_mode_parameters.calling_presentation_selector.value, 1, 4);

		    }
		} else {
		    _out_data->normal_mode_parameters.calling_presentation_selector.length = 0;
		    _out_data->normal_mode_parameters.calling_presentation_selector.value = nullptr;
		}
		OSS_CNTX_SET(138)
		if (_out_data->normal_mode_parameters.bit_mask & 0x20000000) {
		    if (_oss_get_1bit_unaligned(_g)) {
			_out_data->normal_mode_parameters.called_presentation_selector.length = _oss_pdec_unconstr_uoct_ia(_g, (unsigned char **)&_out_data->normal_mode_parameters.called_presentation_selector.value);

		    } else {
			_out_data->normal_mode_parameters.called_presentation_selector.length = _oss_pdec_constr_uoct_ia(_g, (unsigned char **)&_out_data->normal_mode_parameters.called_presentation_selector.value, 1, 4);

		    }
		} else {
		    _out_data->normal_mode_parameters.called_presentation_selector.length = 0;
		    _out_data->normal_mode_parameters.called_presentation_selector.value = nullptr;
		}
		OSS_CNTX_SET(137)
		_out_data->normal_mode_parameters.presentation_context_definition_list = nullptr;
		if (_out_data->normal_mode_parameters.bit_mask & 0x10000000) {
		    _dp_Context_list(_g, &_out_data->normal_mode_parameters.presentation_context_definition_list);
		} else {
		    _out_data->normal_mode_parameters.presentation_context_definition_list = nullptr;
		}
		OSS_CNTX_SET(136)
		if (_out_data->normal_mode_parameters.bit_mask & 0x8000000) {
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			OSS_CNTX_INIT

			OSS_CNTX_PUSH(_oss_c, 37)
			_out_data->normal_mode_parameters.default_context_name.abstract_syntax_name.length = _oss_pdec_eobjid_ia(_g, &_out_data->normal_mode_parameters.default_context_name.abstract_syntax_name.value, -1);
			OSS_CNTX_SET(39)
			_out_data->normal_mode_parameters.default_context_name.transfer_syntax_name.length = _oss_pdec_eobjid_ia(_g, &_out_data->normal_mode_parameters.default_context_name.transfer_syntax_name.value, -1);
			OSS_CNTX_POP(_oss_c)
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		} else {
		    memset(&(_out_data->normal_mode_parameters.default_context_name), 0, sizeof(_Default_context_name ));
		}
		OSS_CNTX_SET(135)
		if (_out_data->normal_mode_parameters.bit_mask & 0x4000000) {
		    _out_data->normal_mode_parameters.presentation_requirements.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->normal_mode_parameters.presentation_requirements.value);

		} else {
		    _out_data->normal_mode_parameters.presentation_requirements.length = 0;
		    _out_data->normal_mode_parameters.presentation_requirements.value = nullptr;
		}
		OSS_CNTX_SET(134)
		if (_out_data->normal_mode_parameters.bit_mask & 0x2000000) {
		    _out_data->normal_mode_parameters.user_session_requirements.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->normal_mode_parameters.user_session_requirements.value);

		} else {
		    _out_data->normal_mode_parameters.user_session_requirements.length = 0;
		    _out_data->normal_mode_parameters.user_session_requirements.value = nullptr;
		}
		OSS_CNTX_SET(133)
		if (_out_data->normal_mode_parameters.bit_mask & 0x1000000) {
		    _out_data->normal_mode_parameters.protocol_options.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->normal_mode_parameters.protocol_options.value);

		} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
		    memcpy(&_out_data->normal_mode_parameters.protocol_options, &_v632, sizeof(_v632));
#else
		    _out_data->normal_mode_parameters.protocol_options.length = 0;
		    _out_data->normal_mode_parameters.protocol_options.value = nullptr;
#endif
		}
		OSS_CNTX_SET(132)
		if (_out_data->normal_mode_parameters.bit_mask & 0x800000) {
		    if (_oss_get_1bit_unaligned(_g)) {
			_out_data->normal_mode_parameters.initiators_nominated_context = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		    } else {
			_out_data->normal_mode_parameters.initiators_nominated_context = (OSS_INT32)_oss_pdec_nonneg_7int(_g) + 1;
		    }
		}
		OSS_CNTX_SET(131)
		if (_out_data->normal_mode_parameters.bit_mask & 0x400000) {
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			unsigned char *_pext;
			unsigned char _extPres = 0x00;
			unsigned long _ea_count = 0;
			OSS_CNTX_INIT

			_extPres = _oss_get_1bit_unaligned(_g);
			if (_extPres) {
			    _ea_count = _oss_pdec_eap(_g, &_pext);
			    _oss_pdec_eas(_g, _pext, _ea_count, 0);
			}
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		} else {
		    ((char *)(&(_out_data->normal_mode_parameters.extensions)))[0] = 0;
		}
		OSS_CNTX_SET(130)
		if (_out_data->normal_mode_parameters.bit_mask & 0x200000) {
		    _dp_User_data(_g, &_out_data->normal_mode_parameters.user_data);
		} else {
		    memset(&(_out_data->normal_mode_parameters.user_data), 0, sizeof(_User_data ));
		}
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	} else {
	    memset(&(_out_data->normal_mode_parameters), 0, sizeof(_seq3 ));
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dCPC_type(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _User_data *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(5,143)
    _out_data = (_User_data *)_oss_dec_const_alloc(_g, sizeof(_User_data));
    _oss_c->_tag_decoded = FALSE;
    _d_User_data(_g, &_bufpos, &_buflen, 0, 0, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpCPC_type(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _User_data	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(5,143)
    _out_data = (_User_data *)_oss_dec_const_alloc(_g, sizeof(_User_data));
    _dp_User_data(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dCPA_PPDU(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CPA_PPDU *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(6,144)
    _out_data = (_CPA_PPDU *)_oss_dec_const_alloc(_g, sizeof(_CPA_PPDU));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
    _data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	unsigned short _present_flags = 0;
	OSS_CNTX_DEF
	OSS_CNTX_SETOCC(0)
	_out_data->bit_mask = 0;
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    switch (_data_tag) {
	    default:
		if (!(_data_tag & 0x8000))
		    _oss_dec_error(_g, _unknown_field, _data_tag);
		switch (_data_tag & 0x7fff) {
		case 0x0: {
		    OSS_CNTX_PUSH(_oss_c, 142)
		    if (_present_flags & 0x1)
			_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _d_Mode_selector(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->mode_selector);
		    _present_flags |= 0x1;
		}   break;
		case 0x1: {
		    OSS_CNTX_PUSH(_oss_c, 141)
		    if (_out_data->bit_mask & 0x80000000)
			_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		    _out_data->bit_mask |= 0x80000000;
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			int _indef_tags = 0;
			long _total_len = _data_length;
			char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
			unsigned short _present_flags = 0;
			OSS_CNTX_DEF
			OSS_CNTX_SETOCC(0)
			_out_data->x410_mode_parameters.bit_mask = 0;
			for (;;) {
			    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
				if (_bufpos > _end_pos)
				    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
				break;
			    }
			    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
				_bufpos++;
			    } else
				if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
				    if (_oss_dec_length(_g, &_bufpos, &_buflen))
					_oss_dec_error(_g, _non_std_eoc, 0L);
				    _oss_c->_tag_decoded = FALSE;
				    break;
				}
			    _oss_c->_tag_decoded = TRUE;
			    switch (_data_tag) {
			    default:
				if (!(_data_tag & 0x8000))
				    _oss_dec_error(_g, _unknown_field, _data_tag);
				switch (_data_tag & 0x7fff) {
				case 0x0: {
				    OSS_CNTX_PUSH(_oss_c, 48)
				    if (_out_data->x410_mode_parameters.bit_mask & 0x80000000)
					_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
				    _out_data->x410_mode_parameters.bit_mask |= 0x80000000;
				    _oss_c->_tag_decoded = FALSE;
				    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					_buflen--;
					_bufpos++;
				    } else
					_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				    _out_data->x410_mode_parameters.checkpointSize = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
				    _present_flags |= 0x1;
				}   break;
				case 0x1: {
				    OSS_CNTX_PUSH(_oss_c, 47)
				    if (_out_data->x410_mode_parameters.bit_mask & 0x40000000)
					_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
				    _out_data->x410_mode_parameters.bit_mask |= 0x40000000;
				    _oss_c->_tag_decoded = FALSE;
				    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					_buflen--;
					_bufpos++;
				    } else
					_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				    _out_data->x410_mode_parameters.windowSize = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
				    _present_flags |= 0x2;
				}   break;
				case 0x2: {
				    OSS_CNTX_PUSH(_oss_c, 49)
				    if (_present_flags & 0x4)
					_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
				    _oss_c->_tag_decoded = FALSE;
				    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					_buflen--;
					_bufpos++;
				    } else
					_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				    if (_data_length < 0) ++_indef_tags;
				    _d_ConnectionData(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->x410_mode_parameters.connectionDataAC);
				    while (_indef_tags > 0) {
					if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
					    _buflen -= 2;
					    _bufpos += 2;
					} else
					    if (!_buflen || _bufpos[0])
						_oss_dec_error(_g, _expec_eoc, 0L);
					    else
						_oss_dec_error(_g, _non_std_eoc, 0L);
					_indef_tags--;
				    }
				    _present_flags |= 0x4;
				}   break;
				default:
				    _oss_dec_error(_g, _unknown_field, _data_tag);
				}
				break;
			    }
			    OSS_CNTX_POP(_oss_c)
			}
			if (!(_present_flags & 0x1)) {
			    _out_data->x410_mode_parameters.bit_mask &= ~0x80000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
			    memcpy(&_out_data->x410_mode_parameters.checkpointSize, &__shared15::default_checkpointSize, sizeof(__shared15::default_checkpointSize));
#else
			    _out_data->x410_mode_parameters.checkpointSize = 0;
#endif
			}
			if (!(_present_flags & 0x2)) {
			    _out_data->x410_mode_parameters.bit_mask &= ~0x40000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
			    memcpy(&_out_data->x410_mode_parameters.windowSize, &__shared15::default_windowSize, sizeof(__shared15::default_windowSize));
#else
			    _out_data->x410_mode_parameters.windowSize = 0;
#endif
			}
			if ((_present_flags & 0x4) != 0x4)
			    _oss_dec_error(_g, _field_omit, 0L);
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		    _present_flags |= 0x2;
		}   break;
		case 0x2: {
		    OSS_CNTX_PUSH(_oss_c, 129)
		    if (_out_data->bit_mask & 0x40000000)
			_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		    _out_data->bit_mask |= 0x40000000;
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			int _indef_tags = 0;
			long _total_len = _data_length;
			char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
			OSS_CNTX_INIT

			_out_data->normal_mode_parameters.bit_mask = 0;
			if (_bufpos < _end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x8000 || _bufpos >= _end_pos)
			 {
			    _out_data->normal_mode_parameters.bit_mask &= ~0x80000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
			    memcpy(&_out_data->normal_mode_parameters.protocol_version, &_v633, sizeof(_v633));
#else
			    _out_data->normal_mode_parameters.protocol_version.length = 0;
			    _out_data->normal_mode_parameters.protocol_version.value = nullptr;
#endif
			}
else {
			    _out_data->normal_mode_parameters.bit_mask |= 0x80000000;
			    OSS_CNTX_PUSH(_oss_c, 140)
			    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 128 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_bufpos += 2;
			    } else {
				if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
				} else
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
				_oss_c->_tag_decoded = FALSE;
			    }
			    _data_tag = 0x8000;
			    _out_data->normal_mode_parameters.protocol_version.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->normal_mode_parameters.protocol_version.value, 0, 128);

			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x8003 || _bufpos >= _end_pos)
			 {
			    _out_data->normal_mode_parameters.bit_mask &= ~0x40000000;
			    memset(&_out_data->normal_mode_parameters.responding_presentation_selector, 0, sizeof(_out_data->normal_mode_parameters.responding_presentation_selector));
			}
else {
			    _out_data->normal_mode_parameters.bit_mask |= 0x40000000;
			    OSS_CNTX_PUSH(_oss_c, 147)
			    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 131 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_bufpos += 2;
			    } else {
				if (!_oss_c->_tag_decoded || _data_tag == 0x8003) {
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x83 : 0);
				} else
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80030000);
				_oss_c->_tag_decoded = FALSE;
			    }
			    _data_tag = 0x8003;
			    _out_data->normal_mode_parameters.responding_presentation_selector.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->normal_mode_parameters.responding_presentation_selector.value, 0);
			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x8005 || _bufpos >= _end_pos)
			 {
			    _out_data->normal_mode_parameters.bit_mask &= ~0x20000000;
			    memset(&_out_data->normal_mode_parameters.presentation_context_definition_result_list, 0, sizeof(_out_data->normal_mode_parameters.presentation_context_definition_result_list));
			}
else {
			    _out_data->normal_mode_parameters.bit_mask |= 0x20000000;
			    OSS_CNTX_PUSH(_oss_c, 146)
			    _out_data->normal_mode_parameters.presentation_context_definition_result_list = nullptr;
			    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 165 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				_buflen -= 2;
				_bufpos += 2;
			    } else {
				if (!_oss_c->_tag_decoded || _data_tag == 0x8005) {
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x85 : 0);
				} else
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80050000);
				_oss_c->_tag_decoded = FALSE;
			    }
			    _data_tag = 0x8005;
			    _d_Result_list(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->normal_mode_parameters.presentation_context_definition_result_list);
			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x8008 || _bufpos >= _end_pos)
			 {
			    _out_data->normal_mode_parameters.bit_mask &= ~0x10000000;
			    memset(&_out_data->normal_mode_parameters.presentation_requirements, 0, sizeof(_out_data->normal_mode_parameters.presentation_requirements));
			}
else {
			    _out_data->normal_mode_parameters.bit_mask |= 0x10000000;
			    OSS_CNTX_PUSH(_oss_c, 135)
			    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 136 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_bufpos += 2;
			    } else {
				if (!_oss_c->_tag_decoded || _data_tag == 0x8008) {
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x88 : 0);
				} else
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80080000);
				_oss_c->_tag_decoded = FALSE;
			    }
			    _data_tag = 0x8008;
			    _out_data->normal_mode_parameters.presentation_requirements.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->normal_mode_parameters.presentation_requirements.value, 0, 128);

			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x8009 || _bufpos >= _end_pos)
			 {
			    _out_data->normal_mode_parameters.bit_mask &= ~0x8000000;
			    memset(&_out_data->normal_mode_parameters.user_session_requirements, 0, sizeof(_out_data->normal_mode_parameters.user_session_requirements));
			}
else {
			    _out_data->normal_mode_parameters.bit_mask |= 0x8000000;
			    OSS_CNTX_PUSH(_oss_c, 134)
			    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 137 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_bufpos += 2;
			    } else {
				if (!_oss_c->_tag_decoded || _data_tag == 0x8009) {
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x89 : 0);
				} else
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80090000);
				_oss_c->_tag_decoded = FALSE;
			    }
			    _data_tag = 0x8009;
			    _out_data->normal_mode_parameters.user_session_requirements.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->normal_mode_parameters.user_session_requirements.value, 0, 128);

			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x800B || _bufpos >= _end_pos)
			 {
			    _out_data->normal_mode_parameters.bit_mask &= ~0x4000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
			    memcpy(&_out_data->normal_mode_parameters.protocol_options, &_v634, sizeof(_v634));
#else
			    _out_data->normal_mode_parameters.protocol_options.length = 0;
			    _out_data->normal_mode_parameters.protocol_options.value = nullptr;
#endif
			}
else {
			    _out_data->normal_mode_parameters.bit_mask |= 0x4000000;
			    OSS_CNTX_PUSH(_oss_c, 133)
			    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 171 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				_buflen -= 2;
				_bufpos += 2;
			    } else {
				if (!_oss_c->_tag_decoded || _data_tag == 0x800B) {
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x8B : 0);
				} else
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x800B0000);
				_oss_c->_tag_decoded = FALSE;
			    }
			    _data_tag = 0x800B;
			    if (_data_length < 0) ++_indef_tags;
			    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 3 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_bufpos += 2;
			    } else
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x3);
			    _data_tag = 0x3;
			    _out_data->normal_mode_parameters.protocol_options.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->normal_mode_parameters.protocol_options.value, 0, 128);

			    while (_indef_tags > 0) {
				if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    if (!_buflen || _bufpos[0])
					_oss_dec_error(_g, _expec_eoc, 0L);
				    else
					_oss_dec_error(_g, _non_std_eoc, 0L);
				_indef_tags--;
			    }
			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x800D || _bufpos >= _end_pos)
			 {
			    _out_data->normal_mode_parameters.bit_mask &= ~0x2000000;
			}
else {
			    _out_data->normal_mode_parameters.bit_mask |= 0x2000000;
			    OSS_CNTX_PUSH(_oss_c, 145)
			    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 173 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				_buflen -= 2;
				_bufpos += 2;
			    } else {
				if (!_oss_c->_tag_decoded || _data_tag == 0x800D) {
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x8D : 0);
				} else
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x800D0000);
				_oss_c->_tag_decoded = FALSE;
			    }
			    _data_tag = 0x800D;
			    if (_data_length < 0) ++_indef_tags;
			    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
			    _data_tag = 0x2;
			    _out_data->normal_mode_parameters.responders_nominated_context = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
			    while (_indef_tags > 0) {
				if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    if (!_buflen || _bufpos[0])
					_oss_dec_error(_g, _expec_eoc, 0L);
				    else
					_oss_dec_error(_g, _non_std_eoc, 0L);
				_indef_tags--;
			    }
			    OSS_CNTX_POP(_oss_c)
			}
			if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if ((FALSE)
			    || (_total_len >= 0 && _bufpos >= _end_pos))
			 {
			    _out_data->normal_mode_parameters.bit_mask &= ~0x1000000;
			    memset(&_out_data->normal_mode_parameters.user_data, 0, sizeof(_out_data->normal_mode_parameters.user_data));
			}
else {
			    _out_data->normal_mode_parameters.bit_mask |= 0x1000000;
			    OSS_CNTX_PUSH(_oss_c, 130)
			    _d_User_data(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->normal_mode_parameters.user_data);
			    OSS_CNTX_POP(_oss_c)
			}
			if (_bufpos != _end_pos) {
			    if (_total_len < 0) {
				if (!_oss_c->_tag_decoded)
				    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

				if (_data_tag)
				    _oss_dec_error(_g, _expec_eoc, 0L);
				if (_oss_dec_length(_g, &_bufpos, &_buflen))
				    _oss_dec_error(_g, _non_std_eoc, 0L);
				_oss_c->_tag_decoded = FALSE;
			    } else
				_oss_dec_error(_g, _inconsis_len, 0L);
			}
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		    _present_flags |= 0x4;
		}   break;
		default:
		    _oss_dec_error(_g, _unknown_field, _data_tag);
		}
		break;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!(_present_flags & 0x2)) {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->x410_mode_parameters, 0, sizeof(_out_data->x410_mode_parameters));
	}
	if (!(_present_flags & 0x4)) {
	    _out_data->bit_mask &= ~0x40000000;
	    memset(&_out_data->normal_mode_parameters, 0, sizeof(_out_data->normal_mode_parameters));
	}
	if ((_present_flags & 0x1) != 0x1)
	    _oss_dec_error(_g, _field_omit, 0L);
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpCPA_PPDU(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CPA_PPDU	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(6,144)
    _out_data = (_CPA_PPDU *)_oss_dec_const_alloc(_g, sizeof(_CPA_PPDU));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_2bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 142)
	_dp_Mode_selector(_g, &_out_data->mode_selector);
	OSS_CNTX_SET(141)
	if (_out_data->bit_mask & 0x80000000) {
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_out_data->x410_mode_parameters.bit_mask = (OSS_UINT32)_oss_get_2bit_unaligned(_g) << 24;
		OSS_CNTX_PUSH(_oss_c, 48)
		if (_out_data->x410_mode_parameters.bit_mask & 0x80000000) {
		    _out_data->x410_mode_parameters.checkpointSize = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
		    memcpy(&_out_data->x410_mode_parameters.checkpointSize, &__shared15::default_checkpointSize, sizeof(__shared15::default_checkpointSize));
#else
		    _out_data->x410_mode_parameters.checkpointSize = 0;
#endif
		}
		OSS_CNTX_SET(47)
		if (_out_data->x410_mode_parameters.bit_mask & 0x40000000) {
		    _out_data->x410_mode_parameters.windowSize = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
		    memcpy(&_out_data->x410_mode_parameters.windowSize, &__shared15::default_windowSize, sizeof(__shared15::default_windowSize));
#else
		    _out_data->x410_mode_parameters.windowSize = 0;
#endif
		}
		OSS_CNTX_SET(49)
		_dp_ConnectionData(_g, &_out_data->x410_mode_parameters.connectionDataAC);
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	} else {
	    memset(&(_out_data->x410_mode_parameters), 0, sizeof(_set2 ));
	}
	OSS_CNTX_SET(129)
	if (_out_data->bit_mask & 0x40000000) {
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_out_data->normal_mode_parameters.bit_mask = (OSS_UINT32)_oss_get_8bit_unaligned(_g) << 24;
		OSS_CNTX_PUSH(_oss_c, 140)
		if (_out_data->normal_mode_parameters.bit_mask & 0x80000000) {
		    _out_data->normal_mode_parameters.protocol_version.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->normal_mode_parameters.protocol_version.value);

		} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
		    memcpy(&_out_data->normal_mode_parameters.protocol_version, &_v633, sizeof(_v633));
#else
		    _out_data->normal_mode_parameters.protocol_version.length = 0;
		    _out_data->normal_mode_parameters.protocol_version.value = nullptr;
#endif
		}
		OSS_CNTX_SET(147)
		if (_out_data->normal_mode_parameters.bit_mask & 0x40000000) {
		    if (_oss_get_1bit_unaligned(_g)) {
			_out_data->normal_mode_parameters.responding_presentation_selector.length = _oss_pdec_unconstr_uoct_ia(_g, (unsigned char **)&_out_data->normal_mode_parameters.responding_presentation_selector.value);

		    } else {
			_out_data->normal_mode_parameters.responding_presentation_selector.length = _oss_pdec_constr_uoct_ia(_g, (unsigned char **)&_out_data->normal_mode_parameters.responding_presentation_selector.value, 1, 4);

		    }
		} else {
		    _out_data->normal_mode_parameters.responding_presentation_selector.length = 0;
		    _out_data->normal_mode_parameters.responding_presentation_selector.value = nullptr;
		}
		OSS_CNTX_SET(146)
		_out_data->normal_mode_parameters.presentation_context_definition_result_list = nullptr;
		if (_out_data->normal_mode_parameters.bit_mask & 0x20000000) {
		    _dp_Result_list(_g, &_out_data->normal_mode_parameters.presentation_context_definition_result_list);
		} else {
		    _out_data->normal_mode_parameters.presentation_context_definition_result_list = nullptr;
		}
		OSS_CNTX_SET(135)
		if (_out_data->normal_mode_parameters.bit_mask & 0x10000000) {
		    _out_data->normal_mode_parameters.presentation_requirements.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->normal_mode_parameters.presentation_requirements.value);

		} else {
		    _out_data->normal_mode_parameters.presentation_requirements.length = 0;
		    _out_data->normal_mode_parameters.presentation_requirements.value = nullptr;
		}
		OSS_CNTX_SET(134)
		if (_out_data->normal_mode_parameters.bit_mask & 0x8000000) {
		    _out_data->normal_mode_parameters.user_session_requirements.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->normal_mode_parameters.user_session_requirements.value);

		} else {
		    _out_data->normal_mode_parameters.user_session_requirements.length = 0;
		    _out_data->normal_mode_parameters.user_session_requirements.value = nullptr;
		}
		OSS_CNTX_SET(133)
		if (_out_data->normal_mode_parameters.bit_mask & 0x4000000) {
		    _out_data->normal_mode_parameters.protocol_options.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->normal_mode_parameters.protocol_options.value);

		} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
		    memcpy(&_out_data->normal_mode_parameters.protocol_options, &_v634, sizeof(_v634));
#else
		    _out_data->normal_mode_parameters.protocol_options.length = 0;
		    _out_data->normal_mode_parameters.protocol_options.value = nullptr;
#endif
		}
		OSS_CNTX_SET(145)
		if (_out_data->normal_mode_parameters.bit_mask & 0x2000000) {
		    if (_oss_get_1bit_unaligned(_g)) {
			_out_data->normal_mode_parameters.responders_nominated_context = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		    } else {
			_out_data->normal_mode_parameters.responders_nominated_context = (OSS_INT32)_oss_pdec_nonneg_7int(_g) + 1;
		    }
		}
		OSS_CNTX_SET(130)
		if (_out_data->normal_mode_parameters.bit_mask & 0x1000000) {
		    _dp_User_data(_g, &_out_data->normal_mode_parameters.user_data);
		} else {
		    memset(&(_out_data->normal_mode_parameters.user_data), 0, sizeof(_User_data ));
		}
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	} else {
	    memset(&(_out_data->normal_mode_parameters), 0, sizeof(_seq4 ));
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dCPR_PPDU(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CPR_PPDU *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(7,148)
    _out_data = (_CPR_PPDU *)_oss_dec_const_alloc(_g, sizeof(_CPR_PPDU));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	switch (_data_tag) {
	case 0x10: {
	    OSS_CNTX_PUSH(_oss_c, 129)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.normal_mode_parameters = (_seq5 *)_oss_dec_const_alloc(_g, sizeof(_seq5));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		OSS_CNTX_INIT

		_out_data->u.normal_mode_parameters->bit_mask = 0;
		if (_bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8000 || _bufpos >= _end_pos)
		 {
		    _out_data->u.normal_mode_parameters->bit_mask &= ~0x80000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
		    memcpy(&_out_data->u.normal_mode_parameters->protocol_version, &_v635, sizeof(_v635));
#else
		    _out_data->u.normal_mode_parameters->protocol_version.length = 0;
		    _out_data->u.normal_mode_parameters->protocol_version.value = nullptr;
#endif
		}
else {
		    _out_data->u.normal_mode_parameters->bit_mask |= 0x80000000;
		    OSS_CNTX_PUSH(_oss_c, 140)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 128 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8000;
		    _out_data->u.normal_mode_parameters->protocol_version.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.normal_mode_parameters->protocol_version.value, 0, 128);

		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8003 || _bufpos >= _end_pos)
		 {
		    _out_data->u.normal_mode_parameters->bit_mask &= ~0x40000000;
		    memset(&_out_data->u.normal_mode_parameters->responding_presentation_selector, 0, sizeof(_out_data->u.normal_mode_parameters->responding_presentation_selector));
		}
else {
		    _out_data->u.normal_mode_parameters->bit_mask |= 0x40000000;
		    OSS_CNTX_PUSH(_oss_c, 147)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 131 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8003) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x83 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80030000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8003;
		    _out_data->u.normal_mode_parameters->responding_presentation_selector.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.normal_mode_parameters->responding_presentation_selector.value, 0);
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8005 || _bufpos >= _end_pos)
		 {
		    _out_data->u.normal_mode_parameters->bit_mask &= ~0x20000000;
		    memset(&_out_data->u.normal_mode_parameters->presentation_context_definition_result_list, 0, sizeof(_out_data->u.normal_mode_parameters->presentation_context_definition_result_list));
		}
else {
		    _out_data->u.normal_mode_parameters->bit_mask |= 0x20000000;
		    OSS_CNTX_PUSH(_oss_c, 146)
		    _out_data->u.normal_mode_parameters->presentation_context_definition_result_list = nullptr;
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 165 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8005) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x85 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80050000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8005;
		    _d_Result_list(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.normal_mode_parameters->presentation_context_definition_result_list);
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8007 || _bufpos >= _end_pos)
		 {
		    _out_data->u.normal_mode_parameters->bit_mask &= ~0x10000000;
		}
else {
		    _out_data->u.normal_mode_parameters->bit_mask |= 0x10000000;
		    OSS_CNTX_PUSH(_oss_c, 150)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 135 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8007) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x87 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80070000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8007;
		    _out_data->u.normal_mode_parameters->default_context_result = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x800A || _bufpos >= _end_pos)
		 {
		    _out_data->u.normal_mode_parameters->bit_mask &= ~0x8000000;
		}
else {
		    _out_data->u.normal_mode_parameters->bit_mask |= 0x8000000;
		    OSS_CNTX_PUSH(_oss_c, 149)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 138 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x800A) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x8A : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x800A0000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x800A;
		    _out_data->u.normal_mode_parameters->provider_reason = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if ((FALSE)
		    || (_total_len >= 0 && _bufpos >= _end_pos))
		 {
		    _out_data->u.normal_mode_parameters->bit_mask &= ~0x4000000;
		    memset(&_out_data->u.normal_mode_parameters->user_data, 0, sizeof(_out_data->u.normal_mode_parameters->user_data));
		}
else {
		    _out_data->u.normal_mode_parameters->bit_mask |= 0x4000000;
		    OSS_CNTX_PUSH(_oss_c, 130)
		    _d_User_data(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.normal_mode_parameters->user_data);
		    OSS_CNTX_POP(_oss_c)
		}
		if (_bufpos != _end_pos) {
		    if (_total_len < 0) {
			if (!_oss_c->_tag_decoded)
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			if (_data_tag)
			    _oss_dec_error(_g, _expec_eoc, 0L);
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
		    } else
			_oss_dec_error(_g, _inconsis_len, 0L);
		}
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	}   break;
	case 0x11: {
	    OSS_CNTX_PUSH(_oss_c, 151)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.x400_mode_parameters = (_set3 *)_oss_dec_const_alloc(_g, sizeof(_set3));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		int _indef_tags = 0;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		unsigned short _present_flags = 0;
		OSS_CNTX_DEF
		OSS_CNTX_SETOCC(0)
		_out_data->u.x400_mode_parameters->bit_mask = 0;
		for (;;) {
		    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos > _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
		    switch (_data_tag) {
		    default:
			if (!(_data_tag & 0x8000))
			    _oss_dec_error(_g, _unknown_field, _data_tag);
			switch (_data_tag & 0x7fff) {
			case 0x0: {
			    OSS_CNTX_PUSH(_oss_c, 51)
			    if (_out_data->u.x400_mode_parameters->bit_mask & 0x80000000)
				_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
			    _out_data->u.x400_mode_parameters->bit_mask |= 0x80000000;
			    _oss_c->_tag_decoded = FALSE;
			    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				_buflen--;
				_bufpos++;
			    } else
				_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			    _out_data->u.x400_mode_parameters->refuseReason = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
			    _present_flags |= 0x1;
			}   break;
			case 0x1: {
			    OSS_CNTX_PUSH(_oss_c, 50)
			    if (_out_data->u.x400_mode_parameters->bit_mask & 0x40000000)
				_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
			    _out_data->u.x400_mode_parameters->bit_mask |= 0x40000000;
			    _oss_c->_tag_decoded = FALSE;
			    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				_buflen--;
				_bufpos++;
			    } else
				_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			    if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
			    _out_data->u.x400_mode_parameters->userDataRJ.userField = nullptr;
#endif
			    _oss_dec_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.x400_mode_parameters->userDataRJ);
			    while (_indef_tags > 0) {
				if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    if (!_buflen || _bufpos[0])
					_oss_dec_error(_g, _expec_eoc, 0L);
				    else
					_oss_dec_error(_g, _non_std_eoc, 0L);
				_indef_tags--;
			    }
			    _present_flags |= 0x2;
			}   break;
			default:
			    _oss_dec_error(_g, _unknown_field, _data_tag);
			}
			break;
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		if (!(_present_flags & 0x1)) {
		    _out_data->u.x400_mode_parameters->bit_mask &= ~0x80000000;
		}
		if (!(_present_flags & 0x2)) {
		    _out_data->u.x400_mode_parameters->bit_mask &= ~0x40000000;
		    memset(&_out_data->u.x400_mode_parameters->userDataRJ, 0, sizeof(_out_data->u.x400_mode_parameters->userDataRJ));
		}
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	}   break;
	default:
	    _oss_dec_error(_g, _unknown_field, _data_tag);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpCPR_PPDU(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CPR_PPDU	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(7,148)
    _out_data = (_CPR_PPDU *)_oss_dec_const_alloc(_g, sizeof(_CPR_PPDU));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 129)
	    _out_data->u.normal_mode_parameters = (_seq5 *)_oss_dec_const_alloc(_g, sizeof(_seq5));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_out_data->u.normal_mode_parameters->bit_mask = (OSS_UINT32)_oss_get_6bit_unaligned(_g) << 24;
		OSS_CNTX_PUSH(_oss_c, 140)
		if (_out_data->u.normal_mode_parameters->bit_mask & 0x80000000) {
		    _out_data->u.normal_mode_parameters->protocol_version.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->u.normal_mode_parameters->protocol_version.value);

		} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
		    memcpy(&_out_data->u.normal_mode_parameters->protocol_version, &_v635, sizeof(_v635));
#else
		    _out_data->u.normal_mode_parameters->protocol_version.length = 0;
		    _out_data->u.normal_mode_parameters->protocol_version.value = nullptr;
#endif
		}
		OSS_CNTX_SET(147)
		if (_out_data->u.normal_mode_parameters->bit_mask & 0x40000000) {
		    if (_oss_get_1bit_unaligned(_g)) {
			_out_data->u.normal_mode_parameters->responding_presentation_selector.length = _oss_pdec_unconstr_uoct_ia(_g, (unsigned char **)&_out_data->u.normal_mode_parameters->responding_presentation_selector.value);

		    } else {
			_out_data->u.normal_mode_parameters->responding_presentation_selector.length = _oss_pdec_constr_uoct_ia(_g, (unsigned char **)&_out_data->u.normal_mode_parameters->responding_presentation_selector.value, 1, 4);

		    }
		} else {
		    _out_data->u.normal_mode_parameters->responding_presentation_selector.length = 0;
		    _out_data->u.normal_mode_parameters->responding_presentation_selector.value = nullptr;
		}
		OSS_CNTX_SET(146)
		_out_data->u.normal_mode_parameters->presentation_context_definition_result_list = nullptr;
		if (_out_data->u.normal_mode_parameters->bit_mask & 0x20000000) {
		    _dp_Result_list(_g, &_out_data->u.normal_mode_parameters->presentation_context_definition_result_list);
		} else {
		    _out_data->u.normal_mode_parameters->presentation_context_definition_result_list = nullptr;
		}
		OSS_CNTX_SET(150)
		if (_out_data->u.normal_mode_parameters->bit_mask & 0x10000000) {
		    _out_data->u.normal_mode_parameters->default_context_result = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		}
		OSS_CNTX_SET(149)
		if (_out_data->u.normal_mode_parameters->bit_mask & 0x8000000) {
		    _out_data->u.normal_mode_parameters->provider_reason = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		}
		OSS_CNTX_SET(130)
		if (_out_data->u.normal_mode_parameters->bit_mask & 0x4000000) {
		    _dp_User_data(_g, &_out_data->u.normal_mode_parameters->user_data);
		} else {
		    memset(&(_out_data->u.normal_mode_parameters->user_data), 0, sizeof(_User_data ));
		}
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 151)
	    _out_data->u.x400_mode_parameters = (_set3 *)_oss_dec_const_alloc(_g, sizeof(_set3));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_out_data->u.x400_mode_parameters->bit_mask = (OSS_UINT32)_oss_get_2bit_unaligned(_g) << 24;
		OSS_CNTX_PUSH(_oss_c, 51)
		if (_out_data->u.x400_mode_parameters->bit_mask & 0x80000000) {
		    _out_data->u.x400_mode_parameters->refuseReason = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		}
		OSS_CNTX_SET(50)
		if (_out_data->u.x400_mode_parameters->bit_mask & 0x40000000) {
#ifdef OSS_OPENTYPE_HAS_USERFIELD
		    _out_data->u.x400_mode_parameters->userDataRJ.userField = nullptr;
#endif
		    _oss_pdec_opentype(_g, &_out_data->u.x400_mode_parameters->userDataRJ);
		} else {
		    memset(&(_out_data->u.x400_mode_parameters->userDataRJ), 0, sizeof(OSSC::COssOpen ));
		}
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dAbort_type(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Abort_type *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(8,152)
    _out_data = (_Abort_type *)_oss_dec_const_alloc(_g, sizeof(_Abort_type));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	if (_data_tag == 0x11 || _data_tag == 0x8000) {
	    OSS_CNTX_PUSH(_oss_c, 156)
	    _out_data->choice = 2;
	    _out_data->u.aru_ppdu = (_ARU_PPDU *)_oss_dec_const_alloc(_g, sizeof(_ARU_PPDU));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		OSS_CNTX_INIT

		switch (_data_tag) {
		case 0x11: {
		    OSS_CNTX_PUSH(_oss_c, 151)
		    _out_data->u.aru_ppdu->choice = 1;
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _out_data->u.aru_ppdu->u.x400_mode_parameters = (_set4 *)_oss_dec_const_alloc(_g, sizeof(_set4));
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			int _indef_tags = 0;
			long _total_len = _data_length;
			char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
			unsigned short _present_flags = 0;
			OSS_CNTX_DEF
			OSS_CNTX_SETOCC(0)
			_out_data->u.aru_ppdu->u.x400_mode_parameters->bit_mask = 0;
			for (;;) {
			    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
				if (_bufpos > _end_pos)
				    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
				break;
			    }
			    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
				_bufpos++;
			    } else
				if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
				    if (_oss_dec_length(_g, &_bufpos, &_buflen))
					_oss_dec_error(_g, _non_std_eoc, 0L);
				    _oss_c->_tag_decoded = FALSE;
				    break;
				}
			    _oss_c->_tag_decoded = TRUE;
			    switch (_data_tag) {
			    default:
				if (!(_data_tag & 0x8000))
				    _oss_dec_error(_g, _unknown_field, _data_tag);
				switch (_data_tag & 0x7fff) {
				case 0x0: {
				    OSS_CNTX_PUSH(_oss_c, 159)
				    if (_out_data->u.aru_ppdu->u.x400_mode_parameters->bit_mask & 0x80000000)
					_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
				    _out_data->u.aru_ppdu->u.x400_mode_parameters->bit_mask |= 0x80000000;
				    _oss_c->_tag_decoded = FALSE;
				    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					_buflen--;
					_bufpos++;
				    } else
					_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				    _out_data->u.aru_ppdu->u.x400_mode_parameters->abortReason = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
				    _present_flags |= 0x1;
				}   break;
				case 0x1: {
				    OSS_CNTX_PUSH(_oss_c, 158)
				    if (_out_data->u.aru_ppdu->u.x400_mode_parameters->bit_mask & 0x40000000)
					_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
				    _out_data->u.aru_ppdu->u.x400_mode_parameters->bit_mask |= 0x40000000;
				    _oss_c->_tag_decoded = FALSE;
				    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					_buflen--;
					_bufpos++;
				    } else
					_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				    _out_data->u.aru_ppdu->u.x400_mode_parameters->reflectedParameter.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.aru_ppdu->u.x400_mode_parameters->reflectedParameter.value, 0, 0);

				    _present_flags |= 0x2;
				}   break;
				case 0x2: {
				    OSS_CNTX_PUSH(_oss_c, 157)
				    if (_out_data->u.aru_ppdu->u.x400_mode_parameters->bit_mask & 0x20000000)
					_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
				    _out_data->u.aru_ppdu->u.x400_mode_parameters->bit_mask |= 0x20000000;
				    _oss_c->_tag_decoded = FALSE;
				    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					_buflen--;
					_bufpos++;
				    } else
					_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				    if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
				    _out_data->u.aru_ppdu->u.x400_mode_parameters->userdataAB.userField = nullptr;
#endif
				    _oss_dec_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.aru_ppdu->u.x400_mode_parameters->userdataAB);
				    while (_indef_tags > 0) {
					if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
					    _buflen -= 2;
					    _bufpos += 2;
					} else
					    if (!_buflen || _bufpos[0])
						_oss_dec_error(_g, _expec_eoc, 0L);
					    else
						_oss_dec_error(_g, _non_std_eoc, 0L);
					_indef_tags--;
				    }
				    _present_flags |= 0x4;
				}   break;
				default:
				    _oss_dec_error(_g, _unknown_field, _data_tag);
				}
				break;
			    }
			    OSS_CNTX_POP(_oss_c)
			}
			if (!(_present_flags & 0x1)) {
			    _out_data->u.aru_ppdu->u.x400_mode_parameters->bit_mask &= ~0x80000000;
			}
			if (!(_present_flags & 0x2)) {
			    _out_data->u.aru_ppdu->u.x400_mode_parameters->bit_mask &= ~0x40000000;
			    memset(&_out_data->u.aru_ppdu->u.x400_mode_parameters->reflectedParameter, 0, sizeof(_out_data->u.aru_ppdu->u.x400_mode_parameters->reflectedParameter));
			}
			if (!(_present_flags & 0x4)) {
			    _out_data->u.aru_ppdu->u.x400_mode_parameters->bit_mask &= ~0x20000000;
			    memset(&_out_data->u.aru_ppdu->u.x400_mode_parameters->userdataAB, 0, sizeof(_out_data->u.aru_ppdu->u.x400_mode_parameters->userdataAB));
			}
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		}   break;
		default:
		    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
		    switch (_data_tag & 0x7fff) {
		    case 0x0: {
			OSS_CNTX_PUSH(_oss_c, 129)
			_out_data->u.aru_ppdu->choice = 2;

			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			_out_data->u.aru_ppdu->u.normal_mode_parameters = (_seq6 *)_oss_dec_const_alloc(_g, sizeof(_seq6));
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			{
			    long _total_len = _data_length;
			    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
			    OSS_CNTX_INIT

			    _out_data->u.aru_ppdu->u.normal_mode_parameters->bit_mask = 0;
			    if (_bufpos < _end_pos) {
				if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				    _buflen--;
				    _oss_c->_bitpos = _bufpos[0] & 0x20;
				    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				    _bufpos++;
				} else
				    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
				_oss_c->_tag_decoded = TRUE;
			    }
			    if (_data_tag != 0x8000 || _bufpos >= _end_pos)
			     {
				_out_data->u.aru_ppdu->u.normal_mode_parameters->bit_mask &= ~0x80000000;
				memset(&_out_data->u.aru_ppdu->u.normal_mode_parameters->presentation_context_identifier_list, 0, sizeof(_out_data->u.aru_ppdu->u.normal_mode_parameters->presentation_context_identifier_list));
			    }
else {
				_out_data->u.aru_ppdu->u.normal_mode_parameters->bit_mask |= 0x80000000;
				OSS_CNTX_PUSH(_oss_c, 160)
				_out_data->u.aru_ppdu->u.normal_mode_parameters->presentation_context_identifier_list = nullptr;
				if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else {
				    if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
					_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
				    } else
					_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
				    _oss_c->_tag_decoded = FALSE;
				}
				_data_tag = 0x8000;
				_d_14Presentation_context_ident(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.aru_ppdu->u.normal_mode_parameters->presentation_context_identifier_list);
				OSS_CNTX_POP(_oss_c)
			    }
			    if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
				if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				    _buflen--;
				    _oss_c->_bitpos = _bufpos[0] & 0x20;
				    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				    _bufpos++;
				} else
				    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
				_oss_c->_tag_decoded = TRUE;
			    }
			    if ((FALSE)
				|| (_total_len >= 0 && _bufpos >= _end_pos))
			     {
				_out_data->u.aru_ppdu->u.normal_mode_parameters->bit_mask &= ~0x40000000;
				memset(&_out_data->u.aru_ppdu->u.normal_mode_parameters->user_data, 0, sizeof(_out_data->u.aru_ppdu->u.normal_mode_parameters->user_data));
			    }
else {
				_out_data->u.aru_ppdu->u.normal_mode_parameters->bit_mask |= 0x40000000;
				OSS_CNTX_PUSH(_oss_c, 130)
				_d_User_data(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.aru_ppdu->u.normal_mode_parameters->user_data);
				OSS_CNTX_POP(_oss_c)
			    }
			    if (_bufpos != _end_pos) {
				if (_total_len < 0) {
				    if (!_oss_c->_tag_decoded)
					_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

				    if (_data_tag)
					_oss_dec_error(_g, _expec_eoc, 0L);
				    if (_oss_dec_length(_g, &_bufpos, &_buflen))
					_oss_dec_error(_g, _non_std_eoc, 0L);
				    _oss_c->_tag_decoded = FALSE;
				} else
				    _oss_dec_error(_g, _inconsis_len, 0L);
			    }
			}
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		    }   break;
		    default:
			_oss_dec_error(_g, _unknown_field, _data_tag);
		    }
		    break;
		}
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    OSS_CNTX_POP(_oss_c)
	} else
	switch (_data_tag) {
	case 0x10: {
	    OSS_CNTX_PUSH(_oss_c, 153)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.arp_ppdu = (_ARP_PPDU *)_oss_dec_const_alloc(_g, sizeof(_ARP_PPDU));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		OSS_CNTX_INIT

		_out_data->u.arp_ppdu->bit_mask = 0;
		if (_bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8000 || _bufpos >= _end_pos)
		 {
		    _out_data->u.arp_ppdu->bit_mask &= ~0x80000000;
		}
else {
		    _out_data->u.arp_ppdu->bit_mask |= 0x80000000;
		    OSS_CNTX_PUSH(_oss_c, 155)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 128 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8000;
		    _out_data->u.arp_ppdu->provider_reason = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8001 || _bufpos >= _end_pos)
		 {
		    _out_data->u.arp_ppdu->bit_mask &= ~0x40000000;
		}
else {
		    _out_data->u.arp_ppdu->bit_mask |= 0x40000000;
		    OSS_CNTX_PUSH(_oss_c, 154)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 129 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8001) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x81 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80010000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8001;
		    _out_data->u.arp_ppdu->event_identifier = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		    OSS_CNTX_POP(_oss_c)
		}
		if (_bufpos != _end_pos) {
		    if (_total_len < 0) {
			if (!_oss_c->_tag_decoded)
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			if (_data_tag)
			    _oss_dec_error(_g, _expec_eoc, 0L);
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
		    } else
			_oss_dec_error(_g, _inconsis_len, 0L);
		}
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	}   break;
	default:
	    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
	    switch (_data_tag & 0x7fff) {
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    break;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpAbort_type(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Abort_type	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(8,152)
    _out_data = (_Abort_type *)_oss_dec_const_alloc(_g, sizeof(_Abort_type));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 153)
	    _out_data->u.arp_ppdu = (_ARP_PPDU *)_oss_dec_const_alloc(_g, sizeof(_ARP_PPDU));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_out_data->u.arp_ppdu->bit_mask = (OSS_UINT32)_oss_get_2bit_unaligned(_g) << 24;
		OSS_CNTX_PUSH(_oss_c, 155)
		if (_out_data->u.arp_ppdu->bit_mask & 0x80000000) {
		    _out_data->u.arp_ppdu->provider_reason = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		}
		OSS_CNTX_SET(154)
		if (_out_data->u.arp_ppdu->bit_mask & 0x40000000) {
		    _out_data->u.arp_ppdu->event_identifier = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		}
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 156)
	    _out_data->u.aru_ppdu = (_ARU_PPDU *)_oss_dec_const_alloc(_g, sizeof(_ARU_PPDU));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		OSS_CNTX_INIT

		{

		    _out_data->u.aru_ppdu->choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
		}
		switch (_out_data->u.aru_ppdu->choice) {
		case 1:
		    OSS_CNTX_PUSH(_oss_c, 151)
		    _out_data->u.aru_ppdu->u.x400_mode_parameters = (_set4 *)_oss_dec_const_alloc(_g, sizeof(_set4));
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			OSS_CNTX_INIT

			_out_data->u.aru_ppdu->u.x400_mode_parameters->bit_mask = (OSS_UINT32)_oss_get_3bit_unaligned(_g) << 24;
			OSS_CNTX_PUSH(_oss_c, 159)
			if (_out_data->u.aru_ppdu->u.x400_mode_parameters->bit_mask & 0x80000000) {
			    _out_data->u.aru_ppdu->u.x400_mode_parameters->abortReason = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
			}
			OSS_CNTX_SET(158)
			if (_out_data->u.aru_ppdu->u.x400_mode_parameters->bit_mask & 0x40000000) {
			    _out_data->u.aru_ppdu->u.x400_mode_parameters->reflectedParameter.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->u.aru_ppdu->u.x400_mode_parameters->reflectedParameter.value);

			} else {
			    _out_data->u.aru_ppdu->u.x400_mode_parameters->reflectedParameter.length = 0;
			    _out_data->u.aru_ppdu->u.x400_mode_parameters->reflectedParameter.value = nullptr;
			}
			OSS_CNTX_SET(157)
			if (_out_data->u.aru_ppdu->u.x400_mode_parameters->bit_mask & 0x20000000) {
#ifdef OSS_OPENTYPE_HAS_USERFIELD
			    _out_data->u.aru_ppdu->u.x400_mode_parameters->userdataAB.userField = nullptr;
#endif
			    _oss_pdec_opentype(_g, &_out_data->u.aru_ppdu->u.x400_mode_parameters->userdataAB);
			} else {
			    memset(&(_out_data->u.aru_ppdu->u.x400_mode_parameters->userdataAB), 0, sizeof(OSSC::COssOpen ));
			}
			OSS_CNTX_POP(_oss_c)
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		    break;
		case 2:
		    OSS_CNTX_PUSH(_oss_c, 129)
		    _out_data->u.aru_ppdu->u.normal_mode_parameters = (_seq6 *)_oss_dec_const_alloc(_g, sizeof(_seq6));
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			OSS_CNTX_INIT

			_out_data->u.aru_ppdu->u.normal_mode_parameters->bit_mask = (OSS_UINT32)_oss_get_2bit_unaligned(_g) << 24;
			OSS_CNTX_PUSH(_oss_c, 160)
			_out_data->u.aru_ppdu->u.normal_mode_parameters->presentation_context_identifier_list = nullptr;
			if (_out_data->u.aru_ppdu->u.normal_mode_parameters->bit_mask & 0x80000000) {
			    _dp_14Presentation_context_ident(_g, &_out_data->u.aru_ppdu->u.normal_mode_parameters->presentation_context_identifier_list);
			} else {
			    _out_data->u.aru_ppdu->u.normal_mode_parameters->presentation_context_identifier_list = nullptr;
			}
			OSS_CNTX_SET(130)
			if (_out_data->u.aru_ppdu->u.normal_mode_parameters->bit_mask & 0x40000000) {
			    _dp_User_data(_g, &_out_data->u.aru_ppdu->u.normal_mode_parameters->user_data);
			} else {
			    memset(&(_out_data->u.aru_ppdu->u.normal_mode_parameters->user_data), 0, sizeof(_User_data ));
			}
			OSS_CNTX_POP(_oss_c)
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		    break;
		default:
		    _oss_enc_error(_g, _bad_choice, _out_data->u.aru_ppdu->choice);	/* Bad choice selector. */
		}
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dTyped_data_type(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Typed_data_type *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(9,161)
    _out_data = (_Typed_data_type *)_oss_dec_const_alloc(_g, sizeof(_Typed_data_type));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	if (_data_tag == 0x4000 || _data_tag == 0x4001 ||
	    (_data_tag != 0x4000 && _data_tag != 0x4001 && _data_tag != 0x8000 && _data_tag != 0x8001 && TRUE)) {
	    OSS_CNTX_PUSH(_oss_c, 162)
	    _out_data->choice = 1;
	    _out_data->u.ttdPPDU = (_User_data *)_oss_dec_const_alloc(_g, sizeof(_User_data));
	    _d_User_data(_g, &_bufpos, &_buflen, 0, _data_tag, _out_data->u.ttdPPDU);
	    OSS_CNTX_POP(_oss_c)
	} else
	switch (_data_tag) {
	default:
	    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
	    switch (_data_tag & 0x7fff) {
	    case 0x0: {
		OSS_CNTX_PUSH(_oss_c, 163)
		_out_data->choice = 2;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.acPPDU = (_AC_PPDU *)_oss_dec_const_alloc(_g, sizeof(_AC_PPDU));
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    OSS_CNTX_INIT

		    _out_data->u.acPPDU->bit_mask = 0;
		    if (_bufpos < _end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if (_data_tag != 0x8000 || _bufpos >= _end_pos)
		     {
			_out_data->u.acPPDU->bit_mask &= ~0x80000000;
			memset(&_out_data->u.acPPDU->presentation_context_addition_list, 0, sizeof(_out_data->u.acPPDU->presentation_context_addition_list));
		    }
else {
			_out_data->u.acPPDU->bit_mask |= 0x80000000;
			OSS_CNTX_PUSH(_oss_c, 166)
			_out_data->u.acPPDU->presentation_context_addition_list = nullptr;
			if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else {
			    if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
			    } else
				_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
			    _oss_c->_tag_decoded = FALSE;
			}
			_data_tag = 0x8000;
			_d_Context_list(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.acPPDU->presentation_context_addition_list);
			OSS_CNTX_POP(_oss_c)
		    }
		    if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if (_data_tag != 0x8001 || _bufpos >= _end_pos)
		     {
			_out_data->u.acPPDU->bit_mask &= ~0x40000000;
			memset(&_out_data->u.acPPDU->presentation_context_deletion_list, 0, sizeof(_out_data->u.acPPDU->presentation_context_deletion_list));
		    }
else {
			_out_data->u.acPPDU->bit_mask |= 0x40000000;
			OSS_CNTX_PUSH(_oss_c, 164)
			_out_data->u.acPPDU->presentation_context_deletion_list = nullptr;
			if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else {
			    if (!_oss_c->_tag_decoded || _data_tag == 0x8001) {
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x81 : 0);
			    } else
				_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80010000);
			    _oss_c->_tag_decoded = FALSE;
			}
			_data_tag = 0x8001;
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			{
			    _Presentation_context_deletion_list * _temp = (_Presentation_context_deletion_list *)&_out_data->u.acPPDU->presentation_context_deletion_list;
			    long _total_len = _data_length;
			    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
			    unsigned long count = 0;
#endif
			    OSS_CNTX_INIT

			    OSS_CNTX_PUSH(_oss_c, 165)
			    for (;;) {
				if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
				    if (_bufpos > _end_pos)
					_oss_dec_error(_g, _inconsis_len, 0L);
#endif
				    break;
				}
				if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
				    _buflen--;
				    _oss_c->_bitpos = _bufpos[0] & 0x20;
				    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
				    _bufpos++;
				} else
				    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
					if (_oss_dec_length(_g, &_bufpos, &_buflen))
					    _oss_dec_error(_g, _non_std_eoc, 0L);
					_oss_c->_tag_decoded = FALSE;
					break;
				    }
				_oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
				count++;
#endif
				if (_data_tag != 0x2)
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x20000);
				_temp->next = (_Presentation_context_deletion_list *)_oss_dec_const_alloc(_g, sizeof(_Presentation_context_deletion_list));
				_temp = _temp->next;
				OSS_CNTX_SETOCC(count)
				_oss_c->_tag_decoded = FALSE;
				if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				    _buflen--;
				    _bufpos++;
				} else
				    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				_temp->value = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
			    }
			    _temp->next = nullptr;
			    OSS_CNTX_POP(_oss_c)
			}
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			OSS_CNTX_POP(_oss_c)
		    }
		    if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if ((FALSE)
			|| (_total_len >= 0 && _bufpos >= _end_pos))
		     {
			_out_data->u.acPPDU->bit_mask &= ~0x20000000;
			memset(&_out_data->u.acPPDU->user_data, 0, sizeof(_out_data->u.acPPDU->user_data));
		    }
else {
			_out_data->u.acPPDU->bit_mask |= 0x20000000;
			OSS_CNTX_PUSH(_oss_c, 130)
			_d_User_data(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.acPPDU->user_data);
			OSS_CNTX_POP(_oss_c)
		    }
		    if (_bufpos != _end_pos) {
			if (_total_len < 0) {
			    if (!_oss_c->_tag_decoded)
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			    if (_data_tag)
				_oss_dec_error(_g, _expec_eoc, 0L);
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			} else
			    _oss_dec_error(_g, _inconsis_len, 0L);
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    }   break;
	    case 0x1: {
		OSS_CNTX_PUSH(_oss_c, 167)
		_out_data->choice = 3;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.acaPPDU = (_ACA_PPDU *)_oss_dec_const_alloc(_g, sizeof(_ACA_PPDU));
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    OSS_CNTX_INIT

		    _out_data->u.acaPPDU->bit_mask = 0;
		    if (_bufpos < _end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if (_data_tag != 0x8000 || _bufpos >= _end_pos)
		     {
			_out_data->u.acaPPDU->bit_mask &= ~0x80000000;
			memset(&_out_data->u.acaPPDU->presentation_context_addition_result_list, 0, sizeof(_out_data->u.acaPPDU->presentation_context_addition_result_list));
		    }
else {
			_out_data->u.acaPPDU->bit_mask |= 0x80000000;
			OSS_CNTX_PUSH(_oss_c, 169)
			_out_data->u.acaPPDU->presentation_context_addition_result_list = nullptr;
			if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else {
			    if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
			    } else
				_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
			    _oss_c->_tag_decoded = FALSE;
			}
			_data_tag = 0x8000;
			_d_Result_list(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.acaPPDU->presentation_context_addition_result_list);
			OSS_CNTX_POP(_oss_c)
		    }
		    if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if (_data_tag != 0x8001 || _bufpos >= _end_pos)
		     {
			_out_data->u.acaPPDU->bit_mask &= ~0x40000000;
			memset(&_out_data->u.acaPPDU->presentation_context_deletion_result_list, 0, sizeof(_out_data->u.acaPPDU->presentation_context_deletion_result_list));
		    }
else {
			_out_data->u.acaPPDU->bit_mask |= 0x40000000;
			OSS_CNTX_PUSH(_oss_c, 168)
			_out_data->u.acaPPDU->presentation_context_deletion_result_list = nullptr;
			if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else {
			    if (!_oss_c->_tag_decoded || _data_tag == 0x8001) {
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x81 : 0);
			    } else
				_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80010000);
			    _oss_c->_tag_decoded = FALSE;
			}
			_data_tag = 0x8001;
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			{
			    _Presentation_context_deletion_list * _temp = (_Presentation_context_deletion_list *)&_out_data->u.acaPPDU->presentation_context_deletion_result_list;
			    long _total_len = _data_length;
			    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
			    unsigned long count = 0;
#endif
			    OSS_CNTX_INIT

			    OSS_CNTX_PUSH(_oss_c, 72)
			    for (;;) {
				if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
				    if (_bufpos > _end_pos)
					_oss_dec_error(_g, _inconsis_len, 0L);
#endif
				    break;
				}
				if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
				    _buflen--;
				    _oss_c->_bitpos = _bufpos[0] & 0x20;
				    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
				    _bufpos++;
				} else
				    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
					if (_oss_dec_length(_g, &_bufpos, &_buflen))
					    _oss_dec_error(_g, _non_std_eoc, 0L);
					_oss_c->_tag_decoded = FALSE;
					break;
				    }
				_oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
				count++;
#endif
				if (_data_tag != 0x2)
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x20000);
				_temp->next = (_Presentation_context_deletion_list *)_oss_dec_const_alloc(_g, sizeof(_Presentation_context_deletion_list));
				_temp = _temp->next;
				OSS_CNTX_SETOCC(count)
				_oss_c->_tag_decoded = FALSE;
				if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				    _buflen--;
				    _bufpos++;
				} else
				    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				_temp->value = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
			    }
			    _temp->next = nullptr;
			    OSS_CNTX_POP(_oss_c)
			}
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			OSS_CNTX_POP(_oss_c)
		    }
		    if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if ((FALSE)
			|| (_total_len >= 0 && _bufpos >= _end_pos))
		     {
			_out_data->u.acaPPDU->bit_mask &= ~0x20000000;
			memset(&_out_data->u.acaPPDU->user_data, 0, sizeof(_out_data->u.acaPPDU->user_data));
		    }
else {
			_out_data->u.acaPPDU->bit_mask |= 0x20000000;
			OSS_CNTX_PUSH(_oss_c, 130)
			_d_User_data(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->u.acaPPDU->user_data);
			OSS_CNTX_POP(_oss_c)
		    }
		    if (_bufpos != _end_pos) {
			if (_total_len < 0) {
			    if (!_oss_c->_tag_decoded)
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			    if (_data_tag)
				_oss_dec_error(_g, _expec_eoc, 0L);
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			} else
			    _oss_dec_error(_g, _inconsis_len, 0L);
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    break;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpTyped_data_type(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Typed_data_type	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(9,161)
    _out_data = (_Typed_data_type *)_oss_dec_const_alloc(_g, sizeof(_Typed_data_type));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_2int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 162)
	    _out_data->u.ttdPPDU = (_User_data *)_oss_dec_const_alloc(_g, sizeof(_User_data));
	    _dp_User_data(_g, _out_data->u.ttdPPDU);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 163)
	    _out_data->u.acPPDU = (_AC_PPDU *)_oss_dec_const_alloc(_g, sizeof(_AC_PPDU));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_out_data->u.acPPDU->bit_mask = (OSS_UINT32)_oss_get_3bit_unaligned(_g) << 24;
		OSS_CNTX_PUSH(_oss_c, 166)
		_out_data->u.acPPDU->presentation_context_addition_list = nullptr;
		if (_out_data->u.acPPDU->bit_mask & 0x80000000) {
		    _dp_Context_list(_g, &_out_data->u.acPPDU->presentation_context_addition_list);
		} else {
		    _out_data->u.acPPDU->presentation_context_addition_list = nullptr;
		}
		OSS_CNTX_SET(164)
		_out_data->u.acPPDU->presentation_context_deletion_list = nullptr;
		if (_out_data->u.acPPDU->bit_mask & 0x40000000) {
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			_Presentation_context_deletion_list * _temp = (_Presentation_context_deletion_list *)&_out_data->u.acPPDU->presentation_context_deletion_list;
			unsigned long count = 0;
			unsigned char _ext = 0x00;
			ossBoolean _last = FALSE;
			unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			unsigned long _prev_fragm0 = 0;
#endif

			OSS_CNTX_INIT

			_ext = _oss_get_1bit_unaligned(_g);
			OSS_CNTX_PUSH(_oss_c, 165)
			while (!_last) {
			    count += _oss_pdec_length(_g, 0, _ext ? 0 : 7, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
				if ((!_last) && _index && (_prev_fragm0 < 65536))
				    _oss_dec_error(_g, _invalid_fragmentation, 0L);
				_prev_fragm0 = count - _index;
			    }
#endif
			    for (; (unsigned long)_index < count; _index++) {
				_temp->next = (_Presentation_context_deletion_list *)_oss_dec_const_alloc(_g, sizeof(_Presentation_context_deletion_list));
				_temp = _temp->next;
				OSS_CNTX_SETOCC(_index + 1)
				if (_oss_get_1bit_unaligned(_g)) {
				    _temp->value = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
				} else {
				    _temp->value = (OSS_INT32)_oss_pdec_nonneg_7int(_g) + 1;
				}
			    }
			    OSS_CNTX_POP(_oss_c)
			}
			_temp->next = nullptr;
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		} else {
		    _out_data->u.acPPDU->presentation_context_deletion_list = nullptr;
		}
		OSS_CNTX_SET(130)
		if (_out_data->u.acPPDU->bit_mask & 0x20000000) {
		    _dp_User_data(_g, &_out_data->u.acPPDU->user_data);
		} else {
		    memset(&(_out_data->u.acPPDU->user_data), 0, sizeof(_User_data ));
		}
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 167)
	    _out_data->u.acaPPDU = (_ACA_PPDU *)_oss_dec_const_alloc(_g, sizeof(_ACA_PPDU));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_out_data->u.acaPPDU->bit_mask = (OSS_UINT32)_oss_get_3bit_unaligned(_g) << 24;
		OSS_CNTX_PUSH(_oss_c, 169)
		_out_data->u.acaPPDU->presentation_context_addition_result_list = nullptr;
		if (_out_data->u.acaPPDU->bit_mask & 0x80000000) {
		    _dp_Result_list(_g, &_out_data->u.acaPPDU->presentation_context_addition_result_list);
		} else {
		    _out_data->u.acaPPDU->presentation_context_addition_result_list = nullptr;
		}
		OSS_CNTX_SET(168)
		_out_data->u.acaPPDU->presentation_context_deletion_result_list = nullptr;
		if (_out_data->u.acaPPDU->bit_mask & 0x40000000) {
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			_Presentation_context_deletion_list * _temp = (_Presentation_context_deletion_list *)&_out_data->u.acaPPDU->presentation_context_deletion_result_list;
			unsigned long count = 0;
			unsigned char _ext = 0x00;
			ossBoolean _last = FALSE;
			unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			unsigned long _prev_fragm0 = 0;
#endif

			OSS_CNTX_INIT

			_ext = _oss_get_1bit_unaligned(_g);
			OSS_CNTX_PUSH(_oss_c, 72)
			while (!_last) {
			    count += _oss_pdec_length(_g, 0, _ext ? 0 : 7, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
				if ((!_last) && _index && (_prev_fragm0 < 65536))
				    _oss_dec_error(_g, _invalid_fragmentation, 0L);
				_prev_fragm0 = count - _index;
			    }
#endif
			    for (; (unsigned long)_index < count; _index++) {
				_temp->next = (_Presentation_context_deletion_list *)_oss_dec_const_alloc(_g, sizeof(_Presentation_context_deletion_list));
				_temp = _temp->next;
				OSS_CNTX_SETOCC(_index + 1)
				_temp->value = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
			    }
			    OSS_CNTX_POP(_oss_c)
			}
			_temp->next = nullptr;
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		} else {
		    _out_data->u.acaPPDU->presentation_context_deletion_result_list = nullptr;
		}
		OSS_CNTX_SET(130)
		if (_out_data->u.acaPPDU->bit_mask & 0x20000000) {
		    _dp_User_data(_g, &_out_data->u.acaPPDU->user_data);
		} else {
		    memset(&(_out_data->u.acaPPDU->user_data), 0, sizeof(_User_data ));
		}
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dRS_PPDU(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _seq6 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(10,170)
    _out_data = (_seq6 *)_oss_dec_const_alloc(_g, sizeof(_seq6));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8000 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->presentation_context_identifier_list, 0, sizeof(_out_data->presentation_context_identifier_list));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 160)
	    _out_data->presentation_context_identifier_list = nullptr;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8000;
	    _d_14Presentation_context_ident(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->presentation_context_identifier_list);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if ((FALSE)
	    || (_total_len >= 0 && _bufpos >= _end_pos))
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    memset(&_out_data->user_data, 0, sizeof(_out_data->user_data));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 130)
	    _d_User_data(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->user_data);
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpRS_PPDU(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _seq6	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(10,170)
    _out_data = (_seq6 *)_oss_dec_const_alloc(_g, sizeof(_seq6));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_2bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 160)
	_out_data->presentation_context_identifier_list = nullptr;
	if (_out_data->bit_mask & 0x80000000) {
	    _dp_14Presentation_context_ident(_g, &_out_data->presentation_context_identifier_list);
	} else {
	    _out_data->presentation_context_identifier_list = nullptr;
	}
	OSS_CNTX_SET(130)
	if (_out_data->bit_mask & 0x40000000) {
	    _dp_User_data(_g, &_out_data->user_data);
	} else {
	    memset(&(_out_data->user_data), 0, sizeof(_User_data ));
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dRSA_PPDU(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _seq6 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(11,171)
    _out_data = (_seq6 *)_oss_dec_const_alloc(_g, sizeof(_seq6));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8000 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->presentation_context_identifier_list, 0, sizeof(_out_data->presentation_context_identifier_list));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 160)
	    _out_data->presentation_context_identifier_list = nullptr;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8000;
	    _d_14Presentation_context_ident(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->presentation_context_identifier_list);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if ((FALSE)
	    || (_total_len >= 0 && _bufpos >= _end_pos))
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    memset(&_out_data->user_data, 0, sizeof(_out_data->user_data));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 130)
	    _d_User_data(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->user_data);
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpRSA_PPDU(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _seq6	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(11,171)
    _out_data = (_seq6 *)_oss_dec_const_alloc(_g, sizeof(_seq6));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_2bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 160)
	_out_data->presentation_context_identifier_list = nullptr;
	if (_out_data->bit_mask & 0x80000000) {
	    _dp_14Presentation_context_ident(_g, &_out_data->presentation_context_identifier_list);
	} else {
	    _out_data->presentation_context_identifier_list = nullptr;
	}
	OSS_CNTX_SET(130)
	if (_out_data->bit_mask & 0x40000000) {
	    _dp_User_data(_g, &_out_data->user_data);
	} else {
	    memset(&(_out_data->user_data), 0, sizeof(_User_data ));
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _d0Reliable_Transfer_APDU_RTSE(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Reliable_Transfer_APDU_RTSE_apdus *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(12,172)
    _out_data = (_Reliable_Transfer_APDU_RTSE_apdus *)_oss_dec_const_alloc(_g, sizeof(_Reliable_Transfer_APDU_RTSE_apdus));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	switch (_data_tag) {
	case 0x2: {
	    OSS_CNTX_PUSH(_oss_c, 173)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.rttp_apdu = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	}   break;
	case 0x4: {
	    OSS_CNTX_PUSH(_oss_c, 174)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.rttr_apdu.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.rttr_apdu.value, 0);
	}   break;
	default:
	    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
	    switch (_data_tag & 0x7fff) {
	    case 0x10: {
		OSS_CNTX_PUSH(_oss_c, 175)
		_out_data->choice = 3;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.rtorq_apdu = (_set1 *)_oss_dec_const_alloc(_g, sizeof(_set1));
		_d_RTORQapdu(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.rtorq_apdu);
	    }   break;
	    case 0x11: {
		OSS_CNTX_PUSH(_oss_c, 176)
		_out_data->choice = 4;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.rtoac_apdu = (_set2 *)_oss_dec_const_alloc(_g, sizeof(_set2));
		_d_RTOACapdu(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.rtoac_apdu);
	    }   break;
	    case 0x12: {
		OSS_CNTX_PUSH(_oss_c, 177)
		_out_data->choice = 5;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.rtorj_apdu = (_set3 *)_oss_dec_const_alloc(_g, sizeof(_set3));
		_d_RTORJapdu(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.rtorj_apdu);
	    }   break;
	    case 0x16: {
		OSS_CNTX_PUSH(_oss_c, 178)
		_out_data->choice = 6;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.rtab_apdu = (_set4 *)_oss_dec_const_alloc(_g, sizeof(_set4));
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    int _indef_tags = 0;
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    unsigned short _present_flags = 0;
		    OSS_CNTX_DEF
		    OSS_CNTX_SETOCC(0)
		    _out_data->u.rtab_apdu->bit_mask = 0;
		    for (;;) {
			if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			    if (_bufpos > _end_pos)
				_oss_dec_error(_g, _inconsis_len, 0L);
#endif
			    break;
			}
			if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			    _bufpos++;
			} else
			    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
				if (_oss_dec_length(_g, &_bufpos, &_buflen))
				    _oss_dec_error(_g, _non_std_eoc, 0L);
				_oss_c->_tag_decoded = FALSE;
				break;
			    }
			_oss_c->_tag_decoded = TRUE;
			switch (_data_tag) {
			default:
			    if (!(_data_tag & 0x8000))
				_oss_dec_error(_g, _unknown_field, _data_tag);
			    switch (_data_tag & 0x7fff) {
			    case 0x0: {
				OSS_CNTX_PUSH(_oss_c, 159)
				if (_out_data->u.rtab_apdu->bit_mask & 0x80000000)
				    _oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
				_out_data->u.rtab_apdu->bit_mask |= 0x80000000;
				_oss_c->_tag_decoded = FALSE;
				if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				    _buflen--;
				    _bufpos++;
				} else
				    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				_out_data->u.rtab_apdu->abortReason = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
				_present_flags |= 0x1;
			    }   break;
			    case 0x1: {
				OSS_CNTX_PUSH(_oss_c, 158)
				if (_out_data->u.rtab_apdu->bit_mask & 0x40000000)
				    _oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
				_out_data->u.rtab_apdu->bit_mask |= 0x40000000;
				_oss_c->_tag_decoded = FALSE;
				if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				    _buflen--;
				    _bufpos++;
				} else
				    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				_out_data->u.rtab_apdu->reflectedParameter.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.rtab_apdu->reflectedParameter.value, 0, 0);

				_present_flags |= 0x2;
			    }   break;
			    case 0x2: {
				OSS_CNTX_PUSH(_oss_c, 157)
				if (_out_data->u.rtab_apdu->bit_mask & 0x20000000)
				    _oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
				_out_data->u.rtab_apdu->bit_mask |= 0x20000000;
				_oss_c->_tag_decoded = FALSE;
				if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				    _buflen--;
				    _bufpos++;
				} else
				    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
				_out_data->u.rtab_apdu->userdataAB.userField = nullptr;
#endif
				_oss_dec_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.rtab_apdu->userdataAB);
				while (_indef_tags > 0) {
				    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
					_buflen -= 2;
					_bufpos += 2;
				    } else
					if (!_buflen || _bufpos[0])
					    _oss_dec_error(_g, _expec_eoc, 0L);
					else
					    _oss_dec_error(_g, _non_std_eoc, 0L);
				    _indef_tags--;
				}
				_present_flags |= 0x4;
			    }   break;
			    default:
				_oss_dec_error(_g, _unknown_field, _data_tag);
			    }
			    break;
			}
			OSS_CNTX_POP(_oss_c)
		    }
		    if (!(_present_flags & 0x1)) {
			_out_data->u.rtab_apdu->bit_mask &= ~0x80000000;
		    }
		    if (!(_present_flags & 0x2)) {
			_out_data->u.rtab_apdu->bit_mask &= ~0x40000000;
			memset(&_out_data->u.rtab_apdu->reflectedParameter, 0, sizeof(_out_data->u.rtab_apdu->reflectedParameter));
		    }
		    if (!(_present_flags & 0x4)) {
			_out_data->u.rtab_apdu->bit_mask &= ~0x20000000;
			memset(&_out_data->u.rtab_apdu->userdataAB, 0, sizeof(_out_data->u.rtab_apdu->userdataAB));
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    break;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp0Reliable_Transfer_APDU_RTSE(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Reliable_Transfer_APDU_RTSE_apdus	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(12,172)
    _out_data = (_Reliable_Transfer_APDU_RTSE_apdus *)_oss_dec_const_alloc(_g, sizeof(_Reliable_Transfer_APDU_RTSE_apdus));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_3int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 173)
	    _out_data->u.rttp_apdu = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 174)
	    _out_data->u.rttr_apdu.length = _oss_pdec_unconstr_uoct_ia(_g, (unsigned char **)&_out_data->u.rttr_apdu.value);

	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 175)
	    _out_data->u.rtorq_apdu = (_set1 *)_oss_dec_const_alloc(_g, sizeof(_set1));
	    _dp_RTORQapdu(_g, _out_data->u.rtorq_apdu);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 176)
	    _out_data->u.rtoac_apdu = (_set2 *)_oss_dec_const_alloc(_g, sizeof(_set2));
	    _dp_RTOACapdu(_g, _out_data->u.rtoac_apdu);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 177)
	    _out_data->u.rtorj_apdu = (_set3 *)_oss_dec_const_alloc(_g, sizeof(_set3));
	    _dp_RTORJapdu(_g, _out_data->u.rtorj_apdu);
	    break;
	case 6:
	    OSS_CNTX_PUSH(_oss_c, 178)
	    _out_data->u.rtab_apdu = (_set4 *)_oss_dec_const_alloc(_g, sizeof(_set4));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_out_data->u.rtab_apdu->bit_mask = (OSS_UINT32)_oss_get_3bit_unaligned(_g) << 24;
		OSS_CNTX_PUSH(_oss_c, 159)
		if (_out_data->u.rtab_apdu->bit_mask & 0x80000000) {
		    _out_data->u.rtab_apdu->abortReason = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		}
		OSS_CNTX_SET(158)
		if (_out_data->u.rtab_apdu->bit_mask & 0x40000000) {
		    _out_data->u.rtab_apdu->reflectedParameter.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->u.rtab_apdu->reflectedParameter.value);

		} else {
		    _out_data->u.rtab_apdu->reflectedParameter.length = 0;
		    _out_data->u.rtab_apdu->reflectedParameter.value = nullptr;
		}
		OSS_CNTX_SET(157)
		if (_out_data->u.rtab_apdu->bit_mask & 0x20000000) {
#ifdef OSS_OPENTYPE_HAS_USERFIELD
		    _out_data->u.rtab_apdu->userdataAB.userField = nullptr;
#endif
		    _oss_pdec_opentype(_g, &_out_data->u.rtab_apdu->userdataAB);
		} else {
		    memset(&(_out_data->u.rtab_apdu->userdataAB), 0, sizeof(OSSC::COssOpen ));
		}
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _d1Remote_Operations_Abstract_(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Reliable_Transfer_APDU_RTSE_apdus *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(13,172)
    _out_data = (_Reliable_Transfer_APDU_RTSE_apdus *)_oss_dec_const_alloc(_g, sizeof(_Reliable_Transfer_APDU_RTSE_apdus));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	switch (_data_tag) {
	case 0x2: {
	    OSS_CNTX_PUSH(_oss_c, 173)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.rttp_apdu = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	}   break;
	case 0x4: {
	    OSS_CNTX_PUSH(_oss_c, 174)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.rttr_apdu.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.rttr_apdu.value, 0);
	}   break;
	default:
	    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
	    switch (_data_tag & 0x7fff) {
	    case 0x10: {
		OSS_CNTX_PUSH(_oss_c, 175)
		_out_data->choice = 3;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.rtorq_apdu = (_set1 *)_oss_dec_const_alloc(_g, sizeof(_set1));
		_d_RTORQapdu(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.rtorq_apdu);
	    }   break;
	    case 0x11: {
		OSS_CNTX_PUSH(_oss_c, 176)
		_out_data->choice = 4;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.rtoac_apdu = (_set2 *)_oss_dec_const_alloc(_g, sizeof(_set2));
		_d_RTOACapdu(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.rtoac_apdu);
	    }   break;
	    case 0x12: {
		OSS_CNTX_PUSH(_oss_c, 177)
		_out_data->choice = 5;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.rtorj_apdu = (_set3 *)_oss_dec_const_alloc(_g, sizeof(_set3));
		_d_RTORJapdu(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data->u.rtorj_apdu);
	    }   break;
	    case 0x16: {
		OSS_CNTX_PUSH(_oss_c, 178)
		_out_data->choice = 6;

		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->u.rtab_apdu = (_set4 *)_oss_dec_const_alloc(_g, sizeof(_set4));
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    int _indef_tags = 0;
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    unsigned short _present_flags = 0;
		    OSS_CNTX_DEF
		    OSS_CNTX_SETOCC(0)
		    _out_data->u.rtab_apdu->bit_mask = 0;
		    for (;;) {
			if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			    if (_bufpos > _end_pos)
				_oss_dec_error(_g, _inconsis_len, 0L);
#endif
			    break;
			}
			if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			    _bufpos++;
			} else
			    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
				if (_oss_dec_length(_g, &_bufpos, &_buflen))
				    _oss_dec_error(_g, _non_std_eoc, 0L);
				_oss_c->_tag_decoded = FALSE;
				break;
			    }
			_oss_c->_tag_decoded = TRUE;
			switch (_data_tag) {
			default:
			    if (!(_data_tag & 0x8000))
				_oss_dec_error(_g, _unknown_field, _data_tag);
			    switch (_data_tag & 0x7fff) {
			    case 0x0: {
				OSS_CNTX_PUSH(_oss_c, 159)
				if (_out_data->u.rtab_apdu->bit_mask & 0x80000000)
				    _oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
				_out_data->u.rtab_apdu->bit_mask |= 0x80000000;
				_oss_c->_tag_decoded = FALSE;
				if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				    _buflen--;
				    _bufpos++;
				} else
				    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				_out_data->u.rtab_apdu->abortReason = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
				_present_flags |= 0x1;
			    }   break;
			    case 0x1: {
				OSS_CNTX_PUSH(_oss_c, 158)
				if (_out_data->u.rtab_apdu->bit_mask & 0x40000000)
				    _oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
				_out_data->u.rtab_apdu->bit_mask |= 0x40000000;
				_oss_c->_tag_decoded = FALSE;
				if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				    _buflen--;
				    _bufpos++;
				} else
				    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				_out_data->u.rtab_apdu->reflectedParameter.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.rtab_apdu->reflectedParameter.value, 0, 0);

				_present_flags |= 0x2;
			    }   break;
			    case 0x2: {
				OSS_CNTX_PUSH(_oss_c, 157)
				if (_out_data->u.rtab_apdu->bit_mask & 0x20000000)
				    _oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
				_out_data->u.rtab_apdu->bit_mask |= 0x20000000;
				_oss_c->_tag_decoded = FALSE;
				if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				    _buflen--;
				    _bufpos++;
				} else
				    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
				_out_data->u.rtab_apdu->userdataAB.userField = nullptr;
#endif
				_oss_dec_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.rtab_apdu->userdataAB);
				while (_indef_tags > 0) {
				    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
					_buflen -= 2;
					_bufpos += 2;
				    } else
					if (!_buflen || _bufpos[0])
					    _oss_dec_error(_g, _expec_eoc, 0L);
					else
					    _oss_dec_error(_g, _non_std_eoc, 0L);
				    _indef_tags--;
				}
				_present_flags |= 0x4;
			    }   break;
			    default:
				_oss_dec_error(_g, _unknown_field, _data_tag);
			    }
			    break;
			}
			OSS_CNTX_POP(_oss_c)
		    }
		    if (!(_present_flags & 0x1)) {
			_out_data->u.rtab_apdu->bit_mask &= ~0x80000000;
		    }
		    if (!(_present_flags & 0x2)) {
			_out_data->u.rtab_apdu->bit_mask &= ~0x40000000;
			memset(&_out_data->u.rtab_apdu->reflectedParameter, 0, sizeof(_out_data->u.rtab_apdu->reflectedParameter));
		    }
		    if (!(_present_flags & 0x4)) {
			_out_data->u.rtab_apdu->bit_mask &= ~0x20000000;
			memset(&_out_data->u.rtab_apdu->userdataAB, 0, sizeof(_out_data->u.rtab_apdu->userdataAB));
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    break;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp1Remote_Operations_Abstract_(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Reliable_Transfer_APDU_RTSE_apdus	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(13,172)
    _out_data = (_Reliable_Transfer_APDU_RTSE_apdus *)_oss_dec_const_alloc(_g, sizeof(_Reliable_Transfer_APDU_RTSE_apdus));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_3int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 173)
	    _out_data->u.rttp_apdu = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 174)
	    _out_data->u.rttr_apdu.length = _oss_pdec_unconstr_uoct_ia(_g, (unsigned char **)&_out_data->u.rttr_apdu.value);

	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 175)
	    _out_data->u.rtorq_apdu = (_set1 *)_oss_dec_const_alloc(_g, sizeof(_set1));
	    _dp_RTORQapdu(_g, _out_data->u.rtorq_apdu);
	    break;
	case 4:
	    OSS_CNTX_PUSH(_oss_c, 176)
	    _out_data->u.rtoac_apdu = (_set2 *)_oss_dec_const_alloc(_g, sizeof(_set2));
	    _dp_RTOACapdu(_g, _out_data->u.rtoac_apdu);
	    break;
	case 5:
	    OSS_CNTX_PUSH(_oss_c, 177)
	    _out_data->u.rtorj_apdu = (_set3 *)_oss_dec_const_alloc(_g, sizeof(_set3));
	    _dp_RTORJapdu(_g, _out_data->u.rtorj_apdu);
	    break;
	case 6:
	    OSS_CNTX_PUSH(_oss_c, 178)
	    _out_data->u.rtab_apdu = (_set4 *)_oss_dec_const_alloc(_g, sizeof(_set4));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		OSS_CNTX_INIT

		_out_data->u.rtab_apdu->bit_mask = (OSS_UINT32)_oss_get_3bit_unaligned(_g) << 24;
		OSS_CNTX_PUSH(_oss_c, 159)
		if (_out_data->u.rtab_apdu->bit_mask & 0x80000000) {
		    _out_data->u.rtab_apdu->abortReason = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		}
		OSS_CNTX_SET(158)
		if (_out_data->u.rtab_apdu->bit_mask & 0x40000000) {
		    _out_data->u.rtab_apdu->reflectedParameter.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->u.rtab_apdu->reflectedParameter.value);

		} else {
		    _out_data->u.rtab_apdu->reflectedParameter.length = 0;
		    _out_data->u.rtab_apdu->reflectedParameter.value = nullptr;
		}
		OSS_CNTX_SET(157)
		if (_out_data->u.rtab_apdu->bit_mask & 0x20000000) {
#ifdef OSS_OPENTYPE_HAS_USERFIELD
		    _out_data->u.rtab_apdu->userdataAB.userField = nullptr;
#endif
		    _oss_pdec_opentype(_g, &_out_data->u.rtab_apdu->userdataAB);
		} else {
		    memset(&(_out_data->u.rtab_apdu->userdataAB), 0, sizeof(OSSC::COssOpen ));
		}
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dROSEInvokeIds(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeId *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(14,179)
    _out_data = (_InvokeId *)_oss_dec_const_alloc(_g, sizeof(_InvokeId));
    _oss_c->_tag_decoded = FALSE;
    _d_InvokeId(_g, &_bufpos, &_buflen, 0, 0, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpROSEInvokeIds(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeId	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(14,179)
    _out_data = (_InvokeId *)_oss_dec_const_alloc(_g, sizeof(_InvokeId));
    _dp_InvokeId(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dReject(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Reject *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(15,180)
    _out_data = (_Reject *)_oss_dec_const_alloc(_g, sizeof(_Reject));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 186)
	_d_InvokeId(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->invokeId);
	OSS_CNTX_SET(181)
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    OSS_CNTX_INIT

	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	    switch (_data_tag) {
	    default:
		if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
		switch (_data_tag & 0x7fff) {
		case 0x0: {
		    OSS_CNTX_PUSH(_oss_c, 182)
		    _out_data->problem.choice = 1;

		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _out_data->problem.u.general = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		}   break;
		case 0x1: {
		    OSS_CNTX_PUSH(_oss_c, 183)
		    _out_data->problem.choice = 2;

		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _out_data->problem.u.invoke = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		}   break;
		case 0x2: {
		    OSS_CNTX_PUSH(_oss_c, 184)
		    _out_data->problem.choice = 3;

		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _out_data->problem.u.returnResult = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		}   break;
		case 0x3: {
		    OSS_CNTX_PUSH(_oss_c, 185)
		    _out_data->problem.choice = 4;

		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _out_data->problem.u.returnError = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		}   break;
		default:
		    _oss_dec_error(_g, _unknown_field, _data_tag);
		}
		break;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpReject(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Reject	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(15,180)
    _out_data = (_Reject *)_oss_dec_const_alloc(_g, sizeof(_Reject));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 186)
	_dp_InvokeId(_g, &_out_data->invokeId);
	OSS_CNTX_SET(181)
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    OSS_CNTX_INIT

	    {

		_out_data->problem.choice = (int)_oss_pdec_nonneg_2int(_g) + 1;
	    }
	    switch (_out_data->problem.choice) {
	    case 1:
		OSS_CNTX_PUSH(_oss_c, 182)
		_out_data->problem.u.general = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		break;
	    case 2:
		OSS_CNTX_PUSH(_oss_c, 183)
		_out_data->problem.u.invoke = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		break;
	    case 3:
		OSS_CNTX_PUSH(_oss_c, 184)
		_out_data->problem.u.returnResult = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		break;
	    case 4:
		OSS_CNTX_PUSH(_oss_c, 185)
		_out_data->problem.u.returnError = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		break;
	    default:
		_oss_enc_error(_g, _bad_choice, _out_data->problem.choice);	/* Bad choice selector. */
	    }
	    OSS_CNTX_POP(_oss_c)
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dNoInvokeId(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeId *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(16,187)
    _out_data = (_InvokeId *)_oss_dec_const_alloc(_g, sizeof(_InvokeId));
    _oss_c->_tag_decoded = FALSE;
    _d_InvokeId(_g, &_bufpos, &_buflen, 0, 0, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpNoInvokeId(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _InvokeId	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(16,187)
    _out_data = (_InvokeId *)_oss_dec_const_alloc(_g, sizeof(_InvokeId));
    _dp_InvokeId(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dUnboundedDirectoryString(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _UnboundedDirectoryString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(17,188)
    _out_data = (_UnboundedDirectoryString *)_oss_dec_const_alloc(_g, sizeof(_UnboundedDirectoryString));
    _oss_c->_tag_decoded = FALSE;
    _d_UnboundedDirectoryString(_g, &_bufpos, &_buflen, 0, 0, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpUnboundedDirectoryString(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _UnboundedDirectoryString	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(17,188)
    _out_data = (_UnboundedDirectoryString *)_oss_dec_const_alloc(_g, sizeof(_UnboundedDirectoryString));
    _dp_UnboundedDirectoryString(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dUniqueIdentifier(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(18,189)
    _out_data = (OSSC::COssBitString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssBitString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 3 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x3);
    _data_tag = 0x3;
    _out_data->length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 0, 0);

    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpUniqueIdentifier(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(18,189)
    _out_data = (OSSC::COssBitString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssBitString));
    _out_data->length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->value);

    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dUUIDPair(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _UUIDPair *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(19,190)
    _out_data = (_UUIDPair *)_oss_dec_const_alloc(_g, sizeof(_UUIDPair));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 192)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->issuerUUID.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->issuerUUID.value, 16);
	OSS_CNTX_SET(191)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->subjectUUID.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->subjectUUID.value, 16);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpUUIDPair(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _UUIDPair	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(19,190)
    _out_data = (_UUIDPair *)_oss_dec_const_alloc(_g, sizeof(_UUIDPair));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 192)
	_out_data->issuerUUID.length = _oss_pdec_constr_uoct_ia(_g, (unsigned char **)&_out_data->issuerUUID.value, 16, 16);

	OSS_CNTX_SET(191)
	_out_data->subjectUUID.length = _oss_pdec_constr_uoct_ia(_g, (unsigned char **)&_out_data->subjectUUID.value, 16, 16);

	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dCountryName(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(20,193)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 19 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x13);
    _data_tag = 0x13;
    _out_data->length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 2);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpCountryName(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(20,193)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _out_data->length = _oss_pdec_ub_kmstr(_g, &_out_data->value, _chars + 4);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dGuide(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Guide *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(21,194)
    _out_data = (_Guide *)_oss_dec_const_alloc(_g, sizeof(_Guide));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
    _data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	unsigned short _present_flags = 0;
	OSS_CNTX_DEF
	OSS_CNTX_SETOCC(0)
	_out_data->bit_mask = 0;
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    switch (_data_tag) {
	    default:
		if (!(_data_tag & 0x8000))
		    _oss_dec_error(_g, _unknown_field, _data_tag);
		switch (_data_tag & 0x7fff) {
		case 0x0: {
		    OSS_CNTX_PUSH(_oss_c, 196)
		    if (_out_data->bit_mask & 0x80000000)
			_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		    _out_data->bit_mask |= 0x80000000;
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    if (_data_length < 0) ++_indef_tags;
		    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
		    _data_tag = 0x6;
		    _out_data->objectClass.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->objectClass.value, -1);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    _present_flags |= 0x1;
		}   break;
		case 0x1: {
		    OSS_CNTX_PUSH(_oss_c, 195)
		    if (_present_flags & 0x2)
			_oss_dec_error(_g, _field_repeat, 0L);	/* We already decoded this. */
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    if (_data_length < 0) ++_indef_tags;
		    _d_Criteria(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->criteria);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    _present_flags |= 0x2;
		}   break;
		default:
		    _oss_dec_error(_g, _unknown_field, _data_tag);
		}
		break;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!(_present_flags & 0x1)) {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->objectClass, 0, sizeof(_out_data->objectClass));
	}
	if ((_present_flags & 0x2) != 0x2)
	    _oss_dec_error(_g, _field_omit, 0L);
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpGuide(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Guide	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(21,194)
    _out_data = (_Guide *)_oss_dec_const_alloc(_g, sizeof(_Guide));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_1bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 196)
	if (_out_data->bit_mask & 0x80000000) {
	    _out_data->objectClass.length = _oss_pdec_eobjid_ia(_g, &_out_data->objectClass.value, -1);
	} else {
	    _out_data->objectClass.length = 0;
	    _out_data->objectClass.value = nullptr;
	}
	OSS_CNTX_SET(195)
	_dp_Criteria(_g, &_out_data->criteria);
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dEnhancedGuide(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EnhancedGuide *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(22,197)
    _out_data = (_EnhancedGuide *)_oss_dec_const_alloc(_g, sizeof(_EnhancedGuide));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 196)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
	_data_tag = 0x6;
	_out_data->objectClass.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->objectClass.value, -1);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_SET(195)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x81);
	_data_tag = 0x8001;
	if (_data_length < 0) ++_indef_tags;
	_d_Criteria(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->criteria);
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8002 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->subset, &EnhancedGuide::default_subset, sizeof(EnhancedGuide::default_subset));
#else
	    _out_data->subset = 0;
#endif
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 198)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8002) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x82 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80020000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8002;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	    _data_tag = 0x2;
	    _out_data->subset = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpEnhancedGuide(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EnhancedGuide	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(22,197)
    _out_data = (_EnhancedGuide *)_oss_dec_const_alloc(_g, sizeof(_EnhancedGuide));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_1bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 196)
	_out_data->objectClass.length = _oss_pdec_eobjid_ia(_g, &_out_data->objectClass.value, -1);
	OSS_CNTX_SET(195)
	_dp_Criteria(_g, &_out_data->criteria);
	OSS_CNTX_SET(198)
	if (_out_data->bit_mask & 0x80000000) {
	    _out_data->subset = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->subset, &EnhancedGuide::default_subset, sizeof(EnhancedGuide::default_subset));
#else
	    _out_data->subset = 0;
#endif
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dPostalAddress(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PostalAddress **_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(23,199)
    _out_data = (_PostalAddress **)_oss_dec_const_init_alloc(_g, sizeof(_PostalAddress *));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_PostalAddress * _temp = (_PostalAddress *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 200)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    _temp->next = (_PostalAddress *)_oss_dec_const_alloc(_g, sizeof(_PostalAddress));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
	    _d_UnboundedDirectoryString(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
	}
	_temp->next = nullptr;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpPostalAddress(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PostalAddress	**_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(23,199)
    _out_data = (_PostalAddress **)_oss_dec_const_init_alloc(_g, sizeof(_PostalAddress *));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_PostalAddress * _temp = (_PostalAddress *)_out_data;
	unsigned long count = 0;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 200)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_PostalAddress *)_oss_dec_const_alloc(_g, sizeof(_PostalAddress));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
		_dp_UnboundedDirectoryString(_g, &_temp->value);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = nullptr;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dTelephoneNumber(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(24,201)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 19 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x13);
    _data_tag = 0x13;
    _out_data->length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 32);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpTelephoneNumber(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(24,201)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _out_data->length = _oss_pdec_ub_kmstr(_g, &_out_data->value, _chars + 5);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dTelexNumber(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _TelexNumber *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(25,202)
    _out_data = (_TelexNumber *)_oss_dec_const_alloc(_g, sizeof(_TelexNumber));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 205)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 19 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x13);
	_data_tag = 0x13;
	_out_data->telexNumber.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->telexNumber.value, 14);
	OSS_CNTX_SET(204)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 19 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x13);
	_data_tag = 0x13;
	_out_data->countryCode.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->countryCode.value, 4);
	OSS_CNTX_SET(203)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 19 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x13);
	_data_tag = 0x13;
	_out_data->answerback.length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->answerback.value, 8);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpTelexNumber(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _TelexNumber	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(25,202)
    _out_data = (_TelexNumber *)_oss_dec_const_alloc(_g, sizeof(_TelexNumber));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 205)
	_out_data->telexNumber.length = _oss_pdec_ub_kmstr(_g, &_out_data->telexNumber.value, _chars + 6);
	OSS_CNTX_SET(204)
	_out_data->countryCode.length = _oss_pdec_ub_kmstr(_g, &_out_data->countryCode.value, _chars + 7);
	OSS_CNTX_SET(203)
	_out_data->answerback.length = _oss_pdec_ub_kmstr(_g, &_out_data->answerback.value, _chars + 8);
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dX121Address(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(26,206)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 18 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x12);
    _data_tag = 0x12;
    _out_data->length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 15);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpX121Address(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(26,206)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _out_data->length = _oss_pdec_ub_kmstr(_g, &_out_data->value, _chars + 9);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dInternationalISDNNumber(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(27,207)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 18 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x12);
    _data_tag = 0x12;
    _out_data->length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 16);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpInternationalISDNNumber(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(27,207)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _out_data->length = _oss_pdec_ub_kmstr(_g, &_out_data->value, _chars + 10);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dDestinationIndicator(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(28,208)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 19 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x13);
    _data_tag = 0x13;
    _out_data->length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 0);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpDestinationIndicator(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(28,208)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _out_data->length = _oss_pdec_ub_kmstr(_g, &_out_data->value, _chars + 0);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dCommunicationsService(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssEncOID *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(29,209)
    _out_data = (OSSC::COssEncOID *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssEncOID));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
    _data_tag = 0x6;
    _out_data->length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, -1);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpCommunicationsService(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssEncOID	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(29,209)
    _out_data = (OSSC::COssEncOID *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssEncOID));
    _out_data->length = _oss_pdec_eobjid_ia(_g, &_out_data->value, -1);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dCommunicationsNetwork(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssEncOID *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(30,210)
    _out_data = (OSSC::COssEncOID *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssEncOID));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
    _data_tag = 0x6;
    _out_data->length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, -1);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpCommunicationsNetwork(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssEncOID	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(30,210)
    _out_data = (OSSC::COssEncOID *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssEncOID));
    _out_data->length = _oss_pdec_eobjid_ia(_g, &_out_data->value, -1);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dPreferredDeliveryMethod(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Presentation_context_deletion_list **_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(31,211)
    _out_data = (_Presentation_context_deletion_list **)_oss_dec_const_init_alloc(_g, sizeof(_Presentation_context_deletion_list *));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_Presentation_context_deletion_list * _temp = (_Presentation_context_deletion_list *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 72)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    if (_data_tag != 0x2)
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x20000);
	    _temp->next = (_Presentation_context_deletion_list *)_oss_dec_const_alloc(_g, sizeof(_Presentation_context_deletion_list));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _temp->value = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	}
	_temp->next = nullptr;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpPreferredDeliveryMethod(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Presentation_context_deletion_list	**_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(31,211)
    _out_data = (_Presentation_context_deletion_list **)_oss_dec_const_init_alloc(_g, sizeof(_Presentation_context_deletion_list *));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_Presentation_context_deletion_list * _temp = (_Presentation_context_deletion_list *)_out_data;
	unsigned long count = 0;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 72)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_Presentation_context_deletion_list *)_oss_dec_const_alloc(_g, sizeof(_Presentation_context_deletion_list));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
		_temp->value = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = nullptr;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dPresentationAddress(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PresentationAddress *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(32,212)
    _out_data = (_PresentationAddress *)_oss_dec_const_alloc(_g, sizeof(_PresentationAddress));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8000 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->pSelector, 0, sizeof(_out_data->pSelector));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 217)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8000;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	    _data_tag = 0x4;
	    _out_data->pSelector.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->pSelector.value, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8001 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    memset(&_out_data->sSelector, 0, sizeof(_out_data->sSelector));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 216)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8001) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x81 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80010000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8001;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	    _data_tag = 0x4;
	    _out_data->sSelector.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->sSelector.value, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8002 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x20000000;
	    memset(&_out_data->tSelector, 0, sizeof(_out_data->tSelector));
	}
else {
	    _out_data->bit_mask |= 0x20000000;
	    OSS_CNTX_PUSH(_oss_c, 215)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8002) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x82 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80020000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8002;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	    _data_tag = 0x4;
	    _out_data->tSelector.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->tSelector.value, 0);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 213)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 163 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8003) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x83 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80030000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8003;
	if (_data_length < 0) ++_indef_tags;
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
	_data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _setof3 * _temp = (_setof3 *)&_out_data->nAddresses;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	    unsigned long count = 0;
#endif
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 214)
	    for (;;) {
		if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos > _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x4)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x40000);
		_temp->next = (_setof3 *)_oss_dec_const_alloc(_g, sizeof(_setof3));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_temp->value.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.value, 0);
	    }
	    _temp->next = nullptr;
	    OSS_CNTX_POP(_oss_c)
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpPresentationAddress(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PresentationAddress	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(32,212)
    _out_data = (_PresentationAddress *)_oss_dec_const_alloc(_g, sizeof(_PresentationAddress));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_3bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 217)
	if (_out_data->bit_mask & 0x80000000) {
	    _out_data->pSelector.length = _oss_pdec_unconstr_uoct_ia(_g, (unsigned char **)&_out_data->pSelector.value);

	} else {
	    _out_data->pSelector.length = 0;
	    _out_data->pSelector.value = nullptr;
	}
	OSS_CNTX_SET(216)
	if (_out_data->bit_mask & 0x40000000) {
	    _out_data->sSelector.length = _oss_pdec_unconstr_uoct_ia(_g, (unsigned char **)&_out_data->sSelector.value);

	} else {
	    _out_data->sSelector.length = 0;
	    _out_data->sSelector.value = nullptr;
	}
	OSS_CNTX_SET(215)
	if (_out_data->bit_mask & 0x20000000) {
	    _out_data->tSelector.length = _oss_pdec_unconstr_uoct_ia(_g, (unsigned char **)&_out_data->tSelector.value);

	} else {
	    _out_data->tSelector.length = 0;
	    _out_data->tSelector.value = nullptr;
	}
	OSS_CNTX_SET(213)
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _setof3 * _temp = (_setof3 *)&_out_data->nAddresses;
	    unsigned long count = 0;
	    ossBoolean _last = FALSE;
	    unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    unsigned long _prev_fragm0 = 0;
#endif

	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 214)
	    while (!_last) {
		count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		    if ((!_last) && _index && (_prev_fragm0 < 65536))
			_oss_dec_error(_g, _invalid_fragmentation, 0L);
		    _prev_fragm0 = count - _index;
		}
#endif
		for (; (unsigned long)_index < count; _index++) {
		    _temp->next = (_setof3 *)_oss_dec_const_alloc(_g, sizeof(_setof3));
		    _temp = _temp->next;
		    OSS_CNTX_SETOCC(_index + 1)
		    _temp->value.length = _oss_pdec_unconstr_uoct_ia(_g, (unsigned char **)&_temp->value.value);

		}
		OSS_CNTX_POP(_oss_c)
	    }
	    _temp->next = nullptr;
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dProtocolInformation(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ProtocolInformation *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(33,218)
    _out_data = (_ProtocolInformation *)_oss_dec_const_alloc(_g, sizeof(_ProtocolInformation));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 221)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->nAddress.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->nAddress.value, 0);
	OSS_CNTX_SET(219)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
	_data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _Application_context_name_list * _temp = (_Application_context_name_list *)&_out_data->profiles;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	    unsigned long count = 0;
#endif
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 220)
	    for (;;) {
		if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos > _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x6)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x60000);
		_temp->next = (_Application_context_name_list *)_oss_dec_const_alloc(_g, sizeof(_Application_context_name_list));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_temp->value.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.value, -1);
	    }
	    _temp->next = nullptr;
	    OSS_CNTX_POP(_oss_c)
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpProtocolInformation(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ProtocolInformation	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(33,218)
    _out_data = (_ProtocolInformation *)_oss_dec_const_alloc(_g, sizeof(_ProtocolInformation));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 221)
	_out_data->nAddress.length = _oss_pdec_unconstr_uoct_ia(_g, (unsigned char **)&_out_data->nAddress.value);

	OSS_CNTX_SET(219)
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _Application_context_name_list * _temp = (_Application_context_name_list *)&_out_data->profiles;
	    unsigned long count = 0;
	    ossBoolean _last = FALSE;
	    unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    unsigned long _prev_fragm0 = 0;
#endif

	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 220)
	    while (!_last) {
		count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		    if ((!_last) && _index && (_prev_fragm0 < 65536))
			_oss_dec_error(_g, _invalid_fragmentation, 0L);
		    _prev_fragm0 = count - _index;
		}
#endif
		for (; (unsigned long)_index < count; _index++) {
		    _temp->next = (_Application_context_name_list *)_oss_dec_const_alloc(_g, sizeof(_Application_context_name_list));
		    _temp = _temp->next;
		    OSS_CNTX_SETOCC(_index + 1)
		    _temp->value.length = _oss_pdec_eobjid_ia(_g, &_temp->value.value, -1);
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    _temp->next = nullptr;
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dNameAndOptionalUID(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _NameAndOptionalUID *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(34,222)
    _out_data = (_NameAndOptionalUID *)_oss_dec_const_alloc(_g, sizeof(_NameAndOptionalUID));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 224)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_RDNSequence(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->dn);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x3 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->uid, 0, sizeof(_out_data->uid));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 223)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 3 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x3) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x3 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x30000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x3;
	    _out_data->uid.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->uid.value, 0, 0);

	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpNameAndOptionalUID(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _NameAndOptionalUID	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(34,222)
    _out_data = (_NameAndOptionalUID *)_oss_dec_const_alloc(_g, sizeof(_NameAndOptionalUID));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_1bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 224)
	_dp_RDNSequence(_g, &_out_data->dn);
	OSS_CNTX_SET(223)
	if (_out_data->bit_mask & 0x80000000) {
	    _out_data->uid.length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->uid.value);

	} else {
	    _out_data->uid.length = 0;
	    _out_data->uid.value = nullptr;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dMultipleMatchingLocalities(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _MultipleMatchingLocalities *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(35,225)
    _out_data = (_MultipleMatchingLocalities *)_oss_dec_const_alloc(_g, sizeof(_MultipleMatchingLocalities));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x6 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->matchingRuleUsed, 0, sizeof(_out_data->matchingRuleUsed));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 233)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x6) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x6 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x60000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x6;
	    _out_data->matchingRuleUsed.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->matchingRuleUsed.value, -1);
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_PUSH(_oss_c, 226)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x10) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x10 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _seqof2 * _temp = (_seqof2 *)&_out_data->attributeList;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	    unsigned long count = 0;
#endif
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 227)
	    for (;;) {
		if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos > _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x10)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		_temp->next = (_seqof2 *)_oss_dec_const_alloc(_g, sizeof(_seqof2));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    OSS_CNTX_INIT

		    _temp->value.bit_mask = 0;
		    OSS_CNTX_PUSH(_oss_c, 83)
		    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
		    _data_tag = 0x6;
		    _temp->value.type.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.type.value, -1);
		    OSS_CNTX_SET(232)
		    if (_data_length == 0) _data_length = 1;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
		    _temp->value.assertion.userField = nullptr;
#endif
		    _oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_temp->value.assertion.encoded);
		    _temp->value.assertion.pduNum = 0;
		    *(void **)&_temp->value.assertion.decoded = nullptr;
		    OSS_CNTX_POP(_oss_c)
		    if (_bufpos < _end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if ((_data_tag != 0x8000 && _data_tag != 0x8001)
			|| (_total_len >= 0 && _bufpos >= _end_pos))
		     {
			_temp->value.bit_mask &= ~0x80000000;
			memset(&_temp->value.assertedContexts, 0, sizeof(_temp->value.assertedContexts));
		    }
else {
			_temp->value.bit_mask |= 0x80000000;
			OSS_CNTX_PUSH(_oss_c, 228)
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			{
			    int _indef_tags = 0;
			    OSS_CNTX_INIT

			    if (!_oss_c->_tag_decoded) {
				if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				    _buflen--;
				    _oss_c->_bitpos = _bufpos[0] & 0x20;
				    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				    _bufpos++;
				} else
				    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
				_oss_c->_tag_decoded = TRUE;
			    }
			    switch (_data_tag) {
			    default:
				if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
				switch (_data_tag & 0x7fff) {
				case 0x0: {
				    OSS_CNTX_PUSH(_oss_c, 229)
				    _temp->value.assertedContexts.choice = 1;

				    _oss_c->_tag_decoded = FALSE;
				    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					_buflen--;
					_bufpos++;
				    } else
					_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				    if (_data_length < 0) ++_indef_tags;
				    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 5 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
					_buflen -= 2;
					_bufpos += 2;
				    } else
					_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x5);
				    _data_tag = 0x5;
				    _temp->value.assertedContexts.u.allContexts = 0;
				    if (_data_length != 0)
					_oss_dec_error(_g, _inval_enc, 0L);
				    while (_indef_tags > 0) {
					if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
					    _buflen -= 2;
					    _bufpos += 2;
					} else
					    if (!_buflen || _bufpos[0])
						_oss_dec_error(_g, _expec_eoc, 0L);
					    else
						_oss_dec_error(_g, _non_std_eoc, 0L);
					_indef_tags--;
				    }
				}   break;
				case 0x1: {
				    OSS_CNTX_PUSH(_oss_c, 230)
				    _temp->value.assertedContexts.choice = 2;

				    _oss_c->_tag_decoded = FALSE;
				    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					_buflen--;
					_bufpos++;
				    } else
					_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				    if (_data_length < 0) ++_indef_tags;
				    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
					_buflen -= 2;
					_bufpos += 2;
				    } else
					_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
				    _data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
				    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
					    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
					    _oss_c->reserved.fields.ext->seqSetNestingLimit)
					_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
				    {
					_setof6 * _temp1 = (_setof6 *)&_temp->value.assertedContexts.u.selectedContexts;
					long _total_len = _data_length;
					char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
					unsigned long count = 0;
#endif
					OSS_CNTX_INIT

					OSS_CNTX_PUSH(_oss_c, 231)
					for (;;) {
					    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
						if (_bufpos > _end_pos)
						    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
						break;
					    }
					    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
						_buflen--;
						_oss_c->_bitpos = _bufpos[0] & 0x20;
						_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
						_bufpos++;
					    } else
						if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
						    if (_oss_dec_length(_g, &_bufpos, &_buflen))
							_oss_dec_error(_g, _non_std_eoc, 0L);
						    _oss_c->_tag_decoded = FALSE;
						    break;
						}
					    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
					    count++;
#endif
					    if (_data_tag != 0x10)
						_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
					    _temp1->next = (_setof6 *)_oss_dec_const_alloc(_g, sizeof(_setof6));
					    _temp1 = _temp1->next;
					    OSS_CNTX_SETOCC(count)
					    _oss_c->_tag_decoded = FALSE;
					    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
						_buflen--;
						_bufpos++;
					    } else
						_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
					    _d_ContextAssertion(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp1->value);
					}
					_temp1->next = nullptr;
					OSS_CNTX_POP(_oss_c)
				    }
#ifndef OSS_NO_NESTING_CONTROL
				    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
					_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
				    while (_indef_tags > 0) {
					if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
					    _buflen -= 2;
					    _bufpos += 2;
					} else
					    if (!_buflen || _bufpos[0])
						_oss_dec_error(_g, _expec_eoc, 0L);
					    else
						_oss_dec_error(_g, _non_std_eoc, 0L);
					_indef_tags--;
				    }
				}   break;
				default:
				    _oss_dec_error(_g, _unknown_field, _data_tag);
				}
				break;
			    }
			    OSS_CNTX_POP(_oss_c)
			}
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			OSS_CNTX_POP(_oss_c)
		    }
		    if (_bufpos != _end_pos) {
			if (_total_len < 0) {
			    if (!_oss_c->_tag_decoded)
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			    if (_data_tag)
				_oss_dec_error(_g, _expec_eoc, 0L);
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			} else
			    _oss_dec_error(_g, _inconsis_len, 0L);
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    }
	    _temp->next = nullptr;
	    OSS_CNTX_POP(_oss_c)
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpMultipleMatchingLocalities(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _MultipleMatchingLocalities	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(35,225)
    _out_data = (_MultipleMatchingLocalities *)_oss_dec_const_alloc(_g, sizeof(_MultipleMatchingLocalities));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_1bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 233)
	if (_out_data->bit_mask & 0x80000000) {
	    _out_data->matchingRuleUsed.length = _oss_pdec_eobjid_ia(_g, &_out_data->matchingRuleUsed.value, -1);
	} else {
	    _out_data->matchingRuleUsed.length = 0;
	    _out_data->matchingRuleUsed.value = nullptr;
	}
	OSS_CNTX_SET(226)
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _seqof2 * _temp = (_seqof2 *)&_out_data->attributeList;
	    unsigned long count = 0;
	    ossBoolean _last = FALSE;
	    unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    unsigned long _prev_fragm0 = 0;
#endif

	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 227)
	    while (!_last) {
		count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		    if ((!_last) && _index && (_prev_fragm0 < 65536))
			_oss_dec_error(_g, _invalid_fragmentation, 0L);
		    _prev_fragm0 = count - _index;
		}
#endif
		for (; (unsigned long)_index < count; _index++) {
		    _temp->next = (_seqof2 *)_oss_dec_const_alloc(_g, sizeof(_seqof2));
		    _temp = _temp->next;
		    OSS_CNTX_SETOCC(_index + 1)
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			OSS_CNTX_INIT

			_temp->value.bit_mask = (OSS_UINT32)_oss_get_1bit_unaligned(_g) << 24;
			OSS_CNTX_PUSH(_oss_c, 83)
			_temp->value.type.length = _oss_pdec_eobjid_ia(_g, &_temp->value.type.value, -1);
			OSS_CNTX_SET(232)
#ifdef OSS_OPENTYPE_HAS_USERFIELD
			_temp->value.assertion.userField = nullptr;
#endif
			_temp->value.assertion.encoded.length = _oss_pdec_unconstr_uoct_ia(_g, &_temp->value.assertion.encoded.value);
			if (_temp->value.assertion.encoded.length == 0 && ((STRICT_ENCODING_DECODING_RULES | AUTOMATIC_ENCDEC) & _g->decodingFlags))
			    _oss_dec_error(_g, _zero_length_OpenType, 0L);
			_temp->value.assertion.pduNum = 0;
			*(void **)&_temp->value.assertion.decoded = nullptr;
			OSS_CNTX_SET(228)
			if (_temp->value.bit_mask & 0x80000000) {
#ifndef OSS_NO_NESTING_CONTROL
			    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				    _oss_c->reserved.fields.ext->seqSetNestingLimit)
				_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			    {
				OSS_CNTX_INIT

				{

				    _temp->value.assertedContexts.choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
				}
				switch (_temp->value.assertedContexts.choice) {
				case 1:
				    OSS_CNTX_PUSH(_oss_c, 229)
				    break;
				case 2:
				    OSS_CNTX_PUSH(_oss_c, 230)
#ifndef OSS_NO_NESTING_CONTROL
				    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
					    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
					    _oss_c->reserved.fields.ext->seqSetNestingLimit)
					_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
				    {
					_setof6 * _temp1 = (_setof6 *)&_temp->value.assertedContexts.u.selectedContexts;
					unsigned long count = 0;
					ossBoolean _last = FALSE;
					unsigned long _index1 = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
					unsigned long _prev_fragm1 = 0;
#endif

					OSS_CNTX_INIT

					OSS_CNTX_PUSH(_oss_c, 231)
					while (!_last) {
					    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
					    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
						if ((!_last) && _index1 && (_prev_fragm1 < 65536))
						    _oss_dec_error(_g, _invalid_fragmentation, 0L);
						_prev_fragm1 = count - _index1;
					    }
#endif
					    for (; (unsigned long)_index1 < count; _index1++) {
						_temp1->next = (_setof6 *)_oss_dec_const_alloc(_g, sizeof(_setof6));
						_temp1 = _temp1->next;
						OSS_CNTX_SETOCC(_index1 + 1)
						_dp_ContextAssertion(_g, &_temp1->value);
					    }
					    OSS_CNTX_POP(_oss_c)
					}
					_temp1->next = nullptr;
				    }
#ifndef OSS_NO_NESTING_CONTROL
				    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
					_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
				    break;
				default:
				    _oss_enc_error(_g, _bad_choice, _temp->value.assertedContexts.choice);	/* Bad choice selector. */
				}
				OSS_CNTX_POP(_oss_c)
			    }
#ifndef OSS_NO_NESTING_CONTROL
			    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
				_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			} else {
			    memset(&(_temp->value.assertedContexts), 0, sizeof(_choice4 ));
			}
			OSS_CNTX_POP(_oss_c)
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		}
		OSS_CNTX_POP(_oss_c)
	    }
	    _temp->next = nullptr;
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dSubstringAssertion(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SubstringAssertion **_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(36,234)
    _out_data = (_SubstringAssertion **)_oss_dec_const_init_alloc(_g, sizeof(_SubstringAssertion *));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_SubstringAssertion * _temp = (_SubstringAssertion *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 235)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    _temp->next = (_SubstringAssertion *)_oss_dec_const_alloc(_g, sizeof(_SubstringAssertion));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		int _indef_tags = 0;
		OSS_CNTX_INIT

		switch (_data_tag) {
		case 0x10: {
		    OSS_CNTX_PUSH(_oss_c, 236)
		    _temp->value.choice = 1;
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _temp->value.u.control = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			long _total_len = _data_length;
			char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
			OSS_CNTX_INIT

			_temp->value.u.control->bit_mask = 0;
			OSS_CNTX_PUSH(_oss_c, 83)
			if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
			_data_tag = 0x6;
			_temp->value.u.control->type.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.u.control->type.value, -1);
			OSS_CNTX_SET(237)
			if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
			_data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			{
			    _setof13 * _temp1 = (_setof13 *)&_temp->value.u.control->values;
			    long _total_len = _data_length;
			    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
			    unsigned long count = 0;
#endif
			    OSS_CNTX_INIT

			    OSS_CNTX_PUSH(_oss_c, 6)
			    for (;;) {
				if (_total_len < 0) {
				    char *tmp_pos = _bufpos;
				    long tmp_len = _buflen;

				    if ((_data_tag = _oss_dec_tag(_g, &tmp_pos, &tmp_len)) == 0) {
					if (_oss_dec_length(_g, &tmp_pos, &tmp_len))
					    _oss_dec_error(_g, _non_std_eoc, 0L);
					_oss_c->_tag_decoded = FALSE;
					_bufpos = tmp_pos;
					_buflen = tmp_len;
					break;
				    }
				} else
				    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
					if (_bufpos > _end_pos)
					    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
					break;
				    }
#if OSSDEBUG > 1
				count++;
#endif
				_temp1->next = (_setof13 *)_oss_dec_const_alloc(_g, sizeof(_setof13));
				_temp1 = _temp1->next;
				OSS_CNTX_SETOCC(count)
#ifdef OSS_OPENTYPE_HAS_USERFIELD
				_temp1->value.userField = nullptr;
#endif
				_oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_temp1->value.encoded);
				_temp1->value.pduNum = 0;
				*(void **)&_temp1->value.decoded = nullptr;
			    }
			    _temp1->next = nullptr;
			    OSS_CNTX_POP(_oss_c)
			}
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			OSS_CNTX_POP(_oss_c)
			if (_bufpos < _end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x11 || _bufpos >= _end_pos)
			 {
			    _temp->value.u.control->bit_mask &= ~0x80000000;
			    memset(&_temp->value.u.control->valuesWithContext, 0, sizeof(_temp->value.u.control->valuesWithContext));
			}
else {
			    _temp->value.u.control->bit_mask |= 0x80000000;
			    OSS_CNTX_PUSH(_oss_c, 77)
			    _temp->value.u.control->valuesWithContext = nullptr;
			    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				_buflen -= 2;
				_bufpos += 2;
			    } else {
				if (!_oss_c->_tag_decoded || _data_tag == 0x11) {
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x11 : 0);
				} else
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x110000);
				_oss_c->_tag_decoded = FALSE;
			    }
			    _data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
			    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				    _oss_c->reserved.fields.ext->seqSetNestingLimit)
				_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			    {
				_setof14 * _temp1 = (_setof14 *)&_temp->value.u.control->valuesWithContext;
				long _total_len = _data_length;
				char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
				unsigned long count = 0;
#endif
				OSS_CNTX_INIT

				OSS_CNTX_PUSH(_oss_c, 29)
				for (;;) {
				    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
					if (_bufpos > _end_pos)
					    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
					break;
				    }
				    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
					_buflen--;
					_oss_c->_bitpos = _bufpos[0] & 0x20;
					_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
					_bufpos++;
				    } else
					if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
					    if (_oss_dec_length(_g, &_bufpos, &_buflen))
						_oss_dec_error(_g, _non_std_eoc, 0L);
					    _oss_c->_tag_decoded = FALSE;
					    break;
					}
				    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
				    count++;
#endif
				    if (_data_tag != 0x10)
					_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
				    _temp1->next = (_setof14 *)_oss_dec_const_alloc(_g, sizeof(_setof14));
				    _temp1 = _temp1->next;
				    OSS_CNTX_SETOCC(count)
				    _oss_c->_tag_decoded = FALSE;
				    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					_buflen--;
					_bufpos++;
				    } else
					_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
				    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
					    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
					    _oss_c->reserved.fields.ext->seqSetNestingLimit)
					_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
				    {
					long _total_len = _data_length;
					char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
					OSS_CNTX_INIT

					OSS_CNTX_PUSH(_oss_c, 82)
					if (_data_length == 0) _data_length = 1;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
					_temp1->value.value.userField = nullptr;
#endif
					_oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_temp1->value.value.encoded);
					_temp1->value.value.pduNum = 0;
					*(void **)&_temp1->value.value.decoded = nullptr;
					OSS_CNTX_SET(78)
					if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
					    _buflen -= 2;
					    _bufpos += 2;
					} else
					    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
					_data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
					if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
						++_oss_c->reserved.fields.ext->seqSetNestingCounter >
						_oss_c->reserved.fields.ext->seqSetNestingLimit)
					    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
					{
					    _setof15 * _temp2 = (_setof15 *)&_temp1->value.contextList;
					    long _total_len = _data_length;
					    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
					    unsigned long count = 0;
#endif
					    OSS_CNTX_INIT

					    OSS_CNTX_PUSH(_oss_c, 79)
					    for (;;) {
						if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
						    if (_bufpos > _end_pos)
							_oss_dec_error(_g, _inconsis_len, 0L);
#endif
						    break;
						}
						if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
						    _buflen--;
						    _oss_c->_bitpos = _bufpos[0] & 0x20;
						    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
						    _bufpos++;
						} else
						    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
							if (_oss_dec_length(_g, &_bufpos, &_buflen))
							    _oss_dec_error(_g, _non_std_eoc, 0L);
							_oss_c->_tag_decoded = FALSE;
							break;
						    }
						_oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
						count++;
#endif
						if (_data_tag != 0x10)
						    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
						_temp2->next = (_setof15 *)_oss_dec_const_alloc(_g, sizeof(_setof15));
						_temp2 = _temp2->next;
						OSS_CNTX_SETOCC(count)
						_oss_c->_tag_decoded = FALSE;
						if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
						    _buflen--;
						    _bufpos++;
						} else
						    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
						_d_Context(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp2->value);
					    }
					    _temp2->next = nullptr;
					    OSS_CNTX_POP(_oss_c)
					}
#ifndef OSS_NO_NESTING_CONTROL
					if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
					    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
					OSS_CNTX_POP(_oss_c)
					if (_bufpos != _end_pos) {
					    if (_total_len < 0) {
						if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
						    _buflen--;
						    _bufpos++;
						} else
						    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

						if (_data_tag)
						    _oss_dec_error(_g, _expec_eoc, 0L);
						if (_oss_dec_length(_g, &_bufpos, &_buflen))
						    _oss_dec_error(_g, _non_std_eoc, 0L);
						_oss_c->_tag_decoded = FALSE;
					    } else
						_oss_dec_error(_g, _inconsis_len, 0L);
					}
				    }
#ifndef OSS_NO_NESTING_CONTROL
				    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
					_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
				}
				_temp1->next = nullptr;
				OSS_CNTX_POP(_oss_c)
			    }
#ifndef OSS_NO_NESTING_CONTROL
			    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
				_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			    OSS_CNTX_POP(_oss_c)
			}
			if (_bufpos != _end_pos) {
			    if (_total_len < 0) {
				if (!_oss_c->_tag_decoded)
				    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

				if (_data_tag)
				    _oss_dec_error(_g, _expec_eoc, 0L);
				if (_oss_dec_length(_g, &_bufpos, &_buflen))
				    _oss_dec_error(_g, _non_std_eoc, 0L);
				_oss_c->_tag_decoded = FALSE;
			    } else
				_oss_dec_error(_g, _inconsis_len, 0L);
			}
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		}   break;
		default:
		    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
		    switch (_data_tag & 0x7fff) {
		    case 0x0: {
			OSS_CNTX_PUSH(_oss_c, 238)
			_temp->value.choice = 2;

			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			if (_data_length < 0) ++_indef_tags;
			_temp->value.u.initial = (_UnboundedDirectoryString *)_oss_dec_const_alloc(_g, sizeof(_UnboundedDirectoryString));
			_d_UnboundedDirectoryString(_g, &_bufpos, &_buflen, _data_length, _data_tag, _temp->value.u.initial);
			while (_indef_tags > 0) {
			    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				if (!_buflen || _bufpos[0])
				    _oss_dec_error(_g, _expec_eoc, 0L);
				else
				    _oss_dec_error(_g, _non_std_eoc, 0L);
			    _indef_tags--;
			}
		    }   break;
		    case 0x1: {
			OSS_CNTX_PUSH(_oss_c, 239)
			_temp->value.choice = 3;

			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			if (_data_length < 0) ++_indef_tags;
			_temp->value.u.any = (_UnboundedDirectoryString *)_oss_dec_const_alloc(_g, sizeof(_UnboundedDirectoryString));
			_d_UnboundedDirectoryString(_g, &_bufpos, &_buflen, _data_length, _data_tag, _temp->value.u.any);
			while (_indef_tags > 0) {
			    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				if (!_buflen || _bufpos[0])
				    _oss_dec_error(_g, _expec_eoc, 0L);
				else
				    _oss_dec_error(_g, _non_std_eoc, 0L);
			    _indef_tags--;
			}
		    }   break;
		    case 0x2: {
			OSS_CNTX_PUSH(_oss_c, 240)
			_temp->value.choice = 4;

			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			if (_data_length < 0) ++_indef_tags;
			_temp->value.u.final = (_UnboundedDirectoryString *)_oss_dec_const_alloc(_g, sizeof(_UnboundedDirectoryString));
			_d_UnboundedDirectoryString(_g, &_bufpos, &_buflen, _data_length, _data_tag, _temp->value.u.final);
			while (_indef_tags > 0) {
			    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				if (!_buflen || _bufpos[0])
				    _oss_dec_error(_g, _expec_eoc, 0L);
				else
				    _oss_dec_error(_g, _non_std_eoc, 0L);
			    _indef_tags--;
			}
		    }   break;
		    default:
			_oss_dec_error(_g, _unknown_field, _data_tag);
		    }
		    break;
		}
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	}
	_temp->next = nullptr;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpSubstringAssertion(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SubstringAssertion	**_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(36,234)
    _out_data = (_SubstringAssertion **)_oss_dec_const_init_alloc(_g, sizeof(_SubstringAssertion *));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_SubstringAssertion * _temp = (_SubstringAssertion *)_out_data;
	unsigned long count = 0;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 235)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_SubstringAssertion *)_oss_dec_const_alloc(_g, sizeof(_SubstringAssertion));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    OSS_CNTX_INIT

		    {

			_temp->value.choice = (int)_oss_pdec_nonneg_2int(_g) + 1;
		    }
		    switch (_temp->value.choice) {
		    case 1:
			OSS_CNTX_PUSH(_oss_c, 236)
			_temp->value.u.control = (_Attribute *)_oss_dec_const_alloc(_g, sizeof(_Attribute));
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			{
			    OSS_CNTX_INIT

			    _temp->value.u.control->bit_mask = (OSS_UINT32)_oss_get_1bit_unaligned(_g) << 24;
			    OSS_CNTX_PUSH(_oss_c, 83)
			    _temp->value.u.control->type.length = _oss_pdec_eobjid_ia(_g, &_temp->value.u.control->type.value, -1);
			    OSS_CNTX_SET(237)
#ifndef OSS_NO_NESTING_CONTROL
			    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				    _oss_c->reserved.fields.ext->seqSetNestingLimit)
				_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			    {
				_setof13 * _temp1 = (_setof13 *)&_temp->value.u.control->values;
				unsigned long count = 0;
				ossBoolean _last = FALSE;
				unsigned long _index1 = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
				unsigned long _prev_fragm1 = 0;
#endif

				OSS_CNTX_INIT

				OSS_CNTX_PUSH(_oss_c, 6)
				while (!_last) {
				    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
				    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
					if ((!_last) && _index1 && (_prev_fragm1 < 65536))
					    _oss_dec_error(_g, _invalid_fragmentation, 0L);
					_prev_fragm1 = count - _index1;
				    }
#endif
				    for (; (unsigned long)_index1 < count; _index1++) {
					_temp1->next = (_setof13 *)_oss_dec_const_alloc(_g, sizeof(_setof13));
					_temp1 = _temp1->next;
					OSS_CNTX_SETOCC(_index1 + 1)
#ifdef OSS_OPENTYPE_HAS_USERFIELD
					_temp1->value.userField = nullptr;
#endif
					_temp1->value.encoded.length = _oss_pdec_unconstr_uoct_ia(_g, &_temp1->value.encoded.value);
					if (_temp1->value.encoded.length == 0 && ((STRICT_ENCODING_DECODING_RULES | AUTOMATIC_ENCDEC) & _g->decodingFlags))
					    _oss_dec_error(_g, _zero_length_OpenType, 0L);
					_temp1->value.pduNum = 0;
					*(void **)&_temp1->value.decoded = nullptr;
				    }
				    OSS_CNTX_POP(_oss_c)
				}
				_temp1->next = nullptr;
			    }
#ifndef OSS_NO_NESTING_CONTROL
			    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
				_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			    OSS_CNTX_SET(77)
			    _temp->value.u.control->valuesWithContext = nullptr;
			    if (_temp->value.u.control->bit_mask & 0x80000000) {
#ifndef OSS_NO_NESTING_CONTROL
				if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
					++_oss_c->reserved.fields.ext->seqSetNestingCounter >
					_oss_c->reserved.fields.ext->seqSetNestingLimit)
				    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
				{
				    _setof14 * _temp1 = (_setof14 *)&_temp->value.u.control->valuesWithContext;
				    unsigned long count = 0;
				    ossBoolean _last = FALSE;
				    unsigned long _index1 = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
				    unsigned long _prev_fragm1 = 0;
#endif

				    OSS_CNTX_INIT

				    OSS_CNTX_PUSH(_oss_c, 29)
				    while (!_last) {
					count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
					if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
					    if ((!_last) && _index1 && (_prev_fragm1 < 65536))
						_oss_dec_error(_g, _invalid_fragmentation, 0L);
					    _prev_fragm1 = count - _index1;
					}
#endif
					for (; (unsigned long)_index1 < count; _index1++) {
					    _temp1->next = (_setof14 *)_oss_dec_const_alloc(_g, sizeof(_setof14));
					    _temp1 = _temp1->next;
					    OSS_CNTX_SETOCC(_index1 + 1)
#ifndef OSS_NO_NESTING_CONTROL
					    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
						    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
						    _oss_c->reserved.fields.ext->seqSetNestingLimit)
						_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
					    {
						OSS_CNTX_INIT

						OSS_CNTX_PUSH(_oss_c, 82)
#ifdef OSS_OPENTYPE_HAS_USERFIELD
						_temp1->value.value.userField = nullptr;
#endif
						_temp1->value.value.encoded.length = _oss_pdec_unconstr_uoct_ia(_g, &_temp1->value.value.encoded.value);
						if (_temp1->value.value.encoded.length == 0 && ((STRICT_ENCODING_DECODING_RULES | AUTOMATIC_ENCDEC) & _g->decodingFlags))
						    _oss_dec_error(_g, _zero_length_OpenType, 0L);
						_temp1->value.value.pduNum = 0;
						*(void **)&_temp1->value.value.decoded = nullptr;
						OSS_CNTX_SET(78)
#ifndef OSS_NO_NESTING_CONTROL
						if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
							++_oss_c->reserved.fields.ext->seqSetNestingCounter >
							_oss_c->reserved.fields.ext->seqSetNestingLimit)
						    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
						{
						    _setof15 * _temp2 = (_setof15 *)&_temp1->value.contextList;
						    unsigned long count = 0;
						    ossBoolean _last = FALSE;
						    unsigned long _index2 = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
						    unsigned long _prev_fragm2 = 0;
#endif

						    OSS_CNTX_INIT

						    OSS_CNTX_PUSH(_oss_c, 79)
						    while (!_last) {
							count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
							if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
							    if ((!_last) && _index2 && (_prev_fragm2 < 65536))
								_oss_dec_error(_g, _invalid_fragmentation, 0L);
							    _prev_fragm2 = count - _index2;
							}
#endif
							for (; (unsigned long)_index2 < count; _index2++) {
							    _temp2->next = (_setof15 *)_oss_dec_const_alloc(_g, sizeof(_setof15));
							    _temp2 = _temp2->next;
							    OSS_CNTX_SETOCC(_index2 + 1)
							    _dp_Context(_g, &_temp2->value);
							}
							OSS_CNTX_POP(_oss_c)
						    }
						    _temp2->next = nullptr;
						}
#ifndef OSS_NO_NESTING_CONTROL
						if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
						    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
						OSS_CNTX_POP(_oss_c)
					    }
#ifndef OSS_NO_NESTING_CONTROL
					    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
						_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
					}
					OSS_CNTX_POP(_oss_c)
				    }
				    _temp1->next = nullptr;
				}
#ifndef OSS_NO_NESTING_CONTROL
				if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
				    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			    } else {
				_temp->value.u.control->valuesWithContext = nullptr;
			    }
			    OSS_CNTX_POP(_oss_c)
			}
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			break;
		    case 2:
			OSS_CNTX_PUSH(_oss_c, 238)
			_temp->value.u.initial = (_UnboundedDirectoryString *)_oss_dec_const_alloc(_g, sizeof(_UnboundedDirectoryString));
			_dp_UnboundedDirectoryString(_g, _temp->value.u.initial);
			break;
		    case 3:
			OSS_CNTX_PUSH(_oss_c, 239)
			_temp->value.u.any = (_UnboundedDirectoryString *)_oss_dec_const_alloc(_g, sizeof(_UnboundedDirectoryString));
			_dp_UnboundedDirectoryString(_g, _temp->value.u.any);
			break;
		    case 4:
			OSS_CNTX_PUSH(_oss_c, 240)
			_temp->value.u.final = (_UnboundedDirectoryString *)_oss_dec_const_alloc(_g, sizeof(_UnboundedDirectoryString));
			_dp_UnboundedDirectoryString(_g, _temp->value.u.final);
			break;
		    default:
			_oss_enc_error(_g, _bad_choice, _temp->value.choice);	/* Bad choice selector. */
		    }
		    OSS_CNTX_POP(_oss_c)
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = nullptr;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dCaseIgnoreList(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PostalAddress **_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(37,241)
    _out_data = (_PostalAddress **)_oss_dec_const_init_alloc(_g, sizeof(_PostalAddress *));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_PostalAddress * _temp = (_PostalAddress *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 200)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    _temp->next = (_PostalAddress *)_oss_dec_const_alloc(_g, sizeof(_PostalAddress));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
	    _d_UnboundedDirectoryString(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
	}
	_temp->next = nullptr;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpCaseIgnoreList(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PostalAddress	**_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(37,241)
    _out_data = (_PostalAddress **)_oss_dec_const_init_alloc(_g, sizeof(_PostalAddress *));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_PostalAddress * _temp = (_PostalAddress *)_out_data;
	unsigned long count = 0;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 200)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_PostalAddress *)_oss_dec_const_alloc(_g, sizeof(_PostalAddress));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
		_dp_UnboundedDirectoryString(_g, &_temp->value);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = nullptr;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dOctetSubstringAssertion(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _OctetSubstringAssertion **_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(38,242)
    _out_data = (_OctetSubstringAssertion **)_oss_dec_const_init_alloc(_g, sizeof(_OctetSubstringAssertion *));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_OctetSubstringAssertion * _temp = (_OctetSubstringAssertion *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 235)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    _temp->next = (_OctetSubstringAssertion *)_oss_dec_const_alloc(_g, sizeof(_OctetSubstringAssertion));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		int _indef_tags = 0;
		OSS_CNTX_INIT

		switch (_data_tag) {
		default:
		    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
		    switch (_data_tag & 0x7fff) {
		    case 0x0: {
			OSS_CNTX_PUSH(_oss_c, 243)
			_temp->value.choice = 1;

			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			if (_data_length < 0) ++_indef_tags;
			if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			    _buflen -= 2;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
			_data_tag = 0x4;
			_temp->value.u.initial.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.u.initial.value, 0);
			while (_indef_tags > 0) {
			    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				if (!_buflen || _bufpos[0])
				    _oss_dec_error(_g, _expec_eoc, 0L);
				else
				    _oss_dec_error(_g, _non_std_eoc, 0L);
			    _indef_tags--;
			}
		    }   break;
		    case 0x1: {
			OSS_CNTX_PUSH(_oss_c, 244)
			_temp->value.choice = 2;

			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			if (_data_length < 0) ++_indef_tags;
			if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			    _buflen -= 2;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
			_data_tag = 0x4;
			_temp->value.u.any.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.u.any.value, 0);
			while (_indef_tags > 0) {
			    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				if (!_buflen || _bufpos[0])
				    _oss_dec_error(_g, _expec_eoc, 0L);
				else
				    _oss_dec_error(_g, _non_std_eoc, 0L);
			    _indef_tags--;
			}
		    }   break;
		    case 0x2: {
			OSS_CNTX_PUSH(_oss_c, 245)
			_temp->value.choice = 3;

			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			if (_data_length < 0) ++_indef_tags;
			if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			    _buflen -= 2;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
			_data_tag = 0x4;
			_temp->value.u.final.length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.u.final.value, 0);
			while (_indef_tags > 0) {
			    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				if (!_buflen || _bufpos[0])
				    _oss_dec_error(_g, _expec_eoc, 0L);
				else
				    _oss_dec_error(_g, _non_std_eoc, 0L);
			    _indef_tags--;
			}
		    }   break;
		    default:
			_oss_dec_error(_g, _unknown_field, _data_tag);
		    }
		    break;
		}
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	}
	_temp->next = nullptr;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpOctetSubstringAssertion(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _OctetSubstringAssertion	**_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(38,242)
    _out_data = (_OctetSubstringAssertion **)_oss_dec_const_init_alloc(_g, sizeof(_OctetSubstringAssertion *));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_OctetSubstringAssertion * _temp = (_OctetSubstringAssertion *)_out_data;
	unsigned long count = 0;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 235)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_OctetSubstringAssertion *)_oss_dec_const_alloc(_g, sizeof(_OctetSubstringAssertion));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    OSS_CNTX_INIT

		    {

			_temp->value.choice = (int)_oss_pdec_nonneg_2int(_g) + 1;
		    }
		    switch (_temp->value.choice) {
		    case 1:
			OSS_CNTX_PUSH(_oss_c, 243)
			_temp->value.u.initial.length = _oss_pdec_unconstr_uoct_ia(_g, (unsigned char **)&_temp->value.u.initial.value);

			break;
		    case 2:
			OSS_CNTX_PUSH(_oss_c, 244)
			_temp->value.u.any.length = _oss_pdec_unconstr_uoct_ia(_g, (unsigned char **)&_temp->value.u.any.value);

			break;
		    case 3:
			OSS_CNTX_PUSH(_oss_c, 245)
			_temp->value.u.final.length = _oss_pdec_unconstr_uoct_ia(_g, (unsigned char **)&_temp->value.u.final.value);

			break;
		    default:
			_oss_enc_error(_g, _bad_choice, _temp->value.choice);	/* Bad choice selector. */
		    }
		    OSS_CNTX_POP(_oss_c)
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = nullptr;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dSequenceMatchType(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    enum SequenceMatchType *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(39,246)
    _out_data = (enum SequenceMatchType *)_oss_dec_const_alloc(_g, sizeof(enum SequenceMatchType));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 10 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0xA);
    _data_tag = 0xA;
    *_out_data = (enum SequenceMatchType )_oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpSequenceMatchType(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    enum SequenceMatchType	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(39,246)
    _out_data = (enum SequenceMatchType *)_oss_dec_const_alloc(_g, sizeof(enum SequenceMatchType));
    *_out_data = (enum SequenceMatchType)_oss_pdec_uenum(_g, (struct _enum_data*)&_enums[4], nullptr);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dWordMatchTypes(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    enum WordMatchTypes *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(40,247)
    _out_data = (enum WordMatchTypes *)_oss_dec_const_alloc(_g, sizeof(enum WordMatchTypes));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 10 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0xA);
    _data_tag = 0xA;
    *_out_data = (enum WordMatchTypes )_oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpWordMatchTypes(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    enum WordMatchTypes	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(40,247)
    _out_data = (enum WordMatchTypes *)_oss_dec_const_alloc(_g, sizeof(enum WordMatchTypes));
    *_out_data = (enum WordMatchTypes)_oss_pdec_uenum(_g, (struct _enum_data*)&_enums[5], nullptr);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dCharacterMatchTypes(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    enum CharacterMatchTypes *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(41,248)
    _out_data = (enum CharacterMatchTypes *)_oss_dec_const_alloc(_g, sizeof(enum CharacterMatchTypes));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 10 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0xA);
    _data_tag = 0xA;
    *_out_data = (enum CharacterMatchTypes )_oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpCharacterMatchTypes(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    enum CharacterMatchTypes	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(41,248)
    _out_data = (enum CharacterMatchTypes *)_oss_dec_const_alloc(_g, sizeof(enum CharacterMatchTypes));
    *_out_data = (enum CharacterMatchTypes)_oss_pdec_uenum(_g, (struct _enum_data*)&_enums[6], nullptr);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dLanguageContextSyntax(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(42,249)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 19 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x13);
    _data_tag = 0x13;
    _out_data->length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 3);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpLanguageContextSyntax(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(42,249)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _out_data->length = _oss_pdec_ub_kmstr(_g, &_out_data->value, _chars + 11);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dTimeSpecification(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _TimeSpecification *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(43,250)
    _out_data = (_TimeSpecification *)_oss_dec_const_alloc(_g, sizeof(_TimeSpecification));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 253)
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    OSS_CNTX_INIT

	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	    switch (_data_tag) {
	    case 0x10: {
		OSS_CNTX_PUSH(_oss_c, 254)
		_out_data->time.choice = 1;
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_out_data->time.u.absolute = (_seq10 *)_oss_dec_const_alloc(_g, sizeof(_seq10));
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    int _indef_tags = 0;
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    OSS_CNTX_INIT

		    if (_bufpos < _end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if (_data_tag != 0x8000 || _bufpos >= _end_pos)
			_out_data->time.u.absolute->startTime = nullptr;
		    else {
			OSS_CNTX_PUSH(_oss_c, 256)
			_out_data->time.u.absolute->startTime = nullptr;
			if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else {
			    if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
			    } else
				_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
			    _oss_c->_tag_decoded = FALSE;
			}
			_data_tag = 0x8000;
			if (_data_length < 0) ++_indef_tags;
			if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
			_data_tag = 0x18;
			_oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->time.u.absolute->startTime, -1, 0);
			while (_indef_tags > 0) {
			    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				if (!_buflen || _bufpos[0])
				    _oss_dec_error(_g, _expec_eoc, 0L);
				else
				    _oss_dec_error(_g, _non_std_eoc, 0L);
			    _indef_tags--;
			}
			OSS_CNTX_POP(_oss_c)
		    }
		    if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
			if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			_oss_c->_tag_decoded = TRUE;
		    }
		    if (_data_tag != 0x8001 || _bufpos >= _end_pos)
			_out_data->time.u.absolute->endTime = nullptr;
		    else {
			OSS_CNTX_PUSH(_oss_c, 255)
			_out_data->time.u.absolute->endTime = nullptr;
			if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else {
			    if (!_oss_c->_tag_decoded || _data_tag == 0x8001) {
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x81 : 0);
			    } else
				_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80010000);
			    _oss_c->_tag_decoded = FALSE;
			}
			_data_tag = 0x8001;
			if (_data_length < 0) ++_indef_tags;
			if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
			_data_tag = 0x18;
			_oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->time.u.absolute->endTime, -1, 0);
			while (_indef_tags > 0) {
			    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				if (!_buflen || _bufpos[0])
				    _oss_dec_error(_g, _expec_eoc, 0L);
				else
				    _oss_dec_error(_g, _non_std_eoc, 0L);
			    _indef_tags--;
			}
			OSS_CNTX_POP(_oss_c)
		    }
		    if (_bufpos != _end_pos) {
			if (_total_len < 0) {
			    if (!_oss_c->_tag_decoded)
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			    if (_data_tag)
				_oss_dec_error(_g, _expec_eoc, 0L);
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			} else
			    _oss_dec_error(_g, _inconsis_len, 0L);
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    }   break;
	    case 0x11: {
		OSS_CNTX_PUSH(_oss_c, 257)
		_out_data->time.choice = 2;
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    _setof10 * _temp = (_setof10 *)&_out_data->time.u.periodic;
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
		    unsigned long count = 0;
#endif
		    OSS_CNTX_INIT

		    OSS_CNTX_PUSH(_oss_c, 258)
		    for (;;) {
			if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			    if (_bufpos > _end_pos)
				_oss_dec_error(_g, _inconsis_len, 0L);
#endif
			    break;
			}
			if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			    _bufpos++;
			} else
			    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
				if (_oss_dec_length(_g, &_bufpos, &_buflen))
				    _oss_dec_error(_g, _non_std_eoc, 0L);
				_oss_c->_tag_decoded = FALSE;
				break;
			    }
			_oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
			count++;
#endif
			if (_data_tag != 0x10)
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
			_temp->next = (_setof10 *)_oss_dec_const_alloc(_g, sizeof(_setof10));
			_temp = _temp->next;
			OSS_CNTX_SETOCC(count)
			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			{
			    int _indef_tags = 0;
			    long _total_len = _data_length;
			    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
			    OSS_CNTX_INIT

			    _temp->value.bit_mask = 0;
			    if (_bufpos < _end_pos) {
				if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				    _buflen--;
				    _oss_c->_bitpos = _bufpos[0] & 0x20;
				    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				    _bufpos++;
				} else
				    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
				_oss_c->_tag_decoded = TRUE;
			    }
			    if (_data_tag != 0x8000 || _bufpos >= _end_pos)
			     {
				_temp->value.bit_mask &= ~0x80000000;
				memset(&_temp->value.timesOfDay, 0, sizeof(_temp->value.timesOfDay));
			    }
else {
				_temp->value.bit_mask |= 0x80000000;
				OSS_CNTX_PUSH(_oss_c, 277)
				_temp->value.timesOfDay = nullptr;
				if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else {
				    if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
					_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
				    } else
					_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
				    _oss_c->_tag_decoded = FALSE;
				}
				_data_tag = 0x8000;
				if (_data_length < 0) ++_indef_tags;
				if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
				_data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
				if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
					++_oss_c->reserved.fields.ext->seqSetNestingCounter >
					_oss_c->reserved.fields.ext->seqSetNestingLimit)
				    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
				{
				    _setof8 * _temp1 = (_setof8 *)&_temp->value.timesOfDay;
				    long _total_len = _data_length;
				    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
				    unsigned long count = 0;
#endif
				    OSS_CNTX_INIT

				    OSS_CNTX_PUSH(_oss_c, 278)
				    for (;;) {
					if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
					    if (_bufpos > _end_pos)
						_oss_dec_error(_g, _inconsis_len, 0L);
#endif
					    break;
					}
					if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
					    _buflen--;
					    _oss_c->_bitpos = _bufpos[0] & 0x20;
					    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
					    _bufpos++;
					} else
					    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
						if (_oss_dec_length(_g, &_bufpos, &_buflen))
						    _oss_dec_error(_g, _non_std_eoc, 0L);
						_oss_c->_tag_decoded = FALSE;
						break;
					    }
					_oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
					count++;
#endif
					if (_data_tag != 0x10)
					    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
					_temp1->next = (_setof8 *)_oss_dec_const_alloc(_g, sizeof(_setof8));
					_temp1 = _temp1->next;
					OSS_CNTX_SETOCC(count)
					_oss_c->_tag_decoded = FALSE;
					if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					    _buflen--;
					    _bufpos++;
					} else
					    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
					if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
						++_oss_c->reserved.fields.ext->seqSetNestingCounter >
						_oss_c->reserved.fields.ext->seqSetNestingLimit)
					    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
					{
					    int _indef_tags = 0;
					    long _total_len = _data_length;
					    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
					    OSS_CNTX_INIT

					    _temp1->value.bit_mask = 0;
					    if (_bufpos < _end_pos) {
						if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
						    _buflen--;
						    _oss_c->_bitpos = _bufpos[0] & 0x20;
						    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
						    _bufpos++;
						} else
						    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
						_oss_c->_tag_decoded = TRUE;
					    }
					    if (_data_tag != 0x8000 || _bufpos >= _end_pos)
					     {
						_temp1->value.bit_mask &= ~0x80000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
						memcpy(&_temp1->value.startDayTime, &_v636, sizeof(_v636));
#else
						memset(&(_temp1->value.startDayTime), 0, sizeof(_DayTime ));
#endif
					    }
else {
						_temp1->value.bit_mask |= 0x80000000;
						OSS_CNTX_PUSH(_oss_c, 280)
						if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
						    _buflen -= 2;
						    _bufpos += 2;
						} else {
						    if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
							_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
						    } else
							_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
						    _oss_c->_tag_decoded = FALSE;
						}
						_data_tag = 0x8000;
						if (_data_length < 0) ++_indef_tags;
						if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
						    _buflen -= 2;
						    _bufpos += 2;
						} else
						    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
						_data_tag = 0x10;
						_d_DayTime(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp1->value.startDayTime);
						while (_indef_tags > 0) {
						    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
							_buflen -= 2;
							_bufpos += 2;
						    } else
							if (!_buflen || _bufpos[0])
							    _oss_dec_error(_g, _expec_eoc, 0L);
							else
							    _oss_dec_error(_g, _non_std_eoc, 0L);
						    _indef_tags--;
						}
						OSS_CNTX_POP(_oss_c)
					    }
					    if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
						if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
						    _buflen--;
						    _oss_c->_bitpos = _bufpos[0] & 0x20;
						    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
						    _bufpos++;
						} else
						    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
						_oss_c->_tag_decoded = TRUE;
					    }
					    if (_data_tag != 0x8001 || _bufpos >= _end_pos)
					     {
						_temp1->value.bit_mask &= ~0x40000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
						memcpy(&_temp1->value.endDayTime, &_v637, sizeof(_v637));
#else
						memset(&(_temp1->value.endDayTime), 0, sizeof(_DayTime ));
#endif
					    }
else {
						_temp1->value.bit_mask |= 0x40000000;
						OSS_CNTX_PUSH(_oss_c, 279)
						if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
						    _buflen -= 2;
						    _bufpos += 2;
						} else {
						    if (!_oss_c->_tag_decoded || _data_tag == 0x8001) {
							_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x81 : 0);
						    } else
							_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80010000);
						    _oss_c->_tag_decoded = FALSE;
						}
						_data_tag = 0x8001;
						if (_data_length < 0) ++_indef_tags;
						if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
						    _buflen -= 2;
						    _bufpos += 2;
						} else
						    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
						_data_tag = 0x10;
						_d_DayTime(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp1->value.endDayTime);
						while (_indef_tags > 0) {
						    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
							_buflen -= 2;
							_bufpos += 2;
						    } else
							if (!_buflen || _bufpos[0])
							    _oss_dec_error(_g, _expec_eoc, 0L);
							else
							    _oss_dec_error(_g, _non_std_eoc, 0L);
						    _indef_tags--;
						}
						OSS_CNTX_POP(_oss_c)
					    }
					    if (_bufpos != _end_pos) {
						if (_total_len < 0) {
						    if (!_oss_c->_tag_decoded)
							_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

						    if (_data_tag)
							_oss_dec_error(_g, _expec_eoc, 0L);
						    if (_oss_dec_length(_g, &_bufpos, &_buflen))
							_oss_dec_error(_g, _non_std_eoc, 0L);
						    _oss_c->_tag_decoded = FALSE;
						} else
						    _oss_dec_error(_g, _inconsis_len, 0L);
					    }
					}
#ifndef OSS_NO_NESTING_CONTROL
					if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
					    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
				    }
				    _temp1->next = nullptr;
				    OSS_CNTX_POP(_oss_c)
				}
#ifndef OSS_NO_NESTING_CONTROL
				if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
				    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
				while (_indef_tags > 0) {
				    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
					_buflen -= 2;
					_bufpos += 2;
				    } else
					if (!_buflen || _bufpos[0])
					    _oss_dec_error(_g, _expec_eoc, 0L);
					else
					    _oss_dec_error(_g, _non_std_eoc, 0L);
				    _indef_tags--;
				}
				OSS_CNTX_POP(_oss_c)
			    }
			    if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
				if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				    _buflen--;
				    _oss_c->_bitpos = _bufpos[0] & 0x20;
				    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				    _bufpos++;
				} else
				    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
				_oss_c->_tag_decoded = TRUE;
			    }
			    if (_data_tag != 0x8001 || _bufpos >= _end_pos)
			     {
				_temp->value.bit_mask &= ~0x40000000;
				memset(&_temp->value.days, 0, sizeof(_temp->value.days));
			    }
else {
				_temp->value.bit_mask |= 0x40000000;
				OSS_CNTX_PUSH(_oss_c, 268)
				if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else {
				    if (!_oss_c->_tag_decoded || _data_tag == 0x8001) {
					_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x81 : 0);
				    } else
					_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80010000);
				    _oss_c->_tag_decoded = FALSE;
				}
				_data_tag = 0x8001;
				if (_data_length < 0) ++_indef_tags;
#ifndef OSS_NO_NESTING_CONTROL
				if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
					++_oss_c->reserved.fields.ext->seqSetNestingCounter >
					_oss_c->reserved.fields.ext->seqSetNestingLimit)
				    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
				{
				    OSS_CNTX_INIT

				    if (!_oss_c->_tag_decoded) {
					if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
					    _buflen--;
					    _oss_c->_bitpos = _bufpos[0] & 0x20;
					    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
					    _bufpos++;
					} else
					    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
					_oss_c->_tag_decoded = TRUE;
				    }
				    if (_data_tag == 0x8001 || _data_tag == 0x8002 || _data_tag == 0x8003 || _data_tag == 0x8004 || _data_tag == 0x8005) {
					OSS_CNTX_PUSH(_oss_c, 271)
					_temp->value.days.choice = 3;
					_temp->value.days.u.dayOf = (_XDayOf *)_oss_dec_const_alloc(_g, sizeof(_XDayOf));
#ifndef OSS_NO_NESTING_CONTROL
					if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
						++_oss_c->reserved.fields.ext->seqSetNestingCounter >
						_oss_c->reserved.fields.ext->seqSetNestingLimit)
					    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
					{
					    int _indef_tags = 0;
					    OSS_CNTX_INIT

					    switch (_data_tag) {
					    default:
						if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
						switch (_data_tag & 0x7fff) {
						case 0x1: {
						    OSS_CNTX_PUSH(_oss_c, 272)
						    _temp->value.days.u.dayOf->choice = 1;

						    _oss_c->_tag_decoded = FALSE;
						    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
							_buflen--;
							_bufpos++;
						    } else
							_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
						    if (_data_length < 0) ++_indef_tags;
						    _temp->value.days.u.dayOf->u.first = (_NamedDay *)_oss_dec_const_alloc(_g, sizeof(_NamedDay));
						    _d_NamedDay(_g, &_bufpos, &_buflen, _data_length, _data_tag, _temp->value.days.u.dayOf->u.first);
						    while (_indef_tags > 0) {
							if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
							    _buflen -= 2;
							    _bufpos += 2;
							} else
							    if (!_buflen || _bufpos[0])
								_oss_dec_error(_g, _expec_eoc, 0L);
							    else
								_oss_dec_error(_g, _non_std_eoc, 0L);
							_indef_tags--;
						    }
						}   break;
						case 0x2: {
						    OSS_CNTX_PUSH(_oss_c, 273)
						    _temp->value.days.u.dayOf->choice = 2;

						    _oss_c->_tag_decoded = FALSE;
						    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
							_buflen--;
							_bufpos++;
						    } else
							_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
						    if (_data_length < 0) ++_indef_tags;
						    _temp->value.days.u.dayOf->u.second = (_NamedDay *)_oss_dec_const_alloc(_g, sizeof(_NamedDay));
						    _d_NamedDay(_g, &_bufpos, &_buflen, _data_length, _data_tag, _temp->value.days.u.dayOf->u.second);
						    while (_indef_tags > 0) {
							if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
							    _buflen -= 2;
							    _bufpos += 2;
							} else
							    if (!_buflen || _bufpos[0])
								_oss_dec_error(_g, _expec_eoc, 0L);
							    else
								_oss_dec_error(_g, _non_std_eoc, 0L);
							_indef_tags--;
						    }
						}   break;
						case 0x3: {
						    OSS_CNTX_PUSH(_oss_c, 274)
						    _temp->value.days.u.dayOf->choice = 3;

						    _oss_c->_tag_decoded = FALSE;
						    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
							_buflen--;
							_bufpos++;
						    } else
							_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
						    if (_data_length < 0) ++_indef_tags;
						    _temp->value.days.u.dayOf->u.third = (_NamedDay *)_oss_dec_const_alloc(_g, sizeof(_NamedDay));
						    _d_NamedDay(_g, &_bufpos, &_buflen, _data_length, _data_tag, _temp->value.days.u.dayOf->u.third);
						    while (_indef_tags > 0) {
							if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
							    _buflen -= 2;
							    _bufpos += 2;
							} else
							    if (!_buflen || _bufpos[0])
								_oss_dec_error(_g, _expec_eoc, 0L);
							    else
								_oss_dec_error(_g, _non_std_eoc, 0L);
							_indef_tags--;
						    }
						}   break;
						case 0x4: {
						    OSS_CNTX_PUSH(_oss_c, 275)
						    _temp->value.days.u.dayOf->choice = 4;

						    _oss_c->_tag_decoded = FALSE;
						    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
							_buflen--;
							_bufpos++;
						    } else
							_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
						    if (_data_length < 0) ++_indef_tags;
						    _temp->value.days.u.dayOf->u.fourth = (_NamedDay *)_oss_dec_const_alloc(_g, sizeof(_NamedDay));
						    _d_NamedDay(_g, &_bufpos, &_buflen, _data_length, _data_tag, _temp->value.days.u.dayOf->u.fourth);
						    while (_indef_tags > 0) {
							if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
							    _buflen -= 2;
							    _bufpos += 2;
							} else
							    if (!_buflen || _bufpos[0])
								_oss_dec_error(_g, _expec_eoc, 0L);
							    else
								_oss_dec_error(_g, _non_std_eoc, 0L);
							_indef_tags--;
						    }
						}   break;
						case 0x5: {
						    OSS_CNTX_PUSH(_oss_c, 276)
						    _temp->value.days.u.dayOf->choice = 5;

						    _oss_c->_tag_decoded = FALSE;
						    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
							_buflen--;
							_bufpos++;
						    } else
							_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
						    if (_data_length < 0) ++_indef_tags;
						    _temp->value.days.u.dayOf->u.fifth = (_NamedDay *)_oss_dec_const_alloc(_g, sizeof(_NamedDay));
						    _d_NamedDay(_g, &_bufpos, &_buflen, _data_length, _data_tag, _temp->value.days.u.dayOf->u.fifth);
						    while (_indef_tags > 0) {
							if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
							    _buflen -= 2;
							    _bufpos += 2;
							} else
							    if (!_buflen || _bufpos[0])
								_oss_dec_error(_g, _expec_eoc, 0L);
							    else
								_oss_dec_error(_g, _non_std_eoc, 0L);
							_indef_tags--;
						    }
						}   break;
						default:
						    _oss_dec_error(_g, _unknown_field, _data_tag);
						}
						break;
					    }
					    OSS_CNTX_POP(_oss_c)
					}
#ifndef OSS_NO_NESTING_CONTROL
					if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
					    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
					OSS_CNTX_POP(_oss_c)
				    } else
				    switch (_data_tag) {
				    case 0x3: {
					OSS_CNTX_PUSH(_oss_c, 269)
					_temp->value.days.choice = 1;
					_oss_c->_tag_decoded = FALSE;
					if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					    _buflen--;
					    _bufpos++;
					} else
					    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
					_temp->value.days.u.bitDay.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.days.u.bitDay.value, 0, 128);

				    }   break;
				    case 0x11: {
					OSS_CNTX_PUSH(_oss_c, 270)
					_temp->value.days.choice = 2;
					_oss_c->_tag_decoded = FALSE;
					if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					    _buflen--;
					    _bufpos++;
					} else
					    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
					_d__setof7(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value.days.u.intDay);
				    }   break;
				    default:
					if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
					switch (_data_tag & 0x7fff) {
					default:
					    _oss_dec_error(_g, _unknown_field, _data_tag);
					}
					break;
				    }
				    OSS_CNTX_POP(_oss_c)
				}
#ifndef OSS_NO_NESTING_CONTROL
				if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
				    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
				while (_indef_tags > 0) {
				    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
					_buflen -= 2;
					_bufpos += 2;
				    } else
					if (!_buflen || _bufpos[0])
					    _oss_dec_error(_g, _expec_eoc, 0L);
					else
					    _oss_dec_error(_g, _non_std_eoc, 0L);
				    _indef_tags--;
				}
				OSS_CNTX_POP(_oss_c)
			    }
			    if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
				if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				    _buflen--;
				    _oss_c->_bitpos = _bufpos[0] & 0x20;
				    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				    _bufpos++;
				} else
				    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
				_oss_c->_tag_decoded = TRUE;
			    }
			    if (_data_tag != 0x8002 || _bufpos >= _end_pos)
			     {
				_temp->value.bit_mask &= ~0x20000000;
				memset(&_temp->value.weeks, 0, sizeof(_temp->value.weeks));
			    }
else {
				_temp->value.bit_mask |= 0x20000000;
				OSS_CNTX_PUSH(_oss_c, 264)
				if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else {
				    if (!_oss_c->_tag_decoded || _data_tag == 0x8002) {
					_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x82 : 0);
				    } else
					_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80020000);
				    _oss_c->_tag_decoded = FALSE;
				}
				_data_tag = 0x8002;
				if (_data_length < 0) ++_indef_tags;
#ifndef OSS_NO_NESTING_CONTROL
				if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
					++_oss_c->reserved.fields.ext->seqSetNestingCounter >
					_oss_c->reserved.fields.ext->seqSetNestingLimit)
				    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
				{
				    OSS_CNTX_INIT

				    if (!_oss_c->_tag_decoded) {
					if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
					    _buflen--;
					    _oss_c->_bitpos = _bufpos[0] & 0x20;
					    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
					    _bufpos++;
					} else
					    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
					_oss_c->_tag_decoded = TRUE;
				    }
				    switch (_data_tag) {
				    case 0x3: {
					OSS_CNTX_PUSH(_oss_c, 265)
					_temp->value.weeks.choice = 1;
					_oss_c->_tag_decoded = FALSE;
					if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					    _buflen--;
					    _bufpos++;
					} else
					    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
					_temp->value.weeks.u.bitWeek.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.weeks.u.bitWeek.value, 0, 128);

				    }   break;
				    case 0x5: {
					OSS_CNTX_PUSH(_oss_c, 266)
					_temp->value.weeks.choice = 2;
					_oss_c->_tag_decoded = FALSE;
					if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					    _buflen--;
					    _bufpos++;
					} else
					    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
					_temp->value.weeks.u.allWeeks = 0;
					if (_data_length != 0)
					    _oss_dec_error(_g, _inval_enc, 0L);
				    }   break;
				    case 0x11: {
					OSS_CNTX_PUSH(_oss_c, 267)
					_temp->value.weeks.choice = 3;
					_oss_c->_tag_decoded = FALSE;
					if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					    _buflen--;
					    _bufpos++;
					} else
					    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
					_d__setof7(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value.weeks.u.intWeek);
				    }   break;
				    default:
					_oss_dec_error(_g, _unknown_field, _data_tag);
				    }
				    OSS_CNTX_POP(_oss_c)
				}
#ifndef OSS_NO_NESTING_CONTROL
				if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
				    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
				while (_indef_tags > 0) {
				    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
					_buflen -= 2;
					_bufpos += 2;
				    } else
					if (!_buflen || _bufpos[0])
					    _oss_dec_error(_g, _expec_eoc, 0L);
					else
					    _oss_dec_error(_g, _non_std_eoc, 0L);
				    _indef_tags--;
				}
				OSS_CNTX_POP(_oss_c)
			    }
			    if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
				if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				    _buflen--;
				    _oss_c->_bitpos = _bufpos[0] & 0x20;
				    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				    _bufpos++;
				} else
				    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
				_oss_c->_tag_decoded = TRUE;
			    }
			    if (_data_tag != 0x8003 || _bufpos >= _end_pos)
			     {
				_temp->value.bit_mask &= ~0x10000000;
				memset(&_temp->value.months, 0, sizeof(_temp->value.months));
			    }
else {
				_temp->value.bit_mask |= 0x10000000;
				OSS_CNTX_PUSH(_oss_c, 260)
				if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 163 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else {
				    if (!_oss_c->_tag_decoded || _data_tag == 0x8003) {
					_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x83 : 0);
				    } else
					_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80030000);
				    _oss_c->_tag_decoded = FALSE;
				}
				_data_tag = 0x8003;
				if (_data_length < 0) ++_indef_tags;
#ifndef OSS_NO_NESTING_CONTROL
				if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
					++_oss_c->reserved.fields.ext->seqSetNestingCounter >
					_oss_c->reserved.fields.ext->seqSetNestingLimit)
				    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
				{
				    OSS_CNTX_INIT

				    if (!_oss_c->_tag_decoded) {
					if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
					    _buflen--;
					    _oss_c->_bitpos = _bufpos[0] & 0x20;
					    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
					    _bufpos++;
					} else
					    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
					_oss_c->_tag_decoded = TRUE;
				    }
				    switch (_data_tag) {
				    case 0x3: {
					OSS_CNTX_PUSH(_oss_c, 261)
					_temp->value.months.choice = 1;
					_oss_c->_tag_decoded = FALSE;
					if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					    _buflen--;
					    _bufpos++;
					} else
					    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
					_temp->value.months.u.bitMonth.length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.months.u.bitMonth.value, 0, 128);

				    }   break;
				    case 0x5: {
					OSS_CNTX_PUSH(_oss_c, 262)
					_temp->value.months.choice = 2;
					_oss_c->_tag_decoded = FALSE;
					if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					    _buflen--;
					    _bufpos++;
					} else
					    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
					_temp->value.months.u.allMonths = 0;
					if (_data_length != 0)
					    _oss_dec_error(_g, _inval_enc, 0L);
				    }   break;
				    case 0x11: {
					OSS_CNTX_PUSH(_oss_c, 263)
					_temp->value.months.choice = 3;
					_oss_c->_tag_decoded = FALSE;
					if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					    _buflen--;
					    _bufpos++;
					} else
					    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
					_d__setof7(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value.months.u.intMonth);
				    }   break;
				    default:
					_oss_dec_error(_g, _unknown_field, _data_tag);
				    }
				    OSS_CNTX_POP(_oss_c)
				}
#ifndef OSS_NO_NESTING_CONTROL
				if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
				    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
				while (_indef_tags > 0) {
				    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
					_buflen -= 2;
					_bufpos += 2;
				    } else
					if (!_buflen || _bufpos[0])
					    _oss_dec_error(_g, _expec_eoc, 0L);
					else
					    _oss_dec_error(_g, _non_std_eoc, 0L);
				    _indef_tags--;
				}
				OSS_CNTX_POP(_oss_c)
			    }
			    if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
				if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				    _buflen--;
				    _oss_c->_bitpos = _bufpos[0] & 0x20;
				    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				    _bufpos++;
				} else
				    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
				_oss_c->_tag_decoded = TRUE;
			    }
			    if (_data_tag != 0x8004 || _bufpos >= _end_pos)
			     {
				_temp->value.bit_mask &= ~0x8000000;
				memset(&_temp->value.years, 0, sizeof(_temp->value.years));
			    }
else {
				_temp->value.bit_mask |= 0x8000000;
				OSS_CNTX_PUSH(_oss_c, 259)
				_temp->value.years = nullptr;
				if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 164 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else {
				    if (!_oss_c->_tag_decoded || _data_tag == 0x8004) {
					_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x84 : 0);
				    } else
					_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80040000);
				    _oss_c->_tag_decoded = FALSE;
				}
				_data_tag = 0x8004;
				if (_data_length < 0) ++_indef_tags;
				if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
				_data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
				if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
					++_oss_c->reserved.fields.ext->seqSetNestingCounter >
					_oss_c->reserved.fields.ext->seqSetNestingLimit)
				    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
				{
				    _setof9 * _temp1 = (_setof9 *)&_temp->value.years;
				    long _total_len = _data_length;
				    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
				    unsigned long count = 0;
#endif
				    OSS_CNTX_INIT

				    OSS_CNTX_PUSH(_oss_c, 72)
				    for (;;) {
					if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
					    if (_bufpos > _end_pos)
						_oss_dec_error(_g, _inconsis_len, 0L);
#endif
					    break;
					}
					if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
					    _buflen--;
					    _oss_c->_bitpos = _bufpos[0] & 0x20;
					    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
					    _bufpos++;
					} else
					    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
						if (_oss_dec_length(_g, &_bufpos, &_buflen))
						    _oss_dec_error(_g, _non_std_eoc, 0L);
						_oss_c->_tag_decoded = FALSE;
						break;
					    }
					_oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
					count++;
#endif
					if (_data_tag != 0x2)
					    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x20000);
					_temp1->next = (_setof9 *)_oss_dec_const_alloc(_g, sizeof(_setof9));
					_temp1 = _temp1->next;
					OSS_CNTX_SETOCC(count)
					_oss_c->_tag_decoded = FALSE;
					if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					    _buflen--;
					    _bufpos++;
					} else
					    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
					_temp1->value = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
				    }
				    _temp1->next = nullptr;
				    OSS_CNTX_POP(_oss_c)
				}
#ifndef OSS_NO_NESTING_CONTROL
				if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
				    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
				while (_indef_tags > 0) {
				    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
					_buflen -= 2;
					_bufpos += 2;
				    } else
					if (!_buflen || _bufpos[0])
					    _oss_dec_error(_g, _expec_eoc, 0L);
					else
					    _oss_dec_error(_g, _non_std_eoc, 0L);
				    _indef_tags--;
				}
				OSS_CNTX_POP(_oss_c)
			    }
			    if (_bufpos != _end_pos) {
				if (_total_len < 0) {
				    if (!_oss_c->_tag_decoded)
					_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

				    if (_data_tag)
					_oss_dec_error(_g, _expec_eoc, 0L);
				    if (_oss_dec_length(_g, &_bufpos, &_buflen))
					_oss_dec_error(_g, _non_std_eoc, 0L);
				    _oss_c->_tag_decoded = FALSE;
				} else
				    _oss_dec_error(_g, _inconsis_len, 0L);
			    }
			}
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		    }
		    _temp->next = nullptr;
		    OSS_CNTX_POP(_oss_c)
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    }   break;
	    default:
		_oss_dec_error(_g, _unknown_field, _data_tag);
	    }
	    OSS_CNTX_POP(_oss_c)
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x1 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->notThisTime, &Context::default_fallback, sizeof(Context::default_fallback));
#else
	    _out_data->notThisTime = 0;
#endif
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 252)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 1 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x1) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x1 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x10000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x1;
	    _out_data->notThisTime = _oss_dec_bool(_g, &_bufpos, &_buflen, _data_length);
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x2 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 251)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x2) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x2 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x20000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x2;
	    _out_data->timeZone = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpTimeSpecification(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _TimeSpecification	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(43,250)
    _out_data = (_TimeSpecification *)_oss_dec_const_alloc(_g, sizeof(_TimeSpecification));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_2bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 253)
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    OSS_CNTX_INIT

	    {

		_out_data->time.choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
	    }
	    switch (_out_data->time.choice) {
	    case 1:
		OSS_CNTX_PUSH(_oss_c, 254)
		_out_data->time.u.absolute = (_seq10 *)_oss_dec_const_alloc(_g, sizeof(_seq10));
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    unsigned char _pbase[1];
		    OSS_CNTX_INIT

		    *_pbase = _oss_get_2bit_unaligned(_g);
		    OSS_CNTX_PUSH(_oss_c, 256)
		    if (_pbase[0] & 0x80) {
			_oss_pdec_ntp_kmstr(_g, &_out_data->time.u.absolute->startTime, _chars + 3);
		    } else {
			_out_data->time.u.absolute->startTime = nullptr;
		    }
		    OSS_CNTX_SET(255)
		    if (_pbase[0] & 0x40) {
			_oss_pdec_ntp_kmstr(_g, &_out_data->time.u.absolute->endTime, _chars + 3);
		    } else {
			_out_data->time.u.absolute->endTime = nullptr;
		    }
		    OSS_CNTX_POP(_oss_c)
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		break;
	    case 2:
		OSS_CNTX_PUSH(_oss_c, 257)
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    _setof10 * _temp = (_setof10 *)&_out_data->time.u.periodic;
		    unsigned long count = 0;
		    ossBoolean _last = FALSE;
		    unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    unsigned long _prev_fragm0 = 0;
#endif

		    OSS_CNTX_INIT

		    OSS_CNTX_PUSH(_oss_c, 258)
		    while (!_last) {
			count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
			    if ((!_last) && _index && (_prev_fragm0 < 65536))
				_oss_dec_error(_g, _invalid_fragmentation, 0L);
			    _prev_fragm0 = count - _index;
			}
#endif
			for (; (unsigned long)_index < count; _index++) {
			    _temp->next = (_setof10 *)_oss_dec_const_alloc(_g, sizeof(_setof10));
			    _temp = _temp->next;
			    OSS_CNTX_SETOCC(_index + 1)
#ifndef OSS_NO_NESTING_CONTROL
			    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				    _oss_c->reserved.fields.ext->seqSetNestingLimit)
				_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			    {
				OSS_CNTX_INIT

				_temp->value.bit_mask = (OSS_UINT32)_oss_get_5bit_unaligned(_g) << 24;
				OSS_CNTX_PUSH(_oss_c, 277)
				_temp->value.timesOfDay = nullptr;
				if (_temp->value.bit_mask & 0x80000000) {
#ifndef OSS_NO_NESTING_CONTROL
				    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
					    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
					    _oss_c->reserved.fields.ext->seqSetNestingLimit)
					_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
				    {
					_setof8 * _temp1 = (_setof8 *)&_temp->value.timesOfDay;
					unsigned long count = 0;
					ossBoolean _last = FALSE;
					unsigned long _index1 = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
					unsigned long _prev_fragm1 = 0;
#endif

					OSS_CNTX_INIT

					OSS_CNTX_PUSH(_oss_c, 278)
					while (!_last) {
					    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
					    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
						if ((!_last) && _index1 && (_prev_fragm1 < 65536))
						    _oss_dec_error(_g, _invalid_fragmentation, 0L);
						_prev_fragm1 = count - _index1;
					    }
#endif
					    for (; (unsigned long)_index1 < count; _index1++) {
						_temp1->next = (_setof8 *)_oss_dec_const_alloc(_g, sizeof(_setof8));
						_temp1 = _temp1->next;
						OSS_CNTX_SETOCC(_index1 + 1)
#ifndef OSS_NO_NESTING_CONTROL
						if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
							++_oss_c->reserved.fields.ext->seqSetNestingCounter >
							_oss_c->reserved.fields.ext->seqSetNestingLimit)
						    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
						{
						    OSS_CNTX_INIT

						    _temp1->value.bit_mask = (OSS_UINT32)_oss_get_2bit_unaligned(_g) << 24;
						    OSS_CNTX_PUSH(_oss_c, 280)
						    if (_temp1->value.bit_mask & 0x80000000) {
							_dp_DayTime(_g, &_temp1->value.startDayTime);
						    } else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
							memcpy(&_temp1->value.startDayTime, &_v636, sizeof(_v636));
#else
							memset(&(_temp1->value.startDayTime), 0, sizeof(_DayTime ));
#endif
						    }
						    OSS_CNTX_SET(279)
						    if (_temp1->value.bit_mask & 0x40000000) {
							_dp_DayTime(_g, &_temp1->value.endDayTime);
						    } else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
							memcpy(&_temp1->value.endDayTime, &_v637, sizeof(_v637));
#else
							memset(&(_temp1->value.endDayTime), 0, sizeof(_DayTime ));
#endif
						    }
						    OSS_CNTX_POP(_oss_c)
						}
#ifndef OSS_NO_NESTING_CONTROL
						if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
						    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
					    }
					    OSS_CNTX_POP(_oss_c)
					}
					_temp1->next = nullptr;
				    }
#ifndef OSS_NO_NESTING_CONTROL
				    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
					_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
				} else {
				    _temp->value.timesOfDay = nullptr;
				}
				OSS_CNTX_SET(268)
				if (_temp->value.bit_mask & 0x40000000) {
#ifndef OSS_NO_NESTING_CONTROL
				    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
					    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
					    _oss_c->reserved.fields.ext->seqSetNestingLimit)
					_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
				    {
					OSS_CNTX_INIT

					{

					    _temp->value.days.choice = (int)_oss_pdec_nonneg_2int(_g) + 1;
					}
					switch (_temp->value.days.choice) {
					case 1:
					    OSS_CNTX_PUSH(_oss_c, 269)
					    _temp->value.days.u.bitDay.length = _oss_pdec_unconstr_ubit_ia(_g, &_temp->value.days.u.bitDay.value);

					    break;
					case 2:
					    OSS_CNTX_PUSH(_oss_c, 270)
					    _dp__setof7(_g, &_temp->value.days.u.intDay);
					    break;
					case 3:
					    OSS_CNTX_PUSH(_oss_c, 271)
					    _temp->value.days.u.dayOf = (_XDayOf *)_oss_dec_const_alloc(_g, sizeof(_XDayOf));
#ifndef OSS_NO_NESTING_CONTROL
					    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
						    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
						    _oss_c->reserved.fields.ext->seqSetNestingLimit)
						_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
					    {
						OSS_CNTX_INIT

						{

						    _temp->value.days.u.dayOf->choice = (int)_oss_pdec_nonneg_3int(_g) + 1;
						}
						switch (_temp->value.days.u.dayOf->choice) {
						case 1:
						    OSS_CNTX_PUSH(_oss_c, 272)
						    _temp->value.days.u.dayOf->u.first = (_NamedDay *)_oss_dec_const_alloc(_g, sizeof(_NamedDay));
						    _dp_NamedDay(_g, _temp->value.days.u.dayOf->u.first);
						    break;
						case 2:
						    OSS_CNTX_PUSH(_oss_c, 273)
						    _temp->value.days.u.dayOf->u.second = (_NamedDay *)_oss_dec_const_alloc(_g, sizeof(_NamedDay));
						    _dp_NamedDay(_g, _temp->value.days.u.dayOf->u.second);
						    break;
						case 3:
						    OSS_CNTX_PUSH(_oss_c, 274)
						    _temp->value.days.u.dayOf->u.third = (_NamedDay *)_oss_dec_const_alloc(_g, sizeof(_NamedDay));
						    _dp_NamedDay(_g, _temp->value.days.u.dayOf->u.third);
						    break;
						case 4:
						    OSS_CNTX_PUSH(_oss_c, 275)
						    _temp->value.days.u.dayOf->u.fourth = (_NamedDay *)_oss_dec_const_alloc(_g, sizeof(_NamedDay));
						    _dp_NamedDay(_g, _temp->value.days.u.dayOf->u.fourth);
						    break;
						case 5:
						    OSS_CNTX_PUSH(_oss_c, 276)
						    _temp->value.days.u.dayOf->u.fifth = (_NamedDay *)_oss_dec_const_alloc(_g, sizeof(_NamedDay));
						    _dp_NamedDay(_g, _temp->value.days.u.dayOf->u.fifth);
						    break;
						default:
						    _oss_enc_error(_g, _bad_choice, _temp->value.days.u.dayOf->choice);	/* Bad choice selector. */
						}
						OSS_CNTX_POP(_oss_c)
					    }
#ifndef OSS_NO_NESTING_CONTROL
					    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
						_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
					    break;
					default:
					    _oss_enc_error(_g, _bad_choice, _temp->value.days.choice);	/* Bad choice selector. */
					}
					OSS_CNTX_POP(_oss_c)
				    }
#ifndef OSS_NO_NESTING_CONTROL
				    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
					_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
				} else {
				    memset(&(_temp->value.days), 0, sizeof(_choice7 ));
				}
				OSS_CNTX_SET(264)
				if (_temp->value.bit_mask & 0x20000000) {
#ifndef OSS_NO_NESTING_CONTROL
				    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
					    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
					    _oss_c->reserved.fields.ext->seqSetNestingLimit)
					_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
				    {
					OSS_CNTX_INIT

					{

					    _temp->value.weeks.choice = (int)_oss_pdec_nonneg_2int(_g) + 1;
					}
					switch (_temp->value.weeks.choice) {
					case 1:
					    OSS_CNTX_PUSH(_oss_c, 265)
					    _temp->value.weeks.u.bitWeek.length = _oss_pdec_unconstr_ubit_ia(_g, &_temp->value.weeks.u.bitWeek.value);

					    break;
					case 2:
					    OSS_CNTX_PUSH(_oss_c, 266)
					    break;
					case 3:
					    OSS_CNTX_PUSH(_oss_c, 267)
					    _dp__setof7(_g, &_temp->value.weeks.u.intWeek);
					    break;
					default:
					    _oss_enc_error(_g, _bad_choice, _temp->value.weeks.choice);	/* Bad choice selector. */
					}
					OSS_CNTX_POP(_oss_c)
				    }
#ifndef OSS_NO_NESTING_CONTROL
				    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
					_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
				} else {
				    memset(&(_temp->value.weeks), 0, sizeof(_choice8 ));
				}
				OSS_CNTX_SET(260)
				if (_temp->value.bit_mask & 0x10000000) {
#ifndef OSS_NO_NESTING_CONTROL
				    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
					    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
					    _oss_c->reserved.fields.ext->seqSetNestingLimit)
					_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
				    {
					OSS_CNTX_INIT

					{

					    _temp->value.months.choice = (int)_oss_pdec_nonneg_2int(_g) + 1;
					}
					switch (_temp->value.months.choice) {
					case 1:
					    OSS_CNTX_PUSH(_oss_c, 261)
					    _temp->value.months.u.bitMonth.length = _oss_pdec_unconstr_ubit_ia(_g, &_temp->value.months.u.bitMonth.value);

					    break;
					case 2:
					    OSS_CNTX_PUSH(_oss_c, 262)
					    break;
					case 3:
					    OSS_CNTX_PUSH(_oss_c, 263)
					    _dp__setof7(_g, &_temp->value.months.u.intMonth);
					    break;
					default:
					    _oss_enc_error(_g, _bad_choice, _temp->value.months.choice);	/* Bad choice selector. */
					}
					OSS_CNTX_POP(_oss_c)
				    }
#ifndef OSS_NO_NESTING_CONTROL
				    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
					_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
				} else {
				    memset(&(_temp->value.months), 0, sizeof(_choice9 ));
				}
				OSS_CNTX_SET(259)
				_temp->value.years = nullptr;
				if (_temp->value.bit_mask & 0x8000000) {
#ifndef OSS_NO_NESTING_CONTROL
				    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
					    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
					    _oss_c->reserved.fields.ext->seqSetNestingLimit)
					_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
				    {
					_setof9 * _temp1 = (_setof9 *)&_temp->value.years;
					unsigned long count = 0;
					ossBoolean _last = FALSE;
					unsigned long _index1 = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
					unsigned long _prev_fragm1 = 0;
#endif

					OSS_CNTX_INIT

					OSS_CNTX_PUSH(_oss_c, 72)
					while (!_last) {
					    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
					    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
						if ((!_last) && _index1 && (_prev_fragm1 < 65536))
						    _oss_dec_error(_g, _invalid_fragmentation, 0L);
						_prev_fragm1 = count - _index1;
					    }
#endif
					    for (; (unsigned long)_index1 < count; _index1++) {
						_temp1->next = (_setof9 *)_oss_dec_const_alloc(_g, sizeof(_setof9));
						_temp1 = _temp1->next;
						OSS_CNTX_SETOCC(_index1 + 1)
						{
						    _temp1->value = (OSS_UINT32)_oss_pdec_semicon_limited_int_l(_g, 1000, 0, -1);
						}
					    }
					    OSS_CNTX_POP(_oss_c)
					}
					_temp1->next = nullptr;
				    }
#ifndef OSS_NO_NESTING_CONTROL
				    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
					_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
				} else {
				    _temp->value.years = nullptr;
				}
				OSS_CNTX_POP(_oss_c)
			    }
#ifndef OSS_NO_NESTING_CONTROL
			    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
				_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			}
			OSS_CNTX_POP(_oss_c)
		    }
		    _temp->next = nullptr;
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		break;
	    default:
		_oss_enc_error(_g, _bad_choice, _out_data->time.choice);	/* Bad choice selector. */
	    }
	    OSS_CNTX_POP(_oss_c)
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_SET(252)
	if (_out_data->bit_mask & 0x80000000) {
	    _out_data->notThisTime = _oss_get_1bit_unaligned(_g) ? TRUE : FALSE;
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->notThisTime, &Context::default_fallback, sizeof(Context::default_fallback));
#else
	    _out_data->notThisTime = 0;
#endif
	}
	OSS_CNTX_SET(251)
	if (_out_data->bit_mask & 0x40000000) {
	    {
		_out_data->timeZone = (OSS_INT32)_oss_pdec_nonneg_5int(_g) - 12;
	    }
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dTimeAssertion(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _TimeAssertion *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(44,281)
    _out_data = (_TimeAssertion *)_oss_dec_const_alloc(_g, sizeof(_TimeAssertion));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	switch (_data_tag) {
	case 0x5: {
	    OSS_CNTX_PUSH(_oss_c, 282)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.now = 0;
	    if (_data_length != 0)
		_oss_dec_error(_g, _inval_enc, 0L);
	}   break;
	case 0x10: {
	    OSS_CNTX_PUSH(_oss_c, 283)
	    _out_data->choice = 2;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.between = (_seq11 *)_oss_dec_const_alloc(_g, sizeof(_seq11));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		int _indef_tags = 0;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		OSS_CNTX_INIT

		_out_data->u.between->bit_mask = 0;
		OSS_CNTX_PUSH(_oss_c, 256)
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
		_data_tag = 0x8000;
		if (_data_length < 0) ++_indef_tags;
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
		_data_tag = 0x18;
		_oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.between->startTime, -1, 0);
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
		OSS_CNTX_POP(_oss_c)
		if (_bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x8001 || _bufpos >= _end_pos)
		    _out_data->u.between->endTime = nullptr;
		else {
		    OSS_CNTX_PUSH(_oss_c, 255)
		    _out_data->u.between->endTime = nullptr;
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x8001) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x81 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80010000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x8001;
		    if (_data_length < 0) ++_indef_tags;
		    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
		    _data_tag = 0x18;
		    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.between->endTime, -1, 0);
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
		    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
		    _oss_c->_tag_decoded = TRUE;
		}
		if (_data_tag != 0x1 || _bufpos >= _end_pos)
		 {
		    _out_data->u.between->bit_mask &= ~0x80000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
		    memcpy(&_out_data->u.between->entirely, &Context::default_fallback, sizeof(Context::default_fallback));
#else
		    _out_data->u.between->entirely = 0;
#endif
		}
else {
		    _out_data->u.between->bit_mask |= 0x80000000;
		    OSS_CNTX_PUSH(_oss_c, 284)
		    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 1 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else {
			if (!_oss_c->_tag_decoded || _data_tag == 0x1) {
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x1 : 0);
			} else
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x10000);
			_oss_c->_tag_decoded = FALSE;
		    }
		    _data_tag = 0x1;
		    _out_data->u.between->entirely = _oss_dec_bool(_g, &_bufpos, &_buflen, _data_length);
		    OSS_CNTX_POP(_oss_c)
		}
		if (_bufpos != _end_pos) {
		    if (_total_len < 0) {
			if (!_oss_c->_tag_decoded)
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			if (_data_tag)
			    _oss_dec_error(_g, _expec_eoc, 0L);
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
		    } else
			_oss_dec_error(_g, _inconsis_len, 0L);
		}
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	}   break;
	case 0x18: {
	    OSS_CNTX_PUSH(_oss_c, 285)
	    _out_data->choice = 3;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.at, -1, 0);
	}   break;
	default:
	    _oss_dec_error(_g, _unknown_field, _data_tag);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpTimeAssertion(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _TimeAssertion	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(44,281)
    _out_data = (_TimeAssertion *)_oss_dec_const_alloc(_g, sizeof(_TimeAssertion));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_2int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 282)
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 283)
	    _out_data->u.between = (_seq11 *)_oss_dec_const_alloc(_g, sizeof(_seq11));
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		unsigned char _pbase[1];
		OSS_CNTX_INIT

		_out_data->u.between->bit_mask = 0;
		*_pbase = _oss_get_2bit_unaligned(_g);
		OSS_CNTX_PUSH(_oss_c, 256)
		_oss_pdec_ntp_kmstr(_g, &_out_data->u.between->startTime, _chars + 3);
		OSS_CNTX_SET(255)
		if (_pbase[0] & 0x80) {
		    _oss_pdec_ntp_kmstr(_g, &_out_data->u.between->endTime, _chars + 3);
		} else {
		    _out_data->u.between->endTime = nullptr;
		}
		OSS_CNTX_SET(284)
		if (_pbase[0] & 0x40) {
		    _out_data->u.between->bit_mask |= 0x80000000;
		    _out_data->u.between->entirely = _oss_get_1bit_unaligned(_g) ? TRUE : FALSE;
		} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
		    memcpy(&_out_data->u.between->entirely, &Context::default_fallback, sizeof(Context::default_fallback));
#else
		    _out_data->u.between->entirely = 0;
#endif
		}
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    break;
	case 3:
	    OSS_CNTX_PUSH(_oss_c, 285)
	    _oss_pdec_ntp_kmstr(_g, &_out_data->u.at, _chars + 3);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dLocaleContextSyntax(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _LocaleContextSyntax *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(45,286)
    _out_data = (_LocaleContextSyntax *)_oss_dec_const_alloc(_g, sizeof(_LocaleContextSyntax));
    _oss_c->_tag_decoded = FALSE;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
	    _buflen--;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
	    _bufpos++;
	} else
	    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	_oss_c->_tag_decoded = TRUE;
	if (_data_tag == 0xC || _data_tag == 0x13 || _data_tag == 0x14 || _data_tag == 0x1C || _data_tag == 0x1E) {
	    OSS_CNTX_PUSH(_oss_c, 288)
	    _out_data->choice = 2;
	    _out_data->u.localeID2 = (_UnboundedDirectoryString *)_oss_dec_const_alloc(_g, sizeof(_UnboundedDirectoryString));
	    _d_UnboundedDirectoryString(_g, &_bufpos, &_buflen, 0, _data_tag, _out_data->u.localeID2);
	    OSS_CNTX_POP(_oss_c)
	} else
	switch (_data_tag) {
	case 0x6: {
	    OSS_CNTX_PUSH(_oss_c, 287)
	    _out_data->choice = 1;
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    _out_data->u.localeID1.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->u.localeID1.value, -1);
	}   break;
	default:
	    _oss_dec_error(_g, _unknown_field, _data_tag);
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpLocaleContextSyntax(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _LocaleContextSyntax	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(45,286)
    _out_data = (_LocaleContextSyntax *)_oss_dec_const_alloc(_g, sizeof(_LocaleContextSyntax));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	{

	    _out_data->choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
	}
	switch (_out_data->choice) {
	case 1:
	    OSS_CNTX_PUSH(_oss_c, 287)
	    _out_data->u.localeID1.length = _oss_pdec_eobjid_ia(_g, &_out_data->u.localeID1.value, -1);
	    break;
	case 2:
	    OSS_CNTX_PUSH(_oss_c, 288)
	    _out_data->u.localeID2 = (_UnboundedDirectoryString *)_oss_dec_const_alloc(_g, sizeof(_UnboundedDirectoryString));
	    _dp_UnboundedDirectoryString(_g, _out_data->u.localeID2);
	    break;
	default:
	    _oss_enc_error(_g, _bad_choice, _out_data->choice);	/* Bad choice selector. */
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dAttributeOptionList(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _setof3 **_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(46,289)
    _out_data = (_setof3 **)_oss_dec_const_init_alloc(_g, sizeof(_setof3 *));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_setof3 * _temp = (_setof3 *)_out_data;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 290)
	for (;;) {
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
	    count++;
#endif
	    if (_data_tag != 0xC)
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0xC0000);
	    _temp->next = (_setof3 *)_oss_dec_const_alloc(_g, sizeof(_setof3));
	    _temp = _temp->next;
	    OSS_CNTX_SETOCC(count)
	    _oss_c->_tag_decoded = FALSE;
	    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		_buflen--;
		_bufpos++;
	    } else
		_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
	    if(_data_length) {
		_temp->value.length = _oss_dec_utf8unbound_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.value, 0);
	    } else {
		_temp->value.length = 0;
		_temp->value.value = nullptr;
	    }
	}
	_temp->next = nullptr;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpAttributeOptionList(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _setof3	**_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(46,289)
    _out_data = (_setof3 **)_oss_dec_const_init_alloc(_g, sizeof(_setof3 *));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_setof3 * _temp = (_setof3 *)_out_data;
	unsigned long count = 0;
	ossBoolean _last = FALSE;
	unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	unsigned long _prev_fragm0 = 0;
#endif

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 290)
	while (!_last) {
	    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		if ((!_last) && _index && (_prev_fragm0 < 65536))
		    _oss_dec_error(_g, _invalid_fragmentation, 0L);
		_prev_fragm0 = count - _index;
	    }
#endif
	    for (; (unsigned long)_index < count; _index++) {
		_temp->next = (_setof3 *)_oss_dec_const_alloc(_g, sizeof(_setof3));
		_temp = _temp->next;
		OSS_CNTX_SETOCC(_index + 1)
		_temp->value.length = _oss_pdec_ub_nkmstr_ia(_g, &_temp->value.value);

	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_temp->next = nullptr;
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dID(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssEncOID *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(47,291)
    _out_data = (OSSC::COssEncOID *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssEncOID));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
    _data_tag = 0x6;
    _out_data->length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, -1);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpID(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssEncOID	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(47,291)
    _out_data = (OSSC::COssEncOID *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssEncOID));
    _out_data->length = _oss_pdec_eobjid_ia(_g, &_out_data->value, -1);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dAttributeValue(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssOpen *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(48,292)
    _out_data = (OSSC::COssOpen *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssOpen));
    _oss_c->_tag_decoded = FALSE;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
    _out_data->userField = nullptr;
#endif
    _oss_dec_opentype(_g, &_bufpos, &_buflen, 1, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpAttributeValue(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssOpen	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(48,292)
    _out_data = (OSSC::COssOpen *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssOpen));
#ifdef OSS_OPENTYPE_HAS_USERFIELD
    _out_data->userField = nullptr;
#endif
    _oss_pdec_opentype(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dContextAssertion(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ContextAssertion *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(49,293)
    _out_data = (_ContextAssertion *)_oss_dec_const_alloc(_g, sizeof(_ContextAssertion));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_ContextAssertion(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpContextAssertion(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _ContextAssertion	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(49,293)
    _out_data = (_ContextAssertion *)_oss_dec_const_alloc(_g, sizeof(_ContextAssertion));
    _dp_ContextAssertion(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dAttributeTypeAssertion(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AttributeTypeAssertion *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(50,294)
    _out_data = (_AttributeTypeAssertion *)_oss_dec_const_alloc(_g, sizeof(_AttributeTypeAssertion));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 83)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
	_data_tag = 0x6;
	_out_data->type.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->type.value, -1);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x10 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->assertedContexts, 0, sizeof(_out_data->assertedContexts));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 295)
	    _out_data->assertedContexts = nullptr;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x10) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x10 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_setof6 * _temp = (_setof6 *)&_out_data->assertedContexts;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
		unsigned long count = 0;
#endif
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 231)
		for (;;) {
		    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos > _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
		    count++;
#endif
		    if (_data_tag != 0x10)
			_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		    _temp->next = (_setof6 *)_oss_dec_const_alloc(_g, sizeof(_setof6));
		    _temp = _temp->next;
		    OSS_CNTX_SETOCC(count)
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _d_ContextAssertion(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
		}
		_temp->next = nullptr;
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpAttributeTypeAssertion(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AttributeTypeAssertion	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(50,294)
    _out_data = (_AttributeTypeAssertion *)_oss_dec_const_alloc(_g, sizeof(_AttributeTypeAssertion));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_1bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 83)
	_out_data->type.length = _oss_pdec_eobjid_ia(_g, &_out_data->type.value, -1);
	OSS_CNTX_SET(295)
	_out_data->assertedContexts = nullptr;
	if (_out_data->bit_mask & 0x80000000) {
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_setof6 * _temp = (_setof6 *)&_out_data->assertedContexts;
		unsigned long count = 0;
		ossBoolean _last = FALSE;
		unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		unsigned long _prev_fragm0 = 0;
#endif

		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 231)
		while (!_last) {
		    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
			if ((!_last) && _index && (_prev_fragm0 < 65536))
			    _oss_dec_error(_g, _invalid_fragmentation, 0L);
			_prev_fragm0 = count - _index;
		    }
#endif
		    for (; (unsigned long)_index < count; _index++) {
			_temp->next = (_setof6 *)_oss_dec_const_alloc(_g, sizeof(_setof6));
			_temp = _temp->next;
			OSS_CNTX_SETOCC(_index + 1)
			_dp_ContextAssertion(_g, &_temp->value);
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		_temp->next = nullptr;
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	} else {
	    _out_data->assertedContexts = nullptr;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dDistinguishedName(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RDNSequence **_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(51,296)
    _out_data = (_RDNSequence **)_oss_dec_const_init_alloc(_g, sizeof(_RDNSequence *));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_RDNSequence(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpDistinguishedName(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RDNSequence	**_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(51,296)
    _out_data = (_RDNSequence **)_oss_dec_const_init_alloc(_g, sizeof(_RDNSequence *));
    _dp_RDNSequence(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dSubtreeSpecification(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SubtreeSpecification *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(52,297)
    _out_data = (_SubtreeSpecification *)_oss_dec_const_alloc(_g, sizeof(_SubtreeSpecification));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8000 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    _out_data->base = _v642;
#else
	    _out_data->base = nullptr;
#endif
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 304)
	    _out_data->base = nullptr;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8000;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d_RDNSequence(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->base);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8001 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    memset(&_out_data->specificExclusions, 0, sizeof(_out_data->specificExclusions));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 301)
	    _out_data->specificExclusions = nullptr;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8001) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x81 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80010000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8001;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
	    _data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_setof19 * _temp = (_setof19 *)&_out_data->specificExclusions;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
		unsigned long count = 0;
#endif
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 235)
		for (;;) {
		    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos > _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
		    count++;
#endif
		    _temp->next = (_setof19 *)_oss_dec_const_alloc(_g, sizeof(_setof19));
		    _temp = _temp->next;
		    OSS_CNTX_SETOCC(count)
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			int _indef_tags = 0;
			OSS_CNTX_INIT

			switch (_data_tag) {
			default:
			    if (!(_data_tag & 0x8000)) _oss_dec_error(_g, _unknown_field, _data_tag);
			    switch (_data_tag & 0x7fff) {
			    case 0x0: {
				OSS_CNTX_PUSH(_oss_c, 302)
				_temp->value.choice = 1;

				_oss_c->_tag_decoded = FALSE;
				if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				    _buflen--;
				    _bufpos++;
				} else
				    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				if (_data_length < 0) ++_indef_tags;
				if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
				_data_tag = 0x10;
				_d_RDNSequence(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value.u.chopBefore);
				while (_indef_tags > 0) {
				    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
					_buflen -= 2;
					_bufpos += 2;
				    } else
					if (!_buflen || _bufpos[0])
					    _oss_dec_error(_g, _expec_eoc, 0L);
					else
					    _oss_dec_error(_g, _non_std_eoc, 0L);
				    _indef_tags--;
				}
			    }   break;
			    case 0x1: {
				OSS_CNTX_PUSH(_oss_c, 303)
				_temp->value.choice = 2;

				_oss_c->_tag_decoded = FALSE;
				if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				    _buflen--;
				    _bufpos++;
				} else
				    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				if (_data_length < 0) ++_indef_tags;
				if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
				_data_tag = 0x10;
				_d_RDNSequence(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value.u.chopAfter);
				while (_indef_tags > 0) {
				    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
					_buflen -= 2;
					_bufpos += 2;
				    } else
					if (!_buflen || _bufpos[0])
					    _oss_dec_error(_g, _expec_eoc, 0L);
					else
					    _oss_dec_error(_g, _non_std_eoc, 0L);
				    _indef_tags--;
				}
			    }   break;
			    default:
				_oss_dec_error(_g, _unknown_field, _data_tag);
			    }
			    break;
			}
			OSS_CNTX_POP(_oss_c)
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		}
		_temp->next = nullptr;
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8002 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x20000000;
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->minimum, &SubtreeSpecification::default_minimum, sizeof(SubtreeSpecification::default_minimum));
#else
	    _out_data->minimum = 0;
#endif
	}
else {
	    _out_data->bit_mask |= 0x20000000;
	    OSS_CNTX_PUSH(_oss_c, 300)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8002) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x82 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80020000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8002;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	    _data_tag = 0x2;
	    _out_data->minimum = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8003 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x10000000;
	}
else {
	    _out_data->bit_mask |= 0x10000000;
	    OSS_CNTX_PUSH(_oss_c, 299)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 163 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8003) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x83 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80030000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8003;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	    _data_tag = 0x2;
	    _out_data->maximum = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8004 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x8000000;
	    memset(&_out_data->specificationFilter, 0, sizeof(_out_data->specificationFilter));
	}
else {
	    _out_data->bit_mask |= 0x8000000;
	    OSS_CNTX_PUSH(_oss_c, 298)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 164 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8004) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x84 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80040000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8004;
	    if (_data_length < 0) ++_indef_tags;
	    _d_Refinement(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->specificationFilter);
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpSubtreeSpecification(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SubtreeSpecification	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(52,297)
    _out_data = (_SubtreeSpecification *)_oss_dec_const_alloc(_g, sizeof(_SubtreeSpecification));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_5bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 304)
	_out_data->base = nullptr;
	if (_out_data->bit_mask & 0x80000000) {
	    _dp_RDNSequence(_g, &_out_data->base);
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    _out_data->base = _v642;
#else
	    _out_data->base = nullptr;
#endif
	}
	OSS_CNTX_SET(301)
	_out_data->specificExclusions = nullptr;
	if (_out_data->bit_mask & 0x40000000) {
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_setof19 * _temp = (_setof19 *)&_out_data->specificExclusions;
		unsigned long count = 0;
		ossBoolean _last = FALSE;
		unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		unsigned long _prev_fragm0 = 0;
#endif

		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 235)
		while (!_last) {
		    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
			if ((!_last) && _index && (_prev_fragm0 < 65536))
			    _oss_dec_error(_g, _invalid_fragmentation, 0L);
			_prev_fragm0 = count - _index;
		    }
#endif
		    for (; (unsigned long)_index < count; _index++) {
			_temp->next = (_setof19 *)_oss_dec_const_alloc(_g, sizeof(_setof19));
			_temp = _temp->next;
			OSS_CNTX_SETOCC(_index + 1)
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			{
			    OSS_CNTX_INIT

			    {

				_temp->value.choice = (int)_oss_pdec_nonneg_1int(_g) + 1;
			    }
			    switch (_temp->value.choice) {
			    case 1:
				OSS_CNTX_PUSH(_oss_c, 302)
				_dp_RDNSequence(_g, &_temp->value.u.chopBefore);
				break;
			    case 2:
				OSS_CNTX_PUSH(_oss_c, 303)
				_dp_RDNSequence(_g, &_temp->value.u.chopAfter);
				break;
			    default:
				_oss_enc_error(_g, _bad_choice, _temp->value.choice);	/* Bad choice selector. */
			    }
			    OSS_CNTX_POP(_oss_c)
			}
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		_temp->next = nullptr;
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	} else {
	    _out_data->specificExclusions = nullptr;
	}
	OSS_CNTX_SET(300)
	if (_out_data->bit_mask & 0x20000000) {
	    {
		_out_data->minimum = (OSS_UINT32)_oss_pdec_semicon_limited_int_l(_g, 0, 0, -1);
	    }
	} else {
#ifndef OSS_DO_NOT_SET_DEFAULT_VALUES
	    memcpy(&_out_data->minimum, &SubtreeSpecification::default_minimum, sizeof(SubtreeSpecification::default_minimum));
#else
	    _out_data->minimum = 0;
#endif
	}
	OSS_CNTX_SET(299)
	if (_out_data->bit_mask & 0x10000000) {
	    {
		_out_data->maximum = (OSS_UINT32)_oss_pdec_semicon_limited_int_l(_g, 0, 0, -1);
	    }
	}
	OSS_CNTX_SET(298)
	if (_out_data->bit_mask & 0x8000000) {
	    _dp_Refinement(_g, &_out_data->specificationFilter);
	} else {
	    memset(&(_out_data->specificationFilter), 0, sizeof(_Refinement ));
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dDITStructureRule(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _DITStructureRule *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(53,305)
    _out_data = (_DITStructureRule *)_oss_dec_const_alloc(_g, sizeof(_DITStructureRule));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 309)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->ruleIdentifier = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	OSS_CNTX_SET(308)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
	_data_tag = 0x6;
	_out_data->nameForm.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->nameForm.value, -1);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x11 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->superiorStructureRules, 0, sizeof(_out_data->superiorStructureRules));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 306)
	    _out_data->superiorStructureRules = nullptr;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x11) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x11 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x110000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_Presentation_context_deletion_list * _temp = (_Presentation_context_deletion_list *)&_out_data->superiorStructureRules;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
		unsigned long count = 0;
#endif
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 307)
		for (;;) {
		    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos > _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
		    count++;
#endif
		    if (_data_tag != 0x2)
			_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x20000);
		    _temp->next = (_Presentation_context_deletion_list *)_oss_dec_const_alloc(_g, sizeof(_Presentation_context_deletion_list));
		    _temp = _temp->next;
		    OSS_CNTX_SETOCC(count)
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _temp->value = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		}
		_temp->next = nullptr;
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpDITStructureRule(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _DITStructureRule	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(53,305)
    _out_data = (_DITStructureRule *)_oss_dec_const_alloc(_g, sizeof(_DITStructureRule));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_1bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 309)
	_out_data->ruleIdentifier = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	OSS_CNTX_SET(308)
	_out_data->nameForm.length = _oss_pdec_eobjid_ia(_g, &_out_data->nameForm.value, -1);
	OSS_CNTX_SET(306)
	_out_data->superiorStructureRules = nullptr;
	if (_out_data->bit_mask & 0x80000000) {
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_Presentation_context_deletion_list * _temp = (_Presentation_context_deletion_list *)&_out_data->superiorStructureRules;
		unsigned long count = 0;
		ossBoolean _last = FALSE;
		unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		unsigned long _prev_fragm0 = 0;
#endif

		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 307)
		while (!_last) {
		    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
			if ((!_last) && _index && (_prev_fragm0 < 65536))
			    _oss_dec_error(_g, _invalid_fragmentation, 0L);
			_prev_fragm0 = count - _index;
		    }
#endif
		    for (; (unsigned long)_index < count; _index++) {
			_temp->next = (_Presentation_context_deletion_list *)_oss_dec_const_alloc(_g, sizeof(_Presentation_context_deletion_list));
			_temp = _temp->next;
			OSS_CNTX_SETOCC(_index + 1)
			_temp->value = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		_temp->next = nullptr;
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	} else {
	    _out_data->superiorStructureRules = nullptr;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dDITContentRule(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _DITContentRule *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(54,310)
    _out_data = (_DITContentRule *)_oss_dec_const_alloc(_g, sizeof(_DITContentRule));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 315)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
	_data_tag = 0x6;
	_out_data->structuralObjectClass.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->structuralObjectClass.value, -1);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x11 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->auxiliaries, 0, sizeof(_out_data->auxiliaries));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 314)
	    _out_data->auxiliaries = nullptr;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x11) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x11 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x110000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_Application_context_name_list * _temp = (_Application_context_name_list *)&_out_data->auxiliaries;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
		unsigned long count = 0;
#endif
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 220)
		for (;;) {
		    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos > _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
		    count++;
#endif
		    if (_data_tag != 0x6)
			_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x60000);
		    _temp->next = (_Application_context_name_list *)_oss_dec_const_alloc(_g, sizeof(_Application_context_name_list));
		    _temp = _temp->next;
		    OSS_CNTX_SETOCC(count)
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _temp->value.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.value, -1);
		}
		_temp->next = nullptr;
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8001 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    memset(&_out_data->mandatory, 0, sizeof(_out_data->mandatory));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 313)
	    _out_data->mandatory = nullptr;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8001) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x81 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80010000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8001;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
	    _data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_Application_context_name_list * _temp = (_Application_context_name_list *)&_out_data->mandatory;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
		unsigned long count = 0;
#endif
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 220)
		for (;;) {
		    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos > _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
		    count++;
#endif
		    if (_data_tag != 0x6)
			_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x60000);
		    _temp->next = (_Application_context_name_list *)_oss_dec_const_alloc(_g, sizeof(_Application_context_name_list));
		    _temp = _temp->next;
		    OSS_CNTX_SETOCC(count)
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _temp->value.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.value, -1);
		}
		_temp->next = nullptr;
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8002 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x20000000;
	    memset(&_out_data->optional, 0, sizeof(_out_data->optional));
	}
else {
	    _out_data->bit_mask |= 0x20000000;
	    OSS_CNTX_PUSH(_oss_c, 312)
	    _out_data->optional = nullptr;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8002) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x82 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80020000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8002;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
	    _data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_Application_context_name_list * _temp = (_Application_context_name_list *)&_out_data->optional;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
		unsigned long count = 0;
#endif
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 220)
		for (;;) {
		    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos > _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
		    count++;
#endif
		    if (_data_tag != 0x6)
			_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x60000);
		    _temp->next = (_Application_context_name_list *)_oss_dec_const_alloc(_g, sizeof(_Application_context_name_list));
		    _temp = _temp->next;
		    OSS_CNTX_SETOCC(count)
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _temp->value.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.value, -1);
		}
		_temp->next = nullptr;
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8003 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x10000000;
	    memset(&_out_data->precluded, 0, sizeof(_out_data->precluded));
	}
else {
	    _out_data->bit_mask |= 0x10000000;
	    OSS_CNTX_PUSH(_oss_c, 311)
	    _out_data->precluded = nullptr;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 163 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8003) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x83 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80030000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8003;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
	    _data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_Application_context_name_list * _temp = (_Application_context_name_list *)&_out_data->precluded;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
		unsigned long count = 0;
#endif
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 220)
		for (;;) {
		    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos > _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
		    count++;
#endif
		    if (_data_tag != 0x6)
			_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x60000);
		    _temp->next = (_Application_context_name_list *)_oss_dec_const_alloc(_g, sizeof(_Application_context_name_list));
		    _temp = _temp->next;
		    OSS_CNTX_SETOCC(count)
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _temp->value.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.value, -1);
		}
		_temp->next = nullptr;
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpDITContentRule(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _DITContentRule	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(54,310)
    _out_data = (_DITContentRule *)_oss_dec_const_alloc(_g, sizeof(_DITContentRule));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_4bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 315)
	_out_data->structuralObjectClass.length = _oss_pdec_eobjid_ia(_g, &_out_data->structuralObjectClass.value, -1);
	OSS_CNTX_SET(314)
	_out_data->auxiliaries = nullptr;
	if (_out_data->bit_mask & 0x80000000) {
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_Application_context_name_list * _temp = (_Application_context_name_list *)&_out_data->auxiliaries;
		unsigned long count = 0;
		ossBoolean _last = FALSE;
		unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		unsigned long _prev_fragm0 = 0;
#endif

		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 220)
		while (!_last) {
		    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
			if ((!_last) && _index && (_prev_fragm0 < 65536))
			    _oss_dec_error(_g, _invalid_fragmentation, 0L);
			_prev_fragm0 = count - _index;
		    }
#endif
		    for (; (unsigned long)_index < count; _index++) {
			_temp->next = (_Application_context_name_list *)_oss_dec_const_alloc(_g, sizeof(_Application_context_name_list));
			_temp = _temp->next;
			OSS_CNTX_SETOCC(_index + 1)
			_temp->value.length = _oss_pdec_eobjid_ia(_g, &_temp->value.value, -1);
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		_temp->next = nullptr;
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	} else {
	    _out_data->auxiliaries = nullptr;
	}
	OSS_CNTX_SET(313)
	_out_data->mandatory = nullptr;
	if (_out_data->bit_mask & 0x40000000) {
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_Application_context_name_list * _temp = (_Application_context_name_list *)&_out_data->mandatory;
		unsigned long count = 0;
		ossBoolean _last = FALSE;
		unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		unsigned long _prev_fragm0 = 0;
#endif

		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 220)
		while (!_last) {
		    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
			if ((!_last) && _index && (_prev_fragm0 < 65536))
			    _oss_dec_error(_g, _invalid_fragmentation, 0L);
			_prev_fragm0 = count - _index;
		    }
#endif
		    for (; (unsigned long)_index < count; _index++) {
			_temp->next = (_Application_context_name_list *)_oss_dec_const_alloc(_g, sizeof(_Application_context_name_list));
			_temp = _temp->next;
			OSS_CNTX_SETOCC(_index + 1)
			_temp->value.length = _oss_pdec_eobjid_ia(_g, &_temp->value.value, -1);
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		_temp->next = nullptr;
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	} else {
	    _out_data->mandatory = nullptr;
	}
	OSS_CNTX_SET(312)
	_out_data->optional = nullptr;
	if (_out_data->bit_mask & 0x20000000) {
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_Application_context_name_list * _temp = (_Application_context_name_list *)&_out_data->optional;
		unsigned long count = 0;
		ossBoolean _last = FALSE;
		unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		unsigned long _prev_fragm0 = 0;
#endif

		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 220)
		while (!_last) {
		    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
			if ((!_last) && _index && (_prev_fragm0 < 65536))
			    _oss_dec_error(_g, _invalid_fragmentation, 0L);
			_prev_fragm0 = count - _index;
		    }
#endif
		    for (; (unsigned long)_index < count; _index++) {
			_temp->next = (_Application_context_name_list *)_oss_dec_const_alloc(_g, sizeof(_Application_context_name_list));
			_temp = _temp->next;
			OSS_CNTX_SETOCC(_index + 1)
			_temp->value.length = _oss_pdec_eobjid_ia(_g, &_temp->value.value, -1);
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		_temp->next = nullptr;
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	} else {
	    _out_data->optional = nullptr;
	}
	OSS_CNTX_SET(311)
	_out_data->precluded = nullptr;
	if (_out_data->bit_mask & 0x10000000) {
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_Application_context_name_list * _temp = (_Application_context_name_list *)&_out_data->precluded;
		unsigned long count = 0;
		ossBoolean _last = FALSE;
		unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		unsigned long _prev_fragm0 = 0;
#endif

		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 220)
		while (!_last) {
		    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
			if ((!_last) && _index && (_prev_fragm0 < 65536))
			    _oss_dec_error(_g, _invalid_fragmentation, 0L);
			_prev_fragm0 = count - _index;
		    }
#endif
		    for (; (unsigned long)_index < count; _index++) {
			_temp->next = (_Application_context_name_list *)_oss_dec_const_alloc(_g, sizeof(_Application_context_name_list));
			_temp = _temp->next;
			OSS_CNTX_SETOCC(_index + 1)
			_temp->value.length = _oss_pdec_eobjid_ia(_g, &_temp->value.value, -1);
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		_temp->next = nullptr;
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	} else {
	    _out_data->precluded = nullptr;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dDITContextUse(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _DITContextUse *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(55,316)
    _out_data = (_DITContextUse *)_oss_dec_const_alloc(_g, sizeof(_DITContextUse));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	_out_data->bit_mask = 0;
	OSS_CNTX_PUSH(_oss_c, 319)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
	_data_tag = 0x6;
	_out_data->attributeType.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->attributeType.value, -1);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8001 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x80000000;
	    memset(&_out_data->mandatoryContexts, 0, sizeof(_out_data->mandatoryContexts));
	}
else {
	    _out_data->bit_mask |= 0x80000000;
	    OSS_CNTX_PUSH(_oss_c, 318)
	    _out_data->mandatoryContexts = nullptr;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8001) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x81 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80010000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8001;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
	    _data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_Application_context_name_list * _temp = (_Application_context_name_list *)&_out_data->mandatoryContexts;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
		unsigned long count = 0;
#endif
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 220)
		for (;;) {
		    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos > _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
		    count++;
#endif
		    if (_data_tag != 0x6)
			_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x60000);
		    _temp->next = (_Application_context_name_list *)_oss_dec_const_alloc(_g, sizeof(_Application_context_name_list));
		    _temp = _temp->next;
		    OSS_CNTX_SETOCC(count)
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _temp->value.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.value, -1);
		}
		_temp->next = nullptr;
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (!_oss_c->_tag_decoded && _bufpos < _end_pos) {
	    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
		_bufpos++;
	    } else
		_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
	    _oss_c->_tag_decoded = TRUE;
	}
	if (_data_tag != 0x8002 || _bufpos >= _end_pos)
	 {
	    _out_data->bit_mask &= ~0x40000000;
	    memset(&_out_data->optionalContexts, 0, sizeof(_out_data->optionalContexts));
	}
else {
	    _out_data->bit_mask |= 0x40000000;
	    OSS_CNTX_PUSH(_oss_c, 317)
	    _out_data->optionalContexts = nullptr;
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x8002) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x82 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80020000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x8002;
	    if (_data_length < 0) ++_indef_tags;
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x11);
	    _data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_Application_context_name_list * _temp = (_Application_context_name_list *)&_out_data->optionalContexts;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
		unsigned long count = 0;
#endif
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 220)
		for (;;) {
		    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos > _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
#if OSSDEBUG > 1
		    count++;
#endif
		    if (_data_tag != 0x6)
			_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x60000);
		    _temp->next = (_Application_context_name_list *)_oss_dec_const_alloc(_g, sizeof(_Application_context_name_list));
		    _temp = _temp->next;
		    OSS_CNTX_SETOCC(count)
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _temp->value.length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.value, -1);
		}
		_temp->next = nullptr;
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (!_oss_c->_tag_decoded)
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpDITContextUse(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _DITContextUse	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(55,316)
    _out_data = (_DITContextUse *)_oss_dec_const_alloc(_g, sizeof(_DITContextUse));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	_out_data->bit_mask = (OSS_UINT32)_oss_get_2bit_unaligned(_g) << 24;
	OSS_CNTX_PUSH(_oss_c, 319)
	_out_data->attributeType.length = _oss_pdec_eobjid_ia(_g, &_out_data->attributeType.value, -1);
	OSS_CNTX_SET(318)
	_out_data->mandatoryContexts = nullptr;
	if (_out_data->bit_mask & 0x80000000) {
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_Application_context_name_list * _temp = (_Application_context_name_list *)&_out_data->mandatoryContexts;
		unsigned long count = 0;
		ossBoolean _last = FALSE;
		unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		unsigned long _prev_fragm0 = 0;
#endif

		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 220)
		while (!_last) {
		    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
			if ((!_last) && _index && (_prev_fragm0 < 65536))
			    _oss_dec_error(_g, _invalid_fragmentation, 0L);
			_prev_fragm0 = count - _index;
		    }
#endif
		    for (; (unsigned long)_index < count; _index++) {
			_temp->next = (_Application_context_name_list *)_oss_dec_const_alloc(_g, sizeof(_Application_context_name_list));
			_temp = _temp->next;
			OSS_CNTX_SETOCC(_index + 1)
			_temp->value.length = _oss_pdec_eobjid_ia(_g, &_temp->value.value, -1);
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		_temp->next = nullptr;
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	} else {
	    _out_data->mandatoryContexts = nullptr;
	}
	OSS_CNTX_SET(317)
	_out_data->optionalContexts = nullptr;
	if (_out_data->bit_mask & 0x40000000) {
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_Application_context_name_list * _temp = (_Application_context_name_list *)&_out_data->optionalContexts;
		unsigned long count = 0;
		ossBoolean _last = FALSE;
		unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		unsigned long _prev_fragm0 = 0;
#endif

		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 220)
		while (!_last) {
		    count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
			if ((!_last) && _index && (_prev_fragm0 < 65536))
			    _oss_dec_error(_g, _invalid_fragmentation, 0L);
			_prev_fragm0 = count - _index;
		    }
#endif
		    for (; (unsigned long)_index < count; _index++) {
			_temp->next = (_Application_context_name_list *)_oss_dec_const_alloc(_g, sizeof(_Application_context_name_list));
			_temp = _temp->next;
			OSS_CNTX_SETOCC(_index + 1)
			_temp->value.length = _oss_pdec_eobjid_ia(_g, &_temp->value.value, -1);
		    }
		    OSS_CNTX_POP(_oss_c)
		}
		_temp->next = nullptr;
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	} else {
	    _out_data->optionalContexts = nullptr;
	}
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dHierarchyLevel(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_INT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(56,320)
    _out_data = (OSS_INT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_INT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpHierarchyLevel(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_INT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(56,320)
    _out_data = (OSS_INT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_INT32));
    *_out_data = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dHierarchyBelow(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    ossBoolean *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(57,321)
    _out_data = (ossBoolean *)_oss_dec_const_alloc(_g, sizeof(ossBoolean));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 1 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1);
    _data_tag = 0x1;
    *_out_data = _oss_dec_bool(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpHierarchyBelow(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    ossBoolean	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(57,321)
    _out_data = (ossBoolean *)_oss_dec_const_alloc(_g, sizeof(ossBoolean));
    *_out_data = _oss_get_1bit_unaligned(_g) ? TRUE : FALSE;
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dAcse_RealizationParameter(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(58,322)
    _out_data = (_RealizationParameter *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_RealizationParameter(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpAcse_RealizationParameter(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(58,322)
    _out_data = (_RealizationParameter *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter));
    _dp_RealizationParameter(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _d2Acse_with_concatenation_Rea(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(59,323)
    _out_data = (_RealizationParameter *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_RealizationParameter(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp2Acse_with_concatenation_Rea(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(59,323)
    _out_data = (_RealizationParameter *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter));
    _dp_RealizationParameter(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _d3Association_by_RTSE_Realiza(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(60,324)
    _out_data = (_RealizationParameter *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_RealizationParameter(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp3Association_by_RTSE_Realiza(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(60,324)
    _out_data = (_RealizationParameter *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter));
    _dp_RealizationParameter(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dPData_RealizationParameter(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(61,325)
    _out_data = (_RealizationParameter *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_RealizationParameter(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpPData_RealizationParameter(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(61,325)
    _out_data = (_RealizationParameter *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter));
    _dp_RealizationParameter(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _d4PData_with_concatenation_Re(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(62,326)
    _out_data = (_RealizationParameter *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_RealizationParameter(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp4PData_with_concatenation_Re(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(62,326)
    _out_data = (_RealizationParameter *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter));
    _dp_RealizationParameter(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _d5Transfer_by_RTSE_Realizatio(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(63,327)
    _out_data = (_RealizationParameter *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_RealizationParameter(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp5Transfer_by_RTSE_Realizatio(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RealizationParameter	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(63,327)
    _out_data = (_RealizationParameter *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter));
    _dp_RealizationParameter(_g, _out_data);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dBitStringMatch_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(64,328)
    _out_data = (OSSC::COssBitString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssBitString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 3 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x3);
    _data_tag = 0x3;
    _out_data->length = _oss_dec_ubit_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 0, 0);

    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpBitStringMatch_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssBitString	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(64,328)
    _out_data = (OSSC::COssBitString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssBitString));
    _out_data->length = _oss_pdec_unconstr_ubit_ia(_g, &_out_data->value);

    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dDnQualifier_WITH_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(65,329)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 19 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x13);
    _data_tag = 0x13;
    _out_data->length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 0);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpDnQualifier_WITH_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(65,329)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _out_data->length = _oss_pdec_ub_kmstr(_g, &_out_data->value, _chars + 0);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dSerialNumber_WITH_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(66,330)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 19 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x13);
    _data_tag = 0x13;
    _out_data->length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 0);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpSerialNumber_WITH_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(66,330)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _out_data->length = _oss_pdec_ub_kmstr(_g, &_out_data->value, _chars + 0);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dNumericStringMatch_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(67,331)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 18 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x12);
    _data_tag = 0x12;
    _out_data->length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 0);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpNumericStringMatch_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(67,331)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _out_data->length = _oss_pdec_ub_kmstr(_g, &_out_data->value, _chars + 12);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _d6ProtocolInformationMatch_SY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(68,332)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
    _data_tag = 0x4;
    _out_data->length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 0);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp6ProtocolInformationMatch_SY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(68,332)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _out_data->length = _oss_pdec_unconstr_uoct_ia(_g, (unsigned char **)&_out_data->value);

    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dUiiInUrn_WITH_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(69,333)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 12 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0xC);
    _data_tag = 0xC;
    if(_data_length) {
	_out_data->length = _oss_dec_utf8unbound_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 0);
    } else {
	_out_data->length = 0;
	_out_data->value = nullptr;
    }
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpUiiInUrn_WITH_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(69,333)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _out_data->length = _oss_pdec_ub_nkmstr_ia(_g, &_out_data->value);

    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _d7NumericStringOrderingMatch_(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(70,334)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 18 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x12);
    _data_tag = 0x12;
    _out_data->length = _oss_dec_ustr_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 0);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp7NumericStringOrderingMatch_(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(70,334)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _out_data->length = _oss_pdec_ub_kmstr(_g, &_out_data->value, _chars + 12);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dBooleanMatch_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    ossBoolean *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(71,335)
    _out_data = (ossBoolean *)_oss_dec_const_alloc(_g, sizeof(ossBoolean));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 1 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1);
    _data_tag = 0x1;
    *_out_data = _oss_dec_bool(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpBooleanMatch_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    ossBoolean	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(71,335)
    _out_data = (ossBoolean *)_oss_dec_const_alloc(_g, sizeof(ossBoolean));
    *_out_data = _oss_get_1bit_unaligned(_g) ? TRUE : FALSE;
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dIntegerMatch_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_INT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(72,336)
    _out_data = (OSS_INT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_INT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpIntegerMatch_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_INT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(72,336)
    _out_data = (OSS_INT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_INT32));
    *_out_data = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dIntegerOrderingMatch_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_INT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(73,337)
    _out_data = (OSS_INT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_INT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpIntegerOrderingMatch_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_INT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(73,337)
    _out_data = (OSS_INT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_INT32));
    *_out_data = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dOctetStringMatch_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(74,338)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
    _data_tag = 0x4;
    _out_data->length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 0);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpOctetStringMatch_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(74,338)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _out_data->length = _oss_pdec_unconstr_uoct_ia(_g, (unsigned char **)&_out_data->value);

    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _d8OctetStringOrderingMatch_SY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(75,339)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
    _data_tag = 0x4;
    _out_data->length = _oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, 0);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp8OctetStringOrderingMatch_SY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(75,339)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _out_data->length = _oss_pdec_unconstr_uoct_ia(_g, (unsigned char **)&_out_data->value);

    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dUTCTimeMatch_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char * _out_data;
    char * *_out_data_ptr;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(76,340)
    _out_data_ptr = (char * *)_oss_dec_const_alloc(_g, sizeof(void *));
    _out_data = nullptr;
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 23 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x17);
    _data_tag = 0x17;
    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data, -1, 1);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    *_out_data_ptr = _out_data;
    return _out_data_ptr;
}

static void * _dpUTCTimeMatch_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *	_out_data;
    char *	*_out_data_ptr;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(76,340)
    _out_data_ptr = (char * *)_oss_dec_const_alloc(_g, sizeof(&_out_data));
    _out_data = nullptr;
    _oss_pdec_ntp_kmstr(_g, &_out_data, _chars + 3);
    OSS_CNTX_POP(_oss_c)
    *_out_data_ptr = _out_data;
    return _out_data_ptr;
}

static void * _dUTCTimeOrderingMatch_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char * _out_data;
    char * *_out_data_ptr;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(77,341)
    _out_data_ptr = (char * *)_oss_dec_const_alloc(_g, sizeof(void *));
    _out_data = nullptr;
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 23 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x17);
    _data_tag = 0x17;
    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data, -1, 1);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    *_out_data_ptr = _out_data;
    return _out_data_ptr;
}

static void * _dpUTCTimeOrderingMatch_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *	_out_data;
    char *	*_out_data_ptr;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(77,341)
    _out_data_ptr = (char * *)_oss_dec_const_alloc(_g, sizeof(&_out_data));
    _out_data = nullptr;
    _oss_pdec_ntp_kmstr(_g, &_out_data, _chars + 3);
    OSS_CNTX_POP(_oss_c)
    *_out_data_ptr = _out_data;
    return _out_data_ptr;
}

static void * _dGeneralizedTimeMatch_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char * _out_data;
    char * *_out_data_ptr;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(78,342)
    _out_data_ptr = (char * *)_oss_dec_const_alloc(_g, sizeof(void *));
    _out_data = nullptr;
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
    _data_tag = 0x18;
    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data, -1, 0);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    *_out_data_ptr = _out_data;
    return _out_data_ptr;
}

static void * _dpGeneralizedTimeMatch_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *	_out_data;
    char *	*_out_data_ptr;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(78,342)
    _out_data_ptr = (char * *)_oss_dec_const_alloc(_g, sizeof(&_out_data));
    _out_data = nullptr;
    _oss_pdec_ntp_kmstr(_g, &_out_data, _chars + 3);
    OSS_CNTX_POP(_oss_c)
    *_out_data_ptr = _out_data;
    return _out_data_ptr;
}

static void * _d9GeneralizedTimeOrderingMatc(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char * _out_data;
    char * *_out_data_ptr;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(79,343)
    _out_data_ptr = (char * *)_oss_dec_const_alloc(_g, sizeof(void *));
    _out_data = nullptr;
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
    _data_tag = 0x18;
    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data, -1, 0);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    *_out_data_ptr = _out_data;
    return _out_data_ptr;
}

static void * _dp9GeneralizedTimeOrderingMatc(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *	_out_data;
    char *	*_out_data_ptr;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(79,343)
    _out_data_ptr = (char * *)_oss_dec_const_alloc(_g, sizeof(&_out_data));
    _out_data = nullptr;
    _oss_pdec_ntp_kmstr(_g, &_out_data, _chars + 3);
    OSS_CNTX_POP(_oss_c)
    *_out_data_ptr = _out_data;
    return _out_data_ptr;
}

static void * _d10IntegerFirstComponentMatch(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_INT32 *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(80,344)
    _out_data = (OSS_INT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_INT32));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
    _data_tag = 0x2;
    *_out_data = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp10IntegerFirstComponentMatch(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSS_INT32	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(80,344)
    _out_data = (OSS_INT32 *)_oss_dec_const_alloc(_g, sizeof(OSS_INT32));
    *_out_data = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _d11AdministrativeRole_WITH_SY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssEncOID *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(81,345)
    _out_data = (OSSC::COssEncOID *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssEncOID));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
    _data_tag = 0x6;
    _out_data->length = _oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, -1);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dp11AdministrativeRole_WITH_SY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssEncOID	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(81,345)
    _out_data = (OSSC::COssEncOID *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssEncOID));
    _out_data->length = _oss_pdec_eobjid_ia(_g, &_out_data->value, -1);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dCreateTimestamp_WITH_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char * _out_data;
    char * *_out_data_ptr;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(82,346)
    _out_data_ptr = (char * *)_oss_dec_const_alloc(_g, sizeof(void *));
    _out_data = nullptr;
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
    _data_tag = 0x18;
    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data, -1, 0);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    *_out_data_ptr = _out_data;
    return _out_data_ptr;
}

static void * _dpCreateTimestamp_WITH_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *	_out_data;
    char *	*_out_data_ptr;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(82,346)
    _out_data_ptr = (char * *)_oss_dec_const_alloc(_g, sizeof(&_out_data));
    _out_data = nullptr;
    _oss_pdec_ntp_kmstr(_g, &_out_data, _chars + 3);
    OSS_CNTX_POP(_oss_c)
    *_out_data_ptr = _out_data;
    return _out_data_ptr;
}

static void * _dModifyTimestamp_WITH_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char * _out_data;
    char * *_out_data_ptr;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(83,347)
    _out_data_ptr = (char * *)_oss_dec_const_alloc(_g, sizeof(void *));
    _out_data = nullptr;
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
    _data_tag = 0x18;
    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data, -1, 0);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    *_out_data_ptr = _out_data;
    return _out_data_ptr;
}

static void * _dpModifyTimestamp_WITH_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *	_out_data;
    char *	*_out_data_ptr;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(83,347)
    _out_data_ptr = (char * *)_oss_dec_const_alloc(_g, sizeof(&_out_data));
    _out_data = nullptr;
    _oss_pdec_ntp_kmstr(_g, &_out_data, _chars + 3);
    OSS_CNTX_POP(_oss_c)
    *_out_data_ptr = _out_data;
    return _out_data_ptr;
}

static void * _d12SubschemaTimestamp_WITH_SY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char * _out_data;
    char * *_out_data_ptr;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(84,348)
    _out_data_ptr = (char * *)_oss_dec_const_alloc(_g, sizeof(void *));
    _out_data = nullptr;
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 24 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x18);
    _data_tag = 0x18;
    _oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data, -1, 0);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    *_out_data_ptr = _out_data;
    return _out_data_ptr;
}

static void * _dp12SubschemaTimestamp_WITH_SY(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *	_out_data;
    char *	*_out_data_ptr;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(84,348)
    _out_data_ptr = (char * *)_oss_dec_const_alloc(_g, sizeof(&_out_data));
    _out_data = nullptr;
    _oss_pdec_ntp_kmstr(_g, &_out_data, _chars + 3);
    OSS_CNTX_POP(_oss_c)
    *_out_data_ptr = _out_data;
    return _out_data_ptr;
}

static void * _dHasSubordinates_WITH_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    ossBoolean *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(85,349)
    _out_data = (ossBoolean *)_oss_dec_const_alloc(_g, sizeof(ossBoolean));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 1 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1);
    _data_tag = 0x1;
    *_out_data = _oss_dec_bool(_g, &_bufpos, &_buflen, _data_length);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpHasSubordinates_WITH_SYNTAX(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    ossBoolean	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(85,349)
    _out_data = (ossBoolean *)_oss_dec_const_alloc(_g, sizeof(ossBoolean));
    *_out_data = _oss_get_1bit_unaligned(_g) ? TRUE : FALSE;
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

void DLL_ENTRY_FDEF _dmUpperBounds_(struct ossGlobal * _g, int * _pdunum, void ** _outbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;

    _oss_c->_oss_context_anchor._state = _decoding_data;
    _oss_c->_oss_context_anchor._pdu_number = 0;
#if OSSDEBUG > 0
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_d_pre(_g, _oss_c->_oss_inbufpos, _oss_c->_oss_inbuflen, nullptr);
#else
    _oss_c->_oss_err_msg = nullptr;
#endif

    if (*_pdunum < 1 || *_pdunum > 85)
	_oss_dec_error(_g, _pdu_range, *_pdunum);
    *_outbuf = _Decoders[*_pdunum - 1](_g);

#if OSSDEBUG > 0
    _oss_c->_oss_err_msg = nullptr;
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_d_post(_g, 0, *_pdunum, _outbuf);
#endif
}

void DLL_ENTRY_FDEF _pdUpperBounds_(struct ossGlobal * _g, int * _pdunum, void ** _outbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _oss_c->_oss_context_anchor._state = _decoding_data;
    _oss_c->_oss_context_anchor._pdu_number = 0;
#if OSSDEBUG > 0
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_d_pre(_g, _oss_c->_oss_inbufpos, _oss_c->_oss_inbuflen, nullptr);
#else
    _oss_c->_oss_err_msg = nullptr;
#endif

    if (_g->encRules == OSS_PER_ALIGNED)
	_oss_c->_aligned = 1;
    else
	_oss_toed_error(_g, _toed_rules_not_supp_err, "UNALIGNED PER");

    if (*_pdunum < 1 || *_pdunum > 85)
	_oss_dec_error(_g, _pdu_range, *_pdunum);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
    if (!_oss_c->_oss_inbuflen && (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES)) {
	_oss_c->_oss_context_anchor._pdu_number = *_pdunum;
	_oss_dec_error(_g, _more_input, 0L);
    }
#endif
    *_outbuf = _pDecoders[*_pdunum - 1](_g);

#if OSSDEBUG > 0
    _oss_c->_oss_err_msg = nullptr;
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_d_post(_g, 0, *_pdunum, _outbuf);
#endif
}

#if (OSS_TOED_API_LEVEL < 22) || !defined(OSSNOFREEPDU)
static void _f_UnboundedDirectoryString(OssGlobal * _g, _UnboundedDirectoryString * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	if (_data_ptr->u.uTF8String.value)
	    _oss_dec_free(_g, _data_ptr->u.uTF8String.value);
	break;
    case 2:
	if (_data_ptr->u.printableString.value)
	    _oss_dec_free(_g, _data_ptr->u.printableString.value);
	break;
    case 3:
	if (_data_ptr->u.teletexString.value)
	    _oss_dec_free(_g, _data_ptr->u.teletexString.value);
	break;
    case 4:
	if (_data_ptr->u.universalString.value)
	    _oss_dec_free(_g, _data_ptr->u.universalString.value);
	break;
    case 5:
	if (_data_ptr->u.bmpString.value)
	    _oss_dec_free(_g, _data_ptr->u.bmpString.value);
	break;
    default:
	/* Ignore for now */	;
    }
}

static void _f_ContextAssertion(OssGlobal * _g, _ContextAssertion * _data_ptr)
{
    if (_data_ptr->contextType.value)
	_oss_dec_free(_g, _data_ptr->contextType.value);
    if (_data_ptr->contextValues) {
	_setof11 * _tempa = _data_ptr->contextValues;
	_setof11 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    if (_tempa->value.encoded.value)
		_oss_dec_free(_g, _tempa->value.encoded.value);
	    if (_tempa->value.pduNum != 0 && *(void **)&_tempa->value.decoded)
		_fmUpperBounds_(_g, _tempa->value.pduNum, *(void **)&_tempa->value.decoded);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
}

static void _f__choice1(OssGlobal * _g, _choice1 * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	if (_data_ptr->u.single_ASN1_type.encoded)
	    _oss_dec_free(_g, _data_ptr->u.single_ASN1_type.encoded);
	if (_data_ptr->u.single_ASN1_type.pduNum && _data_ptr->u.single_ASN1_type.decoded)
	    _fmUpperBounds_(_g, _data_ptr->u.single_ASN1_type.pduNum, _data_ptr->u.single_ASN1_type.decoded);
	break;
    case 2:
	if (_data_ptr->u.octet_aligned.value)
	    _oss_dec_free(_g, _data_ptr->u.octet_aligned.value);
	break;
    case 3:
	if (_data_ptr->u.arbitrary.value)
	    _oss_dec_free(_g, _data_ptr->u.arbitrary.value);
	break;
    default:
	/* Ignore for now */	;
    }
}

static void _f_External(OssGlobal * _g, _External * _data_ptr)
{
    if (_data_ptr->bit_mask & 0x80000000) {
	if (_data_ptr->direct_reference.value)
	    _oss_dec_free(_g, _data_ptr->direct_reference.value);
    }
    if (_data_ptr->bit_mask & 0x20000000) {
	if (_data_ptr->data_value_descriptor.value)
	    _oss_dec_free(_g, _data_ptr->data_value_descriptor.value);
    }
    _f__choice1(_g, &_data_ptr->encoding);
}

static void _f_Name(OssGlobal * _g, _Name * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	_f_RDNSequence(_g, &_data_ptr->u.rdnSequence);
	break;
    default:
	/* Ignore for now */	;
    }
}

static void _f_AP_title(OssGlobal * _g, _AP_title * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	if (_data_ptr->u.ap_title_form2.value)
	    _oss_dec_free(_g, _data_ptr->u.ap_title_form2.value);
	break;
    case 2:
	_f_Name(_g, _data_ptr->u.ap_title_form1);
	_oss_dec_free(_g, _data_ptr->u.ap_title_form1);
	break;
    default:
	/* Ignore for now */	;
    }
}

static void _f_AE_qualifier(OssGlobal * _g, _AE_qualifier * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 2:
	_f_RelativeDistinguishedName(_g, &_data_ptr->u.ae_qualifier_form1);
	break;
    default:
	/* Ignore for now */	;
    }
}

static void _f__seq1(OssGlobal * _g, _seq1 * _data_ptr)
{
    if (_data_ptr->other_mechanism_name.value)
	_oss_dec_free(_g, _data_ptr->other_mechanism_name.value);
    if (_data_ptr->other_mechanism_value.encoded.value)
	_oss_dec_free(_g, _data_ptr->other_mechanism_value.encoded.value);
    if (_data_ptr->other_mechanism_value.pduNum != 0 && *(void **)&_data_ptr->other_mechanism_value.decoded)
	_fmUpperBounds_(_g, _data_ptr->other_mechanism_value.pduNum, *(void **)&_data_ptr->other_mechanism_value.decoded);
}

static void _f_Authentication_value(OssGlobal * _g, _Authentication_value * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	if (_data_ptr->u.charstring.value)
	    _oss_dec_free(_g, _data_ptr->u.charstring.value);
	break;
    case 2:
	if (_data_ptr->u.bitstring.value)
	    _oss_dec_free(_g, _data_ptr->u.bitstring.value);
	break;
    case 3:
	_f_External(_g, _data_ptr->u.external);
	_oss_dec_free(_g, _data_ptr->u.external);
	break;
    case 4:
	_f__seq1(_g, _data_ptr->u.other);
	_oss_dec_free(_g, _data_ptr->u.other);
	break;
    default:
	/* Ignore for now */	;
    }
}

static void _f_13Application_context_name_l(OssGlobal * _g, _Application_context_name_list ** _data_ptr)
{
    if (*_data_ptr) {
	_Application_context_name_list * _tempa = *_data_ptr;
	_Application_context_name_list * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    if (_tempa->value.value)
		_oss_dec_free(_g, _tempa->value.value);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
}

static void _f_Association_information(OssGlobal * _g, _Association_information ** _data_ptr)
{
    if (*_data_ptr) {
	_Association_information * _tempa = *_data_ptr;
	_Association_information * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _f_External(_g, &_tempa->value);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
}

static void _f_ConnectionData(OssGlobal * _g, _ConnectionData * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	if (_data_ptr->u.open.encoded)
	    _oss_dec_free(_g, _data_ptr->u.open.encoded);
	if (_data_ptr->u.open.pduNum && _data_ptr->u.open.decoded)
	    _fmUpperBounds_(_g, _data_ptr->u.open.pduNum, _data_ptr->u.open.decoded);
	break;
    case 2:
	_f_SessionConnectionIdentifier(_g, _data_ptr->u.recover);
	_oss_dec_free(_g, _data_ptr->u.recover);
	break;
    default:
	/* Ignore for now */	;
    }
}

static void _f_User_data(OssGlobal * _g, _User_data * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	if (_data_ptr->u.simply_encoded_data.value)
	    _oss_dec_free(_g, _data_ptr->u.simply_encoded_data.value);
	break;
    case 2:
	_f_Fully_encoded_data(_g, &_data_ptr->u.fully_encoded_data);
	break;
    default:
	/* Ignore for now */	;
    }
}

static void _f__seq7(OssGlobal * _g, _seq7 * _data_ptr)
{
    if (_data_ptr->abstract_syntax_name.value)
	_oss_dec_free(_g, _data_ptr->abstract_syntax_name.value);
    if (_data_ptr->transfer_syntax_name_list) {
	_Application_context_name_list * _tempa = _data_ptr->transfer_syntax_name_list;
	_Application_context_name_list * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    if (_tempa->value.value)
		_oss_dec_free(_g, _tempa->value.value);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
}

static void _f_Context_list(OssGlobal * _g, _Context_list ** _data_ptr)
{
    if (*_data_ptr) {
	_Context_list * _tempa = *_data_ptr;
	_Context_list * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _f__seq7(_g, &_tempa->value);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
}

static void _f__seq8(OssGlobal * _g, _seq8 * _data_ptr)
{
    if (_data_ptr->transfer_syntax_name.value)
	_oss_dec_free(_g, _data_ptr->transfer_syntax_name.value);
}

static void _f_14Presentation_context_ident(OssGlobal * _g, _Presentation_context_identifier_list ** _data_ptr)
{
    if (*_data_ptr) {
	_Presentation_context_identifier_list * _tempa = *_data_ptr;
	_Presentation_context_identifier_list * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _f__seq8(_g, &_tempa->value);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
}

static void _f__seq9(OssGlobal * _g, _seq9 * _data_ptr)
{
    if (_data_ptr->bit_mask & 0x80000000) {
	if (_data_ptr->transfer_syntax_name.value)
	    _oss_dec_free(_g, _data_ptr->transfer_syntax_name.value);
    }
}

static void _f_Result_list(OssGlobal * _g, _Result_list ** _data_ptr)
{
    if (*_data_ptr) {
	_Result_list * _tempa = *_data_ptr;
	_Result_list * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _f__seq9(_g, &_tempa->value);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
}

static void _f_PDV_list(OssGlobal * _g, _PDV_list * _data_ptr)
{
    if (_data_ptr->bit_mask & 0x80000000) {
	if (_data_ptr->transfer_syntax_name.value)
	    _oss_dec_free(_g, _data_ptr->transfer_syntax_name.value);
    }
    switch (_data_ptr->presentation_data_values.choice) {
    case 1:
	if (_data_ptr->presentation_data_values.u.single_ASN1_type.encoded)
	    _oss_dec_free(_g, _data_ptr->presentation_data_values.u.single_ASN1_type.encoded);
	if (_data_ptr->presentation_data_values.u.single_ASN1_type.pduNum && _data_ptr->presentation_data_values.u.single_ASN1_type.decoded)
	    _fmUpperBounds_(_g, _data_ptr->presentation_data_values.u.single_ASN1_type.pduNum, _data_ptr->presentation_data_values.u.single_ASN1_type.decoded);
	break;
    case 2:
	if (_data_ptr->presentation_data_values.u.octet_aligned.value)
	    _oss_dec_free(_g, _data_ptr->presentation_data_values.u.octet_aligned.value);
	break;
    case 3:
	if (_data_ptr->presentation_data_values.u.arbitrary.value)
	    _oss_dec_free(_g, _data_ptr->presentation_data_values.u.arbitrary.value);
	break;
    default:
	/* Ignore for now */	;
    }
}

static void _f_Fully_encoded_data(OssGlobal * _g, _Fully_encoded_data ** _data_ptr)
{
    if (*_data_ptr) {
	_Fully_encoded_data * _tempa = *_data_ptr;
	_Fully_encoded_data * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _f_PDV_list(_g, &_tempa->value);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
}

static void _f_RTORQapdu(OssGlobal * _g, _set1 * _data_ptr)
{
    _f_ConnectionData(_g, &_data_ptr->connectionDataRQ);
}

static void _f_RTOACapdu(OssGlobal * _g, _set2 * _data_ptr)
{
    _f_ConnectionData(_g, &_data_ptr->connectionDataAC);
}

static void _f_RTORJapdu(OssGlobal * _g, _set3 * _data_ptr)
{
    if (_data_ptr->bit_mask & 0x40000000) {
	if (_data_ptr->userDataRJ.encoded)
	    _oss_dec_free(_g, _data_ptr->userDataRJ.encoded);
	if (_data_ptr->userDataRJ.pduNum && _data_ptr->userDataRJ.decoded)
	    _fmUpperBounds_(_g, _data_ptr->userDataRJ.pduNum, _data_ptr->userDataRJ.decoded);
    }
}

static void _f_CallingSSuserReference(OssGlobal * _g, _CallingSSuserReference * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	if (_data_ptr->u.octetString.value)
	    _oss_dec_free(_g, _data_ptr->u.octetString.value);
	break;
    case 2:
	if (_data_ptr->u.t61String.value)
	    _oss_dec_free(_g, _data_ptr->u.t61String.value);
	break;
    default:
	/* Ignore for now */	;
    }
}

static void _f_SessionConnectionIdentifier(OssGlobal * _g, _SessionConnectionIdentifier * _data_ptr)
{
    _f_CallingSSuserReference(_g, &_data_ptr->callingSSuserReference);
    _oss_dec_free(_g, _data_ptr->commonReference);
    if (_data_ptr->bit_mask & 0x80000000) {
	if (_data_ptr->additionalReferenceInformation.value)
	    _oss_dec_free(_g, _data_ptr->additionalReferenceInformation.value);
    }
}

static void _f_Criteria(OssGlobal * _g, _Criteria * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	_f_CriteriaItem(_g, _data_ptr->u.type);
	_oss_dec_free(_g, _data_ptr->u.type);
	break;
    case 2:
	_f__setof1(_g, &_data_ptr->u.Criteria_and);
	break;
    case 3:
	_f__setof2(_g, &_data_ptr->u.Criteria_or);
	break;
    case 4:
	_f_Criteria(_g, _data_ptr->u.Criteria_not);
	_oss_dec_free(_g, _data_ptr->u.Criteria_not);
	break;
    default:
	/* Ignore for now */	;
    }
}

static void _f__setof2(OssGlobal * _g, _setof1 ** _data_ptr)
{
    if (*_data_ptr) {
	_setof1 * _tempa = *_data_ptr;
	_setof1 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _f_Criteria(_g, &_tempa->value);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
}

static void _f__setof1(OssGlobal * _g, _setof1 ** _data_ptr)
{
    if (*_data_ptr) {
	_setof1 * _tempa = *_data_ptr;
	_setof1 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _f_Criteria(_g, &_tempa->value);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
}

static void _f_CriteriaItem(OssGlobal * _g, _CriteriaItem * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	if (_data_ptr->u.equality.value)
	    _oss_dec_free(_g, _data_ptr->u.equality.value);
	break;
    case 2:
	if (_data_ptr->u.substrings.value)
	    _oss_dec_free(_g, _data_ptr->u.substrings.value);
	break;
    case 3:
	if (_data_ptr->u.greaterOrEqual.value)
	    _oss_dec_free(_g, _data_ptr->u.greaterOrEqual.value);
	break;
    case 4:
	if (_data_ptr->u.lessOrEqual.value)
	    _oss_dec_free(_g, _data_ptr->u.lessOrEqual.value);
	break;
    case 5:
	if (_data_ptr->u.approximateMatch.value)
	    _oss_dec_free(_g, _data_ptr->u.approximateMatch.value);
	break;
    default:
	/* Ignore for now */	;
    }
}

static void _f__setof7(OssGlobal * _g, _Presentation_context_deletion_list ** _data_ptr)
{
    if (*_data_ptr) {
	_Presentation_context_deletion_list * _tempa = *_data_ptr;
	_Presentation_context_deletion_list * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
}

static void _f_NamedDay(OssGlobal * _g, _NamedDay * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	if (_data_ptr->u.bitNamedDays.value)
	    _oss_dec_free(_g, _data_ptr->u.bitNamedDays.value);
	break;
    default:
	/* Ignore for now */	;
    }
}

static void _f_Context(OssGlobal * _g, _Context * _data_ptr)
{
    if (_data_ptr->contextType.value)
	_oss_dec_free(_g, _data_ptr->contextType.value);
    if (_data_ptr->contextValues) {
	_setof11 * _tempa = _data_ptr->contextValues;
	_setof11 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    if (_tempa->value.encoded.value)
		_oss_dec_free(_g, _tempa->value.encoded.value);
	    if (_tempa->value.pduNum != 0 && *(void **)&_tempa->value.decoded)
		_fmUpperBounds_(_g, _tempa->value.pduNum, *(void **)&_tempa->value.decoded);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
}

static void _f_RDNSequence(OssGlobal * _g, _RDNSequence ** _data_ptr)
{
    if (*_data_ptr) {
	_RDNSequence * _tempa = *_data_ptr;
	_RDNSequence * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _f_RelativeDistinguishedName(_g, &_tempa->value);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
}

static void _f_15AttributeTypeAndDistinguis(OssGlobal * _g, _AttributeTypeAndDistinguishedValue * _data_ptr)
{
    if (_data_ptr->type.value)
	_oss_dec_free(_g, _data_ptr->type.value);
    if (_data_ptr->value.encoded.value)
	_oss_dec_free(_g, _data_ptr->value.encoded.value);
    if (_data_ptr->value.pduNum != 0 && *(void **)&_data_ptr->value.decoded)
	_fmUpperBounds_(_g, _data_ptr->value.pduNum, *(void **)&_data_ptr->value.decoded);
    if (_data_ptr->bit_mask & 0x40000000) {
	if (_data_ptr->valuesWithContext) {
	    _setof16 * _tempa = _data_ptr->valuesWithContext;
	    _setof16 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		if (_tempa->value.bit_mask & 0x80000000) {
		    if (_tempa->value.distingAttrValue.encoded.value)
			_oss_dec_free(_g, _tempa->value.distingAttrValue.encoded.value);
		    if (_tempa->value.distingAttrValue.pduNum != 0 && *(void **)&_tempa->value.distingAttrValue.decoded)
			_fmUpperBounds_(_g, _tempa->value.distingAttrValue.pduNum, *(void **)&_tempa->value.distingAttrValue.decoded);
		}
		if (_tempa->value.contextList) {
		    _setof15 * _temp1a = _tempa->value.contextList;
		    _setof15 * _temp1b;
		    while (_temp1a) {
			_temp1b = _temp1a->next;
			_f_Context(_g, &_temp1a->value);
			_oss_dec_free(_g, _temp1a);
			_temp1a = _temp1b;
		    }
		}
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
}

static void _f_RelativeDistinguishedName(OssGlobal * _g, _RelativeDistinguishedName ** _data_ptr)
{
    if (*_data_ptr) {
	_RelativeDistinguishedName * _tempa = *_data_ptr;
	_RelativeDistinguishedName * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _f_15AttributeTypeAndDistinguis(_g, &_tempa->value);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
}

static void _f_Refinement(OssGlobal * _g, _Refinement * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	if (_data_ptr->u.item.value)
	    _oss_dec_free(_g, _data_ptr->u.item.value);
	break;
    case 2:
	_f__setof17(_g, &_data_ptr->u.Refinement_and);
	break;
    case 3:
	_f__setof18(_g, &_data_ptr->u.Refinement_or);
	break;
    case 4:
	_f_Refinement(_g, _data_ptr->u.Refinement_not);
	_oss_dec_free(_g, _data_ptr->u.Refinement_not);
	break;
    default:
	/* Ignore for now */	;
    }
}

static void _f__setof18(OssGlobal * _g, _setof17 ** _data_ptr)
{
    if (*_data_ptr) {
	_setof17 * _tempa = *_data_ptr;
	_setof17 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _f_Refinement(_g, &_tempa->value);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
}

static void _f__setof17(OssGlobal * _g, _setof17 ** _data_ptr)
{
    if (*_data_ptr) {
	_setof17 * _tempa = *_data_ptr;
	_setof17 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _f_Refinement(_g, &_tempa->value);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
}

static void _fOssEncOID(OssGlobal * _g, void * _data)
{
    OSSC::COssEncOID	*_data_ptr;
    _data_ptr = (OSSC::COssEncOID *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _fACSE_apdu(OssGlobal * _g, void * _data)
{
    _ACSE_apdu	*_data_ptr;
    _data_ptr = (_ACSE_apdu *)_data;
    switch (_data_ptr->choice) {
    case 1:
	if (_data_ptr->u.aarq->bit_mask & 0x80000000) {
	    if (_data_ptr->u.aarq->protocol_version.value)
		_oss_dec_free(_g, _data_ptr->u.aarq->protocol_version.value);
	}
	if (_data_ptr->u.aarq->application_context_name.value)
	    _oss_dec_free(_g, _data_ptr->u.aarq->application_context_name.value);
	if (_data_ptr->u.aarq->bit_mask & 0x40000000) {
	    _f_AP_title(_g, &_data_ptr->u.aarq->called_AP_title);
	}
	if (_data_ptr->u.aarq->bit_mask & 0x20000000) {
	    _f_AE_qualifier(_g, &_data_ptr->u.aarq->called_AE_qualifier);
	}
	if (_data_ptr->u.aarq->bit_mask & 0x4000000) {
	    _f_AP_title(_g, &_data_ptr->u.aarq->calling_AP_title);
	}
	if (_data_ptr->u.aarq->bit_mask & 0x2000000) {
	    _f_AE_qualifier(_g, &_data_ptr->u.aarq->calling_AE_qualifier);
	}
	if (_data_ptr->u.aarq->bit_mask & 0x400000) {
	    if (_data_ptr->u.aarq->sender_acse_requirements.value)
		_oss_dec_free(_g, _data_ptr->u.aarq->sender_acse_requirements.value);
	}
	if (_data_ptr->u.aarq->bit_mask & 0x200000) {
	    if (_data_ptr->u.aarq->mechanism_name.value)
		_oss_dec_free(_g, _data_ptr->u.aarq->mechanism_name.value);
	}
	if (_data_ptr->u.aarq->bit_mask & 0x100000) {
	    _f_Authentication_value(_g, &_data_ptr->u.aarq->calling_authentication_value);
	}
	if (_data_ptr->u.aarq->bit_mask & 0x80000) {
	    _f_13Application_context_name_l(_g, &_data_ptr->u.aarq->application_context_name_list);
	}
	if (_data_ptr->u.aarq->bit_mask & 0x40000) {
	    if (_data_ptr->u.aarq->implementation_information.value)
		_oss_dec_free(_g, _data_ptr->u.aarq->implementation_information.value);
	}
	if (_data_ptr->u.aarq->bit_mask & 0x20000) {
	    _f_Association_information(_g, &_data_ptr->u.aarq->user_information);
	}
	_oss_dec_free(_g, _data_ptr->u.aarq);
	break;
    case 2:
	if (_data_ptr->u.aare->bit_mask & 0x80000000) {
	    if (_data_ptr->u.aare->protocol_version.value)
		_oss_dec_free(_g, _data_ptr->u.aare->protocol_version.value);
	}
	if (_data_ptr->u.aare->application_context_name.value)
	    _oss_dec_free(_g, _data_ptr->u.aare->application_context_name.value);
	if (_data_ptr->u.aare->bit_mask & 0x40000000) {
	    _f_AP_title(_g, &_data_ptr->u.aare->responding_AP_title);
	}
	if (_data_ptr->u.aare->bit_mask & 0x20000000) {
	    _f_AE_qualifier(_g, &_data_ptr->u.aare->responding_AE_qualifier);
	}
	if (_data_ptr->u.aare->bit_mask & 0x4000000) {
	    if (_data_ptr->u.aare->responder_acse_requirements.value)
		_oss_dec_free(_g, _data_ptr->u.aare->responder_acse_requirements.value);
	}
	if (_data_ptr->u.aare->bit_mask & 0x2000000) {
	    if (_data_ptr->u.aare->mechanism_name.value)
		_oss_dec_free(_g, _data_ptr->u.aare->mechanism_name.value);
	}
	if (_data_ptr->u.aare->bit_mask & 0x1000000) {
	    _f_Authentication_value(_g, &_data_ptr->u.aare->responding_authentication_value);
	}
	if (_data_ptr->u.aare->bit_mask & 0x800000) {
	    _f_13Application_context_name_l(_g, &_data_ptr->u.aare->application_context_name_list);
	}
	if (_data_ptr->u.aare->bit_mask & 0x400000) {
	    if (_data_ptr->u.aare->implementation_information.value)
		_oss_dec_free(_g, _data_ptr->u.aare->implementation_information.value);
	}
	if (_data_ptr->u.aare->bit_mask & 0x200000) {
	    _f_Association_information(_g, &_data_ptr->u.aare->user_information);
	}
	_oss_dec_free(_g, _data_ptr->u.aare);
	break;
    case 3:
	if (_data_ptr->u.rlrq->bit_mask & 0x40000000) {
	    _f_Association_information(_g, &_data_ptr->u.rlrq->user_information);
	}
	_oss_dec_free(_g, _data_ptr->u.rlrq);
	break;
    case 4:
	if (_data_ptr->u.rlre->bit_mask & 0x40000000) {
	    _f_Association_information(_g, &_data_ptr->u.rlre->user_information);
	}
	_oss_dec_free(_g, _data_ptr->u.rlre);
	break;
    case 5:
	if (_data_ptr->u.abrt->bit_mask & 0x40000000) {
	    _f_Association_information(_g, &_data_ptr->u.abrt->user_information);
	}
	_oss_dec_free(_g, _data_ptr->u.abrt);
	break;
    default:
	/* Ignore for now */	;
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fAE_title(OssGlobal * _g, void * _data)
{
    _AE_title	*_data_ptr;
    _data_ptr = (_AE_title *)_data;
    switch (_data_ptr->choice) {
    case 1:
	if (_data_ptr->u.ae_title_form2.value)
	    _oss_dec_free(_g, _data_ptr->u.ae_title_form2.value);
	break;
    case 2:
	_f_Name(_g, _data_ptr->u.ae_title_form1);
	_oss_dec_free(_g, _data_ptr->u.ae_title_form1);
	break;
    default:
	/* Ignore for now */	;
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fCP_type(OssGlobal * _g, void * _data)
{
    _CP_type	*_data_ptr;
    _data_ptr = (_CP_type *)_data;
    if (_data_ptr->bit_mask & 0x80000000) {
	_f_ConnectionData(_g, &_data_ptr->x410_mode_parameters.connectionDataRQ);
    }
    if (_data_ptr->bit_mask & 0x40000000) {
	if (_data_ptr->normal_mode_parameters.bit_mask & 0x80000000) {
	    if (_data_ptr->normal_mode_parameters.protocol_version.value)
		_oss_dec_free(_g, _data_ptr->normal_mode_parameters.protocol_version.value);
	}
	if (_data_ptr->normal_mode_parameters.bit_mask & 0x40000000) {
	    if (_data_ptr->normal_mode_parameters.calling_presentation_selector.value)
		_oss_dec_free(_g, _data_ptr->normal_mode_parameters.calling_presentation_selector.value);
	}
	if (_data_ptr->normal_mode_parameters.bit_mask & 0x20000000) {
	    if (_data_ptr->normal_mode_parameters.called_presentation_selector.value)
		_oss_dec_free(_g, _data_ptr->normal_mode_parameters.called_presentation_selector.value);
	}
	if (_data_ptr->normal_mode_parameters.bit_mask & 0x10000000) {
	    _f_Context_list(_g, &_data_ptr->normal_mode_parameters.presentation_context_definition_list);
	}
	if (_data_ptr->normal_mode_parameters.bit_mask & 0x8000000) {
	    if (_data_ptr->normal_mode_parameters.default_context_name.abstract_syntax_name.value)
		_oss_dec_free(_g, _data_ptr->normal_mode_parameters.default_context_name.abstract_syntax_name.value);
	    if (_data_ptr->normal_mode_parameters.default_context_name.transfer_syntax_name.value)
		_oss_dec_free(_g, _data_ptr->normal_mode_parameters.default_context_name.transfer_syntax_name.value);
	}
	if (_data_ptr->normal_mode_parameters.bit_mask & 0x4000000) {
	    if (_data_ptr->normal_mode_parameters.presentation_requirements.value)
		_oss_dec_free(_g, _data_ptr->normal_mode_parameters.presentation_requirements.value);
	}
	if (_data_ptr->normal_mode_parameters.bit_mask & 0x2000000) {
	    if (_data_ptr->normal_mode_parameters.user_session_requirements.value)
		_oss_dec_free(_g, _data_ptr->normal_mode_parameters.user_session_requirements.value);
	}
	if (_data_ptr->normal_mode_parameters.bit_mask & 0x1000000) {
	    if (_data_ptr->normal_mode_parameters.protocol_options.value)
		_oss_dec_free(_g, _data_ptr->normal_mode_parameters.protocol_options.value);
	}
	if (_data_ptr->normal_mode_parameters.bit_mask & 0x200000) {
	    _f_User_data(_g, &_data_ptr->normal_mode_parameters.user_data);
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fCPC_type(OssGlobal * _g, void * _data)
{
    _User_data	*_data_ptr;
    _data_ptr = (_User_data *)_data;
    _f_User_data(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fCPA_PPDU(OssGlobal * _g, void * _data)
{
    _CPA_PPDU	*_data_ptr;
    _data_ptr = (_CPA_PPDU *)_data;
    if (_data_ptr->bit_mask & 0x80000000) {
	_f_ConnectionData(_g, &_data_ptr->x410_mode_parameters.connectionDataAC);
    }
    if (_data_ptr->bit_mask & 0x40000000) {
	if (_data_ptr->normal_mode_parameters.bit_mask & 0x80000000) {
	    if (_data_ptr->normal_mode_parameters.protocol_version.value)
		_oss_dec_free(_g, _data_ptr->normal_mode_parameters.protocol_version.value);
	}
	if (_data_ptr->normal_mode_parameters.bit_mask & 0x40000000) {
	    if (_data_ptr->normal_mode_parameters.responding_presentation_selector.value)
		_oss_dec_free(_g, _data_ptr->normal_mode_parameters.responding_presentation_selector.value);
	}
	if (_data_ptr->normal_mode_parameters.bit_mask & 0x20000000) {
	    _f_Result_list(_g, &_data_ptr->normal_mode_parameters.presentation_context_definition_result_list);
	}
	if (_data_ptr->normal_mode_parameters.bit_mask & 0x10000000) {
	    if (_data_ptr->normal_mode_parameters.presentation_requirements.value)
		_oss_dec_free(_g, _data_ptr->normal_mode_parameters.presentation_requirements.value);
	}
	if (_data_ptr->normal_mode_parameters.bit_mask & 0x8000000) {
	    if (_data_ptr->normal_mode_parameters.user_session_requirements.value)
		_oss_dec_free(_g, _data_ptr->normal_mode_parameters.user_session_requirements.value);
	}
	if (_data_ptr->normal_mode_parameters.bit_mask & 0x4000000) {
	    if (_data_ptr->normal_mode_parameters.protocol_options.value)
		_oss_dec_free(_g, _data_ptr->normal_mode_parameters.protocol_options.value);
	}
	if (_data_ptr->normal_mode_parameters.bit_mask & 0x1000000) {
	    _f_User_data(_g, &_data_ptr->normal_mode_parameters.user_data);
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fCPR_PPDU(OssGlobal * _g, void * _data)
{
    _CPR_PPDU	*_data_ptr;
    _data_ptr = (_CPR_PPDU *)_data;
    switch (_data_ptr->choice) {
    case 1:
	if (_data_ptr->u.normal_mode_parameters->bit_mask & 0x80000000) {
	    if (_data_ptr->u.normal_mode_parameters->protocol_version.value)
		_oss_dec_free(_g, _data_ptr->u.normal_mode_parameters->protocol_version.value);
	}
	if (_data_ptr->u.normal_mode_parameters->bit_mask & 0x40000000) {
	    if (_data_ptr->u.normal_mode_parameters->responding_presentation_selector.value)
		_oss_dec_free(_g, _data_ptr->u.normal_mode_parameters->responding_presentation_selector.value);
	}
	if (_data_ptr->u.normal_mode_parameters->bit_mask & 0x20000000) {
	    _f_Result_list(_g, &_data_ptr->u.normal_mode_parameters->presentation_context_definition_result_list);
	}
	if (_data_ptr->u.normal_mode_parameters->bit_mask & 0x4000000) {
	    _f_User_data(_g, &_data_ptr->u.normal_mode_parameters->user_data);
	}
	_oss_dec_free(_g, _data_ptr->u.normal_mode_parameters);
	break;
    case 2:
	if (_data_ptr->u.x400_mode_parameters->bit_mask & 0x40000000) {
	    if (_data_ptr->u.x400_mode_parameters->userDataRJ.encoded)
		_oss_dec_free(_g, _data_ptr->u.x400_mode_parameters->userDataRJ.encoded);
	    if (_data_ptr->u.x400_mode_parameters->userDataRJ.pduNum && _data_ptr->u.x400_mode_parameters->userDataRJ.decoded)
		_fmUpperBounds_(_g, _data_ptr->u.x400_mode_parameters->userDataRJ.pduNum, _data_ptr->u.x400_mode_parameters->userDataRJ.decoded);
	}
	_oss_dec_free(_g, _data_ptr->u.x400_mode_parameters);
	break;
    default:
	/* Ignore for now */	;
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fAbort_type(OssGlobal * _g, void * _data)
{
    _Abort_type	*_data_ptr;
    _data_ptr = (_Abort_type *)_data;
    switch (_data_ptr->choice) {
    case 1:
	_oss_dec_free(_g, _data_ptr->u.arp_ppdu);
	break;
    case 2:
	switch (_data_ptr->u.aru_ppdu->choice) {
	case 1:
	    if (_data_ptr->u.aru_ppdu->u.x400_mode_parameters->bit_mask & 0x40000000) {
		if (_data_ptr->u.aru_ppdu->u.x400_mode_parameters->reflectedParameter.value)
		    _oss_dec_free(_g, _data_ptr->u.aru_ppdu->u.x400_mode_parameters->reflectedParameter.value);
	    }
	    if (_data_ptr->u.aru_ppdu->u.x400_mode_parameters->bit_mask & 0x20000000) {
		if (_data_ptr->u.aru_ppdu->u.x400_mode_parameters->userdataAB.encoded)
		    _oss_dec_free(_g, _data_ptr->u.aru_ppdu->u.x400_mode_parameters->userdataAB.encoded);
		if (_data_ptr->u.aru_ppdu->u.x400_mode_parameters->userdataAB.pduNum && _data_ptr->u.aru_ppdu->u.x400_mode_parameters->userdataAB.decoded)
		    _fmUpperBounds_(_g, _data_ptr->u.aru_ppdu->u.x400_mode_parameters->userdataAB.pduNum, _data_ptr->u.aru_ppdu->u.x400_mode_parameters->userdataAB.decoded);
	    }
	    _oss_dec_free(_g, _data_ptr->u.aru_ppdu->u.x400_mode_parameters);
	    break;
	case 2:
	    if (_data_ptr->u.aru_ppdu->u.normal_mode_parameters->bit_mask & 0x80000000) {
		_f_14Presentation_context_ident(_g, &_data_ptr->u.aru_ppdu->u.normal_mode_parameters->presentation_context_identifier_list);
	    }
	    if (_data_ptr->u.aru_ppdu->u.normal_mode_parameters->bit_mask & 0x40000000) {
		_f_User_data(_g, &_data_ptr->u.aru_ppdu->u.normal_mode_parameters->user_data);
	    }
	    _oss_dec_free(_g, _data_ptr->u.aru_ppdu->u.normal_mode_parameters);
	    break;
	default:
	    /* Ignore for now */	;
	}
	_oss_dec_free(_g, _data_ptr->u.aru_ppdu);
	break;
    default:
	/* Ignore for now */	;
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fTyped_data_type(OssGlobal * _g, void * _data)
{
    _Typed_data_type	*_data_ptr;
    _data_ptr = (_Typed_data_type *)_data;
    switch (_data_ptr->choice) {
    case 1:
	_f_User_data(_g, _data_ptr->u.ttdPPDU);
	_oss_dec_free(_g, _data_ptr->u.ttdPPDU);
	break;
    case 2:
	if (_data_ptr->u.acPPDU->bit_mask & 0x80000000) {
	    _f_Context_list(_g, &_data_ptr->u.acPPDU->presentation_context_addition_list);
	}
	if (_data_ptr->u.acPPDU->bit_mask & 0x40000000) {
	    if (_data_ptr->u.acPPDU->presentation_context_deletion_list) {
		_Presentation_context_deletion_list * _tempa = _data_ptr->u.acPPDU->presentation_context_deletion_list;
		_Presentation_context_deletion_list * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    _oss_dec_free(_g, _tempa);
		    _tempa = _tempb;
		}
	    }
	}
	if (_data_ptr->u.acPPDU->bit_mask & 0x20000000) {
	    _f_User_data(_g, &_data_ptr->u.acPPDU->user_data);
	}
	_oss_dec_free(_g, _data_ptr->u.acPPDU);
	break;
    case 3:
	if (_data_ptr->u.acaPPDU->bit_mask & 0x80000000) {
	    _f_Result_list(_g, &_data_ptr->u.acaPPDU->presentation_context_addition_result_list);
	}
	if (_data_ptr->u.acaPPDU->bit_mask & 0x40000000) {
	    if (_data_ptr->u.acaPPDU->presentation_context_deletion_result_list) {
		_Presentation_context_deletion_list * _tempa = _data_ptr->u.acaPPDU->presentation_context_deletion_result_list;
		_Presentation_context_deletion_list * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    _oss_dec_free(_g, _tempa);
		    _tempa = _tempb;
		}
	    }
	}
	if (_data_ptr->u.acaPPDU->bit_mask & 0x20000000) {
	    _f_User_data(_g, &_data_ptr->u.acaPPDU->user_data);
	}
	_oss_dec_free(_g, _data_ptr->u.acaPPDU);
	break;
    default:
	/* Ignore for now */	;
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fRS_PPDU(OssGlobal * _g, void * _data)
{
    _seq6	*_data_ptr;
    _data_ptr = (_seq6 *)_data;
    if (_data_ptr->bit_mask & 0x80000000) {
	_f_14Presentation_context_ident(_g, &_data_ptr->presentation_context_identifier_list);
    }
    if (_data_ptr->bit_mask & 0x40000000) {
	_f_User_data(_g, &_data_ptr->user_data);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fRSA_PPDU(OssGlobal * _g, void * _data)
{
    _seq6	*_data_ptr;
    _data_ptr = (_seq6 *)_data;
    if (_data_ptr->bit_mask & 0x80000000) {
	_f_14Presentation_context_ident(_g, &_data_ptr->presentation_context_identifier_list);
    }
    if (_data_ptr->bit_mask & 0x40000000) {
	_f_User_data(_g, &_data_ptr->user_data);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _f0Reliable_Transfer_APDU_RTSE(OssGlobal * _g, void * _data)
{
    _Reliable_Transfer_APDU_RTSE_apdus	*_data_ptr;
    _data_ptr = (_Reliable_Transfer_APDU_RTSE_apdus *)_data;
    switch (_data_ptr->choice) {
    case 2:
	if (_data_ptr->u.rttr_apdu.value)
	    _oss_dec_free(_g, _data_ptr->u.rttr_apdu.value);
	break;
    case 3:
	_f_RTORQapdu(_g, _data_ptr->u.rtorq_apdu);
	_oss_dec_free(_g, _data_ptr->u.rtorq_apdu);
	break;
    case 4:
	_f_RTOACapdu(_g, _data_ptr->u.rtoac_apdu);
	_oss_dec_free(_g, _data_ptr->u.rtoac_apdu);
	break;
    case 5:
	_f_RTORJapdu(_g, _data_ptr->u.rtorj_apdu);
	_oss_dec_free(_g, _data_ptr->u.rtorj_apdu);
	break;
    case 6:
	if (_data_ptr->u.rtab_apdu->bit_mask & 0x40000000) {
	    if (_data_ptr->u.rtab_apdu->reflectedParameter.value)
		_oss_dec_free(_g, _data_ptr->u.rtab_apdu->reflectedParameter.value);
	}
	if (_data_ptr->u.rtab_apdu->bit_mask & 0x20000000) {
	    if (_data_ptr->u.rtab_apdu->userdataAB.encoded)
		_oss_dec_free(_g, _data_ptr->u.rtab_apdu->userdataAB.encoded);
	    if (_data_ptr->u.rtab_apdu->userdataAB.pduNum && _data_ptr->u.rtab_apdu->userdataAB.decoded)
		_fmUpperBounds_(_g, _data_ptr->u.rtab_apdu->userdataAB.pduNum, _data_ptr->u.rtab_apdu->userdataAB.decoded);
	}
	_oss_dec_free(_g, _data_ptr->u.rtab_apdu);
	break;
    default:
	/* Ignore for now */	;
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _f1Remote_Operations_Abstract_(OssGlobal * _g, void * _data)
{
    _Reliable_Transfer_APDU_RTSE_apdus	*_data_ptr;
    _data_ptr = (_Reliable_Transfer_APDU_RTSE_apdus *)_data;
    switch (_data_ptr->choice) {
    case 2:
	if (_data_ptr->u.rttr_apdu.value)
	    _oss_dec_free(_g, _data_ptr->u.rttr_apdu.value);
	break;
    case 3:
	_f_RTORQapdu(_g, _data_ptr->u.rtorq_apdu);
	_oss_dec_free(_g, _data_ptr->u.rtorq_apdu);
	break;
    case 4:
	_f_RTOACapdu(_g, _data_ptr->u.rtoac_apdu);
	_oss_dec_free(_g, _data_ptr->u.rtoac_apdu);
	break;
    case 5:
	_f_RTORJapdu(_g, _data_ptr->u.rtorj_apdu);
	_oss_dec_free(_g, _data_ptr->u.rtorj_apdu);
	break;
    case 6:
	if (_data_ptr->u.rtab_apdu->bit_mask & 0x40000000) {
	    if (_data_ptr->u.rtab_apdu->reflectedParameter.value)
		_oss_dec_free(_g, _data_ptr->u.rtab_apdu->reflectedParameter.value);
	}
	if (_data_ptr->u.rtab_apdu->bit_mask & 0x20000000) {
	    if (_data_ptr->u.rtab_apdu->userdataAB.encoded)
		_oss_dec_free(_g, _data_ptr->u.rtab_apdu->userdataAB.encoded);
	    if (_data_ptr->u.rtab_apdu->userdataAB.pduNum && _data_ptr->u.rtab_apdu->userdataAB.decoded)
		_fmUpperBounds_(_g, _data_ptr->u.rtab_apdu->userdataAB.pduNum, _data_ptr->u.rtab_apdu->userdataAB.decoded);
	}
	_oss_dec_free(_g, _data_ptr->u.rtab_apdu);
	break;
    default:
	/* Ignore for now */	;
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fROSEInvokeIds(OssGlobal * _g, void * _data)
{
    _InvokeId	*_data_ptr;
    _data_ptr = (_InvokeId *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fReject(OssGlobal * _g, void * _data)
{
    _Reject	*_data_ptr;
    _data_ptr = (_Reject *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fNoInvokeId(OssGlobal * _g, void * _data)
{
    _InvokeId	*_data_ptr;
    _data_ptr = (_InvokeId *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fUnboundedDirectoryString(OssGlobal * _g, void * _data)
{
    _UnboundedDirectoryString	*_data_ptr;
    _data_ptr = (_UnboundedDirectoryString *)_data;
    _f_UnboundedDirectoryString(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fUniqueIdentifier(OssGlobal * _g, void * _data)
{
    OSSC::COssBitString	*_data_ptr;
    _data_ptr = (OSSC::COssBitString *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _fUUIDPair(OssGlobal * _g, void * _data)
{
    _UUIDPair	*_data_ptr;
    _data_ptr = (_UUIDPair *)_data;
    if (_data_ptr->issuerUUID.value)
	_oss_dec_free(_g, _data_ptr->issuerUUID.value);
    if (_data_ptr->subjectUUID.value)
	_oss_dec_free(_g, _data_ptr->subjectUUID.value);
    _oss_dec_free(_g, _data_ptr);
}

static void _fCountryName(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _fGuide(OssGlobal * _g, void * _data)
{
    _Guide	*_data_ptr;
    _data_ptr = (_Guide *)_data;
    if (_data_ptr->bit_mask & 0x80000000) {
	if (_data_ptr->objectClass.value)
	    _oss_dec_free(_g, _data_ptr->objectClass.value);
    }
    _f_Criteria(_g, &_data_ptr->criteria);
    _oss_dec_free(_g, _data_ptr);
}

static void _fEnhancedGuide(OssGlobal * _g, void * _data)
{
    _EnhancedGuide	*_data_ptr;
    _data_ptr = (_EnhancedGuide *)_data;
    if (_data_ptr->objectClass.value)
	_oss_dec_free(_g, _data_ptr->objectClass.value);
    _f_Criteria(_g, &_data_ptr->criteria);
    _oss_dec_free(_g, _data_ptr);
}

static void _fPostalAddress(OssGlobal * _g, void * _data)
{
    _PostalAddress	**_data_ptr;
    _data_ptr = (_PostalAddress **)_data;
    if (*_data_ptr) {
	_PostalAddress * _tempa = *_data_ptr;
	_PostalAddress * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _f_UnboundedDirectoryString(_g, &_tempa->value);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fTelephoneNumber(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _fTelexNumber(OssGlobal * _g, void * _data)
{
    _TelexNumber	*_data_ptr;
    _data_ptr = (_TelexNumber *)_data;
    if (_data_ptr->telexNumber.value)
	_oss_dec_free(_g, _data_ptr->telexNumber.value);
    if (_data_ptr->countryCode.value)
	_oss_dec_free(_g, _data_ptr->countryCode.value);
    if (_data_ptr->answerback.value)
	_oss_dec_free(_g, _data_ptr->answerback.value);
    _oss_dec_free(_g, _data_ptr);
}

static void _fX121Address(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _fInternationalISDNNumber(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _fDestinationIndicator(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _fCommunicationsService(OssGlobal * _g, void * _data)
{
    OSSC::COssEncOID	*_data_ptr;
    _data_ptr = (OSSC::COssEncOID *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _fCommunicationsNetwork(OssGlobal * _g, void * _data)
{
    OSSC::COssEncOID	*_data_ptr;
    _data_ptr = (OSSC::COssEncOID *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _fPreferredDeliveryMethod(OssGlobal * _g, void * _data)
{
    _Presentation_context_deletion_list	**_data_ptr;
    _data_ptr = (_Presentation_context_deletion_list **)_data;
    if (*_data_ptr) {
	_Presentation_context_deletion_list * _tempa = *_data_ptr;
	_Presentation_context_deletion_list * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fPresentationAddress(OssGlobal * _g, void * _data)
{
    _PresentationAddress	*_data_ptr;
    _data_ptr = (_PresentationAddress *)_data;
    if (_data_ptr->bit_mask & 0x80000000) {
	if (_data_ptr->pSelector.value)
	    _oss_dec_free(_g, _data_ptr->pSelector.value);
    }
    if (_data_ptr->bit_mask & 0x40000000) {
	if (_data_ptr->sSelector.value)
	    _oss_dec_free(_g, _data_ptr->sSelector.value);
    }
    if (_data_ptr->bit_mask & 0x20000000) {
	if (_data_ptr->tSelector.value)
	    _oss_dec_free(_g, _data_ptr->tSelector.value);
    }
    if (_data_ptr->nAddresses) {
	_setof3 * _tempa = _data_ptr->nAddresses;
	_setof3 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    if (_tempa->value.value)
		_oss_dec_free(_g, _tempa->value.value);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fProtocolInformation(OssGlobal * _g, void * _data)
{
    _ProtocolInformation	*_data_ptr;
    _data_ptr = (_ProtocolInformation *)_data;
    if (_data_ptr->nAddress.value)
	_oss_dec_free(_g, _data_ptr->nAddress.value);
    if (_data_ptr->profiles) {
	_Application_context_name_list * _tempa = _data_ptr->profiles;
	_Application_context_name_list * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    if (_tempa->value.value)
		_oss_dec_free(_g, _tempa->value.value);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fNameAndOptionalUID(OssGlobal * _g, void * _data)
{
    _NameAndOptionalUID	*_data_ptr;
    _data_ptr = (_NameAndOptionalUID *)_data;
    _f_RDNSequence(_g, &_data_ptr->dn);
    if (_data_ptr->bit_mask & 0x80000000) {
	if (_data_ptr->uid.value)
	    _oss_dec_free(_g, _data_ptr->uid.value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fMultipleMatchingLocalities(OssGlobal * _g, void * _data)
{
    _MultipleMatchingLocalities	*_data_ptr;
    _data_ptr = (_MultipleMatchingLocalities *)_data;
    if (_data_ptr->bit_mask & 0x80000000) {
	if (_data_ptr->matchingRuleUsed.value)
	    _oss_dec_free(_g, _data_ptr->matchingRuleUsed.value);
    }
    if (_data_ptr->attributeList) {
	_seqof2 * _tempa = _data_ptr->attributeList;
	_seqof2 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    if (_tempa->value.type.value)
		_oss_dec_free(_g, _tempa->value.type.value);
	    if (_tempa->value.assertion.encoded.value)
		_oss_dec_free(_g, _tempa->value.assertion.encoded.value);
	    if (_tempa->value.assertion.pduNum != 0 && *(void **)&_tempa->value.assertion.decoded)
		_fmUpperBounds_(_g, _tempa->value.assertion.pduNum, *(void **)&_tempa->value.assertion.decoded);
	    if (_tempa->value.bit_mask & 0x80000000) {
		switch (_tempa->value.assertedContexts.choice) {
		case 2:
		    if (_tempa->value.assertedContexts.u.selectedContexts) {
			_setof6 * _temp1a = _tempa->value.assertedContexts.u.selectedContexts;
			_setof6 * _temp1b;
			while (_temp1a) {
			    _temp1b = _temp1a->next;
			    _f_ContextAssertion(_g, &_temp1a->value);
			    _oss_dec_free(_g, _temp1a);
			    _temp1a = _temp1b;
			}
		    }
		    break;
		default:
		    /* Ignore for now */	;
		}
	    }
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fSubstringAssertion(OssGlobal * _g, void * _data)
{
    _SubstringAssertion	**_data_ptr;
    _data_ptr = (_SubstringAssertion **)_data;
    if (*_data_ptr) {
	_SubstringAssertion * _tempa = *_data_ptr;
	_SubstringAssertion * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    switch (_tempa->value.choice) {
	    case 1:
		if (_tempa->value.u.control->type.value)
		    _oss_dec_free(_g, _tempa->value.u.control->type.value);
		if (_tempa->value.u.control->values) {
		    _setof13 * _temp1a = _tempa->value.u.control->values;
		    _setof13 * _temp1b;
		    while (_temp1a) {
			_temp1b = _temp1a->next;
			if (_temp1a->value.encoded.value)
			    _oss_dec_free(_g, _temp1a->value.encoded.value);
			if (_temp1a->value.pduNum != 0 && *(void **)&_temp1a->value.decoded)
			    _fmUpperBounds_(_g, _temp1a->value.pduNum, *(void **)&_temp1a->value.decoded);
			_oss_dec_free(_g, _temp1a);
			_temp1a = _temp1b;
		    }
		}
		if (_tempa->value.u.control->bit_mask & 0x80000000) {
		    if (_tempa->value.u.control->valuesWithContext) {
			_setof14 * _temp1a = _tempa->value.u.control->valuesWithContext;
			_setof14 * _temp1b;
			while (_temp1a) {
			    _temp1b = _temp1a->next;
			    if (_temp1a->value.value.encoded.value)
				_oss_dec_free(_g, _temp1a->value.value.encoded.value);
			    if (_temp1a->value.value.pduNum != 0 && *(void **)&_temp1a->value.value.decoded)
				_fmUpperBounds_(_g, _temp1a->value.value.pduNum, *(void **)&_temp1a->value.value.decoded);
			    if (_temp1a->value.contextList) {
				_setof15 * _temp2a = _temp1a->value.contextList;
				_setof15 * _temp2b;
				while (_temp2a) {
				    _temp2b = _temp2a->next;
				    _f_Context(_g, &_temp2a->value);
				    _oss_dec_free(_g, _temp2a);
				    _temp2a = _temp2b;
				}
			    }
			    _oss_dec_free(_g, _temp1a);
			    _temp1a = _temp1b;
			}
		    }
		}
		_oss_dec_free(_g, _tempa->value.u.control);
		break;
	    case 2:
		_f_UnboundedDirectoryString(_g, _tempa->value.u.initial);
		_oss_dec_free(_g, _tempa->value.u.initial);
		break;
	    case 3:
		_f_UnboundedDirectoryString(_g, _tempa->value.u.any);
		_oss_dec_free(_g, _tempa->value.u.any);
		break;
	    case 4:
		_f_UnboundedDirectoryString(_g, _tempa->value.u.final);
		_oss_dec_free(_g, _tempa->value.u.final);
		break;
	    default:
		/* Ignore for now */	;
	    }
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fCaseIgnoreList(OssGlobal * _g, void * _data)
{
    _PostalAddress	**_data_ptr;
    _data_ptr = (_PostalAddress **)_data;
    if (*_data_ptr) {
	_PostalAddress * _tempa = *_data_ptr;
	_PostalAddress * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _f_UnboundedDirectoryString(_g, &_tempa->value);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fOctetSubstringAssertion(OssGlobal * _g, void * _data)
{
    _OctetSubstringAssertion	**_data_ptr;
    _data_ptr = (_OctetSubstringAssertion **)_data;
    if (*_data_ptr) {
	_OctetSubstringAssertion * _tempa = *_data_ptr;
	_OctetSubstringAssertion * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    switch (_tempa->value.choice) {
	    case 1:
		if (_tempa->value.u.initial.value)
		    _oss_dec_free(_g, _tempa->value.u.initial.value);
		break;
	    case 2:
		if (_tempa->value.u.any.value)
		    _oss_dec_free(_g, _tempa->value.u.any.value);
		break;
	    case 3:
		if (_tempa->value.u.final.value)
		    _oss_dec_free(_g, _tempa->value.u.final.value);
		break;
	    default:
		/* Ignore for now */	;
	    }
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fSequenceMatchType(OssGlobal * _g, void * _data)
{
    enum SequenceMatchType	*_data_ptr;
    _data_ptr = (enum SequenceMatchType *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fWordMatchTypes(OssGlobal * _g, void * _data)
{
    enum WordMatchTypes	*_data_ptr;
    _data_ptr = (enum WordMatchTypes *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fCharacterMatchTypes(OssGlobal * _g, void * _data)
{
    enum CharacterMatchTypes	*_data_ptr;
    _data_ptr = (enum CharacterMatchTypes *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fLanguageContextSyntax(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _fTimeSpecification(OssGlobal * _g, void * _data)
{
    _TimeSpecification	*_data_ptr;
    _data_ptr = (_TimeSpecification *)_data;
    switch (_data_ptr->time.choice) {
    case 1:
	if (_data_ptr->time.u.absolute->startTime) {
	    _oss_dec_free(_g, _data_ptr->time.u.absolute->startTime);
	}
	if (_data_ptr->time.u.absolute->endTime) {
	    _oss_dec_free(_g, _data_ptr->time.u.absolute->endTime);
	}
	_oss_dec_free(_g, _data_ptr->time.u.absolute);
	break;
    case 2:
	if (_data_ptr->time.u.periodic) {
	    _setof10 * _tempa = _data_ptr->time.u.periodic;
	    _setof10 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		if (_tempa->value.bit_mask & 0x80000000) {
		    if (_tempa->value.timesOfDay) {
			_setof8 * _temp1a = _tempa->value.timesOfDay;
			_setof8 * _temp1b;
			while (_temp1a) {
			    _temp1b = _temp1a->next;
			    _oss_dec_free(_g, _temp1a);
			    _temp1a = _temp1b;
			}
		    }
		}
		if (_tempa->value.bit_mask & 0x40000000) {
		    switch (_tempa->value.days.choice) {
		    case 1:
			if (_tempa->value.days.u.bitDay.value)
			    _oss_dec_free(_g, _tempa->value.days.u.bitDay.value);
			break;
		    case 2:
			_f__setof7(_g, &_tempa->value.days.u.intDay);
			break;
		    case 3:
			switch (_tempa->value.days.u.dayOf->choice) {
			case 1:
			    _f_NamedDay(_g, _tempa->value.days.u.dayOf->u.first);
			    _oss_dec_free(_g, _tempa->value.days.u.dayOf->u.first);
			    break;
			case 2:
			    _f_NamedDay(_g, _tempa->value.days.u.dayOf->u.second);
			    _oss_dec_free(_g, _tempa->value.days.u.dayOf->u.second);
			    break;
			case 3:
			    _f_NamedDay(_g, _tempa->value.days.u.dayOf->u.third);
			    _oss_dec_free(_g, _tempa->value.days.u.dayOf->u.third);
			    break;
			case 4:
			    _f_NamedDay(_g, _tempa->value.days.u.dayOf->u.fourth);
			    _oss_dec_free(_g, _tempa->value.days.u.dayOf->u.fourth);
			    break;
			case 5:
			    _f_NamedDay(_g, _tempa->value.days.u.dayOf->u.fifth);
			    _oss_dec_free(_g, _tempa->value.days.u.dayOf->u.fifth);
			    break;
			default:
			    /* Ignore for now */	;
			}
			_oss_dec_free(_g, _tempa->value.days.u.dayOf);
			break;
		    default:
			/* Ignore for now */	;
		    }
		}
		if (_tempa->value.bit_mask & 0x20000000) {
		    switch (_tempa->value.weeks.choice) {
		    case 1:
			if (_tempa->value.weeks.u.bitWeek.value)
			    _oss_dec_free(_g, _tempa->value.weeks.u.bitWeek.value);
			break;
		    case 3:
			_f__setof7(_g, &_tempa->value.weeks.u.intWeek);
			break;
		    default:
			/* Ignore for now */	;
		    }
		}
		if (_tempa->value.bit_mask & 0x10000000) {
		    switch (_tempa->value.months.choice) {
		    case 1:
			if (_tempa->value.months.u.bitMonth.value)
			    _oss_dec_free(_g, _tempa->value.months.u.bitMonth.value);
			break;
		    case 3:
			_f__setof7(_g, &_tempa->value.months.u.intMonth);
			break;
		    default:
			/* Ignore for now */	;
		    }
		}
		if (_tempa->value.bit_mask & 0x8000000) {
		    if (_tempa->value.years) {
			_setof9 * _temp1a = _tempa->value.years;
			_setof9 * _temp1b;
			while (_temp1a) {
			    _temp1b = _temp1a->next;
			    _oss_dec_free(_g, _temp1a);
			    _temp1a = _temp1b;
			}
		    }
		}
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
	break;
    default:
	/* Ignore for now */	;
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fTimeAssertion(OssGlobal * _g, void * _data)
{
    _TimeAssertion	*_data_ptr;
    _data_ptr = (_TimeAssertion *)_data;
    switch (_data_ptr->choice) {
    case 2:
	_oss_dec_free(_g, _data_ptr->u.between->startTime);
	if (_data_ptr->u.between->endTime) {
	    _oss_dec_free(_g, _data_ptr->u.between->endTime);
	}
	_oss_dec_free(_g, _data_ptr->u.between);
	break;
    case 3:
	_oss_dec_free(_g, _data_ptr->u.at);
	break;
    default:
	/* Ignore for now */	;
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fLocaleContextSyntax(OssGlobal * _g, void * _data)
{
    _LocaleContextSyntax	*_data_ptr;
    _data_ptr = (_LocaleContextSyntax *)_data;
    switch (_data_ptr->choice) {
    case 1:
	if (_data_ptr->u.localeID1.value)
	    _oss_dec_free(_g, _data_ptr->u.localeID1.value);
	break;
    case 2:
	_f_UnboundedDirectoryString(_g, _data_ptr->u.localeID2);
	_oss_dec_free(_g, _data_ptr->u.localeID2);
	break;
    default:
	/* Ignore for now */	;
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fAttributeOptionList(OssGlobal * _g, void * _data)
{
    _setof3	**_data_ptr;
    _data_ptr = (_setof3 **)_data;
    if (*_data_ptr) {
	_setof3 * _tempa = *_data_ptr;
	_setof3 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    if (_tempa->value.value)
		_oss_dec_free(_g, _tempa->value.value);
	    _oss_dec_free(_g, _tempa);
	    _tempa = _tempb;
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fID(OssGlobal * _g, void * _data)
{
    OSSC::COssEncOID	*_data_ptr;
    _data_ptr = (OSSC::COssEncOID *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _fAttributeValue(OssGlobal * _g, void * _data)
{
    OSSC::COssOpen	*_data_ptr;
    _data_ptr = (OSSC::COssOpen *)_data;
    if (_data_ptr->encoded)
	_oss_dec_free(_g, _data_ptr->encoded);
    if (_data_ptr->pduNum && _data_ptr->decoded)
	_fmUpperBounds_(_g, _data_ptr->pduNum, _data_ptr->decoded);
    _oss_dec_free(_g, _data_ptr);
}

static void _fContextAssertion(OssGlobal * _g, void * _data)
{
    _ContextAssertion	*_data_ptr;
    _data_ptr = (_ContextAssertion *)_data;
    _f_ContextAssertion(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fAttributeTypeAssertion(OssGlobal * _g, void * _data)
{
    _AttributeTypeAssertion	*_data_ptr;
    _data_ptr = (_AttributeTypeAssertion *)_data;
    if (_data_ptr->type.value)
	_oss_dec_free(_g, _data_ptr->type.value);
    if (_data_ptr->bit_mask & 0x80000000) {
	if (_data_ptr->assertedContexts) {
	    _setof6 * _tempa = _data_ptr->assertedContexts;
	    _setof6 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f_ContextAssertion(_g, &_tempa->value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fDistinguishedName(OssGlobal * _g, void * _data)
{
    _RDNSequence	**_data_ptr;
    _data_ptr = (_RDNSequence **)_data;
    _f_RDNSequence(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fSubtreeSpecification(OssGlobal * _g, void * _data)
{
    _SubtreeSpecification	*_data_ptr;
    _data_ptr = (_SubtreeSpecification *)_data;
    if (_data_ptr->bit_mask & 0x80000000) {
	_f_RDNSequence(_g, &_data_ptr->base);
    }
    if (_data_ptr->bit_mask & 0x40000000) {
	if (_data_ptr->specificExclusions) {
	    _setof19 * _tempa = _data_ptr->specificExclusions;
	    _setof19 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		switch (_tempa->value.choice) {
		case 1:
		    _f_RDNSequence(_g, &_tempa->value.u.chopBefore);
		    break;
		case 2:
		    _f_RDNSequence(_g, &_tempa->value.u.chopAfter);
		    break;
		default:
		    /* Ignore for now */	;
		}
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    if (_data_ptr->bit_mask & 0x8000000) {
	_f_Refinement(_g, &_data_ptr->specificationFilter);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fDITStructureRule(OssGlobal * _g, void * _data)
{
    _DITStructureRule	*_data_ptr;
    _data_ptr = (_DITStructureRule *)_data;
    if (_data_ptr->nameForm.value)
	_oss_dec_free(_g, _data_ptr->nameForm.value);
    if (_data_ptr->bit_mask & 0x80000000) {
	if (_data_ptr->superiorStructureRules) {
	    _Presentation_context_deletion_list * _tempa = _data_ptr->superiorStructureRules;
	    _Presentation_context_deletion_list * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fDITContentRule(OssGlobal * _g, void * _data)
{
    _DITContentRule	*_data_ptr;
    _data_ptr = (_DITContentRule *)_data;
    if (_data_ptr->structuralObjectClass.value)
	_oss_dec_free(_g, _data_ptr->structuralObjectClass.value);
    if (_data_ptr->bit_mask & 0x80000000) {
	if (_data_ptr->auxiliaries) {
	    _Application_context_name_list * _tempa = _data_ptr->auxiliaries;
	    _Application_context_name_list * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		if (_tempa->value.value)
		    _oss_dec_free(_g, _tempa->value.value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    if (_data_ptr->bit_mask & 0x40000000) {
	if (_data_ptr->mandatory) {
	    _Application_context_name_list * _tempa = _data_ptr->mandatory;
	    _Application_context_name_list * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		if (_tempa->value.value)
		    _oss_dec_free(_g, _tempa->value.value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    if (_data_ptr->bit_mask & 0x20000000) {
	if (_data_ptr->optional) {
	    _Application_context_name_list * _tempa = _data_ptr->optional;
	    _Application_context_name_list * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		if (_tempa->value.value)
		    _oss_dec_free(_g, _tempa->value.value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    if (_data_ptr->bit_mask & 0x10000000) {
	if (_data_ptr->precluded) {
	    _Application_context_name_list * _tempa = _data_ptr->precluded;
	    _Application_context_name_list * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		if (_tempa->value.value)
		    _oss_dec_free(_g, _tempa->value.value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fDITContextUse(OssGlobal * _g, void * _data)
{
    _DITContextUse	*_data_ptr;
    _data_ptr = (_DITContextUse *)_data;
    if (_data_ptr->attributeType.value)
	_oss_dec_free(_g, _data_ptr->attributeType.value);
    if (_data_ptr->bit_mask & 0x80000000) {
	if (_data_ptr->mandatoryContexts) {
	    _Application_context_name_list * _tempa = _data_ptr->mandatoryContexts;
	    _Application_context_name_list * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		if (_tempa->value.value)
		    _oss_dec_free(_g, _tempa->value.value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    if (_data_ptr->bit_mask & 0x40000000) {
	if (_data_ptr->optionalContexts) {
	    _Application_context_name_list * _tempa = _data_ptr->optionalContexts;
	    _Application_context_name_list * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		if (_tempa->value.value)
		    _oss_dec_free(_g, _tempa->value.value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fHierarchyLevel(OssGlobal * _g, void * _data)
{
    OSS_INT32	*_data_ptr;
    _data_ptr = (OSS_INT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fHierarchyBelow(OssGlobal * _g, void * _data)
{
    ossBoolean	*_data_ptr;
    _data_ptr = (ossBoolean *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fAcse_RealizationParameter(OssGlobal * _g, void * _data)
{
    _RealizationParameter	*_data_ptr;
    _data_ptr = (_RealizationParameter *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _f2Acse_with_concatenation_Rea(OssGlobal * _g, void * _data)
{
    _RealizationParameter	*_data_ptr;
    _data_ptr = (_RealizationParameter *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _f3Association_by_RTSE_Realiza(OssGlobal * _g, void * _data)
{
    _RealizationParameter	*_data_ptr;
    _data_ptr = (_RealizationParameter *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fPData_RealizationParameter(OssGlobal * _g, void * _data)
{
    _RealizationParameter	*_data_ptr;
    _data_ptr = (_RealizationParameter *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _f4PData_with_concatenation_Re(OssGlobal * _g, void * _data)
{
    _RealizationParameter	*_data_ptr;
    _data_ptr = (_RealizationParameter *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _f5Transfer_by_RTSE_Realizatio(OssGlobal * _g, void * _data)
{
    _RealizationParameter	*_data_ptr;
    _data_ptr = (_RealizationParameter *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fBitStringMatch_SYNTAX(OssGlobal * _g, void * _data)
{
    OSSC::COssBitString	*_data_ptr;
    _data_ptr = (OSSC::COssBitString *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _fDnQualifier_WITH_SYNTAX(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _fSerialNumber_WITH_SYNTAX(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _fNumericStringMatch_SYNTAX(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _f6ProtocolInformationMatch_SY(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _fUiiInUrn_WITH_SYNTAX(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _f7NumericStringOrderingMatch_(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _fBooleanMatch_SYNTAX(OssGlobal * _g, void * _data)
{
    ossBoolean	*_data_ptr;
    _data_ptr = (ossBoolean *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fIntegerMatch_SYNTAX(OssGlobal * _g, void * _data)
{
    OSS_INT32	*_data_ptr;
    _data_ptr = (OSS_INT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fIntegerOrderingMatch_SYNTAX(OssGlobal * _g, void * _data)
{
    OSS_INT32	*_data_ptr;
    _data_ptr = (OSS_INT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fOctetStringMatch_SYNTAX(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _f8OctetStringOrderingMatch_SY(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _fUTCTimeMatch_SYNTAX(OssGlobal * _g, void * _data)
{
    char *	_data_ptr;
    char *	*_data_ptr_ptr;
    _data_ptr_ptr = (char * *)_data;
    _data_ptr = *_data_ptr_ptr;
    _oss_dec_free(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr_ptr);
}

static void _fUTCTimeOrderingMatch_SYNTAX(OssGlobal * _g, void * _data)
{
    char *	_data_ptr;
    char *	*_data_ptr_ptr;
    _data_ptr_ptr = (char * *)_data;
    _data_ptr = *_data_ptr_ptr;
    _oss_dec_free(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr_ptr);
}

static void _fGeneralizedTimeMatch_SYNTAX(OssGlobal * _g, void * _data)
{
    char *	_data_ptr;
    char *	*_data_ptr_ptr;
    _data_ptr_ptr = (char * *)_data;
    _data_ptr = *_data_ptr_ptr;
    _oss_dec_free(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr_ptr);
}

static void _f9GeneralizedTimeOrderingMatc(OssGlobal * _g, void * _data)
{
    char *	_data_ptr;
    char *	*_data_ptr_ptr;
    _data_ptr_ptr = (char * *)_data;
    _data_ptr = *_data_ptr_ptr;
    _oss_dec_free(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr_ptr);
}

static void _f10IntegerFirstComponentMatch(OssGlobal * _g, void * _data)
{
    OSS_INT32	*_data_ptr;
    _data_ptr = (OSS_INT32 *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _f11AdministrativeRole_WITH_SY(OssGlobal * _g, void * _data)
{
    OSSC::COssEncOID	*_data_ptr;
    _data_ptr = (OSSC::COssEncOID *)_data;
    if (_data_ptr->value)
	_oss_dec_free(_g, _data_ptr->value);
    _oss_dec_free(_g, _data_ptr);
}

static void _fCreateTimestamp_WITH_SYNTAX(OssGlobal * _g, void * _data)
{
    char *	_data_ptr;
    char *	*_data_ptr_ptr;
    _data_ptr_ptr = (char * *)_data;
    _data_ptr = *_data_ptr_ptr;
    _oss_dec_free(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr_ptr);
}

static void _fModifyTimestamp_WITH_SYNTAX(OssGlobal * _g, void * _data)
{
    char *	_data_ptr;
    char *	*_data_ptr_ptr;
    _data_ptr_ptr = (char * *)_data;
    _data_ptr = *_data_ptr_ptr;
    _oss_dec_free(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr_ptr);
}

static void _f12SubschemaTimestamp_WITH_SY(OssGlobal * _g, void * _data)
{
    char *	_data_ptr;
    char *	*_data_ptr_ptr;
    _data_ptr_ptr = (char * *)_data;
    _data_ptr = *_data_ptr_ptr;
    _oss_dec_free(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr_ptr);
}

static void _fHasSubordinates_WITH_SYNTAX(OssGlobal * _g, void * _data)
{
    ossBoolean	*_data_ptr;
    _data_ptr = (ossBoolean *)_data;
    _oss_dec_free(_g, _data_ptr);
}

int DLL_ENTRY_FDEF _fmUpperBounds_(struct ossGlobal * _g, int _pdunum, void * _data)
{
    if (_pdunum < 1 || _pdunum > 85)
	return PDU_RANGE;
    else
	_FreePDU[_pdunum - 1](_g, _data);

    return PDU_FREED;
}

#endif
#ifdef OSSPRINT
static void _p_UnboundedDirectoryString(OssGlobal * _g, _UnboundedDirectoryString * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "uTF8String : ");
	_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.uTF8String.value, _data_ptr->u.uTF8String.length, 1);
	break;
    case 2:
	ossPrint(_g, "printableString : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.printableString.value, _data_ptr->u.printableString.length);
	break;
    case 3:
	ossPrint(_g, "teletexString : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.teletexString.value, _data_ptr->u.teletexString.length);
	break;
    case 4:
	ossPrint(_g, "universalString : ");
	_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.universalString.value, _data_ptr->u.universalString.length, 4);
	break;
    case 5:
	ossPrint(_g, "bmpString : ");
	_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->u.bmpString.value, _data_ptr->u.bmpString.length, 2);
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p_ContextAssertion(OssGlobal * _g, _ContextAssertion * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "contextType ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = nullptr;
	    _e.length = (unsigned short)_data_ptr->contextType.length;
	    _e.value = _data_ptr->contextType.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "contextValues ");
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->contextValues) {
	    _setof11 * _tempa = _data_ptr->contextValues;
	    _setof11 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_oss_indent(_g, 0);
		_oss_prt_new_opentype(_g, _tempa->value.pduNum, *(void **)&_tempa->value.decoded, &_tempa->value.encoded);
		_tempa = _tempb;
		if (_tempa)
		    ossPrint(_g, ",");
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p__choice1(OssGlobal * _g, _choice1 * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "single-ASN1-type : ");
	_oss_prt_opentype(_g, (OpenType *)&_data_ptr->u.single_ASN1_type);
	break;
    case 2:
	ossPrint(_g, "octet-aligned : ");
	_oss_prt_oct(_g, _data_ptr->u.octet_aligned.value, _data_ptr->u.octet_aligned.length);
	break;
    case 3:
	ossPrint(_g, "arbitrary : ");
	_oss_prt_bit(_g, _data_ptr->u.arbitrary.value, _data_ptr->u.arbitrary.length);
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p_External(OssGlobal * _g, _External * _data_ptr)
{
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "direct-reference ");
	    {
		OssBuf _val;
		OssEncodedOID _e;
		_val.length = 0;
		_val.value = nullptr;
		_e.length = (unsigned short)_data_ptr->direct_reference.length;
		_e.value = _data_ptr->direct_reference.value;
		ossEncodedOidToAsnVal(_g, &_e, &_val);
		if (_val.length) {
		    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		    _oss_dec_free(_g, _val.value);
		} else
		    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	    }
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "indirect-reference ");
	    {
		LONG_LONG value = _data_ptr->indirect_reference;

		ossPrint(_g, LLONG_FMT, value);
	    }
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "data-value-descriptor ");
	    _oss_prt_char(_g, (char *)_data_ptr->data_value_descriptor.value, _data_ptr->data_value_descriptor.length);
	    _comma = 1;
	}
	if (_comma) ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "encoding ");
	_p__choice1(_g, &_data_ptr->encoding);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_Name(OssGlobal * _g, _Name * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "rdnSequence : ");
	_p_RDNSequence(_g, &_data_ptr->u.rdnSequence);
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p_AP_title(OssGlobal * _g, _AP_title * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "ap-title-form2 : ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = nullptr;
	    _e.length = (unsigned short)_data_ptr->u.ap_title_form2.length;
	    _e.value = _data_ptr->u.ap_title_form2.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	break;
    case 2:
	ossPrint(_g, "ap-title-form1 : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.ap_title_form1 == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    _p_Name(_g, _data_ptr->u.ap_title_form1);
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p_AE_qualifier(OssGlobal * _g, _AE_qualifier * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "ae-qualifier-form2 : ");
	{
	    LONG_LONG value = _data_ptr->u.ae_qualifier_form2;

	    ossPrint(_g, LLONG_FMT, value);
	}
	break;
    case 2:
	ossPrint(_g, "ae-qualifier-form1 : ");
	_p_RelativeDistinguishedName(_g, &_data_ptr->u.ae_qualifier_form1);
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p_RealizationParameter(OssGlobal * _g, _RealizationParameter * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "realization-type ");
	{
	    ULONG_LONG value = _data_ptr->realization_type;
	    _oss_prt_enum(_g, value, _ssd[0].sa, (int)_ssd[0].alen);
	}
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "concatenation ");
	    ossPrint(_g, _data_ptr->concatenation ? "TRUE" : "FALSE");
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p__seq1(OssGlobal * _g, _seq1 * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "other-mechanism-name ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = nullptr;
	    _e.length = (unsigned short)_data_ptr->other_mechanism_name.length;
	    _e.value = _data_ptr->other_mechanism_name.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "other-mechanism-value ");
	_oss_prt_new_opentype(_g, _data_ptr->other_mechanism_value.pduNum, *(void **)&_data_ptr->other_mechanism_value.decoded, &_data_ptr->other_mechanism_value.encoded);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_Authentication_value(OssGlobal * _g, _Authentication_value * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "charstring : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.charstring.value, _data_ptr->u.charstring.length);
	break;
    case 2:
	ossPrint(_g, "bitstring : ");
	_oss_prt_bit(_g, _data_ptr->u.bitstring.value, _data_ptr->u.bitstring.length);
	break;
    case 3:
	ossPrint(_g, "external : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.external == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    _p_External(_g, _data_ptr->u.external);
	break;
    case 4:
	ossPrint(_g, "other : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.other == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    _p__seq1(_g, _data_ptr->u.other);
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p_13Application_context_name_l(OssGlobal * _g, _Application_context_name_list ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_Application_context_name_list * _tempa = *_data_ptr;
	_Application_context_name_list * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_indent(_g, 0);
	    {
		OssBuf _val;
		OssEncodedOID _e;
		_val.length = 0;
		_val.value = nullptr;
		_e.length = (unsigned short)_tempa->value.length;
		_e.value = _tempa->value.value;
		ossEncodedOidToAsnVal(_g, &_e, &_val);
		if (_val.length) {
		    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		    _oss_dec_free(_g, _val.value);
		} else
		    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	    }
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p_Association_information(OssGlobal * _g, _Association_information ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_Association_information * _tempa = *_data_ptr;
	_Association_information * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _p_External(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p_Mode_selector(OssGlobal * _g, _Mode_selector * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "mode-value ");
	{
	    LONG_LONG value = _data_ptr->mode_value;

	    ossPrint(_g, LLONG_FMT, value);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_ConnectionData(OssGlobal * _g, _ConnectionData * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "open : ");
	_oss_prt_opentype(_g, (OpenType *)&_data_ptr->u.open);
	break;
    case 2:
	ossPrint(_g, "recover : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.recover == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    _p_SessionConnectionIdentifier(_g, _data_ptr->u.recover);
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p_User_data(OssGlobal * _g, _User_data * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "simply-encoded-data : ");
	_oss_prt_oct(_g, _data_ptr->u.simply_encoded_data.value, _data_ptr->u.simply_encoded_data.length);
	break;
    case 2:
	ossPrint(_g, "fully-encoded-data : ");
	_p_Fully_encoded_data(_g, &_data_ptr->u.fully_encoded_data);
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p__seq7(OssGlobal * _g, _seq7 * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "presentation-context-identifier ");
	{
	    LONG_LONG value = _data_ptr->presentation_context_identifier;

	    ossPrint(_g, LLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "abstract-syntax-name ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = nullptr;
	    _e.length = (unsigned short)_data_ptr->abstract_syntax_name.length;
	    _e.value = _data_ptr->abstract_syntax_name.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "transfer-syntax-name-list ");
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->transfer_syntax_name_list) {
	    _Application_context_name_list * _tempa = _data_ptr->transfer_syntax_name_list;
	    _Application_context_name_list * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_oss_indent(_g, 0);
		{
		    OssBuf _val;
		    OssEncodedOID _e;
		    _val.length = 0;
		    _val.value = nullptr;
		    _e.length = (unsigned short)_tempa->value.length;
		    _e.value = _tempa->value.value;
		    ossEncodedOidToAsnVal(_g, &_e, &_val);
		    if (_val.length) {
			ossPrint(_g, "%.*s", (int)_val.length, _val.value);
			_oss_dec_free(_g, _val.value);
		    } else
			_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
		}
		_tempa = _tempb;
		if (_tempa)
		    ossPrint(_g, ",");
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_Context_list(OssGlobal * _g, _Context_list ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_Context_list * _tempa = *_data_ptr;
	_Context_list * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _p__seq7(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p__seq8(OssGlobal * _g, _seq8 * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "presentation-context-identifier ");
	{
	    LONG_LONG value = _data_ptr->presentation_context_identifier;

	    ossPrint(_g, LLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "transfer-syntax-name ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = nullptr;
	    _e.length = (unsigned short)_data_ptr->transfer_syntax_name.length;
	    _e.value = _data_ptr->transfer_syntax_name.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_14Presentation_context_ident(OssGlobal * _g, _Presentation_context_identifier_list ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_Presentation_context_identifier_list * _tempa = *_data_ptr;
	_Presentation_context_identifier_list * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _p__seq8(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p__seq9(OssGlobal * _g, _seq9 * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "result ");
	{
	    LONG_LONG value = _data_ptr->result;

	    ossPrint(_g, LLONG_FMT, value);
	}
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "transfer-syntax-name ");
	    {
		OssBuf _val;
		OssEncodedOID _e;
		_val.length = 0;
		_val.value = nullptr;
		_e.length = (unsigned short)_data_ptr->transfer_syntax_name.length;
		_e.value = _data_ptr->transfer_syntax_name.value;
		ossEncodedOidToAsnVal(_g, &_e, &_val);
		if (_val.length) {
		    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		    _oss_dec_free(_g, _val.value);
		} else
		    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	    }
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "provider-reason ");
	    {
		LONG_LONG value = _data_ptr->provider_reason;

		ossPrint(_g, LLONG_FMT, value);
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_Result_list(OssGlobal * _g, _Result_list ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_Result_list * _tempa = *_data_ptr;
	_Result_list * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _p__seq9(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p_PDV_list(OssGlobal * _g, _PDV_list * _data_ptr)
{
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "transfer-syntax-name ");
	    {
		OssBuf _val;
		OssEncodedOID _e;
		_val.length = 0;
		_val.value = nullptr;
		_e.length = (unsigned short)_data_ptr->transfer_syntax_name.length;
		_e.value = _data_ptr->transfer_syntax_name.value;
		ossEncodedOidToAsnVal(_g, &_e, &_val);
		if (_val.length) {
		    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		    _oss_dec_free(_g, _val.value);
		} else
		    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	    }
	    _comma = 1;
	}
	if (_comma) ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "presentation-context-identifier ");
	{
	    LONG_LONG value = _data_ptr->presentation_context_identifier;

	    ossPrint(_g, LLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "presentation-data-values ");
	switch (_data_ptr->presentation_data_values.choice) {
	case 1:
	    ossPrint(_g, "single-ASN1-type : ");
	    _oss_prt_opentype(_g, (OpenType *)&_data_ptr->presentation_data_values.u.single_ASN1_type);
	    break;
	case 2:
	    ossPrint(_g, "octet-aligned : ");
	    _oss_prt_oct(_g, _data_ptr->presentation_data_values.u.octet_aligned.value, _data_ptr->presentation_data_values.u.octet_aligned.length);
	    break;
	case 3:
	    ossPrint(_g, "arbitrary : ");
	    _oss_prt_bit(_g, _data_ptr->presentation_data_values.u.arbitrary.value, _data_ptr->presentation_data_values.u.arbitrary.length);
	    break;
	default:
	    ossPrint(_g, "<unknown choice>");
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_Fully_encoded_data(OssGlobal * _g, _Fully_encoded_data ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_Fully_encoded_data * _tempa = *_data_ptr;
	_Fully_encoded_data * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _p_PDV_list(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p_RTORQapdu(OssGlobal * _g, _set1 * _data_ptr)
{
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "checkpointSize ");
	    {
		LONG_LONG value = _data_ptr->checkpointSize;

		ossPrint(_g, LLONG_FMT, value);
	    }
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "windowSize ");
	    {
		LONG_LONG value = _data_ptr->windowSize;

		ossPrint(_g, LLONG_FMT, value);
	    }
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "dialogueMode ");
	    {
		LONG_LONG value = _data_ptr->dialogueMode;

		ossPrint(_g, LLONG_FMT, value);
	    }
	    _comma = 1;
	}
	if (_comma) ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "connectionDataRQ ");
	_p_ConnectionData(_g, &_data_ptr->connectionDataRQ);
	if (_data_ptr->bit_mask & 0x10000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "applicationProtocol ");
	    {
		LONG_LONG value = _data_ptr->applicationProtocol;

		ossPrint(_g, LLONG_FMT, value);
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_RTOACapdu(OssGlobal * _g, _set2 * _data_ptr)
{
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "checkpointSize ");
	    {
		LONG_LONG value = _data_ptr->checkpointSize;

		ossPrint(_g, LLONG_FMT, value);
	    }
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "windowSize ");
	    {
		LONG_LONG value = _data_ptr->windowSize;

		ossPrint(_g, LLONG_FMT, value);
	    }
	    _comma = 1;
	}
	if (_comma) ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "connectionDataAC ");
	_p_ConnectionData(_g, &_data_ptr->connectionDataAC);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_RTORJapdu(OssGlobal * _g, _set3 * _data_ptr)
{
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "refuseReason ");
	    {
		LONG_LONG value = _data_ptr->refuseReason;

		ossPrint(_g, LLONG_FMT, value);
	    }
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "userDataRJ ");
	    _oss_prt_opentype(_g, (OpenType *)&_data_ptr->userDataRJ);
	    _comma = 1;
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_CallingSSuserReference(OssGlobal * _g, _CallingSSuserReference * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "octetString : ");
	_oss_prt_oct(_g, _data_ptr->u.octetString.value, _data_ptr->u.octetString.length);
	break;
    case 2:
	ossPrint(_g, "t61String : ");
	_oss_prt_char(_g, (char *)_data_ptr->u.t61String.value, _data_ptr->u.t61String.length);
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p_SessionConnectionIdentifier(OssGlobal * _g, _SessionConnectionIdentifier * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "callingSSuserReference ");
	_p_CallingSSuserReference(_g, &_data_ptr->callingSSuserReference);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "commonReference ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->commonReference == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    _oss_prt_nchar(_g, (char *)_data_ptr->commonReference);
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "additionalReferenceInformation ");
	    _oss_prt_char(_g, (char *)_data_ptr->additionalReferenceInformation.value, _data_ptr->additionalReferenceInformation.length);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_InvokeId(OssGlobal * _g, _InvokeId * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "present : ");
	{
	    LONG_LONG value = _data_ptr->u.present;

	    ossPrint(_g, LLONG_FMT, value);
	}
	break;
    case 2:
	ossPrint(_g, "absent : ");
	ossPrint(_g, "nullptr");
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p_Criteria(OssGlobal * _g, _Criteria * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "type : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.type == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    _p_CriteriaItem(_g, _data_ptr->u.type);
	break;
    case 2:
	ossPrint(_g, "and : ");
	_p__setof1(_g, &_data_ptr->u.Criteria_and);
	break;
    case 3:
	ossPrint(_g, "or : ");
	_p__setof2(_g, &_data_ptr->u.Criteria_or);
	break;
    case 4:
	ossPrint(_g, "not : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.Criteria_not == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    _p_Criteria(_g, _data_ptr->u.Criteria_not);
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p__setof2(OssGlobal * _g, _setof1 ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_setof1 * _tempa = *_data_ptr;
	_setof1 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_indent(_g, 0);
	    _p_Criteria(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p__setof1(OssGlobal * _g, _setof1 ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_setof1 * _tempa = *_data_ptr;
	_setof1 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_indent(_g, 0);
	    _p_Criteria(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p_CriteriaItem(OssGlobal * _g, _CriteriaItem * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "equality : ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = nullptr;
	    _e.length = (unsigned short)_data_ptr->u.equality.length;
	    _e.value = _data_ptr->u.equality.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	break;
    case 2:
	ossPrint(_g, "substrings : ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = nullptr;
	    _e.length = (unsigned short)_data_ptr->u.substrings.length;
	    _e.value = _data_ptr->u.substrings.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	break;
    case 3:
	ossPrint(_g, "greaterOrEqual : ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = nullptr;
	    _e.length = (unsigned short)_data_ptr->u.greaterOrEqual.length;
	    _e.value = _data_ptr->u.greaterOrEqual.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	break;
    case 4:
	ossPrint(_g, "lessOrEqual : ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = nullptr;
	    _e.length = (unsigned short)_data_ptr->u.lessOrEqual.length;
	    _e.value = _data_ptr->u.lessOrEqual.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	break;
    case 5:
	ossPrint(_g, "approximateMatch : ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = nullptr;
	    _e.length = (unsigned short)_data_ptr->u.approximateMatch.length;
	    _e.value = _data_ptr->u.approximateMatch.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p_DayTime(OssGlobal * _g, _DayTime * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "hour ");
	{
	    ULONG_LONG value = _data_ptr->hour;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "minute ");
	    {
		ULONG_LONG value = _data_ptr->minute;
		ossPrint(_g, ULLONG_FMT, value);
	    }
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "second ");
	    {
		ULONG_LONG value = _data_ptr->second;
		ossPrint(_g, ULLONG_FMT, value);
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p__setof7(OssGlobal * _g, _Presentation_context_deletion_list ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_Presentation_context_deletion_list * _tempa = *_data_ptr;
	_Presentation_context_deletion_list * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_indent(_g, 0);
	    {
		LONG_LONG value = _tempa->value;

		ossPrint(_g, LLONG_FMT, value);
	    }
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p_NamedDay(OssGlobal * _g, _NamedDay * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "bitNamedDays : ");
	_oss_prt_bit(_g, _data_ptr->u.bitNamedDays.value, _data_ptr->u.bitNamedDays.length);
	break;
    case 2:
	ossPrint(_g, "intNamedDays : ");
	{
	    ULONG_LONG value = _data_ptr->u.intNamedDays;
	    _oss_prt_enum(_g, value, _ssd[1].sa, (int)_ssd[1].alen);
	}
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p_Context(OssGlobal * _g, _Context * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "contextType ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = nullptr;
	    _e.length = (unsigned short)_data_ptr->contextType.length;
	    _e.value = _data_ptr->contextType.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "contextValues ");
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->contextValues) {
	    _setof11 * _tempa = _data_ptr->contextValues;
	    _setof11 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_oss_indent(_g, 0);
		_oss_prt_new_opentype(_g, _tempa->value.pduNum, *(void **)&_tempa->value.decoded, &_tempa->value.encoded);
		_tempa = _tempb;
		if (_tempa)
		    ossPrint(_g, ",");
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "fallback ");
	    ossPrint(_g, _data_ptr->fallback ? "TRUE" : "FALSE");
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_RDNSequence(OssGlobal * _g, _RDNSequence ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_RDNSequence * _tempa = *_data_ptr;
	_RDNSequence * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _p_RelativeDistinguishedName(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p_15AttributeTypeAndDistinguis(OssGlobal * _g, _AttributeTypeAndDistinguishedValue * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "type ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = nullptr;
	    _e.length = (unsigned short)_data_ptr->type.length;
	    _e.value = _data_ptr->type.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "value ");
	_oss_prt_new_opentype(_g, _data_ptr->value.pduNum, *(void **)&_data_ptr->value.decoded, &_data_ptr->value.encoded);
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "primaryDistinguished ");
	    ossPrint(_g, _data_ptr->primaryDistinguished ? "TRUE" : "FALSE");
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "valuesWithContext ");
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_data_ptr->valuesWithContext) {
		_setof16 * _tempa = _data_ptr->valuesWithContext;
		_setof16 * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    {
			short _comma = 0;

			_oss_indent(_g, 1);
			ossPrint(_g, "{");
			if (_tempa->value.bit_mask & 0x80000000) {
			    _oss_indent(_g, 0);
			    ossPrint(_g, "distingAttrValue ");
			    _oss_prt_new_opentype(_g, _tempa->value.distingAttrValue.pduNum, *(void **)&_tempa->value.distingAttrValue.decoded, &_tempa->value.distingAttrValue.encoded);
			    _comma = 1;
			}
			if (_comma) ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "contextList ");
			_oss_indent(_g, 1);
			ossPrint(_g, "{");
			if (_tempa->value.contextList) {
			    _setof15 * _temp1a = _tempa->value.contextList;
			    _setof15 * _temp1b;
			    while (_temp1a) {
				_temp1b = _temp1a->next;
				_p_Context(_g, &_temp1a->value);
				_temp1a = _temp1b;
				if (_temp1a)
				    ossPrint(_g, ",");
			    }
			}
			_oss_indent(_g, -1);
			ossPrint(_g, "}");
			_oss_indent(_g, -1);
			ossPrint(_g, "}");
		    }
		    _tempa = _tempb;
		    if (_tempa)
			ossPrint(_g, ",");
		}
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_RelativeDistinguishedName(OssGlobal * _g, _RelativeDistinguishedName ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_RelativeDistinguishedName * _tempa = *_data_ptr;
	_RelativeDistinguishedName * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _p_15AttributeTypeAndDistinguis(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p_Refinement(OssGlobal * _g, _Refinement * _data_ptr)
{
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "item : ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = nullptr;
	    _e.length = (unsigned short)_data_ptr->u.item.length;
	    _e.value = _data_ptr->u.item.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	break;
    case 2:
	ossPrint(_g, "and : ");
	_p__setof17(_g, &_data_ptr->u.Refinement_and);
	break;
    case 3:
	ossPrint(_g, "or : ");
	_p__setof18(_g, &_data_ptr->u.Refinement_or);
	break;
    case 4:
	ossPrint(_g, "not : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.Refinement_not == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    _p_Refinement(_g, _data_ptr->u.Refinement_not);
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

}

static void _p__setof18(OssGlobal * _g, _setof17 ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_setof17 * _tempa = *_data_ptr;
	_setof17 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_indent(_g, 0);
	    _p_Refinement(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p__setof17(OssGlobal * _g, _setof17 ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_setof17 * _tempa = *_data_ptr;
	_setof17 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_indent(_g, 0);
	    _p_Refinement(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static int _pOssEncOID(OssGlobal * _g, void * _data)
{
    OSSC::COssEncOID	*_data_ptr;
    _data_ptr = (OSSC::COssEncOID *)_data;
    {
	OssBuf _val;
	OssEncodedOID _e;
	_val.length = 0;
	_val.value = nullptr;
	_e.length = (unsigned short)_data_ptr->length;
	_e.value = _data_ptr->value;
	ossEncodedOidToAsnVal(_g, &_e, &_val);
	if (_val.length) {
	    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
	    _oss_dec_free(_g, _val.value);
	} else
	    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
    }

    return PDU_PRINTED;
}

static int _pACSE_apdu(OssGlobal * _g, void * _data)
{
    _ACSE_apdu	*_data_ptr;
    _data_ptr = (_ACSE_apdu *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "aarq : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.aarq == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    {
		short _comma = 0;

		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		if (_data_ptr->u.aarq->bit_mask & 0x80000000) {
		    _oss_indent(_g, 0);
		    ossPrint(_g, "protocol-version ");
		    _oss_prt_bit(_g, _data_ptr->u.aarq->protocol_version.value, _data_ptr->u.aarq->protocol_version.length);
		    _comma = 1;
		}
		if (_comma) ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "application-context-name ");
		{
		    OssBuf _val;
		    OssEncodedOID _e;
		    _val.length = 0;
		    _val.value = nullptr;
		    _e.length = (unsigned short)_data_ptr->u.aarq->application_context_name.length;
		    _e.value = _data_ptr->u.aarq->application_context_name.value;
		    ossEncodedOidToAsnVal(_g, &_e, &_val);
		    if (_val.length) {
			ossPrint(_g, "%.*s", (int)_val.length, _val.value);
			_oss_dec_free(_g, _val.value);
		    } else
			_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
		}
		if (_data_ptr->u.aarq->bit_mask & 0x40000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "called-AP-title ");
		    _p_AP_title(_g, &_data_ptr->u.aarq->called_AP_title);
		}
		if (_data_ptr->u.aarq->bit_mask & 0x20000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "called-AE-qualifier ");
		    _p_AE_qualifier(_g, &_data_ptr->u.aarq->called_AE_qualifier);
		}
		if (_data_ptr->u.aarq->bit_mask & 0x10000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "called-AP-invocation-identifier ");
		    {
			LONG_LONG value = _data_ptr->u.aarq->called_AP_invocation_identifier;

			ossPrint(_g, LLONG_FMT, value);
		    }
		}
		if (_data_ptr->u.aarq->bit_mask & 0x8000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "called-AE-invocation-identifier ");
		    {
			LONG_LONG value = _data_ptr->u.aarq->called_AE_invocation_identifier;

			ossPrint(_g, LLONG_FMT, value);
		    }
		}
		if (_data_ptr->u.aarq->bit_mask & 0x4000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "calling-AP-title ");
		    _p_AP_title(_g, &_data_ptr->u.aarq->calling_AP_title);
		}
		if (_data_ptr->u.aarq->bit_mask & 0x2000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "calling-AE-qualifier ");
		    _p_AE_qualifier(_g, &_data_ptr->u.aarq->calling_AE_qualifier);
		}
		if (_data_ptr->u.aarq->bit_mask & 0x1000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "calling-AP-invocation-identifier ");
		    {
			LONG_LONG value = _data_ptr->u.aarq->calling_AP_invocation_identifier;

			ossPrint(_g, LLONG_FMT, value);
		    }
		}
		if (_data_ptr->u.aarq->bit_mask & 0x800000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "calling-AE-invocation-identifier ");
		    {
			LONG_LONG value = _data_ptr->u.aarq->calling_AE_invocation_identifier;

			ossPrint(_g, LLONG_FMT, value);
		    }
		}
		if (_data_ptr->u.aarq->bit_mask & 0x400000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "sender-acse-requirements ");
		    _oss_prt_bit(_g, _data_ptr->u.aarq->sender_acse_requirements.value, _data_ptr->u.aarq->sender_acse_requirements.length);
		}
		if (_data_ptr->u.aarq->bit_mask & 0x200000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "mechanism-name ");
		    {
			OssBuf _val;
			OssEncodedOID _e;
			_val.length = 0;
			_val.value = nullptr;
			_e.length = (unsigned short)_data_ptr->u.aarq->mechanism_name.length;
			_e.value = _data_ptr->u.aarq->mechanism_name.value;
			ossEncodedOidToAsnVal(_g, &_e, &_val);
			if (_val.length) {
			    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
			    _oss_dec_free(_g, _val.value);
			} else
			    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
		    }
		}
		if (_data_ptr->u.aarq->bit_mask & 0x100000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "calling-authentication-value ");
		    _p_Authentication_value(_g, &_data_ptr->u.aarq->calling_authentication_value);
		}
		if (_data_ptr->u.aarq->bit_mask & 0x80000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "application-context-name-list ");
		    _p_13Application_context_name_l(_g, &_data_ptr->u.aarq->application_context_name_list);
		}
		if (_data_ptr->u.aarq->bit_mask & 0x40000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "implementation-information ");
		    _oss_prt_char(_g, (char *)_data_ptr->u.aarq->implementation_information.value, _data_ptr->u.aarq->implementation_information.length);
		}
		if (_data_ptr->u.aarq->bit_mask & 0x20000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "user-information ");
		    _p_Association_information(_g, &_data_ptr->u.aarq->user_information);
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	break;
    case 2:
	ossPrint(_g, "aare : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.aare == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    {
		short _comma = 0;

		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		if (_data_ptr->u.aare->bit_mask & 0x80000000) {
		    _oss_indent(_g, 0);
		    ossPrint(_g, "protocol-version ");
		    _oss_prt_bit(_g, _data_ptr->u.aare->protocol_version.value, _data_ptr->u.aare->protocol_version.length);
		    _comma = 1;
		}
		if (_comma) ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "application-context-name ");
		{
		    OssBuf _val;
		    OssEncodedOID _e;
		    _val.length = 0;
		    _val.value = nullptr;
		    _e.length = (unsigned short)_data_ptr->u.aare->application_context_name.length;
		    _e.value = _data_ptr->u.aare->application_context_name.value;
		    ossEncodedOidToAsnVal(_g, &_e, &_val);
		    if (_val.length) {
			ossPrint(_g, "%.*s", (int)_val.length, _val.value);
			_oss_dec_free(_g, _val.value);
		    } else
			_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
		}
		ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "result ");
		{
		    LONG_LONG value = _data_ptr->u.aare->result;

		    ossPrint(_g, LLONG_FMT, value);
		}
		ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "result-source-diagnostic ");
		switch (_data_ptr->u.aare->result_source_diagnostic.choice) {
		case 1:
		    ossPrint(_g, "acse-service-user : ");
		    {
			LONG_LONG value = _data_ptr->u.aare->result_source_diagnostic.u.acse_service_user;

			ossPrint(_g, LLONG_FMT, value);
		    }
		    break;
		case 2:
		    ossPrint(_g, "acse-service-provider : ");
		    {
			LONG_LONG value = _data_ptr->u.aare->result_source_diagnostic.u.acse_service_provider;

			ossPrint(_g, LLONG_FMT, value);
		    }
		    break;
		default:
		    ossPrint(_g, "<unknown choice>");
		}
		if (_data_ptr->u.aare->bit_mask & 0x40000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "responding-AP-title ");
		    _p_AP_title(_g, &_data_ptr->u.aare->responding_AP_title);
		}
		if (_data_ptr->u.aare->bit_mask & 0x20000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "responding-AE-qualifier ");
		    _p_AE_qualifier(_g, &_data_ptr->u.aare->responding_AE_qualifier);
		}
		if (_data_ptr->u.aare->bit_mask & 0x10000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "responding-AP-invocation-identifier ");
		    {
			LONG_LONG value = _data_ptr->u.aare->responding_AP_invocation_identifier;

			ossPrint(_g, LLONG_FMT, value);
		    }
		}
		if (_data_ptr->u.aare->bit_mask & 0x8000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "responding-AE-invocation-identifier ");
		    {
			LONG_LONG value = _data_ptr->u.aare->responding_AE_invocation_identifier;

			ossPrint(_g, LLONG_FMT, value);
		    }
		}
		if (_data_ptr->u.aare->bit_mask & 0x4000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "responder-acse-requirements ");
		    _oss_prt_bit(_g, _data_ptr->u.aare->responder_acse_requirements.value, _data_ptr->u.aare->responder_acse_requirements.length);
		}
		if (_data_ptr->u.aare->bit_mask & 0x2000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "mechanism-name ");
		    {
			OssBuf _val;
			OssEncodedOID _e;
			_val.length = 0;
			_val.value = nullptr;
			_e.length = (unsigned short)_data_ptr->u.aare->mechanism_name.length;
			_e.value = _data_ptr->u.aare->mechanism_name.value;
			ossEncodedOidToAsnVal(_g, &_e, &_val);
			if (_val.length) {
			    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
			    _oss_dec_free(_g, _val.value);
			} else
			    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
		    }
		}
		if (_data_ptr->u.aare->bit_mask & 0x1000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "responding-authentication-value ");
		    _p_Authentication_value(_g, &_data_ptr->u.aare->responding_authentication_value);
		}
		if (_data_ptr->u.aare->bit_mask & 0x800000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "application-context-name-list ");
		    _p_13Application_context_name_l(_g, &_data_ptr->u.aare->application_context_name_list);
		}
		if (_data_ptr->u.aare->bit_mask & 0x400000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "implementation-information ");
		    _oss_prt_char(_g, (char *)_data_ptr->u.aare->implementation_information.value, _data_ptr->u.aare->implementation_information.length);
		}
		if (_data_ptr->u.aare->bit_mask & 0x200000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "user-information ");
		    _p_Association_information(_g, &_data_ptr->u.aare->user_information);
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	break;
    case 3:
	ossPrint(_g, "rlrq : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.rlrq == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    {
		short _comma = 0;

		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		if (_data_ptr->u.rlrq->bit_mask & 0x80000000) {
		    _oss_indent(_g, 0);
		    ossPrint(_g, "reason ");
		    {
			LONG_LONG value = _data_ptr->u.rlrq->reason;

			ossPrint(_g, LLONG_FMT, value);
		    }
		    _comma = 1;
		}
		if (_data_ptr->u.rlrq->bit_mask & 0x40000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "user-information ");
		    _p_Association_information(_g, &_data_ptr->u.rlrq->user_information);
		    _comma = 1;
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	break;
    case 4:
	ossPrint(_g, "rlre : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.rlre == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    {
		short _comma = 0;

		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		if (_data_ptr->u.rlre->bit_mask & 0x80000000) {
		    _oss_indent(_g, 0);
		    ossPrint(_g, "reason ");
		    {
			LONG_LONG value = _data_ptr->u.rlre->reason;

			ossPrint(_g, LLONG_FMT, value);
		    }
		    _comma = 1;
		}
		if (_data_ptr->u.rlre->bit_mask & 0x40000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "user-information ");
		    _p_Association_information(_g, &_data_ptr->u.rlre->user_information);
		    _comma = 1;
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	break;
    case 5:
	ossPrint(_g, "abrt : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.abrt == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    {
		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		_oss_indent(_g, 0);
		ossPrint(_g, "abort-source ");
		{
		    LONG_LONG value = _data_ptr->u.abrt->abort_source;

		    ossPrint(_g, LLONG_FMT, value);
		}
		if (_data_ptr->u.abrt->bit_mask & 0x80000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "abort-diagnostic ");
		    {
			LONG_LONG value = _data_ptr->u.abrt->abort_diagnostic;
			_oss_prt_enum(_g, (unsigned)value, _ssd[2].sa, (int)_ssd[2].alen);
		    }
		}
		if (_data_ptr->u.abrt->bit_mask & 0x40000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "user-information ");
		    _p_Association_information(_g, &_data_ptr->u.abrt->user_information);
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

    return PDU_PRINTED;
}

static int _pAE_title(OssGlobal * _g, void * _data)
{
    _AE_title	*_data_ptr;
    _data_ptr = (_AE_title *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "ae-title-form2 : ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = nullptr;
	    _e.length = (unsigned short)_data_ptr->u.ae_title_form2.length;
	    _e.value = _data_ptr->u.ae_title_form2.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	break;
    case 2:
	ossPrint(_g, "ae-title-form1 : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.ae_title_form1 == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    _p_Name(_g, _data_ptr->u.ae_title_form1);
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

    return PDU_PRINTED;
}

static int _pCP_type(OssGlobal * _g, void * _data)
{
    _CP_type	*_data_ptr;
    _data_ptr = (_CP_type *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "mode-selector ");
	_p_Mode_selector(_g, &_data_ptr->mode_selector);
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "x410-mode-parameters ");
	    {
		short _comma = 0;

		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		if (_data_ptr->x410_mode_parameters.bit_mask & 0x80000000) {
		    _oss_indent(_g, 0);
		    ossPrint(_g, "checkpointSize ");
		    {
			LONG_LONG value = _data_ptr->x410_mode_parameters.checkpointSize;

			ossPrint(_g, LLONG_FMT, value);
		    }
		    _comma = 1;
		}
		if (_data_ptr->x410_mode_parameters.bit_mask & 0x40000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "windowSize ");
		    {
			LONG_LONG value = _data_ptr->x410_mode_parameters.windowSize;

			ossPrint(_g, LLONG_FMT, value);
		    }
		    _comma = 1;
		}
		if (_data_ptr->x410_mode_parameters.bit_mask & 0x20000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "dialogueMode ");
		    {
			LONG_LONG value = _data_ptr->x410_mode_parameters.dialogueMode;

			ossPrint(_g, LLONG_FMT, value);
		    }
		    _comma = 1;
		}
		if (_comma) ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "connectionDataRQ ");
		_p_ConnectionData(_g, &_data_ptr->x410_mode_parameters.connectionDataRQ);
		if (_data_ptr->x410_mode_parameters.bit_mask & 0x10000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "applicationProtocol ");
		    {
			LONG_LONG value = _data_ptr->x410_mode_parameters.applicationProtocol;

			ossPrint(_g, LLONG_FMT, value);
		    }
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "normal-mode-parameters ");
	    {
		short _comma = 0;

		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		if (_data_ptr->normal_mode_parameters.bit_mask & 0x80000000) {
		    _oss_indent(_g, 0);
		    ossPrint(_g, "protocol-version ");
		    _oss_prt_bit(_g, _data_ptr->normal_mode_parameters.protocol_version.value, _data_ptr->normal_mode_parameters.protocol_version.length);
		    _comma = 1;
		}
		if (_data_ptr->normal_mode_parameters.bit_mask & 0x40000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "calling-presentation-selector ");
		    _oss_prt_oct(_g, _data_ptr->normal_mode_parameters.calling_presentation_selector.value, _data_ptr->normal_mode_parameters.calling_presentation_selector.length);
		    _comma = 1;
		}
		if (_data_ptr->normal_mode_parameters.bit_mask & 0x20000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "called-presentation-selector ");
		    _oss_prt_oct(_g, _data_ptr->normal_mode_parameters.called_presentation_selector.value, _data_ptr->normal_mode_parameters.called_presentation_selector.length);
		    _comma = 1;
		}
		if (_data_ptr->normal_mode_parameters.bit_mask & 0x10000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "presentation-context-definition-list ");
		    _p_Context_list(_g, &_data_ptr->normal_mode_parameters.presentation_context_definition_list);
		    _comma = 1;
		}
		if (_data_ptr->normal_mode_parameters.bit_mask & 0x8000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "default-context-name ");
		    {
			_oss_indent(_g, 1);
			ossPrint(_g, "{");
			_oss_indent(_g, 0);
			ossPrint(_g, "abstract-syntax-name ");
			{
			    OssBuf _val;
			    OssEncodedOID _e;
			    _val.length = 0;
			    _val.value = nullptr;
			    _e.length = (unsigned short)_data_ptr->normal_mode_parameters.default_context_name.abstract_syntax_name.length;
			    _e.value = _data_ptr->normal_mode_parameters.default_context_name.abstract_syntax_name.value;
			    ossEncodedOidToAsnVal(_g, &_e, &_val);
			    if (_val.length) {
				ossPrint(_g, "%.*s", (int)_val.length, _val.value);
				_oss_dec_free(_g, _val.value);
			    } else
				_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
			}
			ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "transfer-syntax-name ");
			{
			    OssBuf _val;
			    OssEncodedOID _e;
			    _val.length = 0;
			    _val.value = nullptr;
			    _e.length = (unsigned short)_data_ptr->normal_mode_parameters.default_context_name.transfer_syntax_name.length;
			    _e.value = _data_ptr->normal_mode_parameters.default_context_name.transfer_syntax_name.value;
			    ossEncodedOidToAsnVal(_g, &_e, &_val);
			    if (_val.length) {
				ossPrint(_g, "%.*s", (int)_val.length, _val.value);
				_oss_dec_free(_g, _val.value);
			    } else
				_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
			}
			_oss_indent(_g, -1);
			ossPrint(_g, "}");
		    }
		    _comma = 1;
		}
		if (_data_ptr->normal_mode_parameters.bit_mask & 0x4000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "presentation-requirements ");
		    _oss_prt_bit(_g, _data_ptr->normal_mode_parameters.presentation_requirements.value, _data_ptr->normal_mode_parameters.presentation_requirements.length);
		    _comma = 1;
		}
		if (_data_ptr->normal_mode_parameters.bit_mask & 0x2000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "user-session-requirements ");
		    _oss_prt_bit(_g, _data_ptr->normal_mode_parameters.user_session_requirements.value, _data_ptr->normal_mode_parameters.user_session_requirements.length);
		    _comma = 1;
		}
		if (_data_ptr->normal_mode_parameters.bit_mask & 0x1000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "protocol-options ");
		    _oss_prt_bit(_g, _data_ptr->normal_mode_parameters.protocol_options.value, _data_ptr->normal_mode_parameters.protocol_options.length);
		    _comma = 1;
		}
		if (_data_ptr->normal_mode_parameters.bit_mask & 0x800000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "initiators-nominated-context ");
		    {
			LONG_LONG value = _data_ptr->normal_mode_parameters.initiators_nominated_context;

			ossPrint(_g, LLONG_FMT, value);
		    }
		    _comma = 1;
		}
		if (_data_ptr->normal_mode_parameters.bit_mask & 0x400000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "extensions ");
		    {
			_oss_indent(_g, 1);
			ossPrint(_g, "{");
			_oss_indent(_g, -1);
			ossPrint(_g, "}");
		    }
		    _comma = 1;
		}
		if (_data_ptr->normal_mode_parameters.bit_mask & 0x200000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "user-data ");
		    _p_User_data(_g, &_data_ptr->normal_mode_parameters.user_data);
		    _comma = 1;
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pCPC_type(OssGlobal * _g, void * _data)
{
    _User_data	*_data_ptr;
    _data_ptr = (_User_data *)_data;
    _p_User_data(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pCPA_PPDU(OssGlobal * _g, void * _data)
{
    _CPA_PPDU	*_data_ptr;
    _data_ptr = (_CPA_PPDU *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "mode-selector ");
	_p_Mode_selector(_g, &_data_ptr->mode_selector);
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "x410-mode-parameters ");
	    {
		short _comma = 0;

		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		if (_data_ptr->x410_mode_parameters.bit_mask & 0x80000000) {
		    _oss_indent(_g, 0);
		    ossPrint(_g, "checkpointSize ");
		    {
			LONG_LONG value = _data_ptr->x410_mode_parameters.checkpointSize;

			ossPrint(_g, LLONG_FMT, value);
		    }
		    _comma = 1;
		}
		if (_data_ptr->x410_mode_parameters.bit_mask & 0x40000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "windowSize ");
		    {
			LONG_LONG value = _data_ptr->x410_mode_parameters.windowSize;

			ossPrint(_g, LLONG_FMT, value);
		    }
		    _comma = 1;
		}
		if (_comma) ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "connectionDataAC ");
		_p_ConnectionData(_g, &_data_ptr->x410_mode_parameters.connectionDataAC);
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "normal-mode-parameters ");
	    {
		short _comma = 0;

		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		if (_data_ptr->normal_mode_parameters.bit_mask & 0x80000000) {
		    _oss_indent(_g, 0);
		    ossPrint(_g, "protocol-version ");
		    _oss_prt_bit(_g, _data_ptr->normal_mode_parameters.protocol_version.value, _data_ptr->normal_mode_parameters.protocol_version.length);
		    _comma = 1;
		}
		if (_data_ptr->normal_mode_parameters.bit_mask & 0x40000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "responding-presentation-selector ");
		    _oss_prt_oct(_g, _data_ptr->normal_mode_parameters.responding_presentation_selector.value, _data_ptr->normal_mode_parameters.responding_presentation_selector.length);
		    _comma = 1;
		}
		if (_data_ptr->normal_mode_parameters.bit_mask & 0x20000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "presentation-context-definition-result-list ");
		    _p_Result_list(_g, &_data_ptr->normal_mode_parameters.presentation_context_definition_result_list);
		    _comma = 1;
		}
		if (_data_ptr->normal_mode_parameters.bit_mask & 0x10000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "presentation-requirements ");
		    _oss_prt_bit(_g, _data_ptr->normal_mode_parameters.presentation_requirements.value, _data_ptr->normal_mode_parameters.presentation_requirements.length);
		    _comma = 1;
		}
		if (_data_ptr->normal_mode_parameters.bit_mask & 0x8000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "user-session-requirements ");
		    _oss_prt_bit(_g, _data_ptr->normal_mode_parameters.user_session_requirements.value, _data_ptr->normal_mode_parameters.user_session_requirements.length);
		    _comma = 1;
		}
		if (_data_ptr->normal_mode_parameters.bit_mask & 0x4000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "protocol-options ");
		    _oss_prt_bit(_g, _data_ptr->normal_mode_parameters.protocol_options.value, _data_ptr->normal_mode_parameters.protocol_options.length);
		    _comma = 1;
		}
		if (_data_ptr->normal_mode_parameters.bit_mask & 0x2000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "responders-nominated-context ");
		    {
			LONG_LONG value = _data_ptr->normal_mode_parameters.responders_nominated_context;

			ossPrint(_g, LLONG_FMT, value);
		    }
		    _comma = 1;
		}
		if (_data_ptr->normal_mode_parameters.bit_mask & 0x1000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "user-data ");
		    _p_User_data(_g, &_data_ptr->normal_mode_parameters.user_data);
		    _comma = 1;
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pCPR_PPDU(OssGlobal * _g, void * _data)
{
    _CPR_PPDU	*_data_ptr;
    _data_ptr = (_CPR_PPDU *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "normal-mode-parameters : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.normal_mode_parameters == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    {
		short _comma = 0;

		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		if (_data_ptr->u.normal_mode_parameters->bit_mask & 0x80000000) {
		    _oss_indent(_g, 0);
		    ossPrint(_g, "protocol-version ");
		    _oss_prt_bit(_g, _data_ptr->u.normal_mode_parameters->protocol_version.value, _data_ptr->u.normal_mode_parameters->protocol_version.length);
		    _comma = 1;
		}
		if (_data_ptr->u.normal_mode_parameters->bit_mask & 0x40000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "responding-presentation-selector ");
		    _oss_prt_oct(_g, _data_ptr->u.normal_mode_parameters->responding_presentation_selector.value, _data_ptr->u.normal_mode_parameters->responding_presentation_selector.length);
		    _comma = 1;
		}
		if (_data_ptr->u.normal_mode_parameters->bit_mask & 0x20000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "presentation-context-definition-result-list ");
		    _p_Result_list(_g, &_data_ptr->u.normal_mode_parameters->presentation_context_definition_result_list);
		    _comma = 1;
		}
		if (_data_ptr->u.normal_mode_parameters->bit_mask & 0x10000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "default-context-result ");
		    {
			LONG_LONG value = _data_ptr->u.normal_mode_parameters->default_context_result;

			ossPrint(_g, LLONG_FMT, value);
		    }
		    _comma = 1;
		}
		if (_data_ptr->u.normal_mode_parameters->bit_mask & 0x8000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "provider-reason ");
		    {
			LONG_LONG value = _data_ptr->u.normal_mode_parameters->provider_reason;

			ossPrint(_g, LLONG_FMT, value);
		    }
		    _comma = 1;
		}
		if (_data_ptr->u.normal_mode_parameters->bit_mask & 0x4000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "user-data ");
		    _p_User_data(_g, &_data_ptr->u.normal_mode_parameters->user_data);
		    _comma = 1;
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	break;
    case 2:
	ossPrint(_g, "x400-mode-parameters : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.x400_mode_parameters == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    {
		short _comma = 0;

		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		if (_data_ptr->u.x400_mode_parameters->bit_mask & 0x80000000) {
		    _oss_indent(_g, 0);
		    ossPrint(_g, "refuseReason ");
		    {
			LONG_LONG value = _data_ptr->u.x400_mode_parameters->refuseReason;

			ossPrint(_g, LLONG_FMT, value);
		    }
		    _comma = 1;
		}
		if (_data_ptr->u.x400_mode_parameters->bit_mask & 0x40000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "userDataRJ ");
		    _oss_prt_opentype(_g, (OpenType *)&_data_ptr->u.x400_mode_parameters->userDataRJ);
		    _comma = 1;
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

    return PDU_PRINTED;
}

static int _pAbort_type(OssGlobal * _g, void * _data)
{
    _Abort_type	*_data_ptr;
    _data_ptr = (_Abort_type *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "arp-ppdu : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.arp_ppdu == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    {
		short _comma = 0;

		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		if (_data_ptr->u.arp_ppdu->bit_mask & 0x80000000) {
		    _oss_indent(_g, 0);
		    ossPrint(_g, "provider-reason ");
		    {
			LONG_LONG value = _data_ptr->u.arp_ppdu->provider_reason;

			ossPrint(_g, LLONG_FMT, value);
		    }
		    _comma = 1;
		}
		if (_data_ptr->u.arp_ppdu->bit_mask & 0x40000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "event-identifier ");
		    {
			LONG_LONG value = _data_ptr->u.arp_ppdu->event_identifier;

			ossPrint(_g, LLONG_FMT, value);
		    }
		    _comma = 1;
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	break;
    case 2:
	ossPrint(_g, "aru-ppdu : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.aru_ppdu == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    switch (_data_ptr->u.aru_ppdu->choice) {
	    case 1:
		ossPrint(_g, "x400-mode-parameters : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
		if (_data_ptr->u.aru_ppdu->u.x400_mode_parameters == nullptr)
		    ossPrint(_g, "<<<<<<nullptr>>>>>>");
		else
#endif
		    {
			short _comma = 0;

			_oss_indent(_g, 1);
			ossPrint(_g, "{");
			if (_data_ptr->u.aru_ppdu->u.x400_mode_parameters->bit_mask & 0x80000000) {
			    _oss_indent(_g, 0);
			    ossPrint(_g, "abortReason ");
			    {
				LONG_LONG value = _data_ptr->u.aru_ppdu->u.x400_mode_parameters->abortReason;

				ossPrint(_g, LLONG_FMT, value);
			    }
			    _comma = 1;
			}
			if (_data_ptr->u.aru_ppdu->u.x400_mode_parameters->bit_mask & 0x40000000) {
			    if (_comma) ossPrint(_g, ",");
			    _oss_indent(_g, 0);
			    ossPrint(_g, "reflectedParameter ");
			    _oss_prt_bit(_g, _data_ptr->u.aru_ppdu->u.x400_mode_parameters->reflectedParameter.value, _data_ptr->u.aru_ppdu->u.x400_mode_parameters->reflectedParameter.length);
			    _comma = 1;
			}
			if (_data_ptr->u.aru_ppdu->u.x400_mode_parameters->bit_mask & 0x20000000) {
			    if (_comma) ossPrint(_g, ",");
			    _oss_indent(_g, 0);
			    ossPrint(_g, "userdataAB ");
			    _oss_prt_opentype(_g, (OpenType *)&_data_ptr->u.aru_ppdu->u.x400_mode_parameters->userdataAB);
			    _comma = 1;
			}
			_oss_indent(_g, -1);
			ossPrint(_g, "}");
		    }
		break;
	    case 2:
		ossPrint(_g, "normal-mode-parameters : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
		if (_data_ptr->u.aru_ppdu->u.normal_mode_parameters == nullptr)
		    ossPrint(_g, "<<<<<<nullptr>>>>>>");
		else
#endif
		    {
			short _comma = 0;

			_oss_indent(_g, 1);
			ossPrint(_g, "{");
			if (_data_ptr->u.aru_ppdu->u.normal_mode_parameters->bit_mask & 0x80000000) {
			    _oss_indent(_g, 0);
			    ossPrint(_g, "presentation-context-identifier-list ");
			    _p_14Presentation_context_ident(_g, &_data_ptr->u.aru_ppdu->u.normal_mode_parameters->presentation_context_identifier_list);
			    _comma = 1;
			}
			if (_data_ptr->u.aru_ppdu->u.normal_mode_parameters->bit_mask & 0x40000000) {
			    if (_comma) ossPrint(_g, ",");
			    _oss_indent(_g, 0);
			    ossPrint(_g, "user-data ");
			    _p_User_data(_g, &_data_ptr->u.aru_ppdu->u.normal_mode_parameters->user_data);
			    _comma = 1;
			}
			_oss_indent(_g, -1);
			ossPrint(_g, "}");
		    }
		break;
	    default:
		ossPrint(_g, "<unknown choice>");
	    }
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

    return PDU_PRINTED;
}

static int _pTyped_data_type(OssGlobal * _g, void * _data)
{
    _Typed_data_type	*_data_ptr;
    _data_ptr = (_Typed_data_type *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "ttdPPDU : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.ttdPPDU == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    _p_User_data(_g, _data_ptr->u.ttdPPDU);
	break;
    case 2:
	ossPrint(_g, "acPPDU : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.acPPDU == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    {
		short _comma = 0;

		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		if (_data_ptr->u.acPPDU->bit_mask & 0x80000000) {
		    _oss_indent(_g, 0);
		    ossPrint(_g, "presentation-context-addition-list ");
		    _p_Context_list(_g, &_data_ptr->u.acPPDU->presentation_context_addition_list);
		    _comma = 1;
		}
		if (_data_ptr->u.acPPDU->bit_mask & 0x40000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "presentation-context-deletion-list ");
		    _oss_indent(_g, 1);
		    ossPrint(_g, "{");
		    if (_data_ptr->u.acPPDU->presentation_context_deletion_list) {
			_Presentation_context_deletion_list * _tempa = _data_ptr->u.acPPDU->presentation_context_deletion_list;
			_Presentation_context_deletion_list * _tempb;
			while (_tempa) {
			    _tempb = _tempa->next;
			    _oss_indent(_g, 0);
			    {
				LONG_LONG value = _tempa->value;

				ossPrint(_g, LLONG_FMT, value);
			    }
			    _tempa = _tempb;
			    if (_tempa)
				ossPrint(_g, ",");
			}
		    }
		    _oss_indent(_g, -1);
		    ossPrint(_g, "}");
		    _comma = 1;
		}
		if (_data_ptr->u.acPPDU->bit_mask & 0x20000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "user-data ");
		    _p_User_data(_g, &_data_ptr->u.acPPDU->user_data);
		    _comma = 1;
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	break;
    case 3:
	ossPrint(_g, "acaPPDU : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.acaPPDU == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    {
		short _comma = 0;

		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		if (_data_ptr->u.acaPPDU->bit_mask & 0x80000000) {
		    _oss_indent(_g, 0);
		    ossPrint(_g, "presentation-context-addition-result-list ");
		    _p_Result_list(_g, &_data_ptr->u.acaPPDU->presentation_context_addition_result_list);
		    _comma = 1;
		}
		if (_data_ptr->u.acaPPDU->bit_mask & 0x40000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "presentation-context-deletion-result-list ");
		    _oss_indent(_g, 1);
		    ossPrint(_g, "{");
		    if (_data_ptr->u.acaPPDU->presentation_context_deletion_result_list) {
			_Presentation_context_deletion_list * _tempa = _data_ptr->u.acaPPDU->presentation_context_deletion_result_list;
			_Presentation_context_deletion_list * _tempb;
			while (_tempa) {
			    _tempb = _tempa->next;
			    _oss_indent(_g, 0);
			    {
				LONG_LONG value = _tempa->value;

				ossPrint(_g, LLONG_FMT, value);
			    }
			    _tempa = _tempb;
			    if (_tempa)
				ossPrint(_g, ",");
			}
		    }
		    _oss_indent(_g, -1);
		    ossPrint(_g, "}");
		    _comma = 1;
		}
		if (_data_ptr->u.acaPPDU->bit_mask & 0x20000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "user-data ");
		    _p_User_data(_g, &_data_ptr->u.acaPPDU->user_data);
		    _comma = 1;
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

    return PDU_PRINTED;
}

static int _pRS_PPDU(OssGlobal * _g, void * _data)
{
    _seq6	*_data_ptr;
    _data_ptr = (_seq6 *)_data;
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "presentation-context-identifier-list ");
	    _p_14Presentation_context_ident(_g, &_data_ptr->presentation_context_identifier_list);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "user-data ");
	    _p_User_data(_g, &_data_ptr->user_data);
	    _comma = 1;
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pRSA_PPDU(OssGlobal * _g, void * _data)
{
    _seq6	*_data_ptr;
    _data_ptr = (_seq6 *)_data;
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "presentation-context-identifier-list ");
	    _p_14Presentation_context_ident(_g, &_data_ptr->presentation_context_identifier_list);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "user-data ");
	    _p_User_data(_g, &_data_ptr->user_data);
	    _comma = 1;
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _p0Reliable_Transfer_APDU_RTSE(OssGlobal * _g, void * _data)
{
    _Reliable_Transfer_APDU_RTSE_apdus	*_data_ptr;
    _data_ptr = (_Reliable_Transfer_APDU_RTSE_apdus *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "rttp-apdu : ");
	{
	    LONG_LONG value = _data_ptr->u.rttp_apdu;

	    ossPrint(_g, LLONG_FMT, value);
	}
	break;
    case 2:
	ossPrint(_g, "rttr-apdu : ");
	_oss_prt_oct(_g, _data_ptr->u.rttr_apdu.value, _data_ptr->u.rttr_apdu.length);
	break;
    case 3:
	ossPrint(_g, "rtorq-apdu : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.rtorq_apdu == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    _p_RTORQapdu(_g, _data_ptr->u.rtorq_apdu);
	break;
    case 4:
	ossPrint(_g, "rtoac-apdu : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.rtoac_apdu == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    _p_RTOACapdu(_g, _data_ptr->u.rtoac_apdu);
	break;
    case 5:
	ossPrint(_g, "rtorj-apdu : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.rtorj_apdu == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    _p_RTORJapdu(_g, _data_ptr->u.rtorj_apdu);
	break;
    case 6:
	ossPrint(_g, "rtab-apdu : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.rtab_apdu == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    {
		short _comma = 0;

		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		if (_data_ptr->u.rtab_apdu->bit_mask & 0x80000000) {
		    _oss_indent(_g, 0);
		    ossPrint(_g, "abortReason ");
		    {
			LONG_LONG value = _data_ptr->u.rtab_apdu->abortReason;

			ossPrint(_g, LLONG_FMT, value);
		    }
		    _comma = 1;
		}
		if (_data_ptr->u.rtab_apdu->bit_mask & 0x40000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "reflectedParameter ");
		    _oss_prt_bit(_g, _data_ptr->u.rtab_apdu->reflectedParameter.value, _data_ptr->u.rtab_apdu->reflectedParameter.length);
		    _comma = 1;
		}
		if (_data_ptr->u.rtab_apdu->bit_mask & 0x20000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "userdataAB ");
		    _oss_prt_opentype(_g, (OpenType *)&_data_ptr->u.rtab_apdu->userdataAB);
		    _comma = 1;
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

    return PDU_PRINTED;
}

static int _p1Remote_Operations_Abstract_(OssGlobal * _g, void * _data)
{
    _Reliable_Transfer_APDU_RTSE_apdus	*_data_ptr;
    _data_ptr = (_Reliable_Transfer_APDU_RTSE_apdus *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "rttp-apdu : ");
	{
	    LONG_LONG value = _data_ptr->u.rttp_apdu;

	    ossPrint(_g, LLONG_FMT, value);
	}
	break;
    case 2:
	ossPrint(_g, "rttr-apdu : ");
	_oss_prt_oct(_g, _data_ptr->u.rttr_apdu.value, _data_ptr->u.rttr_apdu.length);
	break;
    case 3:
	ossPrint(_g, "rtorq-apdu : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.rtorq_apdu == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    _p_RTORQapdu(_g, _data_ptr->u.rtorq_apdu);
	break;
    case 4:
	ossPrint(_g, "rtoac-apdu : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.rtoac_apdu == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    _p_RTOACapdu(_g, _data_ptr->u.rtoac_apdu);
	break;
    case 5:
	ossPrint(_g, "rtorj-apdu : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.rtorj_apdu == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    _p_RTORJapdu(_g, _data_ptr->u.rtorj_apdu);
	break;
    case 6:
	ossPrint(_g, "rtab-apdu : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.rtab_apdu == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    {
		short _comma = 0;

		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		if (_data_ptr->u.rtab_apdu->bit_mask & 0x80000000) {
		    _oss_indent(_g, 0);
		    ossPrint(_g, "abortReason ");
		    {
			LONG_LONG value = _data_ptr->u.rtab_apdu->abortReason;

			ossPrint(_g, LLONG_FMT, value);
		    }
		    _comma = 1;
		}
		if (_data_ptr->u.rtab_apdu->bit_mask & 0x40000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "reflectedParameter ");
		    _oss_prt_bit(_g, _data_ptr->u.rtab_apdu->reflectedParameter.value, _data_ptr->u.rtab_apdu->reflectedParameter.length);
		    _comma = 1;
		}
		if (_data_ptr->u.rtab_apdu->bit_mask & 0x20000000) {
		    if (_comma) ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "userdataAB ");
		    _oss_prt_opentype(_g, (OpenType *)&_data_ptr->u.rtab_apdu->userdataAB);
		    _comma = 1;
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

    return PDU_PRINTED;
}

static int _pROSEInvokeIds(OssGlobal * _g, void * _data)
{
    _InvokeId	*_data_ptr;
    _data_ptr = (_InvokeId *)_data;
    _p_InvokeId(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pReject(OssGlobal * _g, void * _data)
{
    _Reject	*_data_ptr;
    _data_ptr = (_Reject *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "invokeId ");
	_p_InvokeId(_g, &_data_ptr->invokeId);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "problem ");
	switch (_data_ptr->problem.choice) {
	case 1:
	    ossPrint(_g, "general : ");
	    {
		LONG_LONG value = _data_ptr->problem.u.general;

		ossPrint(_g, LLONG_FMT, value);
	    }
	    break;
	case 2:
	    ossPrint(_g, "invoke : ");
	    {
		LONG_LONG value = _data_ptr->problem.u.invoke;

		ossPrint(_g, LLONG_FMT, value);
	    }
	    break;
	case 3:
	    ossPrint(_g, "returnResult : ");
	    {
		LONG_LONG value = _data_ptr->problem.u.returnResult;

		ossPrint(_g, LLONG_FMT, value);
	    }
	    break;
	case 4:
	    ossPrint(_g, "returnError : ");
	    {
		LONG_LONG value = _data_ptr->problem.u.returnError;

		ossPrint(_g, LLONG_FMT, value);
	    }
	    break;
	default:
	    ossPrint(_g, "<unknown choice>");
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pNoInvokeId(OssGlobal * _g, void * _data)
{
    _InvokeId	*_data_ptr;
    _data_ptr = (_InvokeId *)_data;
    _p_InvokeId(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pUnboundedDirectoryString(OssGlobal * _g, void * _data)
{
    _UnboundedDirectoryString	*_data_ptr;
    _data_ptr = (_UnboundedDirectoryString *)_data;
    _p_UnboundedDirectoryString(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pUniqueIdentifier(OssGlobal * _g, void * _data)
{
    OSSC::COssBitString	*_data_ptr;
    _data_ptr = (OSSC::COssBitString *)_data;
    _oss_prt_bit(_g, _data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pUUIDPair(OssGlobal * _g, void * _data)
{
    _UUIDPair	*_data_ptr;
    _data_ptr = (_UUIDPair *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "issuerUUID ");
	_oss_prt_oct(_g, _data_ptr->issuerUUID.value, _data_ptr->issuerUUID.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "subjectUUID ");
	_oss_prt_oct(_g, _data_ptr->subjectUUID.value, _data_ptr->subjectUUID.length);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pCountryName(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_char(_g, (char *)_data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pGuide(OssGlobal * _g, void * _data)
{
    _Guide	*_data_ptr;
    _data_ptr = (_Guide *)_data;
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "objectClass ");
	    {
		OssBuf _val;
		OssEncodedOID _e;
		_val.length = 0;
		_val.value = nullptr;
		_e.length = (unsigned short)_data_ptr->objectClass.length;
		_e.value = _data_ptr->objectClass.value;
		ossEncodedOidToAsnVal(_g, &_e, &_val);
		if (_val.length) {
		    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		    _oss_dec_free(_g, _val.value);
		} else
		    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	    }
	    _comma = 1;
	}
	if (_comma) ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "criteria ");
	_p_Criteria(_g, &_data_ptr->criteria);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pEnhancedGuide(OssGlobal * _g, void * _data)
{
    _EnhancedGuide	*_data_ptr;
    _data_ptr = (_EnhancedGuide *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "objectClass ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = nullptr;
	    _e.length = (unsigned short)_data_ptr->objectClass.length;
	    _e.value = _data_ptr->objectClass.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "criteria ");
	_p_Criteria(_g, &_data_ptr->criteria);
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "subset ");
	    {
		LONG_LONG value = _data_ptr->subset;

		ossPrint(_g, LLONG_FMT, value);
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pPostalAddress(OssGlobal * _g, void * _data)
{
    _PostalAddress	**_data_ptr;
    _data_ptr = (_PostalAddress **)_data;
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_PostalAddress * _tempa = *_data_ptr;
	_PostalAddress * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_indent(_g, 0);
	    _p_UnboundedDirectoryString(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

    return PDU_PRINTED;
}

static int _pTelephoneNumber(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_char(_g, (char *)_data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pTelexNumber(OssGlobal * _g, void * _data)
{
    _TelexNumber	*_data_ptr;
    _data_ptr = (_TelexNumber *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "telexNumber ");
	_oss_prt_char(_g, (char *)_data_ptr->telexNumber.value, _data_ptr->telexNumber.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "countryCode ");
	_oss_prt_char(_g, (char *)_data_ptr->countryCode.value, _data_ptr->countryCode.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "answerback ");
	_oss_prt_char(_g, (char *)_data_ptr->answerback.value, _data_ptr->answerback.length);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pX121Address(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_char(_g, (char *)_data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pInternationalISDNNumber(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_char(_g, (char *)_data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pDestinationIndicator(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_char(_g, (char *)_data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pCommunicationsService(OssGlobal * _g, void * _data)
{
    OSSC::COssEncOID	*_data_ptr;
    _data_ptr = (OSSC::COssEncOID *)_data;
    {
	OssBuf _val;
	OssEncodedOID _e;
	_val.length = 0;
	_val.value = nullptr;
	_e.length = (unsigned short)_data_ptr->length;
	_e.value = _data_ptr->value;
	ossEncodedOidToAsnVal(_g, &_e, &_val);
	if (_val.length) {
	    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
	    _oss_dec_free(_g, _val.value);
	} else
	    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
    }

    return PDU_PRINTED;
}

static int _pCommunicationsNetwork(OssGlobal * _g, void * _data)
{
    OSSC::COssEncOID	*_data_ptr;
    _data_ptr = (OSSC::COssEncOID *)_data;
    {
	OssBuf _val;
	OssEncodedOID _e;
	_val.length = 0;
	_val.value = nullptr;
	_e.length = (unsigned short)_data_ptr->length;
	_e.value = _data_ptr->value;
	ossEncodedOidToAsnVal(_g, &_e, &_val);
	if (_val.length) {
	    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
	    _oss_dec_free(_g, _val.value);
	} else
	    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
    }

    return PDU_PRINTED;
}

static int _pPreferredDeliveryMethod(OssGlobal * _g, void * _data)
{
    _Presentation_context_deletion_list	**_data_ptr;
    _data_ptr = (_Presentation_context_deletion_list **)_data;
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_Presentation_context_deletion_list * _tempa = *_data_ptr;
	_Presentation_context_deletion_list * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_indent(_g, 0);
	    {
		LONG_LONG value = _tempa->value;

		ossPrint(_g, LLONG_FMT, value);
	    }
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

    return PDU_PRINTED;
}

static int _pPresentationAddress(OssGlobal * _g, void * _data)
{
    _PresentationAddress	*_data_ptr;
    _data_ptr = (_PresentationAddress *)_data;
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "pSelector ");
	    _oss_prt_oct(_g, _data_ptr->pSelector.value, _data_ptr->pSelector.length);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "sSelector ");
	    _oss_prt_oct(_g, _data_ptr->sSelector.value, _data_ptr->sSelector.length);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "tSelector ");
	    _oss_prt_oct(_g, _data_ptr->tSelector.value, _data_ptr->tSelector.length);
	    _comma = 1;
	}
	if (_comma) ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "nAddresses ");
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->nAddresses) {
	    _setof3 * _tempa = _data_ptr->nAddresses;
	    _setof3 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_oss_indent(_g, 0);
		_oss_prt_oct(_g, _tempa->value.value, _tempa->value.length);
		_tempa = _tempb;
		if (_tempa)
		    ossPrint(_g, ",");
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pProtocolInformation(OssGlobal * _g, void * _data)
{
    _ProtocolInformation	*_data_ptr;
    _data_ptr = (_ProtocolInformation *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "nAddress ");
	_oss_prt_oct(_g, _data_ptr->nAddress.value, _data_ptr->nAddress.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "profiles ");
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->profiles) {
	    _Application_context_name_list * _tempa = _data_ptr->profiles;
	    _Application_context_name_list * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_oss_indent(_g, 0);
		{
		    OssBuf _val;
		    OssEncodedOID _e;
		    _val.length = 0;
		    _val.value = nullptr;
		    _e.length = (unsigned short)_tempa->value.length;
		    _e.value = _tempa->value.value;
		    ossEncodedOidToAsnVal(_g, &_e, &_val);
		    if (_val.length) {
			ossPrint(_g, "%.*s", (int)_val.length, _val.value);
			_oss_dec_free(_g, _val.value);
		    } else
			_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
		}
		_tempa = _tempb;
		if (_tempa)
		    ossPrint(_g, ",");
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pNameAndOptionalUID(OssGlobal * _g, void * _data)
{
    _NameAndOptionalUID	*_data_ptr;
    _data_ptr = (_NameAndOptionalUID *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "dn ");
	_p_RDNSequence(_g, &_data_ptr->dn);
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "uid ");
	    _oss_prt_bit(_g, _data_ptr->uid.value, _data_ptr->uid.length);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pMultipleMatchingLocalities(OssGlobal * _g, void * _data)
{
    _MultipleMatchingLocalities	*_data_ptr;
    _data_ptr = (_MultipleMatchingLocalities *)_data;
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "matchingRuleUsed ");
	    {
		OssBuf _val;
		OssEncodedOID _e;
		_val.length = 0;
		_val.value = nullptr;
		_e.length = (unsigned short)_data_ptr->matchingRuleUsed.length;
		_e.value = _data_ptr->matchingRuleUsed.value;
		ossEncodedOidToAsnVal(_g, &_e, &_val);
		if (_val.length) {
		    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		    _oss_dec_free(_g, _val.value);
		} else
		    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	    }
	    _comma = 1;
	}
	if (_comma) ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "attributeList ");
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->attributeList) {
	    _seqof2 * _tempa = _data_ptr->attributeList;
	    _seqof2 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		{
		    _oss_indent(_g, 1);
		    ossPrint(_g, "{");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "type ");
		    {
			OssBuf _val;
			OssEncodedOID _e;
			_val.length = 0;
			_val.value = nullptr;
			_e.length = (unsigned short)_tempa->value.type.length;
			_e.value = _tempa->value.type.value;
			ossEncodedOidToAsnVal(_g, &_e, &_val);
			if (_val.length) {
			    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
			    _oss_dec_free(_g, _val.value);
			} else
			    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
		    }
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "assertion ");
		    _oss_prt_new_opentype(_g, _tempa->value.assertion.pduNum, *(void **)&_tempa->value.assertion.decoded, &_tempa->value.assertion.encoded);
		    if (_tempa->value.bit_mask & 0x80000000) {
			ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "assertedContexts ");
			switch (_tempa->value.assertedContexts.choice) {
			case 1:
			    ossPrint(_g, "allContexts : ");
			    ossPrint(_g, "nullptr");
			    break;
			case 2:
			    ossPrint(_g, "selectedContexts : ");
			    _oss_indent(_g, 1);
			    ossPrint(_g, "{");
			    if (_tempa->value.assertedContexts.u.selectedContexts) {
				_setof6 * _temp1a = _tempa->value.assertedContexts.u.selectedContexts;
				_setof6 * _temp1b;
				while (_temp1a) {
				    _temp1b = _temp1a->next;
				    _p_ContextAssertion(_g, &_temp1a->value);
				    _temp1a = _temp1b;
				    if (_temp1a)
					ossPrint(_g, ",");
				}
			    }
			    _oss_indent(_g, -1);
			    ossPrint(_g, "}");
			    break;
			default:
			    ossPrint(_g, "<unknown choice>");
			}
		    }
		    _oss_indent(_g, -1);
		    ossPrint(_g, "}");
		}
		_tempa = _tempb;
		if (_tempa)
		    ossPrint(_g, ",");
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pSubstringAssertion(OssGlobal * _g, void * _data)
{
    _SubstringAssertion	**_data_ptr;
    _data_ptr = (_SubstringAssertion **)_data;
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_SubstringAssertion * _tempa = *_data_ptr;
	_SubstringAssertion * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_indent(_g, 0);
	    switch (_tempa->value.choice) {
	    case 1:
		ossPrint(_g, "control : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
		if (_tempa->value.u.control == nullptr)
		    ossPrint(_g, "<<<<<<nullptr>>>>>>");
		else
#endif
		    {
			_oss_indent(_g, 1);
			ossPrint(_g, "{");
			_oss_indent(_g, 0);
			ossPrint(_g, "type ");
			{
			    OssBuf _val;
			    OssEncodedOID _e;
			    _val.length = 0;
			    _val.value = nullptr;
			    _e.length = (unsigned short)_tempa->value.u.control->type.length;
			    _e.value = _tempa->value.u.control->type.value;
			    ossEncodedOidToAsnVal(_g, &_e, &_val);
			    if (_val.length) {
				ossPrint(_g, "%.*s", (int)_val.length, _val.value);
				_oss_dec_free(_g, _val.value);
			    } else
				_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
			}
			ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "values ");
			_oss_indent(_g, 1);
			ossPrint(_g, "{");
			if (_tempa->value.u.control->values) {
			    _setof13 * _temp1a = _tempa->value.u.control->values;
			    _setof13 * _temp1b;
			    while (_temp1a) {
				_temp1b = _temp1a->next;
				_oss_indent(_g, 0);
				_oss_prt_new_opentype(_g, _temp1a->value.pduNum, *(void **)&_temp1a->value.decoded, &_temp1a->value.encoded);
				_temp1a = _temp1b;
				if (_temp1a)
				    ossPrint(_g, ",");
			    }
			}
			_oss_indent(_g, -1);
			ossPrint(_g, "}");
			if (_tempa->value.u.control->bit_mask & 0x80000000) {
			    ossPrint(_g, ",");
			    _oss_indent(_g, 0);
			    ossPrint(_g, "valuesWithContext ");
			    _oss_indent(_g, 1);
			    ossPrint(_g, "{");
			    if (_tempa->value.u.control->valuesWithContext) {
				_setof14 * _temp1a = _tempa->value.u.control->valuesWithContext;
				_setof14 * _temp1b;
				while (_temp1a) {
				    _temp1b = _temp1a->next;
				    {
					_oss_indent(_g, 1);
					ossPrint(_g, "{");
					_oss_indent(_g, 0);
					ossPrint(_g, "value ");
					_oss_prt_new_opentype(_g, _temp1a->value.value.pduNum, *(void **)&_temp1a->value.value.decoded, &_temp1a->value.value.encoded);
					ossPrint(_g, ",");
					_oss_indent(_g, 0);
					ossPrint(_g, "contextList ");
					_oss_indent(_g, 1);
					ossPrint(_g, "{");
					if (_temp1a->value.contextList) {
					    _setof15 * _temp2a = _temp1a->value.contextList;
					    _setof15 * _temp2b;
					    while (_temp2a) {
						_temp2b = _temp2a->next;
						_p_Context(_g, &_temp2a->value);
						_temp2a = _temp2b;
						if (_temp2a)
						    ossPrint(_g, ",");
					    }
					}
					_oss_indent(_g, -1);
					ossPrint(_g, "}");
					_oss_indent(_g, -1);
					ossPrint(_g, "}");
				    }
				    _temp1a = _temp1b;
				    if (_temp1a)
					ossPrint(_g, ",");
				}
			    }
			    _oss_indent(_g, -1);
			    ossPrint(_g, "}");
			}
			_oss_indent(_g, -1);
			ossPrint(_g, "}");
		    }
		break;
	    case 2:
		ossPrint(_g, "initial : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
		if (_tempa->value.u.initial == nullptr)
		    ossPrint(_g, "<<<<<<nullptr>>>>>>");
		else
#endif
		    _p_UnboundedDirectoryString(_g, _tempa->value.u.initial);
		break;
	    case 3:
		ossPrint(_g, "any : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
		if (_tempa->value.u.any == nullptr)
		    ossPrint(_g, "<<<<<<nullptr>>>>>>");
		else
#endif
		    _p_UnboundedDirectoryString(_g, _tempa->value.u.any);
		break;
	    case 4:
		ossPrint(_g, "final : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
		if (_tempa->value.u.final == nullptr)
		    ossPrint(_g, "<<<<<<nullptr>>>>>>");
		else
#endif
		    _p_UnboundedDirectoryString(_g, _tempa->value.u.final);
		break;
	    default:
		ossPrint(_g, "<unknown choice>");
	    }
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

    return PDU_PRINTED;
}

static int _pCaseIgnoreList(OssGlobal * _g, void * _data)
{
    _PostalAddress	**_data_ptr;
    _data_ptr = (_PostalAddress **)_data;
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_PostalAddress * _tempa = *_data_ptr;
	_PostalAddress * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_indent(_g, 0);
	    _p_UnboundedDirectoryString(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

    return PDU_PRINTED;
}

static int _pOctetSubstringAssertion(OssGlobal * _g, void * _data)
{
    _OctetSubstringAssertion	**_data_ptr;
    _data_ptr = (_OctetSubstringAssertion **)_data;
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_OctetSubstringAssertion * _tempa = *_data_ptr;
	_OctetSubstringAssertion * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_indent(_g, 0);
	    switch (_tempa->value.choice) {
	    case 1:
		ossPrint(_g, "initial : ");
		_oss_prt_oct(_g, _tempa->value.u.initial.value, _tempa->value.u.initial.length);
		break;
	    case 2:
		ossPrint(_g, "any : ");
		_oss_prt_oct(_g, _tempa->value.u.any.value, _tempa->value.u.any.length);
		break;
	    case 3:
		ossPrint(_g, "final : ");
		_oss_prt_oct(_g, _tempa->value.u.final.value, _tempa->value.u.final.length);
		break;
	    default:
		ossPrint(_g, "<unknown choice>");
	    }
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

    return PDU_PRINTED;
}

static int _pSequenceMatchType(OssGlobal * _g, void * _data)
{
    enum SequenceMatchType	*_data_ptr;
    _data_ptr = (enum SequenceMatchType *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	_oss_prt_enum(_g, value, _ssd[3].sa, (int)_ssd[3].alen);
    }

    return PDU_PRINTED;
}

static int _pWordMatchTypes(OssGlobal * _g, void * _data)
{
    enum WordMatchTypes	*_data_ptr;
    _data_ptr = (enum WordMatchTypes *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	_oss_prt_enum(_g, value, _ssd[4].sa, (int)_ssd[4].alen);
    }

    return PDU_PRINTED;
}

static int _pCharacterMatchTypes(OssGlobal * _g, void * _data)
{
    enum CharacterMatchTypes	*_data_ptr;
    _data_ptr = (enum CharacterMatchTypes *)_data;
    {
	ULONG_LONG value = *_data_ptr;
	_oss_prt_enum(_g, value, _ssd[5].sa, (int)_ssd[5].alen);
    }

    return PDU_PRINTED;
}

static int _pLanguageContextSyntax(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_char(_g, (char *)_data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pTimeSpecification(OssGlobal * _g, void * _data)
{
    _TimeSpecification	*_data_ptr;
    _data_ptr = (_TimeSpecification *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "time ");
	switch (_data_ptr->time.choice) {
	case 1:
	    ossPrint(_g, "absolute : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	    if (_data_ptr->time.u.absolute == nullptr)
		ossPrint(_g, "<<<<<<nullptr>>>>>>");
	    else
#endif
		{
		    short _comma = 0;

		    _oss_indent(_g, 1);
		    ossPrint(_g, "{");
		    if (_data_ptr->time.u.absolute->startTime) {
			_oss_indent(_g, 0);
			ossPrint(_g, "startTime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_data_ptr->time.u.absolute->startTime == nullptr)
			    ossPrint(_g, "<<<<<<nullptr>>>>>>");
			else
#endif
			    _oss_prt_nchar(_g, (char *)_data_ptr->time.u.absolute->startTime);
			_comma = 1;
		    }
		    if (_data_ptr->time.u.absolute->endTime) {
			if (_comma) ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "endTime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_data_ptr->time.u.absolute->endTime == nullptr)
			    ossPrint(_g, "<<<<<<nullptr>>>>>>");
			else
#endif
			    _oss_prt_nchar(_g, (char *)_data_ptr->time.u.absolute->endTime);
			_comma = 1;
		    }
		    _oss_indent(_g, -1);
		    ossPrint(_g, "}");
		}
	    break;
	case 2:
	    ossPrint(_g, "periodic : ");
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_data_ptr->time.u.periodic) {
		_setof10 * _tempa = _data_ptr->time.u.periodic;
		_setof10 * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    {
			short _comma = 0;

			_oss_indent(_g, 1);
			ossPrint(_g, "{");
			if (_tempa->value.bit_mask & 0x80000000) {
			    _oss_indent(_g, 0);
			    ossPrint(_g, "timesOfDay ");
			    _oss_indent(_g, 1);
			    ossPrint(_g, "{");
			    if (_tempa->value.timesOfDay) {
				_setof8 * _temp1a = _tempa->value.timesOfDay;
				_setof8 * _temp1b;
				while (_temp1a) {
				    _temp1b = _temp1a->next;
				    {
					short _comma = 0;

					_oss_indent(_g, 1);
					ossPrint(_g, "{");
					if (_temp1a->value.bit_mask & 0x80000000) {
					    _oss_indent(_g, 0);
					    ossPrint(_g, "startDayTime ");
					    _p_DayTime(_g, &_temp1a->value.startDayTime);
					    _comma = 1;
					}
					if (_temp1a->value.bit_mask & 0x40000000) {
					    if (_comma) ossPrint(_g, ",");
					    _oss_indent(_g, 0);
					    ossPrint(_g, "endDayTime ");
					    _p_DayTime(_g, &_temp1a->value.endDayTime);
					    _comma = 1;
					}
					_oss_indent(_g, -1);
					ossPrint(_g, "}");
				    }
				    _temp1a = _temp1b;
				    if (_temp1a)
					ossPrint(_g, ",");
				}
			    }
			    _oss_indent(_g, -1);
			    ossPrint(_g, "}");
			    _comma = 1;
			}
			if (_tempa->value.bit_mask & 0x40000000) {
			    if (_comma) ossPrint(_g, ",");
			    _oss_indent(_g, 0);
			    ossPrint(_g, "days ");
			    switch (_tempa->value.days.choice) {
			    case 1:
				ossPrint(_g, "bitDay : ");
				_oss_prt_bit(_g, _tempa->value.days.u.bitDay.value, _tempa->value.days.u.bitDay.length);
				break;
			    case 2:
				ossPrint(_g, "intDay : ");
				_p__setof7(_g, &_tempa->value.days.u.intDay);
				break;
			    case 3:
				ossPrint(_g, "dayOf : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
				if (_tempa->value.days.u.dayOf == nullptr)
				    ossPrint(_g, "<<<<<<nullptr>>>>>>");
				else
#endif
				    switch (_tempa->value.days.u.dayOf->choice) {
				    case 1:
					ossPrint(_g, "first : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
					if (_tempa->value.days.u.dayOf->u.first == nullptr)
					    ossPrint(_g, "<<<<<<nullptr>>>>>>");
					else
#endif
					    _p_NamedDay(_g, _tempa->value.days.u.dayOf->u.first);
					break;
				    case 2:
					ossPrint(_g, "second : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
					if (_tempa->value.days.u.dayOf->u.second == nullptr)
					    ossPrint(_g, "<<<<<<nullptr>>>>>>");
					else
#endif
					    _p_NamedDay(_g, _tempa->value.days.u.dayOf->u.second);
					break;
				    case 3:
					ossPrint(_g, "third : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
					if (_tempa->value.days.u.dayOf->u.third == nullptr)
					    ossPrint(_g, "<<<<<<nullptr>>>>>>");
					else
#endif
					    _p_NamedDay(_g, _tempa->value.days.u.dayOf->u.third);
					break;
				    case 4:
					ossPrint(_g, "fourth : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
					if (_tempa->value.days.u.dayOf->u.fourth == nullptr)
					    ossPrint(_g, "<<<<<<nullptr>>>>>>");
					else
#endif
					    _p_NamedDay(_g, _tempa->value.days.u.dayOf->u.fourth);
					break;
				    case 5:
					ossPrint(_g, "fifth : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
					if (_tempa->value.days.u.dayOf->u.fifth == nullptr)
					    ossPrint(_g, "<<<<<<nullptr>>>>>>");
					else
#endif
					    _p_NamedDay(_g, _tempa->value.days.u.dayOf->u.fifth);
					break;
				    default:
					ossPrint(_g, "<unknown choice>");
				    }
				break;
			    default:
				ossPrint(_g, "<unknown choice>");
			    }
			    _comma = 1;
			}
			if (_tempa->value.bit_mask & 0x20000000) {
			    if (_comma) ossPrint(_g, ",");
			    _oss_indent(_g, 0);
			    ossPrint(_g, "weeks ");
			    switch (_tempa->value.weeks.choice) {
			    case 1:
				ossPrint(_g, "bitWeek : ");
				_oss_prt_bit(_g, _tempa->value.weeks.u.bitWeek.value, _tempa->value.weeks.u.bitWeek.length);
				break;
			    case 2:
				ossPrint(_g, "allWeeks : ");
				ossPrint(_g, "nullptr");
				break;
			    case 3:
				ossPrint(_g, "intWeek : ");
				_p__setof7(_g, &_tempa->value.weeks.u.intWeek);
				break;
			    default:
				ossPrint(_g, "<unknown choice>");
			    }
			    _comma = 1;
			}
			if (_tempa->value.bit_mask & 0x10000000) {
			    if (_comma) ossPrint(_g, ",");
			    _oss_indent(_g, 0);
			    ossPrint(_g, "months ");
			    switch (_tempa->value.months.choice) {
			    case 1:
				ossPrint(_g, "bitMonth : ");
				_oss_prt_bit(_g, _tempa->value.months.u.bitMonth.value, _tempa->value.months.u.bitMonth.length);
				break;
			    case 2:
				ossPrint(_g, "allMonths : ");
				ossPrint(_g, "nullptr");
				break;
			    case 3:
				ossPrint(_g, "intMonth : ");
				_p__setof7(_g, &_tempa->value.months.u.intMonth);
				break;
			    default:
				ossPrint(_g, "<unknown choice>");
			    }
			    _comma = 1;
			}
			if (_tempa->value.bit_mask & 0x8000000) {
			    if (_comma) ossPrint(_g, ",");
			    _oss_indent(_g, 0);
			    ossPrint(_g, "years ");
			    _oss_indent(_g, 1);
			    ossPrint(_g, "{");
			    if (_tempa->value.years) {
				_setof9 * _temp1a = _tempa->value.years;
				_setof9 * _temp1b;
				while (_temp1a) {
				    _temp1b = _temp1a->next;
				    _oss_indent(_g, 0);
				    {
					ULONG_LONG value = _temp1a->value;
					ossPrint(_g, ULLONG_FMT, value);
				    }
				    _temp1a = _temp1b;
				    if (_temp1a)
					ossPrint(_g, ",");
				}
			    }
			    _oss_indent(_g, -1);
			    ossPrint(_g, "}");
			    _comma = 1;
			}
			_oss_indent(_g, -1);
			ossPrint(_g, "}");
		    }
		    _tempa = _tempb;
		    if (_tempa)
			ossPrint(_g, ",");
		}
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	    break;
	default:
	    ossPrint(_g, "<unknown choice>");
	}
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "notThisTime ");
	    ossPrint(_g, _data_ptr->notThisTime ? "TRUE" : "FALSE");
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "timeZone ");
	    {
		LONG_LONG value = _data_ptr->timeZone;

		ossPrint(_g, LLONG_FMT, value);
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pTimeAssertion(OssGlobal * _g, void * _data)
{
    _TimeAssertion	*_data_ptr;
    _data_ptr = (_TimeAssertion *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "now : ");
	ossPrint(_g, "nullptr");
	break;
    case 2:
	ossPrint(_g, "between : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.between == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    {
		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		_oss_indent(_g, 0);
		ossPrint(_g, "startTime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
		if (_data_ptr->u.between->startTime == nullptr)
		    ossPrint(_g, "<<<<<<nullptr>>>>>>");
		else
#endif
		    _oss_prt_nchar(_g, (char *)_data_ptr->u.between->startTime);
		if (_data_ptr->u.between->endTime) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "endTime ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_data_ptr->u.between->endTime == nullptr)
			ossPrint(_g, "<<<<<<nullptr>>>>>>");
		    else
#endif
			_oss_prt_nchar(_g, (char *)_data_ptr->u.between->endTime);
		}
		if (_data_ptr->u.between->bit_mask & 0x80000000) {
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "entirely ");
		    ossPrint(_g, _data_ptr->u.between->entirely ? "TRUE" : "FALSE");
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	break;
    case 3:
	ossPrint(_g, "at : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.at == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    _oss_prt_nchar(_g, (char *)_data_ptr->u.at);
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

    return PDU_PRINTED;
}

static int _pLocaleContextSyntax(OssGlobal * _g, void * _data)
{
    _LocaleContextSyntax	*_data_ptr;
    _data_ptr = (_LocaleContextSyntax *)_data;
    switch (_data_ptr->choice) {
    case 1:
	ossPrint(_g, "localeID1 : ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = nullptr;
	    _e.length = (unsigned short)_data_ptr->u.localeID1.length;
	    _e.value = _data_ptr->u.localeID1.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	break;
    case 2:
	ossPrint(_g, "localeID2 : ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->u.localeID2 == nullptr)
	    ossPrint(_g, "<<<<<<nullptr>>>>>>");
	else
#endif
	    _p_UnboundedDirectoryString(_g, _data_ptr->u.localeID2);
	break;
    default:
	ossPrint(_g, "<unknown choice>");
    }

    return PDU_PRINTED;
}

static int _pAttributeOptionList(OssGlobal * _g, void * _data)
{
    _setof3	**_data_ptr;
    _data_ptr = (_setof3 **)_data;
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_setof3 * _tempa = *_data_ptr;
	_setof3 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_indent(_g, 0);
	    _oss_prt_mbchar(_g, (unsigned char *)_tempa->value.value, _tempa->value.length, 1);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

    return PDU_PRINTED;
}

static int _pID(OssGlobal * _g, void * _data)
{
    OSSC::COssEncOID	*_data_ptr;
    _data_ptr = (OSSC::COssEncOID *)_data;
    {
	OssBuf _val;
	OssEncodedOID _e;
	_val.length = 0;
	_val.value = nullptr;
	_e.length = (unsigned short)_data_ptr->length;
	_e.value = _data_ptr->value;
	ossEncodedOidToAsnVal(_g, &_e, &_val);
	if (_val.length) {
	    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
	    _oss_dec_free(_g, _val.value);
	} else
	    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
    }

    return PDU_PRINTED;
}

static int _pAttributeValue(OssGlobal * _g, void * _data)
{
    OSSC::COssOpen	*_data_ptr;
    _data_ptr = (OSSC::COssOpen *)_data;
    _oss_prt_opentype(_g, (OpenType *)_data_ptr);

    return PDU_PRINTED;
}

static int _pContextAssertion(OssGlobal * _g, void * _data)
{
    _ContextAssertion	*_data_ptr;
    _data_ptr = (_ContextAssertion *)_data;
    _p_ContextAssertion(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pAttributeTypeAssertion(OssGlobal * _g, void * _data)
{
    _AttributeTypeAssertion	*_data_ptr;
    _data_ptr = (_AttributeTypeAssertion *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "type ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = nullptr;
	    _e.length = (unsigned short)_data_ptr->type.length;
	    _e.value = _data_ptr->type.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "assertedContexts ");
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_data_ptr->assertedContexts) {
		_setof6 * _tempa = _data_ptr->assertedContexts;
		_setof6 * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    _p_ContextAssertion(_g, &_tempa->value);
		    _tempa = _tempb;
		    if (_tempa)
			ossPrint(_g, ",");
		}
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pDistinguishedName(OssGlobal * _g, void * _data)
{
    _RDNSequence	**_data_ptr;
    _data_ptr = (_RDNSequence **)_data;
    _p_RDNSequence(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pSubtreeSpecification(OssGlobal * _g, void * _data)
{
    _SubtreeSpecification	*_data_ptr;
    _data_ptr = (_SubtreeSpecification *)_data;
    {
	short _comma = 0;

	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->bit_mask & 0x80000000) {
	    _oss_indent(_g, 0);
	    ossPrint(_g, "base ");
	    _p_RDNSequence(_g, &_data_ptr->base);
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "specificExclusions ");
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_data_ptr->specificExclusions) {
		_setof19 * _tempa = _data_ptr->specificExclusions;
		_setof19 * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    _oss_indent(_g, 0);
		    switch (_tempa->value.choice) {
		    case 1:
			ossPrint(_g, "chopBefore : ");
			_p_RDNSequence(_g, &_tempa->value.u.chopBefore);
			break;
		    case 2:
			ossPrint(_g, "chopAfter : ");
			_p_RDNSequence(_g, &_tempa->value.u.chopAfter);
			break;
		    default:
			ossPrint(_g, "<unknown choice>");
		    }
		    _tempa = _tempb;
		    if (_tempa)
			ossPrint(_g, ",");
		}
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "minimum ");
	    {
		ULONG_LONG value = _data_ptr->minimum;
		ossPrint(_g, ULLONG_FMT, value);
	    }
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x10000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "maximum ");
	    {
		ULONG_LONG value = _data_ptr->maximum;
		ossPrint(_g, ULLONG_FMT, value);
	    }
	    _comma = 1;
	}
	if (_data_ptr->bit_mask & 0x8000000) {
	    if (_comma) ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "specificationFilter ");
	    _p_Refinement(_g, &_data_ptr->specificationFilter);
	    _comma = 1;
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pDITStructureRule(OssGlobal * _g, void * _data)
{
    _DITStructureRule	*_data_ptr;
    _data_ptr = (_DITStructureRule *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "ruleIdentifier ");
	{
	    LONG_LONG value = _data_ptr->ruleIdentifier;

	    ossPrint(_g, LLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "nameForm ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = nullptr;
	    _e.length = (unsigned short)_data_ptr->nameForm.length;
	    _e.value = _data_ptr->nameForm.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "superiorStructureRules ");
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_data_ptr->superiorStructureRules) {
		_Presentation_context_deletion_list * _tempa = _data_ptr->superiorStructureRules;
		_Presentation_context_deletion_list * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    _oss_indent(_g, 0);
		    {
			LONG_LONG value = _tempa->value;

			ossPrint(_g, LLONG_FMT, value);
		    }
		    _tempa = _tempb;
		    if (_tempa)
			ossPrint(_g, ",");
		}
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pDITContentRule(OssGlobal * _g, void * _data)
{
    _DITContentRule	*_data_ptr;
    _data_ptr = (_DITContentRule *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "structuralObjectClass ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = nullptr;
	    _e.length = (unsigned short)_data_ptr->structuralObjectClass.length;
	    _e.value = _data_ptr->structuralObjectClass.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "auxiliaries ");
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_data_ptr->auxiliaries) {
		_Application_context_name_list * _tempa = _data_ptr->auxiliaries;
		_Application_context_name_list * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    _oss_indent(_g, 0);
		    {
			OssBuf _val;
			OssEncodedOID _e;
			_val.length = 0;
			_val.value = nullptr;
			_e.length = (unsigned short)_tempa->value.length;
			_e.value = _tempa->value.value;
			ossEncodedOidToAsnVal(_g, &_e, &_val);
			if (_val.length) {
			    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
			    _oss_dec_free(_g, _val.value);
			} else
			    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
		    }
		    _tempa = _tempb;
		    if (_tempa)
			ossPrint(_g, ",");
		}
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "mandatory ");
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_data_ptr->mandatory) {
		_Application_context_name_list * _tempa = _data_ptr->mandatory;
		_Application_context_name_list * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    _oss_indent(_g, 0);
		    {
			OssBuf _val;
			OssEncodedOID _e;
			_val.length = 0;
			_val.value = nullptr;
			_e.length = (unsigned short)_tempa->value.length;
			_e.value = _tempa->value.value;
			ossEncodedOidToAsnVal(_g, &_e, &_val);
			if (_val.length) {
			    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
			    _oss_dec_free(_g, _val.value);
			} else
			    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
		    }
		    _tempa = _tempb;
		    if (_tempa)
			ossPrint(_g, ",");
		}
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	if (_data_ptr->bit_mask & 0x20000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "optional ");
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_data_ptr->optional) {
		_Application_context_name_list * _tempa = _data_ptr->optional;
		_Application_context_name_list * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    _oss_indent(_g, 0);
		    {
			OssBuf _val;
			OssEncodedOID _e;
			_val.length = 0;
			_val.value = nullptr;
			_e.length = (unsigned short)_tempa->value.length;
			_e.value = _tempa->value.value;
			ossEncodedOidToAsnVal(_g, &_e, &_val);
			if (_val.length) {
			    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
			    _oss_dec_free(_g, _val.value);
			} else
			    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
		    }
		    _tempa = _tempb;
		    if (_tempa)
			ossPrint(_g, ",");
		}
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	if (_data_ptr->bit_mask & 0x10000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "precluded ");
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_data_ptr->precluded) {
		_Application_context_name_list * _tempa = _data_ptr->precluded;
		_Application_context_name_list * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    _oss_indent(_g, 0);
		    {
			OssBuf _val;
			OssEncodedOID _e;
			_val.length = 0;
			_val.value = nullptr;
			_e.length = (unsigned short)_tempa->value.length;
			_e.value = _tempa->value.value;
			ossEncodedOidToAsnVal(_g, &_e, &_val);
			if (_val.length) {
			    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
			    _oss_dec_free(_g, _val.value);
			} else
			    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
		    }
		    _tempa = _tempb;
		    if (_tempa)
			ossPrint(_g, ",");
		}
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pDITContextUse(OssGlobal * _g, void * _data)
{
    _DITContextUse	*_data_ptr;
    _data_ptr = (_DITContextUse *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "attributeType ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = nullptr;
	    _e.length = (unsigned short)_data_ptr->attributeType.length;
	    _e.value = _data_ptr->attributeType.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	if (_data_ptr->bit_mask & 0x80000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "mandatoryContexts ");
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_data_ptr->mandatoryContexts) {
		_Application_context_name_list * _tempa = _data_ptr->mandatoryContexts;
		_Application_context_name_list * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    _oss_indent(_g, 0);
		    {
			OssBuf _val;
			OssEncodedOID _e;
			_val.length = 0;
			_val.value = nullptr;
			_e.length = (unsigned short)_tempa->value.length;
			_e.value = _tempa->value.value;
			ossEncodedOidToAsnVal(_g, &_e, &_val);
			if (_val.length) {
			    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
			    _oss_dec_free(_g, _val.value);
			} else
			    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
		    }
		    _tempa = _tempb;
		    if (_tempa)
			ossPrint(_g, ",");
		}
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	if (_data_ptr->bit_mask & 0x40000000) {
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "optionalContexts ");
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_data_ptr->optionalContexts) {
		_Application_context_name_list * _tempa = _data_ptr->optionalContexts;
		_Application_context_name_list * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    _oss_indent(_g, 0);
		    {
			OssBuf _val;
			OssEncodedOID _e;
			_val.length = 0;
			_val.value = nullptr;
			_e.length = (unsigned short)_tempa->value.length;
			_e.value = _tempa->value.value;
			ossEncodedOidToAsnVal(_g, &_e, &_val);
			if (_val.length) {
			    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
			    _oss_dec_free(_g, _val.value);
			} else
			    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
		    }
		    _tempa = _tempb;
		    if (_tempa)
			ossPrint(_g, ",");
		}
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pHierarchyLevel(OssGlobal * _g, void * _data)
{
    OSS_INT32	*_data_ptr;
    _data_ptr = (OSS_INT32 *)_data;
    {
	LONG_LONG value = *_data_ptr;

	ossPrint(_g, LLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _pHierarchyBelow(OssGlobal * _g, void * _data)
{
    ossBoolean	*_data_ptr;
    _data_ptr = (ossBoolean *)_data;
    ossPrint(_g, *(ossBoolean *)_data_ptr ? "TRUE" : "FALSE");

    return PDU_PRINTED;
}

static int _pAcse_RealizationParameter(OssGlobal * _g, void * _data)
{
    _RealizationParameter	*_data_ptr;
    _data_ptr = (_RealizationParameter *)_data;
    _p_RealizationParameter(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _p2Acse_with_concatenation_Rea(OssGlobal * _g, void * _data)
{
    _RealizationParameter	*_data_ptr;
    _data_ptr = (_RealizationParameter *)_data;
    _p_RealizationParameter(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _p3Association_by_RTSE_Realiza(OssGlobal * _g, void * _data)
{
    _RealizationParameter	*_data_ptr;
    _data_ptr = (_RealizationParameter *)_data;
    _p_RealizationParameter(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pPData_RealizationParameter(OssGlobal * _g, void * _data)
{
    _RealizationParameter	*_data_ptr;
    _data_ptr = (_RealizationParameter *)_data;
    _p_RealizationParameter(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _p4PData_with_concatenation_Re(OssGlobal * _g, void * _data)
{
    _RealizationParameter	*_data_ptr;
    _data_ptr = (_RealizationParameter *)_data;
    _p_RealizationParameter(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _p5Transfer_by_RTSE_Realizatio(OssGlobal * _g, void * _data)
{
    _RealizationParameter	*_data_ptr;
    _data_ptr = (_RealizationParameter *)_data;
    _p_RealizationParameter(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pBitStringMatch_SYNTAX(OssGlobal * _g, void * _data)
{
    OSSC::COssBitString	*_data_ptr;
    _data_ptr = (OSSC::COssBitString *)_data;
    _oss_prt_bit(_g, _data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pDnQualifier_WITH_SYNTAX(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_char(_g, (char *)_data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pSerialNumber_WITH_SYNTAX(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_char(_g, (char *)_data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pNumericStringMatch_SYNTAX(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_char(_g, (char *)_data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _p6ProtocolInformationMatch_SY(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_oct(_g, _data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pUiiInUrn_WITH_SYNTAX(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_mbchar(_g, (unsigned char *)_data_ptr->value, _data_ptr->length, 1);

    return PDU_PRINTED;
}

static int _p7NumericStringOrderingMatch_(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_char(_g, (char *)_data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pBooleanMatch_SYNTAX(OssGlobal * _g, void * _data)
{
    ossBoolean	*_data_ptr;
    _data_ptr = (ossBoolean *)_data;
    ossPrint(_g, *(ossBoolean *)_data_ptr ? "TRUE" : "FALSE");

    return PDU_PRINTED;
}

static int _pIntegerMatch_SYNTAX(OssGlobal * _g, void * _data)
{
    OSS_INT32	*_data_ptr;
    _data_ptr = (OSS_INT32 *)_data;
    {
	LONG_LONG value = *_data_ptr;

	ossPrint(_g, LLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _pIntegerOrderingMatch_SYNTAX(OssGlobal * _g, void * _data)
{
    OSS_INT32	*_data_ptr;
    _data_ptr = (OSS_INT32 *)_data;
    {
	LONG_LONG value = *_data_ptr;

	ossPrint(_g, LLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _pOctetStringMatch_SYNTAX(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_oct(_g, _data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _p8OctetStringOrderingMatch_SY(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_oct(_g, _data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pUTCTimeMatch_SYNTAX(OssGlobal * _g, void * _data)
{
    char *	_data_ptr;
    char *	*_data_ptr_ptr;
    _data_ptr_ptr = (char * *)_data;
    _data_ptr = *_data_ptr_ptr;
#ifndef OSS_DO_NOT_CHECK_POINTERS
    if (_data_ptr == nullptr)
	return BAD_PTR;
#endif
    _oss_prt_nchar(_g, (char *)_data_ptr);

    return PDU_PRINTED;
}

static int _pUTCTimeOrderingMatch_SYNTAX(OssGlobal * _g, void * _data)
{
    char *	_data_ptr;
    char *	*_data_ptr_ptr;
    _data_ptr_ptr = (char * *)_data;
    _data_ptr = *_data_ptr_ptr;
#ifndef OSS_DO_NOT_CHECK_POINTERS
    if (_data_ptr == nullptr)
	return BAD_PTR;
#endif
    _oss_prt_nchar(_g, (char *)_data_ptr);

    return PDU_PRINTED;
}

static int _pGeneralizedTimeMatch_SYNTAX(OssGlobal * _g, void * _data)
{
    char *	_data_ptr;
    char *	*_data_ptr_ptr;
    _data_ptr_ptr = (char * *)_data;
    _data_ptr = *_data_ptr_ptr;
#ifndef OSS_DO_NOT_CHECK_POINTERS
    if (_data_ptr == nullptr)
	return BAD_PTR;
#endif
    _oss_prt_nchar(_g, (char *)_data_ptr);

    return PDU_PRINTED;
}

static int _p9GeneralizedTimeOrderingMatc(OssGlobal * _g, void * _data)
{
    char *	_data_ptr;
    char *	*_data_ptr_ptr;
    _data_ptr_ptr = (char * *)_data;
    _data_ptr = *_data_ptr_ptr;
#ifndef OSS_DO_NOT_CHECK_POINTERS
    if (_data_ptr == nullptr)
	return BAD_PTR;
#endif
    _oss_prt_nchar(_g, (char *)_data_ptr);

    return PDU_PRINTED;
}

static int _p10IntegerFirstComponentMatch(OssGlobal * _g, void * _data)
{
    OSS_INT32	*_data_ptr;
    _data_ptr = (OSS_INT32 *)_data;
    {
	LONG_LONG value = *_data_ptr;

	ossPrint(_g, LLONG_FMT, value);
    }

    return PDU_PRINTED;
}

static int _p11AdministrativeRole_WITH_SY(OssGlobal * _g, void * _data)
{
    OSSC::COssEncOID	*_data_ptr;
    _data_ptr = (OSSC::COssEncOID *)_data;
    {
	OssBuf _val;
	OssEncodedOID _e;
	_val.length = 0;
	_val.value = nullptr;
	_e.length = (unsigned short)_data_ptr->length;
	_e.value = _data_ptr->value;
	ossEncodedOidToAsnVal(_g, &_e, &_val);
	if (_val.length) {
	    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
	    _oss_dec_free(_g, _val.value);
	} else
	    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
    }

    return PDU_PRINTED;
}

static int _pCreateTimestamp_WITH_SYNTAX(OssGlobal * _g, void * _data)
{
    char *	_data_ptr;
    char *	*_data_ptr_ptr;
    _data_ptr_ptr = (char * *)_data;
    _data_ptr = *_data_ptr_ptr;
#ifndef OSS_DO_NOT_CHECK_POINTERS
    if (_data_ptr == nullptr)
	return BAD_PTR;
#endif
    _oss_prt_nchar(_g, (char *)_data_ptr);

    return PDU_PRINTED;
}

static int _pModifyTimestamp_WITH_SYNTAX(OssGlobal * _g, void * _data)
{
    char *	_data_ptr;
    char *	*_data_ptr_ptr;
    _data_ptr_ptr = (char * *)_data;
    _data_ptr = *_data_ptr_ptr;
#ifndef OSS_DO_NOT_CHECK_POINTERS
    if (_data_ptr == nullptr)
	return BAD_PTR;
#endif
    _oss_prt_nchar(_g, (char *)_data_ptr);

    return PDU_PRINTED;
}

static int _p12SubschemaTimestamp_WITH_SY(OssGlobal * _g, void * _data)
{
    char *	_data_ptr;
    char *	*_data_ptr_ptr;
    _data_ptr_ptr = (char * *)_data;
    _data_ptr = *_data_ptr_ptr;
#ifndef OSS_DO_NOT_CHECK_POINTERS
    if (_data_ptr == nullptr)
	return BAD_PTR;
#endif
    _oss_prt_nchar(_g, (char *)_data_ptr);

    return PDU_PRINTED;
}

static int _pHasSubordinates_WITH_SYNTAX(OssGlobal * _g, void * _data)
{
    ossBoolean	*_data_ptr;
    _data_ptr = (ossBoolean *)_data;
    ossPrint(_g, *(ossBoolean *)_data_ptr ? "TRUE" : "FALSE");

    return PDU_PRINTED;
}

int DLL_ENTRY_FDEF _pmUpperBounds_(struct ossGlobal * _g, int _pdunum, void * _data)
{
    int _rc = _pdunum < 0;

    if (_rc)
	_pdunum = -_pdunum;
    if (_pdunum < 1 || _pdunum > 85 || !_PrintPDU[_pdunum - 1]._pf)
	return PDU_RANGE;
    else {
	if (_rc) {
	    ossPrint(_g, "%s : ", _PrintPDU[_pdunum - 1]._name);
	    _rc = _PrintPDU[_pdunum - 1]._pf(_g, _data);
	} else {
	    ossPrint(_g, "value %s ::= ", _PrintPDU[_pdunum - 1]._name);
	    _rc = _PrintPDU[_pdunum - 1]._pf(_g, _data);
	    ossPrint(_g, "\n");
	}
    }

    return _rc;
}

#endif

static int _cmDayTime(OssGlobal * _g, _DayTime  * _odata, _DayTime  * _cdata)
{
    int _res = 0;

    if ((*_cdata).hour != (*_odata).hour)
	return 1;
    if (((*_odata).bit_mask & (*_cdata).bit_mask) & 0x80000000) {
	if ((*_cdata).minute != (*_odata).minute)
	    return 1;
    } else {
	if ((*_odata).bit_mask & 0x80000000) {
	    if (DayTime::default_minute != (*_odata).minute)
		return 1;
	}
	if ((*_cdata).bit_mask & 0x80000000) {
	    if ((*_cdata).minute != DayTime::default_minute)
		return 1;
	}
    }
    if (((*_odata).bit_mask & (*_cdata).bit_mask) & 0x40000000) {
	if ((*_cdata).second != (*_odata).second)
	    return 1;
    } else {
	if ((*_odata).bit_mask & 0x40000000) {
	    if (DayTime::default_second != (*_odata).second)
		return 1;
	}
	if ((*_cdata).bit_mask & 0x40000000) {
	    if ((*_cdata).second != DayTime::default_second)
		return 1;
	}
    }

    return _res;
}

static int _nDDayTime(OssGlobal * _g, _DayTime  * _odata, _DayTime  * _cdata)
{
    int _res = _cmDayTime(_g, _odata, _cdata);

    if (_res == -1)
	_oss_enc_error(_g, _type_not_supported_der_toed, 0);
    return _res;
}

static int _cmContext(OssGlobal * _g, _Context  * _odata, _Context  * _cdata)
{
    int _res = 0;

    if (!((*_cdata).contextType).length)
	return 1;
    if (_oss_cmp_unbnd_octet_ia(&((*_odata).contextType), &((*_cdata).contextType), sizeof(((*_cdata).contextType).length), sizeof(((*_cdata).contextType).value[0]), (unsigned int)((char *)&((*_odata).contextType).value - (char *)&((*_odata).contextType))))
	return 1;
    {
	_setof11 *  _s_2 = (*_odata).contextValues;
	_setof11 *  _d_2 = (*_cdata).contextValues;
	long        *_a, _i, _i_next, _c = 0L;

	while (_s_2 && _d_2) {
	    ++ _c;
	    _s_2 = _s_2->next;
	    _d_2 = _d_2->next;
	}
	if (_s_2 || _d_2)
	    return 1;
	if (_c) {
	    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
	    for (_i = 0; _i < _c; _i ++)
		_a[_i] = _i;
	    _a[_c] = -1L;
	    for (_s_2 = (*_odata).contextValues; _s_2; _s_2 = _s_2->next) {
		_i_next = _a[0]; _res = 1;
		for (_d_2 = (*_cdata).contextValues, _i = 0L; _d_2 && _i_next >= 0L && _a[_i_next] >= 0L; _d_2 = _d_2->next,
			_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
		    if (_i < _i_next)
			continue;
		    _res = _oss_cmp_new_open_type(_g, (_s_2->value).pduNum, (_d_2->value).pduNum, &((_s_2->value).encoded), &((_d_2->value).encoded), *(void **)&((_s_2->value).decoded), *(void **)&((_d_2->value).decoded));
		    if (_res)
			continue;
		    _res = 0; _a[_i] = _a[_i+1];
		    break;
		}
		if (_res)
		    break;
	    }
	    _oss_dec_freetempmem(_g, _a);
	    if (_res)
		return _res;
	}
    }
    if (((*_odata).bit_mask & (*_cdata).bit_mask) & 0x80000000) {
	if (((*_cdata).fallback ^ (*_odata).fallback) & 0x01)
	    return 1;
    } else {
	if ((*_odata).bit_mask & 0x80000000) {
	    if ((Context::default_fallback ^ (*_odata).fallback) & 0x01)
		return 1;
	}
	if ((*_cdata).bit_mask & 0x80000000) {
	    if (((*_cdata).fallback ^ Context::default_fallback) & 0x01)
		return 1;
	}
    }

    return _res;
}

static int _cmRDNSequence(OssGlobal * _g, _RDNSequence * * _odata, _RDNSequence * * _cdata)
{
    int _res = 0;

    {
	_RDNSequence *  _s_oss_tmp_1 = *_odata;
	_RDNSequence *  _d_oss_tmp_1 = *_cdata;

	while (_s_oss_tmp_1 && _d_oss_tmp_1) {
	    _res = _cmRelativeDistinguishedName(_g, &(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value));
	    if (_res)
		return _res;
	    _s_oss_tmp_1 = _s_oss_tmp_1->next;
	    _d_oss_tmp_1 = _d_oss_tmp_1->next;
	}
	if (_s_oss_tmp_1 || _d_oss_tmp_1)
	    return 1;
    }

    return _res;
}

static int _nDRDNSequence(OssGlobal * _g, _RDNSequence * * _odata, _RDNSequence * _cdata)
{
    int _res = _cmRDNSequence(_g, _odata, &_cdata);

    if (_res == -1)
	_oss_enc_error(_g, _type_not_supported_der_toed, 0);
    return _res;
}

static int _cm15AttributeTypeAndDistinguis(OssGlobal * _g, _AttributeTypeAndDistinguishedValue  * _odata, _AttributeTypeAndDistinguishedValue  * _cdata)
{
    int _res = 0;

    if (!((*_cdata).type).length)
	return 1;
    if (_oss_cmp_unbnd_octet_ia(&((*_odata).type), &((*_cdata).type), sizeof(((*_cdata).type).length), sizeof(((*_cdata).type).value[0]), (unsigned int)((char *)&((*_odata).type).value - (char *)&((*_odata).type))))
	return 1;
    _res = _oss_cmp_new_open_type(_g, ((*_odata).value).pduNum, ((*_cdata).value).pduNum, &(((*_odata).value).encoded), &(((*_cdata).value).encoded), *(void **)&(((*_odata).value).decoded), *(void **)&(((*_cdata).value).decoded));
    if (_res)
	return _res;
    if (((*_odata).bit_mask & (*_cdata).bit_mask) & 0x80000000) {
	if (((*_cdata).primaryDistinguished ^ (*_odata).primaryDistinguished) & 0x01)
	    return 1;
    } else {
	if ((*_odata).bit_mask & 0x80000000) {
	    if ((AttributeTypeAndDistinguishedValue::default_primaryDistinguished ^ (*_odata).primaryDistinguished) & 0x01)
		return 1;
	}
	if ((*_cdata).bit_mask & 0x80000000) {
	    if (((*_cdata).primaryDistinguished ^ AttributeTypeAndDistinguishedValue::default_primaryDistinguished) & 0x01)
		return 1;
	}
    }
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x40000000)
	return 1;
    if ((*_odata).bit_mask & 0x40000000) {
	{
	    _setof16 *  _s_2 = (*_odata).valuesWithContext;
	    _setof16 *  _d_2 = (*_cdata).valuesWithContext;
	    long        *_a, _i, _i_next, _c = 0L;

	    while (_s_2 && _d_2) {
		++ _c;
		_s_2 = _s_2->next;
		_d_2 = _d_2->next;
	    }
	    if (_s_2 || _d_2)
		return 1;
	    if (_c) {
		_a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
		for (_i = 0; _i < _c; _i ++)
		    _a[_i] = _i;
		_a[_c] = -1L;
		for (_s_2 = (*_odata).valuesWithContext; _s_2; _s_2 = _s_2->next) {
		    _i_next = _a[0]; _res = 1;
		    for (_d_2 = (*_cdata).valuesWithContext, _i = 0L; _d_2 && _i_next >= 0L && _a[_i_next] >= 0L; _d_2 = _d_2->next,
			    _i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
			if (_i < _i_next)
			    continue;
			if (((_s_2->value).bit_mask ^ (_d_2->value).bit_mask) & 0x80000000)
			    continue;
			if ((_s_2->value).bit_mask & 0x80000000) {
			    _res = _oss_cmp_new_open_type(_g, ((_s_2->value).distingAttrValue).pduNum, ((_d_2->value).distingAttrValue).pduNum, &(((_s_2->value).distingAttrValue).encoded), &(((_d_2->value).distingAttrValue).encoded), *(void **)&(((_s_2->value).distingAttrValue).decoded), *(void **)&(((_d_2->value).distingAttrValue).decoded));
			    if (_res)
				continue;
			}
			{
			    _setof15 * * _odata_3 = &((_s_2->value).contextList);
			    _setof15 * * _cdata_3 = &((_d_2->value).contextList);

			    {
				_setof15 *  _s_4 = *_odata_3;
				_setof15 *  _d_4 = *_cdata_3;
				long        *_a, _i, _i_next, _c = 0L;

				while (_s_4 && _d_4) {
				    ++ _c;
				    _s_4 = _s_4->next;
				    _d_4 = _d_4->next;
				}
				if (_s_4 || _d_4)
				    continue;
				if (_c) {
				    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
				    for (_i = 0; _i < _c; _i ++)
					_a[_i] = _i;
				    _a[_c] = -1L;
				    for (_s_4 = *_odata_3; _s_4; _s_4 = _s_4->next) {
					_i_next = _a[0]; _res = 1;
					for (_d_4 = *_cdata_3, _i = 0L; _d_4 && _i_next >= 0L && _a[_i_next] >= 0L; _d_4 = _d_4->next,
						_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
					    if (_i < _i_next)
						continue;
					    _res = _cmContext(_g, &(_s_4->value), &(_d_4->value));
					    if (_res)
						continue;
					    _res = 0; _a[_i] = _a[_i+1];
					    break;
					}
					if (_res)
					    break;
				    }
				    _oss_dec_freetempmem(_g, _a);
				    if (_res)
					continue;
				}
			    }
			}
			_res = 0; _a[_i] = _a[_i+1];
			break;
		    }
		    if (_res)
			break;
		}
		_oss_dec_freetempmem(_g, _a);
		if (_res)
		    return _res;
	    }
	}
    }

    return _res;
}

static int _cmRelativeDistinguishedName(OssGlobal * _g, _RelativeDistinguishedName * * _odata, _RelativeDistinguishedName * * _cdata)
{
    int _res = 0;

    {
	_RelativeDistinguishedName *  _s_1 = *_odata;
	_RelativeDistinguishedName *  _d_1 = *_cdata;
	long        *_a, _i, _i_next, _c = 0L;

	while (_s_1 && _d_1) {
	    ++ _c;
	    _s_1 = _s_1->next;
	    _d_1 = _d_1->next;
	}
	if (_s_1 || _d_1)
	    return 1;
	if (_c) {
	    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
	    for (_i = 0; _i < _c; _i ++)
		_a[_i] = _i;
	    _a[_c] = -1L;
	    for (_s_1 = *_odata; _s_1; _s_1 = _s_1->next) {
		_i_next = _a[0]; _res = 1;
		for (_d_1 = *_cdata, _i = 0L; _d_1 && _i_next >= 0L && _a[_i_next] >= 0L; _d_1 = _d_1->next,
			_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
		    if (_i < _i_next)
			continue;
		    _res = _cm15AttributeTypeAndDistinguis(_g, &(_s_1->value), &(_d_1->value));
		    if (_res)
			continue;
		    _res = 0; _a[_i] = _a[_i+1];
		    break;
		}
		if (_res)
		    break;
	    }
	    _oss_dec_freetempmem(_g, _a);
	    if (_res)
		return _res;
	}
    }

    return _res;
}

#ifdef OSS_COPY_VALUE
#define _oss_c ((_EncDecGlobals*)_g->encDecVar)

static _UnboundedDirectoryString  * _cpUnboundedDirectoryString(OssGlobal * _g, _UnboundedDirectoryString  * psVal, _UnboundedDirectoryString  * pdVal)
{
    if (!pdVal) {
	pdVal = (_UnboundedDirectoryString  *)_oss_dec_const_alloc(_g, sizeof(_UnboundedDirectoryString ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 1: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.uTF8String), &((*pdVal).u.uTF8String), sizeof(((*pdVal).u.uTF8String).length), sizeof(((*pdVal).u.uTF8String).value[0]), (unsigned int)((char *)&((*psVal).u.uTF8String).value - (char *)&((*psVal).u.uTF8String)));
	}   break;
	case 2: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.printableString), &((*pdVal).u.printableString), sizeof(((*pdVal).u.printableString).length), sizeof(((*pdVal).u.printableString).value[0]), (unsigned int)((char *)&((*psVal).u.printableString).value - (char *)&((*psVal).u.printableString)));
	}   break;
	case 3: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.teletexString), &((*pdVal).u.teletexString), sizeof(((*pdVal).u.teletexString).length), sizeof(((*pdVal).u.teletexString).value[0]), (unsigned int)((char *)&((*psVal).u.teletexString).value - (char *)&((*psVal).u.teletexString)));
	}   break;
	case 4: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.universalString), &((*pdVal).u.universalString), sizeof(((*pdVal).u.universalString).length), sizeof(((*pdVal).u.universalString).value[0]), (unsigned int)((char *)&((*psVal).u.universalString).value - (char *)&((*psVal).u.universalString)));
	}   break;
	case 5: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.bmpString), &((*pdVal).u.bmpString), sizeof(((*pdVal).u.bmpString).length), sizeof(((*pdVal).u.bmpString).value[0]), (unsigned int)((char *)&((*psVal).u.bmpString).value - (char *)&((*psVal).u.bmpString)));
	}   break;
	default:;
    }
    return pdVal;
}


static _ContextAssertion  * _cpContextAssertion(OssGlobal * _g, _ContextAssertion  * psVal, _ContextAssertion  * pdVal)
{
    if (!pdVal) {
	pdVal = (_ContextAssertion  *)_oss_dec_const_alloc(_g, sizeof(_ContextAssertion ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).contextType), &((*pdVal).contextType), sizeof(((*pdVal).contextType).length), sizeof(((*pdVal).contextType).value[0]), (unsigned int)((char *)&((*psVal).contextType).value - (char *)&((*psVal).contextType)));
    }
    {
	(*pdVal).contextValues = nullptr;
	if ((*psVal).contextValues) {
	    _setof11 *  s_oss_tmp_2 = (*psVal).contextValues;
	    _setof11 *  d_oss_tmp_2;

	    (*pdVal).contextValues = d_oss_tmp_2 = (_setof11 *)_oss_dec_getmem_internal(_g, sizeof(_setof11));
	    do {
		memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_setof11));
		{
		    int         _pduNum = (s_oss_tmp_2->value).pduNum;
		    _oss_cpy_new_open_type(_g, &_pduNum, &(s_oss_tmp_2->value).encoded, &(d_oss_tmp_2->value).encoded, *(void **)&(s_oss_tmp_2->value).decoded, (void **)&(d_oss_tmp_2->value).decoded);
		    (d_oss_tmp_2->value).pduNum = _pduNum;
		}
		if (s_oss_tmp_2->next)
		    d_oss_tmp_2->next = (_setof11 *)_oss_dec_getmem_internal(_g, sizeof(_setof11));
		s_oss_tmp_2 = s_oss_tmp_2->next;
		d_oss_tmp_2 = d_oss_tmp_2->next;
	    } while (s_oss_tmp_2);
	}
    }
    return pdVal;
}


static _choice1  * _cp_choice1(OssGlobal * _g, _choice1  * psVal, _choice1  * pdVal)
{
    if (!pdVal) {
	pdVal = (_choice1  *)_oss_dec_const_alloc(_g, sizeof(_choice1 ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 1: {
	    _oss_cpy_open_type(_g, (OpenType *)&((*psVal).u.single_ASN1_type), (OpenType *)&((*pdVal).u.single_ASN1_type));
	}   break;
	case 2: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.octet_aligned), &((*pdVal).u.octet_aligned), sizeof(((*pdVal).u.octet_aligned).length), sizeof(((*pdVal).u.octet_aligned).value[0]), (unsigned int)((char *)&((*psVal).u.octet_aligned).value - (char *)&((*psVal).u.octet_aligned)));
	}   break;
	case 3: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.arbitrary), &((*pdVal).u.arbitrary), sizeof(((*pdVal).u.arbitrary).length), -1L, (unsigned int)((char *)&((*psVal).u.arbitrary).value - (char *)&((*psVal).u.arbitrary)));
	}   break;
	default:;
    }
    return pdVal;
}


static _External  * _cpExternal(OssGlobal * _g, _External  * psVal, _External  * pdVal)
{
    if (!pdVal) {
	pdVal = (_External  *)_oss_dec_const_alloc(_g, sizeof(_External ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    if ((*psVal).bit_mask & 0x80000000) {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).direct_reference), &((*pdVal).direct_reference), sizeof(((*pdVal).direct_reference).length), sizeof(((*pdVal).direct_reference).value[0]), (unsigned int)((char *)&((*psVal).direct_reference).value - (char *)&((*psVal).direct_reference)));
    }
    if ((*psVal).bit_mask & 0x20000000) {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).data_value_descriptor), &((*pdVal).data_value_descriptor), sizeof(((*pdVal).data_value_descriptor).length), sizeof(((*pdVal).data_value_descriptor).value[0]), (unsigned int)((char *)&((*psVal).data_value_descriptor).value - (char *)&((*psVal).data_value_descriptor)));
    }
    {
	_cp_choice1(_g, &((*psVal).encoding), &((*pdVal).encoding));
    }
    return pdVal;
}


static _Name  * _cpName(OssGlobal * _g, _Name  * psVal, _Name  * pdVal)
{
    if (!pdVal) {
	pdVal = (_Name  *)_oss_dec_const_alloc(_g, sizeof(_Name ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 1: {
	    _cpRDNSequence(_g, &((*psVal).u.rdnSequence), &((*pdVal).u.rdnSequence));
	}   break;
	default:;
    }
    return pdVal;
}


static _AP_title  * _cpAP_title(OssGlobal * _g, _AP_title  * psVal, _AP_title  * pdVal)
{
    if (!pdVal) {
	pdVal = (_AP_title  *)_oss_dec_const_alloc(_g, sizeof(_AP_title ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 1: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.ap_title_form2), &((*pdVal).u.ap_title_form2), sizeof(((*pdVal).u.ap_title_form2).length), sizeof(((*pdVal).u.ap_title_form2).value[0]), (unsigned int)((char *)&((*psVal).u.ap_title_form2).value - (char *)&((*psVal).u.ap_title_form2)));
	}   break;
	case 2: {
	    (*pdVal).u.ap_title_form1 = nullptr;
	    (*pdVal).u.ap_title_form1 = _cpName(_g, (*psVal).u.ap_title_form1, (*pdVal).u.ap_title_form1);
	}   break;
	default:;
    }
    return pdVal;
}


static _AE_qualifier  * _cpAE_qualifier(OssGlobal * _g, _AE_qualifier  * psVal, _AE_qualifier  * pdVal)
{
    if (!pdVal) {
	pdVal = (_AE_qualifier  *)_oss_dec_const_alloc(_g, sizeof(_AE_qualifier ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 2: {
	    _cpRelativeDistinguishedName(_g, &((*psVal).u.ae_qualifier_form1), &((*pdVal).u.ae_qualifier_form1));
	}   break;
	default:;
    }
    return pdVal;
}


static _seq1 * * _cp_seq1(OssGlobal * _g, _seq1 * * psVal, _seq1 * * pdVal)
{
    if (!pdVal) {
	pdVal = (_seq1 * *)_oss_dec_const_alloc(_g, sizeof(_seq1 *));
    }
    *pdVal = (_seq1 *)_oss_dec_const_alloc(_g, sizeof(*(*pdVal)));
    memcpy(*pdVal, *psVal, sizeof(**pdVal));
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal)->other_mechanism_name), &((*pdVal)->other_mechanism_name), sizeof(((*pdVal)->other_mechanism_name).length), sizeof(((*pdVal)->other_mechanism_name).value[0]), (unsigned int)((char *)&((*psVal)->other_mechanism_name).value - (char *)&((*psVal)->other_mechanism_name)));
    }
    {
	int         _pduNum = ((*psVal)->other_mechanism_value).pduNum;
	_oss_cpy_new_open_type(_g, &_pduNum, &((*psVal)->other_mechanism_value).encoded, &((*pdVal)->other_mechanism_value).encoded, *(void **)&((*psVal)->other_mechanism_value).decoded, (void **)&((*pdVal)->other_mechanism_value).decoded);
	((*pdVal)->other_mechanism_value).pduNum = _pduNum;
    }
    return pdVal;
}


static _Authentication_value  * _cpAuthentication_value(OssGlobal * _g, _Authentication_value  * psVal, _Authentication_value  * pdVal)
{
    if (!pdVal) {
	pdVal = (_Authentication_value  *)_oss_dec_const_alloc(_g, sizeof(_Authentication_value ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 1: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.charstring), &((*pdVal).u.charstring), sizeof(((*pdVal).u.charstring).length), sizeof(((*pdVal).u.charstring).value[0]), (unsigned int)((char *)&((*psVal).u.charstring).value - (char *)&((*psVal).u.charstring)));
	}   break;
	case 2: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.bitstring), &((*pdVal).u.bitstring), sizeof(((*pdVal).u.bitstring).length), -1L, (unsigned int)((char *)&((*psVal).u.bitstring).value - (char *)&((*psVal).u.bitstring)));
	}   break;
	case 3: {
	    (*pdVal).u.external = nullptr;
	    (*pdVal).u.external = _cpExternal(_g, (*psVal).u.external, (*pdVal).u.external);
	}   break;
	case 4: {
	    _cp_seq1(_g, &((*psVal).u.other), &((*pdVal).u.other));
	}   break;
	default:;
    }
    return pdVal;
}


static _Application_context_name_list * * _cp13Application_context_name_l(OssGlobal * _g, _Application_context_name_list * * psVal, _Application_context_name_list * * pdVal)
{
    if (!pdVal) {
	pdVal = (_Application_context_name_list * *)_oss_dec_const_alloc(_g, sizeof(_Application_context_name_list *));
    }
    *pdVal = nullptr;
    if (*psVal) {
	_Application_context_name_list *  s_oss_tmp_1 = *psVal;
	_Application_context_name_list *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_Application_context_name_list *)_oss_dec_getmem_internal(_g, sizeof(_Application_context_name_list));
	do {
	    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_Application_context_name_list));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value), sizeof((d_oss_tmp_1->value).length), sizeof((d_oss_tmp_1->value).value[0]), (unsigned int)((char *)&(s_oss_tmp_1->value).value - (char *)&(s_oss_tmp_1->value)));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_Application_context_name_list *)_oss_dec_getmem_internal(_g, sizeof(_Application_context_name_list));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _Association_information * * _cpAssociation_information(OssGlobal * _g, _Association_information * * psVal, _Association_information * * pdVal)
{
    if (!pdVal) {
	pdVal = (_Association_information * *)_oss_dec_const_alloc(_g, sizeof(_Association_information *));
    }
    *pdVal = nullptr;
    if (*psVal) {
	_Association_information *  s_oss_tmp_1 = *psVal;
	_Association_information *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_Association_information *)_oss_dec_getmem_internal(_g, sizeof(_Association_information));
	do {
	    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_Association_information));
	    {
		_cpExternal(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_Association_information *)_oss_dec_getmem_internal(_g, sizeof(_Association_information));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _ConnectionData  * _cpConnectionData(OssGlobal * _g, _ConnectionData  * psVal, _ConnectionData  * pdVal)
{
    if (!pdVal) {
	pdVal = (_ConnectionData  *)_oss_dec_const_alloc(_g, sizeof(_ConnectionData ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 1: {
	    _oss_cpy_open_type(_g, (OpenType *)&((*psVal).u.open), (OpenType *)&((*pdVal).u.open));
	}   break;
	case 2: {
	    (*pdVal).u.recover = nullptr;
	    (*pdVal).u.recover = _cpSessionConnectionIdentifier(_g, (*psVal).u.recover, (*pdVal).u.recover);
	}   break;
	default:;
    }
    return pdVal;
}


static _User_data  * _cpUser_data(OssGlobal * _g, _User_data  * psVal, _User_data  * pdVal)
{
    if (!pdVal) {
	pdVal = (_User_data  *)_oss_dec_const_alloc(_g, sizeof(_User_data ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 1: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.simply_encoded_data), &((*pdVal).u.simply_encoded_data), sizeof(((*pdVal).u.simply_encoded_data).length), sizeof(((*pdVal).u.simply_encoded_data).value[0]), (unsigned int)((char *)&((*psVal).u.simply_encoded_data).value - (char *)&((*psVal).u.simply_encoded_data)));
	}   break;
	case 2: {
	    _cpFully_encoded_data(_g, &((*psVal).u.fully_encoded_data), &((*pdVal).u.fully_encoded_data));
	}   break;
	default:;
    }
    return pdVal;
}


static _seq7  * _cp_seq7(OssGlobal * _g, _seq7  * psVal, _seq7  * pdVal)
{
    if (!pdVal) {
	pdVal = (_seq7  *)_oss_dec_const_alloc(_g, sizeof(_seq7 ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).abstract_syntax_name), &((*pdVal).abstract_syntax_name), sizeof(((*pdVal).abstract_syntax_name).length), sizeof(((*pdVal).abstract_syntax_name).value[0]), (unsigned int)((char *)&((*psVal).abstract_syntax_name).value - (char *)&((*psVal).abstract_syntax_name)));
    }
    {
	(*pdVal).transfer_syntax_name_list = nullptr;
	if ((*psVal).transfer_syntax_name_list) {
	    _Application_context_name_list *  s_oss_tmp_2 = (*psVal).transfer_syntax_name_list;
	    _Application_context_name_list *  d_oss_tmp_2;

	    (*pdVal).transfer_syntax_name_list = d_oss_tmp_2 = (_Application_context_name_list *)_oss_dec_getmem_internal(_g, sizeof(_Application_context_name_list));
	    do {
		memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_Application_context_name_list));
		{
		    _oss_cpy_unbnd_octet_ia(_g, &(s_oss_tmp_2->value), &(d_oss_tmp_2->value), sizeof((d_oss_tmp_2->value).length), sizeof((d_oss_tmp_2->value).value[0]), (unsigned int)((char *)&(s_oss_tmp_2->value).value - (char *)&(s_oss_tmp_2->value)));
		}
		if (s_oss_tmp_2->next)
		    d_oss_tmp_2->next = (_Application_context_name_list *)_oss_dec_getmem_internal(_g, sizeof(_Application_context_name_list));
		s_oss_tmp_2 = s_oss_tmp_2->next;
		d_oss_tmp_2 = d_oss_tmp_2->next;
	    } while (s_oss_tmp_2);
	}
    }
    return pdVal;
}


static _Context_list * * _cpContext_list(OssGlobal * _g, _Context_list * * psVal, _Context_list * * pdVal)
{
    if (!pdVal) {
	pdVal = (_Context_list * *)_oss_dec_const_alloc(_g, sizeof(_Context_list *));
    }
    *pdVal = nullptr;
    if (*psVal) {
	_Context_list *  s_oss_tmp_1 = *psVal;
	_Context_list *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_Context_list *)_oss_dec_getmem_internal(_g, sizeof(_Context_list));
	do {
	    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_Context_list));
	    {
		_cp_seq7(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_Context_list *)_oss_dec_getmem_internal(_g, sizeof(_Context_list));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _seq8  * _cp_seq8(OssGlobal * _g, _seq8  * psVal, _seq8  * pdVal)
{
    if (!pdVal) {
	pdVal = (_seq8  *)_oss_dec_const_alloc(_g, sizeof(_seq8 ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).transfer_syntax_name), &((*pdVal).transfer_syntax_name), sizeof(((*pdVal).transfer_syntax_name).length), sizeof(((*pdVal).transfer_syntax_name).value[0]), (unsigned int)((char *)&((*psVal).transfer_syntax_name).value - (char *)&((*psVal).transfer_syntax_name)));
    }
    return pdVal;
}


static _Presentation_context_identifier_list * * _cp14Presentation_context_ident(OssGlobal * _g, _Presentation_context_identifier_list * * psVal, _Presentation_context_identifier_list * * pdVal)
{
    if (!pdVal) {
	pdVal = (_Presentation_context_identifier_list * *)_oss_dec_const_alloc(_g, sizeof(_Presentation_context_identifier_list *));
    }
    *pdVal = nullptr;
    if (*psVal) {
	_Presentation_context_identifier_list *  s_oss_tmp_1 = *psVal;
	_Presentation_context_identifier_list *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_Presentation_context_identifier_list *)_oss_dec_getmem_internal(_g, sizeof(_Presentation_context_identifier_list));
	do {
	    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_Presentation_context_identifier_list));
	    {
		_cp_seq8(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_Presentation_context_identifier_list *)_oss_dec_getmem_internal(_g, sizeof(_Presentation_context_identifier_list));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _seq9  * _cp_seq9(OssGlobal * _g, _seq9  * psVal, _seq9  * pdVal)
{
    if (!pdVal) {
	pdVal = (_seq9  *)_oss_dec_const_alloc(_g, sizeof(_seq9 ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    if ((*psVal).bit_mask & 0x80000000) {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).transfer_syntax_name), &((*pdVal).transfer_syntax_name), sizeof(((*pdVal).transfer_syntax_name).length), sizeof(((*pdVal).transfer_syntax_name).value[0]), (unsigned int)((char *)&((*psVal).transfer_syntax_name).value - (char *)&((*psVal).transfer_syntax_name)));
    }
    return pdVal;
}


static _Result_list * * _cpResult_list(OssGlobal * _g, _Result_list * * psVal, _Result_list * * pdVal)
{
    if (!pdVal) {
	pdVal = (_Result_list * *)_oss_dec_const_alloc(_g, sizeof(_Result_list *));
    }
    *pdVal = nullptr;
    if (*psVal) {
	_Result_list *  s_oss_tmp_1 = *psVal;
	_Result_list *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_Result_list *)_oss_dec_getmem_internal(_g, sizeof(_Result_list));
	do {
	    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_Result_list));
	    {
		_cp_seq9(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_Result_list *)_oss_dec_getmem_internal(_g, sizeof(_Result_list));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _PDV_list  * _cpPDV_list(OssGlobal * _g, _PDV_list  * psVal, _PDV_list  * pdVal)
{
    if (!pdVal) {
	pdVal = (_PDV_list  *)_oss_dec_const_alloc(_g, sizeof(_PDV_list ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    if ((*psVal).bit_mask & 0x80000000) {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).transfer_syntax_name), &((*pdVal).transfer_syntax_name), sizeof(((*pdVal).transfer_syntax_name).length), sizeof(((*pdVal).transfer_syntax_name).value[0]), (unsigned int)((char *)&((*psVal).transfer_syntax_name).value - (char *)&((*psVal).transfer_syntax_name)));
    }
    {
	switch (((*psVal).presentation_data_values).choice) {
	    case 1: {
		_oss_cpy_open_type(_g, (OpenType *)&(((*psVal).presentation_data_values).u.single_ASN1_type), (OpenType *)&(((*pdVal).presentation_data_values).u.single_ASN1_type));
	    }   break;
	    case 2: {
		_oss_cpy_unbnd_octet_ia(_g, &(((*psVal).presentation_data_values).u.octet_aligned), &(((*pdVal).presentation_data_values).u.octet_aligned), sizeof((((*pdVal).presentation_data_values).u.octet_aligned).length), sizeof((((*pdVal).presentation_data_values).u.octet_aligned).value[0]), (unsigned int)((char *)&(((*psVal).presentation_data_values).u.octet_aligned).value - (char *)&(((*psVal).presentation_data_values).u.octet_aligned)));
	    }   break;
	    case 3: {
		_oss_cpy_unbnd_octet_ia(_g, &(((*psVal).presentation_data_values).u.arbitrary), &(((*pdVal).presentation_data_values).u.arbitrary), sizeof((((*pdVal).presentation_data_values).u.arbitrary).length), -1L, (unsigned int)((char *)&(((*psVal).presentation_data_values).u.arbitrary).value - (char *)&(((*psVal).presentation_data_values).u.arbitrary)));
	    }   break;
	    default:;
	}
    }
    return pdVal;
}


static _Fully_encoded_data * * _cpFully_encoded_data(OssGlobal * _g, _Fully_encoded_data * * psVal, _Fully_encoded_data * * pdVal)
{
    if (!pdVal) {
	pdVal = (_Fully_encoded_data * *)_oss_dec_const_alloc(_g, sizeof(_Fully_encoded_data *));
    }
    *pdVal = nullptr;
    if (*psVal) {
	_Fully_encoded_data *  s_oss_tmp_1 = *psVal;
	_Fully_encoded_data *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_Fully_encoded_data *)_oss_dec_getmem_internal(_g, sizeof(_Fully_encoded_data));
	do {
	    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_Fully_encoded_data));
	    {
		_cpPDV_list(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_Fully_encoded_data *)_oss_dec_getmem_internal(_g, sizeof(_Fully_encoded_data));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _set1  * _cpRTORQapdu(OssGlobal * _g, _set1  * psVal, _set1  * pdVal)
{
    if (!pdVal) {
	pdVal = (_set1  *)_oss_dec_const_alloc(_g, sizeof(_set1 ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    {
	_cpConnectionData(_g, &((*psVal).connectionDataRQ), &((*pdVal).connectionDataRQ));
    }
    return pdVal;
}


static _set2  * _cpRTOACapdu(OssGlobal * _g, _set2  * psVal, _set2  * pdVal)
{
    if (!pdVal) {
	pdVal = (_set2  *)_oss_dec_const_alloc(_g, sizeof(_set2 ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    {
	_cpConnectionData(_g, &((*psVal).connectionDataAC), &((*pdVal).connectionDataAC));
    }
    return pdVal;
}


static _set3  * _cpRTORJapdu(OssGlobal * _g, _set3  * psVal, _set3  * pdVal)
{
    if (!pdVal) {
	pdVal = (_set3  *)_oss_dec_const_alloc(_g, sizeof(_set3 ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    if ((*psVal).bit_mask & 0x40000000) {
	_oss_cpy_open_type(_g, (OpenType *)&((*psVal).userDataRJ), (OpenType *)&((*pdVal).userDataRJ));
    }
    return pdVal;
}


static _CallingSSuserReference  * _cpCallingSSuserReference(OssGlobal * _g, _CallingSSuserReference  * psVal, _CallingSSuserReference  * pdVal)
{
    if (!pdVal) {
	pdVal = (_CallingSSuserReference  *)_oss_dec_const_alloc(_g, sizeof(_CallingSSuserReference ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 1: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.octetString), &((*pdVal).u.octetString), sizeof(((*pdVal).u.octetString).length), sizeof(((*pdVal).u.octetString).value[0]), (unsigned int)((char *)&((*psVal).u.octetString).value - (char *)&((*psVal).u.octetString)));
	}   break;
	case 2: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.t61String), &((*pdVal).u.t61String), sizeof(((*pdVal).u.t61String).length), sizeof(((*pdVal).u.t61String).value[0]), (unsigned int)((char *)&((*psVal).u.t61String).value - (char *)&((*psVal).u.t61String)));
	}   break;
	default:;
    }
    return pdVal;
}


static _SessionConnectionIdentifier  * _cpSessionConnectionIdentifier(OssGlobal * _g, _SessionConnectionIdentifier  * psVal, _SessionConnectionIdentifier  * pdVal)
{
    if (!pdVal) {
	pdVal = (_SessionConnectionIdentifier  *)_oss_dec_const_alloc(_g, sizeof(_SessionConnectionIdentifier ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    {
	_cpCallingSSuserReference(_g, &((*psVal).callingSSuserReference), &((*pdVal).callingSSuserReference));
    }
    {
	size_t  len_1 = (size_t)sizeof(char) * (strlen((*psVal).commonReference) + 1);

	(*pdVal).commonReference = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
	strcpy((*pdVal).commonReference, (*psVal).commonReference);
    }
    if ((*psVal).bit_mask & 0x80000000) {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).additionalReferenceInformation), &((*pdVal).additionalReferenceInformation), sizeof(((*pdVal).additionalReferenceInformation).length), sizeof(((*pdVal).additionalReferenceInformation).value[0]), (unsigned int)((char *)&((*psVal).additionalReferenceInformation).value - (char *)&((*psVal).additionalReferenceInformation)));
    }
    return pdVal;
}


static _Criteria  * _cpCriteria(OssGlobal * _g, _Criteria  * psVal, _Criteria  * pdVal)
{
    if (!pdVal) {
	pdVal = (_Criteria  *)_oss_dec_const_alloc(_g, sizeof(_Criteria ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 1: {
	    (*pdVal).u.type = nullptr;
	    (*pdVal).u.type = _cpCriteriaItem(_g, (*psVal).u.type, (*pdVal).u.type);
	}   break;
	case 2: {
	    _cp_setof1(_g, &((*psVal).u.Criteria_and), &((*pdVal).u.Criteria_and));
	}   break;
	case 3: {
	    _cp_setof2(_g, &((*psVal).u.Criteria_or), &((*pdVal).u.Criteria_or));
	}   break;
	case 4: {
	    (*pdVal).u.Criteria_not = nullptr;
	    (*pdVal).u.Criteria_not = _cpCriteria(_g, (*psVal).u.Criteria_not, (*pdVal).u.Criteria_not);
	}   break;
	default:;
    }
    return pdVal;
}


static _setof1 * * _cp_setof2(OssGlobal * _g, _setof1 * * psVal, _setof1 * * pdVal)
{
    if (!pdVal) {
	pdVal = (_setof1 * *)_oss_dec_const_alloc(_g, sizeof(_setof1 *));
    }
    *pdVal = nullptr;
    if (*psVal) {
	_setof1 *  s_oss_tmp_1 = *psVal;
	_setof1 *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_setof1 *)_oss_dec_getmem_internal(_g, sizeof(_setof1));
	do {
	    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_setof1));
	    {
		_cpCriteria(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_setof1 *)_oss_dec_getmem_internal(_g, sizeof(_setof1));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _setof1 * * _cp_setof1(OssGlobal * _g, _setof1 * * psVal, _setof1 * * pdVal)
{
    if (!pdVal) {
	pdVal = (_setof1 * *)_oss_dec_const_alloc(_g, sizeof(_setof1 *));
    }
    *pdVal = nullptr;
    if (*psVal) {
	_setof1 *  s_oss_tmp_1 = *psVal;
	_setof1 *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_setof1 *)_oss_dec_getmem_internal(_g, sizeof(_setof1));
	do {
	    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_setof1));
	    {
		_cpCriteria(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_setof1 *)_oss_dec_getmem_internal(_g, sizeof(_setof1));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _CriteriaItem  * _cpCriteriaItem(OssGlobal * _g, _CriteriaItem  * psVal, _CriteriaItem  * pdVal)
{
    if (!pdVal) {
	pdVal = (_CriteriaItem  *)_oss_dec_const_alloc(_g, sizeof(_CriteriaItem ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 1: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.equality), &((*pdVal).u.equality), sizeof(((*pdVal).u.equality).length), sizeof(((*pdVal).u.equality).value[0]), (unsigned int)((char *)&((*psVal).u.equality).value - (char *)&((*psVal).u.equality)));
	}   break;
	case 2: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.substrings), &((*pdVal).u.substrings), sizeof(((*pdVal).u.substrings).length), sizeof(((*pdVal).u.substrings).value[0]), (unsigned int)((char *)&((*psVal).u.substrings).value - (char *)&((*psVal).u.substrings)));
	}   break;
	case 3: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.greaterOrEqual), &((*pdVal).u.greaterOrEqual), sizeof(((*pdVal).u.greaterOrEqual).length), sizeof(((*pdVal).u.greaterOrEqual).value[0]), (unsigned int)((char *)&((*psVal).u.greaterOrEqual).value - (char *)&((*psVal).u.greaterOrEqual)));
	}   break;
	case 4: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.lessOrEqual), &((*pdVal).u.lessOrEqual), sizeof(((*pdVal).u.lessOrEqual).length), sizeof(((*pdVal).u.lessOrEqual).value[0]), (unsigned int)((char *)&((*psVal).u.lessOrEqual).value - (char *)&((*psVal).u.lessOrEqual)));
	}   break;
	case 5: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.approximateMatch), &((*pdVal).u.approximateMatch), sizeof(((*pdVal).u.approximateMatch).length), sizeof(((*pdVal).u.approximateMatch).value[0]), (unsigned int)((char *)&((*psVal).u.approximateMatch).value - (char *)&((*psVal).u.approximateMatch)));
	}   break;
	default:;
    }
    return pdVal;
}


static _NamedDay  * _cpNamedDay(OssGlobal * _g, _NamedDay  * psVal, _NamedDay  * pdVal)
{
    if (!pdVal) {
	pdVal = (_NamedDay  *)_oss_dec_const_alloc(_g, sizeof(_NamedDay ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 1: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.bitNamedDays), &((*pdVal).u.bitNamedDays), sizeof(((*pdVal).u.bitNamedDays).length), -1L, (unsigned int)((char *)&((*psVal).u.bitNamedDays).value - (char *)&((*psVal).u.bitNamedDays)));
	}   break;
	default:;
    }
    return pdVal;
}


static _Context  * _cpContext(OssGlobal * _g, _Context  * psVal, _Context  * pdVal)
{
    if (!pdVal) {
	pdVal = (_Context  *)_oss_dec_const_alloc(_g, sizeof(_Context ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).contextType), &((*pdVal).contextType), sizeof(((*pdVal).contextType).length), sizeof(((*pdVal).contextType).value[0]), (unsigned int)((char *)&((*psVal).contextType).value - (char *)&((*psVal).contextType)));
    }
    {
	(*pdVal).contextValues = nullptr;
	if ((*psVal).contextValues) {
	    _setof11 *  s_oss_tmp_2 = (*psVal).contextValues;
	    _setof11 *  d_oss_tmp_2;

	    (*pdVal).contextValues = d_oss_tmp_2 = (_setof11 *)_oss_dec_getmem_internal(_g, sizeof(_setof11));
	    do {
		memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_setof11));
		{
		    int         _pduNum = (s_oss_tmp_2->value).pduNum;
		    _oss_cpy_new_open_type(_g, &_pduNum, &(s_oss_tmp_2->value).encoded, &(d_oss_tmp_2->value).encoded, *(void **)&(s_oss_tmp_2->value).decoded, (void **)&(d_oss_tmp_2->value).decoded);
		    (d_oss_tmp_2->value).pduNum = _pduNum;
		}
		if (s_oss_tmp_2->next)
		    d_oss_tmp_2->next = (_setof11 *)_oss_dec_getmem_internal(_g, sizeof(_setof11));
		s_oss_tmp_2 = s_oss_tmp_2->next;
		d_oss_tmp_2 = d_oss_tmp_2->next;
	    } while (s_oss_tmp_2);
	}
    }
    return pdVal;
}


static _RDNSequence * * _cpRDNSequence(OssGlobal * _g, _RDNSequence * * psVal, _RDNSequence * * pdVal)
{
    if (!pdVal) {
	pdVal = (_RDNSequence * *)_oss_dec_const_alloc(_g, sizeof(_RDNSequence *));
    }
    *pdVal = nullptr;
    if (*psVal) {
	_RDNSequence *  s_oss_tmp_1 = *psVal;
	_RDNSequence *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_RDNSequence *)_oss_dec_getmem_internal(_g, sizeof(_RDNSequence));
	do {
	    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_RDNSequence));
	    {
		_cpRelativeDistinguishedName(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_RDNSequence *)_oss_dec_getmem_internal(_g, sizeof(_RDNSequence));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _AttributeTypeAndDistinguishedValue  * _cp15AttributeTypeAndDistinguis(OssGlobal * _g, _AttributeTypeAndDistinguishedValue  * psVal, _AttributeTypeAndDistinguishedValue  * pdVal)
{
    if (!pdVal) {
	pdVal = (_AttributeTypeAndDistinguishedValue  *)_oss_dec_const_alloc(_g, sizeof(_AttributeTypeAndDistinguishedValue ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).type), &((*pdVal).type), sizeof(((*pdVal).type).length), sizeof(((*pdVal).type).value[0]), (unsigned int)((char *)&((*psVal).type).value - (char *)&((*psVal).type)));
    }
    {
	int         _pduNum = ((*psVal).value).pduNum;
	_oss_cpy_new_open_type(_g, &_pduNum, &((*psVal).value).encoded, &((*pdVal).value).encoded, *(void **)&((*psVal).value).decoded, (void **)&((*pdVal).value).decoded);
	((*pdVal).value).pduNum = _pduNum;
    }
    if ((*psVal).bit_mask & 0x40000000) {
	(*pdVal).valuesWithContext = nullptr;
	if ((*psVal).valuesWithContext) {
	    _setof16 *  s_oss_tmp_2 = (*psVal).valuesWithContext;
	    _setof16 *  d_oss_tmp_2;

	    (*pdVal).valuesWithContext = d_oss_tmp_2 = (_setof16 *)_oss_dec_getmem_internal(_g, sizeof(_setof16));
	    do {
		memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_setof16));
		{
		    if ((s_oss_tmp_2->value).bit_mask & 0x80000000) {
			int         _pduNum = ((s_oss_tmp_2->value).distingAttrValue).pduNum;
			_oss_cpy_new_open_type(_g, &_pduNum, &((s_oss_tmp_2->value).distingAttrValue).encoded, &((d_oss_tmp_2->value).distingAttrValue).encoded, *(void **)&((s_oss_tmp_2->value).distingAttrValue).decoded, (void **)&((d_oss_tmp_2->value).distingAttrValue).decoded);
			((d_oss_tmp_2->value).distingAttrValue).pduNum = _pduNum;
		    }
		    {
			_setof15 * * src_3 = &((s_oss_tmp_2->value).contextList);
			_setof15 * * dst_3 = &((d_oss_tmp_2->value).contextList);

			*dst_3 = nullptr;
			if (*src_3) {
			    _setof15 *  s_oss_tmp_4 = *src_3;
			    _setof15 *  d_oss_tmp_4;

			    *dst_3 = d_oss_tmp_4 = (_setof15 *)_oss_dec_getmem_internal(_g, sizeof(_setof15));
			    do {
				memcpy(d_oss_tmp_4, s_oss_tmp_4, sizeof(_setof15));
				{
				    _cpContext(_g, &(s_oss_tmp_4->value), &(d_oss_tmp_4->value));
				}
				if (s_oss_tmp_4->next)
				    d_oss_tmp_4->next = (_setof15 *)_oss_dec_getmem_internal(_g, sizeof(_setof15));
				s_oss_tmp_4 = s_oss_tmp_4->next;
				d_oss_tmp_4 = d_oss_tmp_4->next;
			    } while (s_oss_tmp_4);
			}
		    }
		}
		if (s_oss_tmp_2->next)
		    d_oss_tmp_2->next = (_setof16 *)_oss_dec_getmem_internal(_g, sizeof(_setof16));
		s_oss_tmp_2 = s_oss_tmp_2->next;
		d_oss_tmp_2 = d_oss_tmp_2->next;
	    } while (s_oss_tmp_2);
	}
    }
    return pdVal;
}


static _RelativeDistinguishedName * * _cpRelativeDistinguishedName(OssGlobal * _g, _RelativeDistinguishedName * * psVal, _RelativeDistinguishedName * * pdVal)
{
    if (!pdVal) {
	pdVal = (_RelativeDistinguishedName * *)_oss_dec_const_alloc(_g, sizeof(_RelativeDistinguishedName *));
    }
    *pdVal = nullptr;
    if (*psVal) {
	_RelativeDistinguishedName *  s_oss_tmp_1 = *psVal;
	_RelativeDistinguishedName *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_RelativeDistinguishedName *)_oss_dec_getmem_internal(_g, sizeof(_RelativeDistinguishedName));
	do {
	    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_RelativeDistinguishedName));
	    {
		_cp15AttributeTypeAndDistinguis(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_RelativeDistinguishedName *)_oss_dec_getmem_internal(_g, sizeof(_RelativeDistinguishedName));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _Refinement  * _cpRefinement(OssGlobal * _g, _Refinement  * psVal, _Refinement  * pdVal)
{
    if (!pdVal) {
	pdVal = (_Refinement  *)_oss_dec_const_alloc(_g, sizeof(_Refinement ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    switch ((*psVal).choice) {
	case 1: {
	    _oss_cpy_unbnd_octet_ia(_g, &((*psVal).u.item), &((*pdVal).u.item), sizeof(((*pdVal).u.item).length), sizeof(((*pdVal).u.item).value[0]), (unsigned int)((char *)&((*psVal).u.item).value - (char *)&((*psVal).u.item)));
	}   break;
	case 2: {
	    _cp_setof17(_g, &((*psVal).u.Refinement_and), &((*pdVal).u.Refinement_and));
	}   break;
	case 3: {
	    _cp_setof18(_g, &((*psVal).u.Refinement_or), &((*pdVal).u.Refinement_or));
	}   break;
	case 4: {
	    (*pdVal).u.Refinement_not = nullptr;
	    (*pdVal).u.Refinement_not = _cpRefinement(_g, (*psVal).u.Refinement_not, (*pdVal).u.Refinement_not);
	}   break;
	default:;
    }
    return pdVal;
}


static _setof17 * * _cp_setof18(OssGlobal * _g, _setof17 * * psVal, _setof17 * * pdVal)
{
    if (!pdVal) {
	pdVal = (_setof17 * *)_oss_dec_const_alloc(_g, sizeof(_setof17 *));
    }
    *pdVal = nullptr;
    if (*psVal) {
	_setof17 *  s_oss_tmp_1 = *psVal;
	_setof17 *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_setof17 *)_oss_dec_getmem_internal(_g, sizeof(_setof17));
	do {
	    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_setof17));
	    {
		_cpRefinement(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_setof17 *)_oss_dec_getmem_internal(_g, sizeof(_setof17));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _setof17 * * _cp_setof17(OssGlobal * _g, _setof17 * * psVal, _setof17 * * pdVal)
{
    if (!pdVal) {
	pdVal = (_setof17 * *)_oss_dec_const_alloc(_g, sizeof(_setof17 *));
    }
    *pdVal = nullptr;
    if (*psVal) {
	_setof17 *  s_oss_tmp_1 = *psVal;
	_setof17 *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_setof17 *)_oss_dec_getmem_internal(_g, sizeof(_setof17));
	do {
	    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_setof17));
	    {
		_cpRefinement(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_setof17 *)_oss_dec_getmem_internal(_g, sizeof(_setof17));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


int DLL_ENTRY_FDEF _CPUpperBounds_(struct ossGlobal * _g, int pduNum, void * src, void ** pdst)
{
    int res = 0;
    void *pdVal = nullptr;

    if (pduNum <= 0 || pduNum > 86)
	return PDU_RANGE;
    switch (pduNum) {
	case 1: {
	    pdVal = (OSSC::COssEncOID  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssEncOID  *)src, (OSSC::COssEncOID  *)pdVal, sizeof((*(OSSC::COssEncOID  *)pdVal).length), sizeof((*(OSSC::COssEncOID  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssEncOID  *)src).value - (char *)(OSSC::COssEncOID  *)src));
	} break;
	case 2: {
	    pdVal = (_ACSE_apdu  *)_oss_dec_const_alloc(_g, sizeof(_ACSE_apdu ));
	    memcpy((_ACSE_apdu  *)pdVal, (_ACSE_apdu  *)src, sizeof(*(_ACSE_apdu  *)pdVal));
	    switch ((*(_ACSE_apdu  *)src).choice) {
		case 1: {
		    (*(_ACSE_apdu  *)pdVal).u.aarq = (_AARQ_apdu  *)_oss_dec_const_alloc(_g, sizeof(_AARQ_apdu ));
		    memcpy((*(_ACSE_apdu  *)pdVal).u.aarq, (*(_ACSE_apdu  *)src).u.aarq, sizeof(*(*(_ACSE_apdu  *)pdVal).u.aarq));
		    if ((*(*(_ACSE_apdu  *)src).u.aarq).bit_mask & 0x80000000) {
			_oss_cpy_unbnd_octet_ia(_g, &((*(*(_ACSE_apdu  *)src).u.aarq).protocol_version), &((*(*(_ACSE_apdu  *)pdVal).u.aarq).protocol_version), sizeof(((*(*(_ACSE_apdu  *)pdVal).u.aarq).protocol_version).length), -1L, (unsigned int)((char *)&((*(*(_ACSE_apdu  *)src).u.aarq).protocol_version).value - (char *)&((*(*(_ACSE_apdu  *)src).u.aarq).protocol_version)));
		    }
		    {
			_oss_cpy_unbnd_octet_ia(_g, &((*(*(_ACSE_apdu  *)src).u.aarq).application_context_name), &((*(*(_ACSE_apdu  *)pdVal).u.aarq).application_context_name), sizeof(((*(*(_ACSE_apdu  *)pdVal).u.aarq).application_context_name).length), sizeof(((*(*(_ACSE_apdu  *)pdVal).u.aarq).application_context_name).value[0]), (unsigned int)((char *)&((*(*(_ACSE_apdu  *)src).u.aarq).application_context_name).value - (char *)&((*(*(_ACSE_apdu  *)src).u.aarq).application_context_name)));
		    }
		    if ((*(*(_ACSE_apdu  *)src).u.aarq).bit_mask & 0x40000000) {
			_cpAP_title(_g, &((*(*(_ACSE_apdu  *)src).u.aarq).called_AP_title), &((*(*(_ACSE_apdu  *)pdVal).u.aarq).called_AP_title));
		    }
		    if ((*(*(_ACSE_apdu  *)src).u.aarq).bit_mask & 0x20000000) {
			_cpAE_qualifier(_g, &((*(*(_ACSE_apdu  *)src).u.aarq).called_AE_qualifier), &((*(*(_ACSE_apdu  *)pdVal).u.aarq).called_AE_qualifier));
		    }
		    if ((*(*(_ACSE_apdu  *)src).u.aarq).bit_mask & 0x4000000) {
			_cpAP_title(_g, &((*(*(_ACSE_apdu  *)src).u.aarq).calling_AP_title), &((*(*(_ACSE_apdu  *)pdVal).u.aarq).calling_AP_title));
		    }
		    if ((*(*(_ACSE_apdu  *)src).u.aarq).bit_mask & 0x2000000) {
			_cpAE_qualifier(_g, &((*(*(_ACSE_apdu  *)src).u.aarq).calling_AE_qualifier), &((*(*(_ACSE_apdu  *)pdVal).u.aarq).calling_AE_qualifier));
		    }
		    if ((*(*(_ACSE_apdu  *)src).u.aarq).bit_mask & 0x400000) {
			_oss_cpy_unbnd_octet_ia(_g, &((*(*(_ACSE_apdu  *)src).u.aarq).sender_acse_requirements), &((*(*(_ACSE_apdu  *)pdVal).u.aarq).sender_acse_requirements), sizeof(((*(*(_ACSE_apdu  *)pdVal).u.aarq).sender_acse_requirements).length), -1L, (unsigned int)((char *)&((*(*(_ACSE_apdu  *)src).u.aarq).sender_acse_requirements).value - (char *)&((*(*(_ACSE_apdu  *)src).u.aarq).sender_acse_requirements)));
		    }
		    if ((*(*(_ACSE_apdu  *)src).u.aarq).bit_mask & 0x200000) {
			_oss_cpy_unbnd_octet_ia(_g, &((*(*(_ACSE_apdu  *)src).u.aarq).mechanism_name), &((*(*(_ACSE_apdu  *)pdVal).u.aarq).mechanism_name), sizeof(((*(*(_ACSE_apdu  *)pdVal).u.aarq).mechanism_name).length), sizeof(((*(*(_ACSE_apdu  *)pdVal).u.aarq).mechanism_name).value[0]), (unsigned int)((char *)&((*(*(_ACSE_apdu  *)src).u.aarq).mechanism_name).value - (char *)&((*(*(_ACSE_apdu  *)src).u.aarq).mechanism_name)));
		    }
		    if ((*(*(_ACSE_apdu  *)src).u.aarq).bit_mask & 0x100000) {
			_cpAuthentication_value(_g, &((*(*(_ACSE_apdu  *)src).u.aarq).calling_authentication_value), &((*(*(_ACSE_apdu  *)pdVal).u.aarq).calling_authentication_value));
		    }
		    if ((*(*(_ACSE_apdu  *)src).u.aarq).bit_mask & 0x80000) {
			_cp13Application_context_name_l(_g, &((*(*(_ACSE_apdu  *)src).u.aarq).application_context_name_list), &((*(*(_ACSE_apdu  *)pdVal).u.aarq).application_context_name_list));
		    }
		    if ((*(*(_ACSE_apdu  *)src).u.aarq).bit_mask & 0x40000) {
			_oss_cpy_unbnd_octet_ia(_g, &((*(*(_ACSE_apdu  *)src).u.aarq).implementation_information), &((*(*(_ACSE_apdu  *)pdVal).u.aarq).implementation_information), sizeof(((*(*(_ACSE_apdu  *)pdVal).u.aarq).implementation_information).length), sizeof(((*(*(_ACSE_apdu  *)pdVal).u.aarq).implementation_information).value[0]), (unsigned int)((char *)&((*(*(_ACSE_apdu  *)src).u.aarq).implementation_information).value - (char *)&((*(*(_ACSE_apdu  *)src).u.aarq).implementation_information)));
		    }
		    if ((*(*(_ACSE_apdu  *)src).u.aarq).bit_mask & 0x20000) {
			_cpAssociation_information(_g, &((*(*(_ACSE_apdu  *)src).u.aarq).user_information), &((*(*(_ACSE_apdu  *)pdVal).u.aarq).user_information));
		    }
		}   break;
		case 2: {
		    (*(_ACSE_apdu  *)pdVal).u.aare = (_AARE_apdu  *)_oss_dec_const_alloc(_g, sizeof(_AARE_apdu ));
		    memcpy((*(_ACSE_apdu  *)pdVal).u.aare, (*(_ACSE_apdu  *)src).u.aare, sizeof(*(*(_ACSE_apdu  *)pdVal).u.aare));
		    if ((*(*(_ACSE_apdu  *)src).u.aare).bit_mask & 0x80000000) {
			_oss_cpy_unbnd_octet_ia(_g, &((*(*(_ACSE_apdu  *)src).u.aare).protocol_version), &((*(*(_ACSE_apdu  *)pdVal).u.aare).protocol_version), sizeof(((*(*(_ACSE_apdu  *)pdVal).u.aare).protocol_version).length), -1L, (unsigned int)((char *)&((*(*(_ACSE_apdu  *)src).u.aare).protocol_version).value - (char *)&((*(*(_ACSE_apdu  *)src).u.aare).protocol_version)));
		    }
		    {
			_oss_cpy_unbnd_octet_ia(_g, &((*(*(_ACSE_apdu  *)src).u.aare).application_context_name), &((*(*(_ACSE_apdu  *)pdVal).u.aare).application_context_name), sizeof(((*(*(_ACSE_apdu  *)pdVal).u.aare).application_context_name).length), sizeof(((*(*(_ACSE_apdu  *)pdVal).u.aare).application_context_name).value[0]), (unsigned int)((char *)&((*(*(_ACSE_apdu  *)src).u.aare).application_context_name).value - (char *)&((*(*(_ACSE_apdu  *)src).u.aare).application_context_name)));
		    }
		    if ((*(*(_ACSE_apdu  *)src).u.aare).bit_mask & 0x40000000) {
			_cpAP_title(_g, &((*(*(_ACSE_apdu  *)src).u.aare).responding_AP_title), &((*(*(_ACSE_apdu  *)pdVal).u.aare).responding_AP_title));
		    }
		    if ((*(*(_ACSE_apdu  *)src).u.aare).bit_mask & 0x20000000) {
			_cpAE_qualifier(_g, &((*(*(_ACSE_apdu  *)src).u.aare).responding_AE_qualifier), &((*(*(_ACSE_apdu  *)pdVal).u.aare).responding_AE_qualifier));
		    }
		    if ((*(*(_ACSE_apdu  *)src).u.aare).bit_mask & 0x4000000) {
			_oss_cpy_unbnd_octet_ia(_g, &((*(*(_ACSE_apdu  *)src).u.aare).responder_acse_requirements), &((*(*(_ACSE_apdu  *)pdVal).u.aare).responder_acse_requirements), sizeof(((*(*(_ACSE_apdu  *)pdVal).u.aare).responder_acse_requirements).length), -1L, (unsigned int)((char *)&((*(*(_ACSE_apdu  *)src).u.aare).responder_acse_requirements).value - (char *)&((*(*(_ACSE_apdu  *)src).u.aare).responder_acse_requirements)));
		    }
		    if ((*(*(_ACSE_apdu  *)src).u.aare).bit_mask & 0x2000000) {
			_oss_cpy_unbnd_octet_ia(_g, &((*(*(_ACSE_apdu  *)src).u.aare).mechanism_name), &((*(*(_ACSE_apdu  *)pdVal).u.aare).mechanism_name), sizeof(((*(*(_ACSE_apdu  *)pdVal).u.aare).mechanism_name).length), sizeof(((*(*(_ACSE_apdu  *)pdVal).u.aare).mechanism_name).value[0]), (unsigned int)((char *)&((*(*(_ACSE_apdu  *)src).u.aare).mechanism_name).value - (char *)&((*(*(_ACSE_apdu  *)src).u.aare).mechanism_name)));
		    }
		    if ((*(*(_ACSE_apdu  *)src).u.aare).bit_mask & 0x1000000) {
			_cpAuthentication_value(_g, &((*(*(_ACSE_apdu  *)src).u.aare).responding_authentication_value), &((*(*(_ACSE_apdu  *)pdVal).u.aare).responding_authentication_value));
		    }
		    if ((*(*(_ACSE_apdu  *)src).u.aare).bit_mask & 0x800000) {
			_cp13Application_context_name_l(_g, &((*(*(_ACSE_apdu  *)src).u.aare).application_context_name_list), &((*(*(_ACSE_apdu  *)pdVal).u.aare).application_context_name_list));
		    }
		    if ((*(*(_ACSE_apdu  *)src).u.aare).bit_mask & 0x400000) {
			_oss_cpy_unbnd_octet_ia(_g, &((*(*(_ACSE_apdu  *)src).u.aare).implementation_information), &((*(*(_ACSE_apdu  *)pdVal).u.aare).implementation_information), sizeof(((*(*(_ACSE_apdu  *)pdVal).u.aare).implementation_information).length), sizeof(((*(*(_ACSE_apdu  *)pdVal).u.aare).implementation_information).value[0]), (unsigned int)((char *)&((*(*(_ACSE_apdu  *)src).u.aare).implementation_information).value - (char *)&((*(*(_ACSE_apdu  *)src).u.aare).implementation_information)));
		    }
		    if ((*(*(_ACSE_apdu  *)src).u.aare).bit_mask & 0x200000) {
			_cpAssociation_information(_g, &((*(*(_ACSE_apdu  *)src).u.aare).user_information), &((*(*(_ACSE_apdu  *)pdVal).u.aare).user_information));
		    }
		}   break;
		case 3: {
		    (*(_ACSE_apdu  *)pdVal).u.rlrq = (_RLRQ_apdu  *)_oss_dec_const_alloc(_g, sizeof(_RLRQ_apdu ));
		    memcpy((*(_ACSE_apdu  *)pdVal).u.rlrq, (*(_ACSE_apdu  *)src).u.rlrq, sizeof(*(*(_ACSE_apdu  *)pdVal).u.rlrq));
		    if ((*(*(_ACSE_apdu  *)src).u.rlrq).bit_mask & 0x40000000) {
			_cpAssociation_information(_g, &((*(*(_ACSE_apdu  *)src).u.rlrq).user_information), &((*(*(_ACSE_apdu  *)pdVal).u.rlrq).user_information));
		    }
		}   break;
		case 4: {
		    (*(_ACSE_apdu  *)pdVal).u.rlre = (_RLRQ_apdu  *)_oss_dec_const_alloc(_g, sizeof(_RLRQ_apdu ));
		    memcpy((*(_ACSE_apdu  *)pdVal).u.rlre, (*(_ACSE_apdu  *)src).u.rlre, sizeof(*(*(_ACSE_apdu  *)pdVal).u.rlre));
		    if ((*(*(_ACSE_apdu  *)src).u.rlre).bit_mask & 0x40000000) {
			_cpAssociation_information(_g, &((*(*(_ACSE_apdu  *)src).u.rlre).user_information), &((*(*(_ACSE_apdu  *)pdVal).u.rlre).user_information));
		    }
		}   break;
		case 5: {
		    (*(_ACSE_apdu  *)pdVal).u.abrt = (_ABRT_apdu  *)_oss_dec_const_alloc(_g, sizeof(_ABRT_apdu ));
		    memcpy((*(_ACSE_apdu  *)pdVal).u.abrt, (*(_ACSE_apdu  *)src).u.abrt, sizeof(*(*(_ACSE_apdu  *)pdVal).u.abrt));
		    if ((*(*(_ACSE_apdu  *)src).u.abrt).bit_mask & 0x40000000) {
			_cpAssociation_information(_g, &((*(*(_ACSE_apdu  *)src).u.abrt).user_information), &((*(*(_ACSE_apdu  *)pdVal).u.abrt).user_information));
		    }
		}   break;
		default:;
	    }
	} break;
	case 3: {
	    pdVal = (_AE_title  *)_oss_dec_const_alloc(_g, sizeof(_AE_title ));
	    memcpy((_AE_title  *)pdVal, (_AE_title  *)src, sizeof(*(_AE_title  *)pdVal));
	    switch ((*(_AE_title  *)src).choice) {
		case 1: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_AE_title  *)src).u.ae_title_form2), &((*(_AE_title  *)pdVal).u.ae_title_form2), sizeof(((*(_AE_title  *)pdVal).u.ae_title_form2).length), sizeof(((*(_AE_title  *)pdVal).u.ae_title_form2).value[0]), (unsigned int)((char *)&((*(_AE_title  *)src).u.ae_title_form2).value - (char *)&((*(_AE_title  *)src).u.ae_title_form2)));
		}   break;
		case 2: {
		    (*(_AE_title  *)pdVal).u.ae_title_form1 = nullptr;
		    (*(_AE_title  *)pdVal).u.ae_title_form1 = _cpName(_g, (*(_AE_title  *)src).u.ae_title_form1, (*(_AE_title  *)pdVal).u.ae_title_form1);
		}   break;
		default:;
	    }
	} break;
	case 4: {
	    pdVal = (_CP_type  *)_oss_dec_const_alloc(_g, sizeof(_CP_type ));
	    memcpy((_CP_type  *)pdVal, (_CP_type  *)src, sizeof(*(_CP_type  *)pdVal));
	    if ((*(_CP_type  *)src).bit_mask & 0x80000000) {
		{
		    _cpConnectionData(_g, &(((*(_CP_type  *)src).x410_mode_parameters).connectionDataRQ), &(((*(_CP_type  *)pdVal).x410_mode_parameters).connectionDataRQ));
		}
	    }
	    if ((*(_CP_type  *)src).bit_mask & 0x40000000) {
		if (((*(_CP_type  *)src).normal_mode_parameters).bit_mask & 0x80000000) {
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_CP_type  *)src).normal_mode_parameters).protocol_version), &(((*(_CP_type  *)pdVal).normal_mode_parameters).protocol_version), sizeof((((*(_CP_type  *)pdVal).normal_mode_parameters).protocol_version).length), -1L, (unsigned int)((char *)&(((*(_CP_type  *)src).normal_mode_parameters).protocol_version).value - (char *)&(((*(_CP_type  *)src).normal_mode_parameters).protocol_version)));
		}
		if (((*(_CP_type  *)src).normal_mode_parameters).bit_mask & 0x40000000) {
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_CP_type  *)src).normal_mode_parameters).calling_presentation_selector), &(((*(_CP_type  *)pdVal).normal_mode_parameters).calling_presentation_selector), sizeof((((*(_CP_type  *)pdVal).normal_mode_parameters).calling_presentation_selector).length), sizeof((((*(_CP_type  *)pdVal).normal_mode_parameters).calling_presentation_selector).value[0]), (unsigned int)((char *)&(((*(_CP_type  *)src).normal_mode_parameters).calling_presentation_selector).value - (char *)&(((*(_CP_type  *)src).normal_mode_parameters).calling_presentation_selector)));
		}
		if (((*(_CP_type  *)src).normal_mode_parameters).bit_mask & 0x20000000) {
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_CP_type  *)src).normal_mode_parameters).called_presentation_selector), &(((*(_CP_type  *)pdVal).normal_mode_parameters).called_presentation_selector), sizeof((((*(_CP_type  *)pdVal).normal_mode_parameters).called_presentation_selector).length), sizeof((((*(_CP_type  *)pdVal).normal_mode_parameters).called_presentation_selector).value[0]), (unsigned int)((char *)&(((*(_CP_type  *)src).normal_mode_parameters).called_presentation_selector).value - (char *)&(((*(_CP_type  *)src).normal_mode_parameters).called_presentation_selector)));
		}
		if (((*(_CP_type  *)src).normal_mode_parameters).bit_mask & 0x10000000) {
		    _cpContext_list(_g, &(((*(_CP_type  *)src).normal_mode_parameters).presentation_context_definition_list), &(((*(_CP_type  *)pdVal).normal_mode_parameters).presentation_context_definition_list));
		}
		if (((*(_CP_type  *)src).normal_mode_parameters).bit_mask & 0x8000000) {
		    {
			_oss_cpy_unbnd_octet_ia(_g, &((((*(_CP_type  *)src).normal_mode_parameters).default_context_name).abstract_syntax_name), &((((*(_CP_type  *)pdVal).normal_mode_parameters).default_context_name).abstract_syntax_name), sizeof(((((*(_CP_type  *)pdVal).normal_mode_parameters).default_context_name).abstract_syntax_name).length), sizeof(((((*(_CP_type  *)pdVal).normal_mode_parameters).default_context_name).abstract_syntax_name).value[0]), (unsigned int)((char *)&((((*(_CP_type  *)src).normal_mode_parameters).default_context_name).abstract_syntax_name).value - (char *)&((((*(_CP_type  *)src).normal_mode_parameters).default_context_name).abstract_syntax_name)));
		    }
		    {
			_oss_cpy_unbnd_octet_ia(_g, &((((*(_CP_type  *)src).normal_mode_parameters).default_context_name).transfer_syntax_name), &((((*(_CP_type  *)pdVal).normal_mode_parameters).default_context_name).transfer_syntax_name), sizeof(((((*(_CP_type  *)pdVal).normal_mode_parameters).default_context_name).transfer_syntax_name).length), sizeof(((((*(_CP_type  *)pdVal).normal_mode_parameters).default_context_name).transfer_syntax_name).value[0]), (unsigned int)((char *)&((((*(_CP_type  *)src).normal_mode_parameters).default_context_name).transfer_syntax_name).value - (char *)&((((*(_CP_type  *)src).normal_mode_parameters).default_context_name).transfer_syntax_name)));
		    }
		}
		if (((*(_CP_type  *)src).normal_mode_parameters).bit_mask & 0x4000000) {
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_CP_type  *)src).normal_mode_parameters).presentation_requirements), &(((*(_CP_type  *)pdVal).normal_mode_parameters).presentation_requirements), sizeof((((*(_CP_type  *)pdVal).normal_mode_parameters).presentation_requirements).length), -1L, (unsigned int)((char *)&(((*(_CP_type  *)src).normal_mode_parameters).presentation_requirements).value - (char *)&(((*(_CP_type  *)src).normal_mode_parameters).presentation_requirements)));
		}
		if (((*(_CP_type  *)src).normal_mode_parameters).bit_mask & 0x2000000) {
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_CP_type  *)src).normal_mode_parameters).user_session_requirements), &(((*(_CP_type  *)pdVal).normal_mode_parameters).user_session_requirements), sizeof((((*(_CP_type  *)pdVal).normal_mode_parameters).user_session_requirements).length), -1L, (unsigned int)((char *)&(((*(_CP_type  *)src).normal_mode_parameters).user_session_requirements).value - (char *)&(((*(_CP_type  *)src).normal_mode_parameters).user_session_requirements)));
		}
		if (((*(_CP_type  *)src).normal_mode_parameters).bit_mask & 0x1000000) {
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_CP_type  *)src).normal_mode_parameters).protocol_options), &(((*(_CP_type  *)pdVal).normal_mode_parameters).protocol_options), sizeof((((*(_CP_type  *)pdVal).normal_mode_parameters).protocol_options).length), -1L, (unsigned int)((char *)&(((*(_CP_type  *)src).normal_mode_parameters).protocol_options).value - (char *)&(((*(_CP_type  *)src).normal_mode_parameters).protocol_options)));
		}
		if (((*(_CP_type  *)src).normal_mode_parameters).bit_mask & 0x200000) {
		    _cpUser_data(_g, &(((*(_CP_type  *)src).normal_mode_parameters).user_data), &(((*(_CP_type  *)pdVal).normal_mode_parameters).user_data));
		}
	    }
	} break;
	case 5: {
	    pdVal = _cpUser_data(_g, (_User_data  *)src, (_User_data  *)pdVal);
	} break;
	case 6: {
	    pdVal = (_CPA_PPDU  *)_oss_dec_const_alloc(_g, sizeof(_CPA_PPDU ));
	    memcpy((_CPA_PPDU  *)pdVal, (_CPA_PPDU  *)src, sizeof(*(_CPA_PPDU  *)pdVal));
	    if ((*(_CPA_PPDU  *)src).bit_mask & 0x80000000) {
		{
		    _cpConnectionData(_g, &(((*(_CPA_PPDU  *)src).x410_mode_parameters).connectionDataAC), &(((*(_CPA_PPDU  *)pdVal).x410_mode_parameters).connectionDataAC));
		}
	    }
	    if ((*(_CPA_PPDU  *)src).bit_mask & 0x40000000) {
		if (((*(_CPA_PPDU  *)src).normal_mode_parameters).bit_mask & 0x80000000) {
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_CPA_PPDU  *)src).normal_mode_parameters).protocol_version), &(((*(_CPA_PPDU  *)pdVal).normal_mode_parameters).protocol_version), sizeof((((*(_CPA_PPDU  *)pdVal).normal_mode_parameters).protocol_version).length), -1L, (unsigned int)((char *)&(((*(_CPA_PPDU  *)src).normal_mode_parameters).protocol_version).value - (char *)&(((*(_CPA_PPDU  *)src).normal_mode_parameters).protocol_version)));
		}
		if (((*(_CPA_PPDU  *)src).normal_mode_parameters).bit_mask & 0x40000000) {
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_CPA_PPDU  *)src).normal_mode_parameters).responding_presentation_selector), &(((*(_CPA_PPDU  *)pdVal).normal_mode_parameters).responding_presentation_selector), sizeof((((*(_CPA_PPDU  *)pdVal).normal_mode_parameters).responding_presentation_selector).length), sizeof((((*(_CPA_PPDU  *)pdVal).normal_mode_parameters).responding_presentation_selector).value[0]), (unsigned int)((char *)&(((*(_CPA_PPDU  *)src).normal_mode_parameters).responding_presentation_selector).value - (char *)&(((*(_CPA_PPDU  *)src).normal_mode_parameters).responding_presentation_selector)));
		}
		if (((*(_CPA_PPDU  *)src).normal_mode_parameters).bit_mask & 0x20000000) {
		    _cpResult_list(_g, &(((*(_CPA_PPDU  *)src).normal_mode_parameters).presentation_context_definition_result_list), &(((*(_CPA_PPDU  *)pdVal).normal_mode_parameters).presentation_context_definition_result_list));
		}
		if (((*(_CPA_PPDU  *)src).normal_mode_parameters).bit_mask & 0x10000000) {
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_CPA_PPDU  *)src).normal_mode_parameters).presentation_requirements), &(((*(_CPA_PPDU  *)pdVal).normal_mode_parameters).presentation_requirements), sizeof((((*(_CPA_PPDU  *)pdVal).normal_mode_parameters).presentation_requirements).length), -1L, (unsigned int)((char *)&(((*(_CPA_PPDU  *)src).normal_mode_parameters).presentation_requirements).value - (char *)&(((*(_CPA_PPDU  *)src).normal_mode_parameters).presentation_requirements)));
		}
		if (((*(_CPA_PPDU  *)src).normal_mode_parameters).bit_mask & 0x8000000) {
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_CPA_PPDU  *)src).normal_mode_parameters).user_session_requirements), &(((*(_CPA_PPDU  *)pdVal).normal_mode_parameters).user_session_requirements), sizeof((((*(_CPA_PPDU  *)pdVal).normal_mode_parameters).user_session_requirements).length), -1L, (unsigned int)((char *)&(((*(_CPA_PPDU  *)src).normal_mode_parameters).user_session_requirements).value - (char *)&(((*(_CPA_PPDU  *)src).normal_mode_parameters).user_session_requirements)));
		}
		if (((*(_CPA_PPDU  *)src).normal_mode_parameters).bit_mask & 0x4000000) {
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_CPA_PPDU  *)src).normal_mode_parameters).protocol_options), &(((*(_CPA_PPDU  *)pdVal).normal_mode_parameters).protocol_options), sizeof((((*(_CPA_PPDU  *)pdVal).normal_mode_parameters).protocol_options).length), -1L, (unsigned int)((char *)&(((*(_CPA_PPDU  *)src).normal_mode_parameters).protocol_options).value - (char *)&(((*(_CPA_PPDU  *)src).normal_mode_parameters).protocol_options)));
		}
		if (((*(_CPA_PPDU  *)src).normal_mode_parameters).bit_mask & 0x1000000) {
		    _cpUser_data(_g, &(((*(_CPA_PPDU  *)src).normal_mode_parameters).user_data), &(((*(_CPA_PPDU  *)pdVal).normal_mode_parameters).user_data));
		}
	    }
	} break;
	case 7: {
	    pdVal = (_CPR_PPDU  *)_oss_dec_const_alloc(_g, sizeof(_CPR_PPDU ));
	    memcpy((_CPR_PPDU  *)pdVal, (_CPR_PPDU  *)src, sizeof(*(_CPR_PPDU  *)pdVal));
	    switch ((*(_CPR_PPDU  *)src).choice) {
		case 1: {
		    (*(_CPR_PPDU  *)pdVal).u.normal_mode_parameters = (_seq5 *)_oss_dec_const_alloc(_g, sizeof(*((*(_CPR_PPDU  *)pdVal).u.normal_mode_parameters)));
		    memcpy((*(_CPR_PPDU  *)pdVal).u.normal_mode_parameters, (*(_CPR_PPDU  *)src).u.normal_mode_parameters, sizeof(*(*(_CPR_PPDU  *)pdVal).u.normal_mode_parameters));
		    if (((*(_CPR_PPDU  *)src).u.normal_mode_parameters)->bit_mask & 0x80000000) {
			_oss_cpy_unbnd_octet_ia(_g, &(((*(_CPR_PPDU  *)src).u.normal_mode_parameters)->protocol_version), &(((*(_CPR_PPDU  *)pdVal).u.normal_mode_parameters)->protocol_version), sizeof((((*(_CPR_PPDU  *)pdVal).u.normal_mode_parameters)->protocol_version).length), -1L, (unsigned int)((char *)&(((*(_CPR_PPDU  *)src).u.normal_mode_parameters)->protocol_version).value - (char *)&(((*(_CPR_PPDU  *)src).u.normal_mode_parameters)->protocol_version)));
		    }
		    if (((*(_CPR_PPDU  *)src).u.normal_mode_parameters)->bit_mask & 0x40000000) {
			_oss_cpy_unbnd_octet_ia(_g, &(((*(_CPR_PPDU  *)src).u.normal_mode_parameters)->responding_presentation_selector), &(((*(_CPR_PPDU  *)pdVal).u.normal_mode_parameters)->responding_presentation_selector), sizeof((((*(_CPR_PPDU  *)pdVal).u.normal_mode_parameters)->responding_presentation_selector).length), sizeof((((*(_CPR_PPDU  *)pdVal).u.normal_mode_parameters)->responding_presentation_selector).value[0]), (unsigned int)((char *)&(((*(_CPR_PPDU  *)src).u.normal_mode_parameters)->responding_presentation_selector).value - (char *)&(((*(_CPR_PPDU  *)src).u.normal_mode_parameters)->responding_presentation_selector)));
		    }
		    if (((*(_CPR_PPDU  *)src).u.normal_mode_parameters)->bit_mask & 0x20000000) {
			_cpResult_list(_g, &(((*(_CPR_PPDU  *)src).u.normal_mode_parameters)->presentation_context_definition_result_list), &(((*(_CPR_PPDU  *)pdVal).u.normal_mode_parameters)->presentation_context_definition_result_list));
		    }
		    if (((*(_CPR_PPDU  *)src).u.normal_mode_parameters)->bit_mask & 0x4000000) {
			_cpUser_data(_g, &(((*(_CPR_PPDU  *)src).u.normal_mode_parameters)->user_data), &(((*(_CPR_PPDU  *)pdVal).u.normal_mode_parameters)->user_data));
		    }
		}   break;
		case 2: {
		    (*(_CPR_PPDU  *)pdVal).u.x400_mode_parameters = (_set3 *)_oss_dec_const_alloc(_g, sizeof(*((*(_CPR_PPDU  *)pdVal).u.x400_mode_parameters)));
		    memcpy((*(_CPR_PPDU  *)pdVal).u.x400_mode_parameters, (*(_CPR_PPDU  *)src).u.x400_mode_parameters, sizeof(*(*(_CPR_PPDU  *)pdVal).u.x400_mode_parameters));
		    if (((*(_CPR_PPDU  *)src).u.x400_mode_parameters)->bit_mask & 0x40000000) {
			_oss_cpy_open_type(_g, (OpenType *)&(((*(_CPR_PPDU  *)src).u.x400_mode_parameters)->userDataRJ), (OpenType *)&(((*(_CPR_PPDU  *)pdVal).u.x400_mode_parameters)->userDataRJ));
		    }
		}   break;
		default:;
	    }
	} break;
	case 8: {
	    pdVal = (_Abort_type  *)_oss_dec_const_alloc(_g, sizeof(_Abort_type ));
	    memcpy((_Abort_type  *)pdVal, (_Abort_type  *)src, sizeof(*(_Abort_type  *)pdVal));
	    switch ((*(_Abort_type  *)src).choice) {
		case 1: {
		    (*(_Abort_type  *)pdVal).u.arp_ppdu = (_ARP_PPDU  *)_oss_dec_const_alloc(_g, sizeof(_ARP_PPDU ));
		    memcpy((*(_Abort_type  *)pdVal).u.arp_ppdu, (*(_Abort_type  *)src).u.arp_ppdu, sizeof(*(*(_Abort_type  *)pdVal).u.arp_ppdu));
		}   break;
		case 2: {
		    (*(_Abort_type  *)pdVal).u.aru_ppdu = (_ARU_PPDU  *)_oss_dec_const_alloc(_g, sizeof(_ARU_PPDU ));
		    memcpy((*(_Abort_type  *)pdVal).u.aru_ppdu, (*(_Abort_type  *)src).u.aru_ppdu, sizeof(*(*(_Abort_type  *)pdVal).u.aru_ppdu));
		    switch ((*(*(_Abort_type  *)src).u.aru_ppdu).choice) {
			case 1: {
			    (*(*(_Abort_type  *)pdVal).u.aru_ppdu).u.x400_mode_parameters = (_set4 *)_oss_dec_const_alloc(_g, sizeof(*((*(*(_Abort_type  *)pdVal).u.aru_ppdu).u.x400_mode_parameters)));
			    memcpy((*(*(_Abort_type  *)pdVal).u.aru_ppdu).u.x400_mode_parameters, (*(*(_Abort_type  *)src).u.aru_ppdu).u.x400_mode_parameters, sizeof(*(*(*(_Abort_type  *)pdVal).u.aru_ppdu).u.x400_mode_parameters));
			    if (((*(*(_Abort_type  *)src).u.aru_ppdu).u.x400_mode_parameters)->bit_mask & 0x40000000) {
				_oss_cpy_unbnd_octet_ia(_g, &(((*(*(_Abort_type  *)src).u.aru_ppdu).u.x400_mode_parameters)->reflectedParameter), &(((*(*(_Abort_type  *)pdVal).u.aru_ppdu).u.x400_mode_parameters)->reflectedParameter), sizeof((((*(*(_Abort_type  *)pdVal).u.aru_ppdu).u.x400_mode_parameters)->reflectedParameter).length), -1L, (unsigned int)((char *)&(((*(*(_Abort_type  *)src).u.aru_ppdu).u.x400_mode_parameters)->reflectedParameter).value - (char *)&(((*(*(_Abort_type  *)src).u.aru_ppdu).u.x400_mode_parameters)->reflectedParameter)));
			    }
			    if (((*(*(_Abort_type  *)src).u.aru_ppdu).u.x400_mode_parameters)->bit_mask & 0x20000000) {
				_oss_cpy_open_type(_g, (OpenType *)&(((*(*(_Abort_type  *)src).u.aru_ppdu).u.x400_mode_parameters)->userdataAB), (OpenType *)&(((*(*(_Abort_type  *)pdVal).u.aru_ppdu).u.x400_mode_parameters)->userdataAB));
			    }
			}   break;
			case 2: {
			    (*(*(_Abort_type  *)pdVal).u.aru_ppdu).u.normal_mode_parameters = (_seq6 *)_oss_dec_const_alloc(_g, sizeof(*((*(*(_Abort_type  *)pdVal).u.aru_ppdu).u.normal_mode_parameters)));
			    memcpy((*(*(_Abort_type  *)pdVal).u.aru_ppdu).u.normal_mode_parameters, (*(*(_Abort_type  *)src).u.aru_ppdu).u.normal_mode_parameters, sizeof(*(*(*(_Abort_type  *)pdVal).u.aru_ppdu).u.normal_mode_parameters));
			    if (((*(*(_Abort_type  *)src).u.aru_ppdu).u.normal_mode_parameters)->bit_mask & 0x80000000) {
				_cp14Presentation_context_ident(_g, &(((*(*(_Abort_type  *)src).u.aru_ppdu).u.normal_mode_parameters)->presentation_context_identifier_list), &(((*(*(_Abort_type  *)pdVal).u.aru_ppdu).u.normal_mode_parameters)->presentation_context_identifier_list));
			    }
			    if (((*(*(_Abort_type  *)src).u.aru_ppdu).u.normal_mode_parameters)->bit_mask & 0x40000000) {
				_cpUser_data(_g, &(((*(*(_Abort_type  *)src).u.aru_ppdu).u.normal_mode_parameters)->user_data), &(((*(*(_Abort_type  *)pdVal).u.aru_ppdu).u.normal_mode_parameters)->user_data));
			    }
			}   break;
			default:;
		    }
		}   break;
		default:;
	    }
	} break;
	case 9: {
	    pdVal = (_Typed_data_type  *)_oss_dec_const_alloc(_g, sizeof(_Typed_data_type ));
	    memcpy((_Typed_data_type  *)pdVal, (_Typed_data_type  *)src, sizeof(*(_Typed_data_type  *)pdVal));
	    switch ((*(_Typed_data_type  *)src).choice) {
		case 1: {
		    (*(_Typed_data_type  *)pdVal).u.ttdPPDU = nullptr;
		    (*(_Typed_data_type  *)pdVal).u.ttdPPDU = _cpUser_data(_g, (*(_Typed_data_type  *)src).u.ttdPPDU, (*(_Typed_data_type  *)pdVal).u.ttdPPDU);
		}   break;
		case 2: {
		    (*(_Typed_data_type  *)pdVal).u.acPPDU = (_AC_PPDU  *)_oss_dec_const_alloc(_g, sizeof(_AC_PPDU ));
		    memcpy((*(_Typed_data_type  *)pdVal).u.acPPDU, (*(_Typed_data_type  *)src).u.acPPDU, sizeof(*(*(_Typed_data_type  *)pdVal).u.acPPDU));
		    if ((*(*(_Typed_data_type  *)src).u.acPPDU).bit_mask & 0x80000000) {
			_cpContext_list(_g, &((*(*(_Typed_data_type  *)src).u.acPPDU).presentation_context_addition_list), &((*(*(_Typed_data_type  *)pdVal).u.acPPDU).presentation_context_addition_list));
		    }
		    if ((*(*(_Typed_data_type  *)src).u.acPPDU).bit_mask & 0x40000000) {
			_oss_cpy_link_obj(_g, (void**)(&((*(*(_Typed_data_type  *)src).u.acPPDU).presentation_context_deletion_list)), (void**)(&((*(*(_Typed_data_type  *)pdVal).u.acPPDU).presentation_context_deletion_list)), sizeof(_Presentation_context_deletion_list));
		    }
		    if ((*(*(_Typed_data_type  *)src).u.acPPDU).bit_mask & 0x20000000) {
			_cpUser_data(_g, &((*(*(_Typed_data_type  *)src).u.acPPDU).user_data), &((*(*(_Typed_data_type  *)pdVal).u.acPPDU).user_data));
		    }
		}   break;
		case 3: {
		    (*(_Typed_data_type  *)pdVal).u.acaPPDU = (_ACA_PPDU  *)_oss_dec_const_alloc(_g, sizeof(_ACA_PPDU ));
		    memcpy((*(_Typed_data_type  *)pdVal).u.acaPPDU, (*(_Typed_data_type  *)src).u.acaPPDU, sizeof(*(*(_Typed_data_type  *)pdVal).u.acaPPDU));
		    if ((*(*(_Typed_data_type  *)src).u.acaPPDU).bit_mask & 0x80000000) {
			_cpResult_list(_g, &((*(*(_Typed_data_type  *)src).u.acaPPDU).presentation_context_addition_result_list), &((*(*(_Typed_data_type  *)pdVal).u.acaPPDU).presentation_context_addition_result_list));
		    }
		    if ((*(*(_Typed_data_type  *)src).u.acaPPDU).bit_mask & 0x40000000) {
			_oss_cpy_link_obj(_g, (void**)(&((*(*(_Typed_data_type  *)src).u.acaPPDU).presentation_context_deletion_result_list)), (void**)(&((*(*(_Typed_data_type  *)pdVal).u.acaPPDU).presentation_context_deletion_result_list)), sizeof(_Presentation_context_deletion_list));
		    }
		    if ((*(*(_Typed_data_type  *)src).u.acaPPDU).bit_mask & 0x20000000) {
			_cpUser_data(_g, &((*(*(_Typed_data_type  *)src).u.acaPPDU).user_data), &((*(*(_Typed_data_type  *)pdVal).u.acaPPDU).user_data));
		    }
		}   break;
		default:;
	    }
	} break;
	case 10: {
	    pdVal = (_seq6  *)_oss_dec_const_alloc(_g, sizeof(_seq6 ));
	    memcpy((_seq6  *)pdVal, (_seq6  *)src, sizeof(*(_seq6  *)pdVal));
	    if ((*(_seq6  *)src).bit_mask & 0x80000000) {
		_cp14Presentation_context_ident(_g, &((*(_seq6  *)src).presentation_context_identifier_list), &((*(_seq6  *)pdVal).presentation_context_identifier_list));
	    }
	    if ((*(_seq6  *)src).bit_mask & 0x40000000) {
		_cpUser_data(_g, &((*(_seq6  *)src).user_data), &((*(_seq6  *)pdVal).user_data));
	    }
	} break;
	case 11: {
	    pdVal = (_seq6  *)_oss_dec_const_alloc(_g, sizeof(_seq6 ));
	    memcpy((_seq6  *)pdVal, (_seq6  *)src, sizeof(*(_seq6  *)pdVal));
	    if ((*(_seq6  *)src).bit_mask & 0x80000000) {
		_cp14Presentation_context_ident(_g, &((*(_seq6  *)src).presentation_context_identifier_list), &((*(_seq6  *)pdVal).presentation_context_identifier_list));
	    }
	    if ((*(_seq6  *)src).bit_mask & 0x40000000) {
		_cpUser_data(_g, &((*(_seq6  *)src).user_data), &((*(_seq6  *)pdVal).user_data));
	    }
	} break;
	case 12: {
	    pdVal = (_Reliable_Transfer_APDU_RTSE_apdus  *)_oss_dec_const_alloc(_g, sizeof(_Reliable_Transfer_APDU_RTSE_apdus ));
	    memcpy((_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal, (_Reliable_Transfer_APDU_RTSE_apdus  *)src, sizeof(*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal));
	    switch ((*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).choice) {
		case 2: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rttr_apdu), &((*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rttr_apdu), sizeof(((*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rttr_apdu).length), sizeof(((*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rttr_apdu).value[0]), (unsigned int)((char *)&((*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rttr_apdu).value - (char *)&((*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rttr_apdu)));
		}   break;
		case 3: {
		    (*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtorq_apdu = nullptr;
		    (*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtorq_apdu = _cpRTORQapdu(_g, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rtorq_apdu, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtorq_apdu);
		}   break;
		case 4: {
		    (*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtoac_apdu = nullptr;
		    (*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtoac_apdu = _cpRTOACapdu(_g, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rtoac_apdu, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtoac_apdu);
		}   break;
		case 5: {
		    (*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtorj_apdu = nullptr;
		    (*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtorj_apdu = _cpRTORJapdu(_g, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rtorj_apdu, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtorj_apdu);
		}   break;
		case 6: {
		    (*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtab_apdu = (_set4  *)_oss_dec_const_alloc(_g, sizeof(_set4 ));
		    memcpy((*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtab_apdu, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rtab_apdu, sizeof(*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtab_apdu));
		    if ((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rtab_apdu).bit_mask & 0x40000000) {
			_oss_cpy_unbnd_octet_ia(_g, &((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rtab_apdu).reflectedParameter), &((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtab_apdu).reflectedParameter), sizeof(((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtab_apdu).reflectedParameter).length), -1L, (unsigned int)((char *)&((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rtab_apdu).reflectedParameter).value - (char *)&((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rtab_apdu).reflectedParameter)));
		    }
		    if ((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rtab_apdu).bit_mask & 0x20000000) {
			_oss_cpy_open_type(_g, (OpenType *)&((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rtab_apdu).userdataAB), (OpenType *)&((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtab_apdu).userdataAB));
		    }
		}   break;
		default:;
	    }
	} break;
	case 13: {
	    pdVal = (_Reliable_Transfer_APDU_RTSE_apdus  *)_oss_dec_const_alloc(_g, sizeof(_Reliable_Transfer_APDU_RTSE_apdus ));
	    memcpy((_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal, (_Reliable_Transfer_APDU_RTSE_apdus  *)src, sizeof(*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal));
	    switch ((*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).choice) {
		case 2: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rttr_apdu), &((*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rttr_apdu), sizeof(((*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rttr_apdu).length), sizeof(((*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rttr_apdu).value[0]), (unsigned int)((char *)&((*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rttr_apdu).value - (char *)&((*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rttr_apdu)));
		}   break;
		case 3: {
		    (*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtorq_apdu = nullptr;
		    (*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtorq_apdu = _cpRTORQapdu(_g, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rtorq_apdu, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtorq_apdu);
		}   break;
		case 4: {
		    (*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtoac_apdu = nullptr;
		    (*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtoac_apdu = _cpRTOACapdu(_g, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rtoac_apdu, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtoac_apdu);
		}   break;
		case 5: {
		    (*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtorj_apdu = nullptr;
		    (*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtorj_apdu = _cpRTORJapdu(_g, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rtorj_apdu, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtorj_apdu);
		}   break;
		case 6: {
		    (*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtab_apdu = (_set4  *)_oss_dec_const_alloc(_g, sizeof(_set4 ));
		    memcpy((*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtab_apdu, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rtab_apdu, sizeof(*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtab_apdu));
		    if ((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rtab_apdu).bit_mask & 0x40000000) {
			_oss_cpy_unbnd_octet_ia(_g, &((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rtab_apdu).reflectedParameter), &((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtab_apdu).reflectedParameter), sizeof(((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtab_apdu).reflectedParameter).length), -1L, (unsigned int)((char *)&((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rtab_apdu).reflectedParameter).value - (char *)&((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rtab_apdu).reflectedParameter)));
		    }
		    if ((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rtab_apdu).bit_mask & 0x20000000) {
			_oss_cpy_open_type(_g, (OpenType *)&((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)src).u.rtab_apdu).userdataAB), (OpenType *)&((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)pdVal).u.rtab_apdu).userdataAB));
		    }
		}   break;
		default:;
	    }
	} break;
	case 14: {
	    pdVal = (_InvokeId  *)_oss_dec_const_alloc(_g, sizeof(_InvokeId ));
	    memcpy((_InvokeId  *)pdVal, (_InvokeId  *)src, sizeof(*(_InvokeId  *)pdVal));
	} break;
	case 15: {
	    pdVal = (_Reject  *)_oss_dec_const_alloc(_g, sizeof(_Reject ));
	    memcpy((_Reject  *)pdVal, (_Reject  *)src, sizeof(*(_Reject  *)pdVal));
	} break;
	case 16: {
	    pdVal = (_InvokeId  *)_oss_dec_const_alloc(_g, sizeof(_InvokeId ));
	    memcpy((_InvokeId  *)pdVal, (_InvokeId  *)src, sizeof(*(_InvokeId  *)pdVal));
	} break;
	case 17: {
	    pdVal = _cpUnboundedDirectoryString(_g, (_UnboundedDirectoryString  *)src, (_UnboundedDirectoryString  *)pdVal);
	} break;
	case 18: {
	    pdVal = (OSSC::COssBitString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssBitString  *)src, (OSSC::COssBitString  *)pdVal, sizeof((*(OSSC::COssBitString  *)pdVal).length), -1L, (unsigned int)((char *)&(*(OSSC::COssBitString  *)src).value - (char *)(OSSC::COssBitString  *)src));
	} break;
	case 19: {
	    pdVal = (_UUIDPair  *)_oss_dec_const_alloc(_g, sizeof(_UUIDPair ));
	    memcpy((_UUIDPair  *)pdVal, (_UUIDPair  *)src, sizeof(*(_UUIDPair  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_UUIDPair  *)src).issuerUUID), &((*(_UUIDPair  *)pdVal).issuerUUID), sizeof(((*(_UUIDPair  *)pdVal).issuerUUID).length), sizeof(((*(_UUIDPair  *)pdVal).issuerUUID).value[0]), (unsigned int)((char *)&((*(_UUIDPair  *)src).issuerUUID).value - (char *)&((*(_UUIDPair  *)src).issuerUUID)));
	    }
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_UUIDPair  *)src).subjectUUID), &((*(_UUIDPair  *)pdVal).subjectUUID), sizeof(((*(_UUIDPair  *)pdVal).subjectUUID).length), sizeof(((*(_UUIDPair  *)pdVal).subjectUUID).value[0]), (unsigned int)((char *)&((*(_UUIDPair  *)src).subjectUUID).value - (char *)&((*(_UUIDPair  *)src).subjectUUID)));
	    }
	} break;
	case 20: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 21: {
	    pdVal = (_Guide  *)_oss_dec_const_alloc(_g, sizeof(_Guide ));
	    memcpy((_Guide  *)pdVal, (_Guide  *)src, sizeof(*(_Guide  *)pdVal));
	    if ((*(_Guide  *)src).bit_mask & 0x80000000) {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_Guide  *)src).objectClass), &((*(_Guide  *)pdVal).objectClass), sizeof(((*(_Guide  *)pdVal).objectClass).length), sizeof(((*(_Guide  *)pdVal).objectClass).value[0]), (unsigned int)((char *)&((*(_Guide  *)src).objectClass).value - (char *)&((*(_Guide  *)src).objectClass)));
	    }
	    {
		_cpCriteria(_g, &((*(_Guide  *)src).criteria), &((*(_Guide  *)pdVal).criteria));
	    }
	} break;
	case 22: {
	    pdVal = (_EnhancedGuide  *)_oss_dec_const_alloc(_g, sizeof(_EnhancedGuide ));
	    memcpy((_EnhancedGuide  *)pdVal, (_EnhancedGuide  *)src, sizeof(*(_EnhancedGuide  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_EnhancedGuide  *)src).objectClass), &((*(_EnhancedGuide  *)pdVal).objectClass), sizeof(((*(_EnhancedGuide  *)pdVal).objectClass).length), sizeof(((*(_EnhancedGuide  *)pdVal).objectClass).value[0]), (unsigned int)((char *)&((*(_EnhancedGuide  *)src).objectClass).value - (char *)&((*(_EnhancedGuide  *)src).objectClass)));
	    }
	    {
		_cpCriteria(_g, &((*(_EnhancedGuide  *)src).criteria), &((*(_EnhancedGuide  *)pdVal).criteria));
	    }
	} break;
	case 23: {
	    pdVal = (_PostalAddress * *)_oss_dec_const_alloc(_g, sizeof(_PostalAddress *));
	    *(_PostalAddress * *)pdVal = nullptr;
	    if (*(_PostalAddress * *)src) {
		_PostalAddress *  s_oss_tmp_1 = *(_PostalAddress * *)src;
		_PostalAddress *  d_oss_tmp_1;

		*(_PostalAddress * *)pdVal = d_oss_tmp_1 = (_PostalAddress *)_oss_dec_getmem_internal(_g, sizeof(_PostalAddress));
		do {
		    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_PostalAddress));
		    {
			_cpUnboundedDirectoryString(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
		    }
		    if (s_oss_tmp_1->next)
			d_oss_tmp_1->next = (_PostalAddress *)_oss_dec_getmem_internal(_g, sizeof(_PostalAddress));
		    s_oss_tmp_1 = s_oss_tmp_1->next;
		    d_oss_tmp_1 = d_oss_tmp_1->next;
		} while (s_oss_tmp_1);
	    }
	} break;
	case 24: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 25: {
	    pdVal = (_TelexNumber  *)_oss_dec_const_alloc(_g, sizeof(_TelexNumber ));
	    memcpy((_TelexNumber  *)pdVal, (_TelexNumber  *)src, sizeof(*(_TelexNumber  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_TelexNumber  *)src).telexNumber), &((*(_TelexNumber  *)pdVal).telexNumber), sizeof(((*(_TelexNumber  *)pdVal).telexNumber).length), sizeof(((*(_TelexNumber  *)pdVal).telexNumber).value[0]), (unsigned int)((char *)&((*(_TelexNumber  *)src).telexNumber).value - (char *)&((*(_TelexNumber  *)src).telexNumber)));
	    }
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_TelexNumber  *)src).countryCode), &((*(_TelexNumber  *)pdVal).countryCode), sizeof(((*(_TelexNumber  *)pdVal).countryCode).length), sizeof(((*(_TelexNumber  *)pdVal).countryCode).value[0]), (unsigned int)((char *)&((*(_TelexNumber  *)src).countryCode).value - (char *)&((*(_TelexNumber  *)src).countryCode)));
	    }
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_TelexNumber  *)src).answerback), &((*(_TelexNumber  *)pdVal).answerback), sizeof(((*(_TelexNumber  *)pdVal).answerback).length), sizeof(((*(_TelexNumber  *)pdVal).answerback).value[0]), (unsigned int)((char *)&((*(_TelexNumber  *)src).answerback).value - (char *)&((*(_TelexNumber  *)src).answerback)));
	    }
	} break;
	case 26: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 27: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 28: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 29: {
	    pdVal = (OSSC::COssEncOID  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssEncOID  *)src, (OSSC::COssEncOID  *)pdVal, sizeof((*(OSSC::COssEncOID  *)pdVal).length), sizeof((*(OSSC::COssEncOID  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssEncOID  *)src).value - (char *)(OSSC::COssEncOID  *)src));
	} break;
	case 30: {
	    pdVal = (OSSC::COssEncOID  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssEncOID  *)src, (OSSC::COssEncOID  *)pdVal, sizeof((*(OSSC::COssEncOID  *)pdVal).length), sizeof((*(OSSC::COssEncOID  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssEncOID  *)src).value - (char *)(OSSC::COssEncOID  *)src));
	} break;
	case 31: {
	    pdVal = (_Presentation_context_deletion_list * *)_oss_cpy_link_obj(_g, (void**)((_Presentation_context_deletion_list * *)src), (void**)((_Presentation_context_deletion_list * *)pdVal), sizeof(_Presentation_context_deletion_list));
	} break;
	case 32: {
	    pdVal = (_PresentationAddress  *)_oss_dec_const_alloc(_g, sizeof(_PresentationAddress ));
	    memcpy((_PresentationAddress  *)pdVal, (_PresentationAddress  *)src, sizeof(*(_PresentationAddress  *)pdVal));
	    if ((*(_PresentationAddress  *)src).bit_mask & 0x80000000) {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_PresentationAddress  *)src).pSelector), &((*(_PresentationAddress  *)pdVal).pSelector), sizeof(((*(_PresentationAddress  *)pdVal).pSelector).length), sizeof(((*(_PresentationAddress  *)pdVal).pSelector).value[0]), (unsigned int)((char *)&((*(_PresentationAddress  *)src).pSelector).value - (char *)&((*(_PresentationAddress  *)src).pSelector)));
	    }
	    if ((*(_PresentationAddress  *)src).bit_mask & 0x40000000) {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_PresentationAddress  *)src).sSelector), &((*(_PresentationAddress  *)pdVal).sSelector), sizeof(((*(_PresentationAddress  *)pdVal).sSelector).length), sizeof(((*(_PresentationAddress  *)pdVal).sSelector).value[0]), (unsigned int)((char *)&((*(_PresentationAddress  *)src).sSelector).value - (char *)&((*(_PresentationAddress  *)src).sSelector)));
	    }
	    if ((*(_PresentationAddress  *)src).bit_mask & 0x20000000) {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_PresentationAddress  *)src).tSelector), &((*(_PresentationAddress  *)pdVal).tSelector), sizeof(((*(_PresentationAddress  *)pdVal).tSelector).length), sizeof(((*(_PresentationAddress  *)pdVal).tSelector).value[0]), (unsigned int)((char *)&((*(_PresentationAddress  *)src).tSelector).value - (char *)&((*(_PresentationAddress  *)src).tSelector)));
	    }
	    {
		(*(_PresentationAddress  *)pdVal).nAddresses = nullptr;
		if ((*(_PresentationAddress  *)src).nAddresses) {
		    _setof3 *  s_oss_tmp_2 = (*(_PresentationAddress  *)src).nAddresses;
		    _setof3 *  d_oss_tmp_2;

		    (*(_PresentationAddress  *)pdVal).nAddresses = d_oss_tmp_2 = (_setof3 *)_oss_dec_getmem_internal(_g, sizeof(_setof3));
		    do {
			memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_setof3));
			{
			    _oss_cpy_unbnd_octet_ia(_g, &(s_oss_tmp_2->value), &(d_oss_tmp_2->value), sizeof((d_oss_tmp_2->value).length), sizeof((d_oss_tmp_2->value).value[0]), (unsigned int)((char *)&(s_oss_tmp_2->value).value - (char *)&(s_oss_tmp_2->value)));
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_setof3 *)_oss_dec_getmem_internal(_g, sizeof(_setof3));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	} break;
	case 33: {
	    pdVal = (_ProtocolInformation  *)_oss_dec_const_alloc(_g, sizeof(_ProtocolInformation ));
	    memcpy((_ProtocolInformation  *)pdVal, (_ProtocolInformation  *)src, sizeof(*(_ProtocolInformation  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_ProtocolInformation  *)src).nAddress), &((*(_ProtocolInformation  *)pdVal).nAddress), sizeof(((*(_ProtocolInformation  *)pdVal).nAddress).length), sizeof(((*(_ProtocolInformation  *)pdVal).nAddress).value[0]), (unsigned int)((char *)&((*(_ProtocolInformation  *)src).nAddress).value - (char *)&((*(_ProtocolInformation  *)src).nAddress)));
	    }
	    {
		(*(_ProtocolInformation  *)pdVal).profiles = nullptr;
		if ((*(_ProtocolInformation  *)src).profiles) {
		    _Application_context_name_list *  s_oss_tmp_2 = (*(_ProtocolInformation  *)src).profiles;
		    _Application_context_name_list *  d_oss_tmp_2;

		    (*(_ProtocolInformation  *)pdVal).profiles = d_oss_tmp_2 = (_Application_context_name_list *)_oss_dec_getmem_internal(_g, sizeof(_Application_context_name_list));
		    do {
			memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_Application_context_name_list));
			{
			    _oss_cpy_unbnd_octet_ia(_g, &(s_oss_tmp_2->value), &(d_oss_tmp_2->value), sizeof((d_oss_tmp_2->value).length), sizeof((d_oss_tmp_2->value).value[0]), (unsigned int)((char *)&(s_oss_tmp_2->value).value - (char *)&(s_oss_tmp_2->value)));
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_Application_context_name_list *)_oss_dec_getmem_internal(_g, sizeof(_Application_context_name_list));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	} break;
	case 34: {
	    pdVal = (_NameAndOptionalUID  *)_oss_dec_const_alloc(_g, sizeof(_NameAndOptionalUID ));
	    memcpy((_NameAndOptionalUID  *)pdVal, (_NameAndOptionalUID  *)src, sizeof(*(_NameAndOptionalUID  *)pdVal));
	    {
		_cpRDNSequence(_g, &((*(_NameAndOptionalUID  *)src).dn), &((*(_NameAndOptionalUID  *)pdVal).dn));
	    }
	    if ((*(_NameAndOptionalUID  *)src).bit_mask & 0x80000000) {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_NameAndOptionalUID  *)src).uid), &((*(_NameAndOptionalUID  *)pdVal).uid), sizeof(((*(_NameAndOptionalUID  *)pdVal).uid).length), -1L, (unsigned int)((char *)&((*(_NameAndOptionalUID  *)src).uid).value - (char *)&((*(_NameAndOptionalUID  *)src).uid)));
	    }
	} break;
	case 35: {
	    pdVal = (_MultipleMatchingLocalities  *)_oss_dec_const_alloc(_g, sizeof(_MultipleMatchingLocalities ));
	    memcpy((_MultipleMatchingLocalities  *)pdVal, (_MultipleMatchingLocalities  *)src, sizeof(*(_MultipleMatchingLocalities  *)pdVal));
	    if ((*(_MultipleMatchingLocalities  *)src).bit_mask & 0x80000000) {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_MultipleMatchingLocalities  *)src).matchingRuleUsed), &((*(_MultipleMatchingLocalities  *)pdVal).matchingRuleUsed), sizeof(((*(_MultipleMatchingLocalities  *)pdVal).matchingRuleUsed).length), sizeof(((*(_MultipleMatchingLocalities  *)pdVal).matchingRuleUsed).value[0]), (unsigned int)((char *)&((*(_MultipleMatchingLocalities  *)src).matchingRuleUsed).value - (char *)&((*(_MultipleMatchingLocalities  *)src).matchingRuleUsed)));
	    }
	    {
		(*(_MultipleMatchingLocalities  *)pdVal).attributeList = nullptr;
		if ((*(_MultipleMatchingLocalities  *)src).attributeList) {
		    _seqof2 *  s_oss_tmp_2 = (*(_MultipleMatchingLocalities  *)src).attributeList;
		    _seqof2 *  d_oss_tmp_2;

		    (*(_MultipleMatchingLocalities  *)pdVal).attributeList = d_oss_tmp_2 = (_seqof2 *)_oss_dec_getmem_internal(_g, sizeof(_seqof2));
		    do {
			memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_seqof2));
			{
			    {
				_oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_2->value).type), &((d_oss_tmp_2->value).type), sizeof(((d_oss_tmp_2->value).type).length), sizeof(((d_oss_tmp_2->value).type).value[0]), (unsigned int)((char *)&((s_oss_tmp_2->value).type).value - (char *)&((s_oss_tmp_2->value).type)));
			    }
			    {
				int         _pduNum = ((s_oss_tmp_2->value).assertion).pduNum;
				_oss_cpy_new_open_type(_g, &_pduNum, &((s_oss_tmp_2->value).assertion).encoded, &((d_oss_tmp_2->value).assertion).encoded, *(void **)&((s_oss_tmp_2->value).assertion).decoded, (void **)&((d_oss_tmp_2->value).assertion).decoded);
				((d_oss_tmp_2->value).assertion).pduNum = _pduNum;
			    }
			    if ((s_oss_tmp_2->value).bit_mask & 0x80000000) {
				_choice4  * src_3 = &((s_oss_tmp_2->value).assertedContexts);
				_choice4  * dst_3 = &((d_oss_tmp_2->value).assertedContexts);

				switch ((*src_3).choice) {
				    case 2: {
					(*dst_3).u.selectedContexts = nullptr;
					if ((*src_3).u.selectedContexts) {
					    _setof6 *  s_oss_tmp_5 = (*src_3).u.selectedContexts;
					    _setof6 *  d_oss_tmp_5;

					    (*dst_3).u.selectedContexts = d_oss_tmp_5 = (_setof6 *)_oss_dec_getmem_internal(_g, sizeof(_setof6));
					    do {
						memcpy(d_oss_tmp_5, s_oss_tmp_5, sizeof(_setof6));
						{
						    _cpContextAssertion(_g, &(s_oss_tmp_5->value), &(d_oss_tmp_5->value));
						}
						if (s_oss_tmp_5->next)
						    d_oss_tmp_5->next = (_setof6 *)_oss_dec_getmem_internal(_g, sizeof(_setof6));
						s_oss_tmp_5 = s_oss_tmp_5->next;
						d_oss_tmp_5 = d_oss_tmp_5->next;
					    } while (s_oss_tmp_5);
					}
				    }   break;
				    default:;
				}
			    }
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_seqof2 *)_oss_dec_getmem_internal(_g, sizeof(_seqof2));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	} break;
	case 36: {
	    pdVal = (_SubstringAssertion * *)_oss_dec_const_alloc(_g, sizeof(_SubstringAssertion *));
	    *(_SubstringAssertion * *)pdVal = nullptr;
	    if (*(_SubstringAssertion * *)src) {
		_SubstringAssertion *  s_oss_tmp_1 = *(_SubstringAssertion * *)src;
		_SubstringAssertion *  d_oss_tmp_1;

		*(_SubstringAssertion * *)pdVal = d_oss_tmp_1 = (_SubstringAssertion *)_oss_dec_getmem_internal(_g, sizeof(_SubstringAssertion));
		do {
		    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_SubstringAssertion));
		    {
			switch ((s_oss_tmp_1->value).choice) {
			    case 1: {
				(d_oss_tmp_1->value).u.control = (_Attribute  *)_oss_dec_const_alloc(_g, sizeof(_Attribute ));
				memcpy((d_oss_tmp_1->value).u.control, (s_oss_tmp_1->value).u.control, sizeof(*(d_oss_tmp_1->value).u.control));
				{
				    _oss_cpy_unbnd_octet_ia(_g, &((*(s_oss_tmp_1->value).u.control).type), &((*(d_oss_tmp_1->value).u.control).type), sizeof(((*(d_oss_tmp_1->value).u.control).type).length), sizeof(((*(d_oss_tmp_1->value).u.control).type).value[0]), (unsigned int)((char *)&((*(s_oss_tmp_1->value).u.control).type).value - (char *)&((*(s_oss_tmp_1->value).u.control).type)));
				}
				{
				    _setof13 * * src_3 = &((*(s_oss_tmp_1->value).u.control).values);
				    _setof13 * * dst_3 = &((*(d_oss_tmp_1->value).u.control).values);

				    *dst_3 = nullptr;
				    if (*src_3) {
					_setof13 *  s_oss_tmp_4 = *src_3;
					_setof13 *  d_oss_tmp_4;

					*dst_3 = d_oss_tmp_4 = (_setof13 *)_oss_dec_getmem_internal(_g, sizeof(_setof13));
					do {
					    memcpy(d_oss_tmp_4, s_oss_tmp_4, sizeof(_setof13));
					    {
						int         _pduNum = (s_oss_tmp_4->value).pduNum;
						_oss_cpy_new_open_type(_g, &_pduNum, &(s_oss_tmp_4->value).encoded, &(d_oss_tmp_4->value).encoded, *(void **)&(s_oss_tmp_4->value).decoded, (void **)&(d_oss_tmp_4->value).decoded);
						(d_oss_tmp_4->value).pduNum = _pduNum;
					    }
					    if (s_oss_tmp_4->next)
						d_oss_tmp_4->next = (_setof13 *)_oss_dec_getmem_internal(_g, sizeof(_setof13));
					    s_oss_tmp_4 = s_oss_tmp_4->next;
					    d_oss_tmp_4 = d_oss_tmp_4->next;
					} while (s_oss_tmp_4);
				    }
				}
				if ((*(s_oss_tmp_1->value).u.control).bit_mask & 0x80000000) {
				    _setof14 * * src_3 = &((*(s_oss_tmp_1->value).u.control).valuesWithContext);
				    _setof14 * * dst_3 = &((*(d_oss_tmp_1->value).u.control).valuesWithContext);

				    *dst_3 = nullptr;
				    if (*src_3) {
					_setof14 *  s_oss_tmp_4 = *src_3;
					_setof14 *  d_oss_tmp_4;

					*dst_3 = d_oss_tmp_4 = (_setof14 *)_oss_dec_getmem_internal(_g, sizeof(_setof14));
					do {
					    memcpy(d_oss_tmp_4, s_oss_tmp_4, sizeof(_setof14));
					    {
						{
						    int         _pduNum = ((s_oss_tmp_4->value).value).pduNum;
						    _oss_cpy_new_open_type(_g, &_pduNum, &((s_oss_tmp_4->value).value).encoded, &((d_oss_tmp_4->value).value).encoded, *(void **)&((s_oss_tmp_4->value).value).decoded, (void **)&((d_oss_tmp_4->value).value).decoded);
						    ((d_oss_tmp_4->value).value).pduNum = _pduNum;
						}
						{
						    (d_oss_tmp_4->value).contextList = nullptr;
						    if ((s_oss_tmp_4->value).contextList) {
							_setof15 *  s_oss_tmp_6 = (s_oss_tmp_4->value).contextList;
							_setof15 *  d_oss_tmp_6;

							(d_oss_tmp_4->value).contextList = d_oss_tmp_6 = (_setof15 *)_oss_dec_getmem_internal(_g, sizeof(_setof15));
							do {
							    memcpy(d_oss_tmp_6, s_oss_tmp_6, sizeof(_setof15));
							    {
								_cpContext(_g, &(s_oss_tmp_6->value), &(d_oss_tmp_6->value));
							    }
							    if (s_oss_tmp_6->next)
								d_oss_tmp_6->next = (_setof15 *)_oss_dec_getmem_internal(_g, sizeof(_setof15));
							    s_oss_tmp_6 = s_oss_tmp_6->next;
							    d_oss_tmp_6 = d_oss_tmp_6->next;
							} while (s_oss_tmp_6);
						    }
						}
					    }
					    if (s_oss_tmp_4->next)
						d_oss_tmp_4->next = (_setof14 *)_oss_dec_getmem_internal(_g, sizeof(_setof14));
					    s_oss_tmp_4 = s_oss_tmp_4->next;
					    d_oss_tmp_4 = d_oss_tmp_4->next;
					} while (s_oss_tmp_4);
				    }
				}
			    }   break;
			    case 2: {
				(d_oss_tmp_1->value).u.initial = nullptr;
				(d_oss_tmp_1->value).u.initial = _cpUnboundedDirectoryString(_g, (s_oss_tmp_1->value).u.initial, (d_oss_tmp_1->value).u.initial);
			    }   break;
			    case 3: {
				(d_oss_tmp_1->value).u.any = nullptr;
				(d_oss_tmp_1->value).u.any = _cpUnboundedDirectoryString(_g, (s_oss_tmp_1->value).u.any, (d_oss_tmp_1->value).u.any);
			    }   break;
			    case 4: {
				(d_oss_tmp_1->value).u.final = nullptr;
				(d_oss_tmp_1->value).u.final = _cpUnboundedDirectoryString(_g, (s_oss_tmp_1->value).u.final, (d_oss_tmp_1->value).u.final);
			    }   break;
			    default:;
			}
		    }
		    if (s_oss_tmp_1->next)
			d_oss_tmp_1->next = (_SubstringAssertion *)_oss_dec_getmem_internal(_g, sizeof(_SubstringAssertion));
		    s_oss_tmp_1 = s_oss_tmp_1->next;
		    d_oss_tmp_1 = d_oss_tmp_1->next;
		} while (s_oss_tmp_1);
	    }
	} break;
	case 37: {
	    pdVal = (_PostalAddress * *)_oss_dec_const_alloc(_g, sizeof(_PostalAddress *));
	    *(_PostalAddress * *)pdVal = nullptr;
	    if (*(_PostalAddress * *)src) {
		_PostalAddress *  s_oss_tmp_1 = *(_PostalAddress * *)src;
		_PostalAddress *  d_oss_tmp_1;

		*(_PostalAddress * *)pdVal = d_oss_tmp_1 = (_PostalAddress *)_oss_dec_getmem_internal(_g, sizeof(_PostalAddress));
		do {
		    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_PostalAddress));
		    {
			_cpUnboundedDirectoryString(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
		    }
		    if (s_oss_tmp_1->next)
			d_oss_tmp_1->next = (_PostalAddress *)_oss_dec_getmem_internal(_g, sizeof(_PostalAddress));
		    s_oss_tmp_1 = s_oss_tmp_1->next;
		    d_oss_tmp_1 = d_oss_tmp_1->next;
		} while (s_oss_tmp_1);
	    }
	} break;
	case 38: {
	    pdVal = (_OctetSubstringAssertion * *)_oss_dec_const_alloc(_g, sizeof(_OctetSubstringAssertion *));
	    *(_OctetSubstringAssertion * *)pdVal = nullptr;
	    if (*(_OctetSubstringAssertion * *)src) {
		_OctetSubstringAssertion *  s_oss_tmp_1 = *(_OctetSubstringAssertion * *)src;
		_OctetSubstringAssertion *  d_oss_tmp_1;

		*(_OctetSubstringAssertion * *)pdVal = d_oss_tmp_1 = (_OctetSubstringAssertion *)_oss_dec_getmem_internal(_g, sizeof(_OctetSubstringAssertion));
		do {
		    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_OctetSubstringAssertion));
		    {
			switch ((s_oss_tmp_1->value).choice) {
			    case 1: {
				_oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_1->value).u.initial), &((d_oss_tmp_1->value).u.initial), sizeof(((d_oss_tmp_1->value).u.initial).length), sizeof(((d_oss_tmp_1->value).u.initial).value[0]), (unsigned int)((char *)&((s_oss_tmp_1->value).u.initial).value - (char *)&((s_oss_tmp_1->value).u.initial)));
			    }   break;
			    case 2: {
				_oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_1->value).u.any), &((d_oss_tmp_1->value).u.any), sizeof(((d_oss_tmp_1->value).u.any).length), sizeof(((d_oss_tmp_1->value).u.any).value[0]), (unsigned int)((char *)&((s_oss_tmp_1->value).u.any).value - (char *)&((s_oss_tmp_1->value).u.any)));
			    }   break;
			    case 3: {
				_oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_1->value).u.final), &((d_oss_tmp_1->value).u.final), sizeof(((d_oss_tmp_1->value).u.final).length), sizeof(((d_oss_tmp_1->value).u.final).value[0]), (unsigned int)((char *)&((s_oss_tmp_1->value).u.final).value - (char *)&((s_oss_tmp_1->value).u.final)));
			    }   break;
			    default:;
			}
		    }
		    if (s_oss_tmp_1->next)
			d_oss_tmp_1->next = (_OctetSubstringAssertion *)_oss_dec_getmem_internal(_g, sizeof(_OctetSubstringAssertion));
		    s_oss_tmp_1 = s_oss_tmp_1->next;
		    d_oss_tmp_1 = d_oss_tmp_1->next;
		} while (s_oss_tmp_1);
	    }
	} break;
	case 39: {
	    pdVal = (enum SequenceMatchType  *)_oss_dec_const_alloc(_g, sizeof(enum SequenceMatchType ));
	    *(enum SequenceMatchType  *)pdVal = *(enum SequenceMatchType  *)src;
	} break;
	case 40: {
	    pdVal = (enum WordMatchTypes  *)_oss_dec_const_alloc(_g, sizeof(enum WordMatchTypes ));
	    *(enum WordMatchTypes  *)pdVal = *(enum WordMatchTypes  *)src;
	} break;
	case 41: {
	    pdVal = (enum CharacterMatchTypes  *)_oss_dec_const_alloc(_g, sizeof(enum CharacterMatchTypes ));
	    *(enum CharacterMatchTypes  *)pdVal = *(enum CharacterMatchTypes  *)src;
	} break;
	case 42: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 43: {
	    pdVal = (_TimeSpecification  *)_oss_dec_const_alloc(_g, sizeof(_TimeSpecification ));
	    memcpy((_TimeSpecification  *)pdVal, (_TimeSpecification  *)src, sizeof(*(_TimeSpecification  *)pdVal));
	    {
		switch (((*(_TimeSpecification  *)src).time).choice) {
		    case 1: {
			((*(_TimeSpecification  *)pdVal).time).u.absolute = (_seq10 *)_oss_dec_const_alloc(_g, sizeof(*(((*(_TimeSpecification  *)pdVal).time).u.absolute)));
			memcpy(((*(_TimeSpecification  *)pdVal).time).u.absolute, ((*(_TimeSpecification  *)src).time).u.absolute, sizeof(*((*(_TimeSpecification  *)pdVal).time).u.absolute));
			if ((((*(_TimeSpecification  *)src).time).u.absolute)->startTime) {
			    char *  * src_3 = &((((*(_TimeSpecification  *)src).time).u.absolute)->startTime);
			    char *  * dst_3 = &((((*(_TimeSpecification  *)pdVal).time).u.absolute)->startTime);
			    size_t  len_3 = (size_t)sizeof(char) * (strlen(*src_3) + 1);

			    *dst_3 = (char * )_oss_dec_getmem_internal(_g, (long)len_3);
			    strcpy(*dst_3, *src_3);
			}
			if ((((*(_TimeSpecification  *)src).time).u.absolute)->endTime) {
			    char *  * src_3 = &((((*(_TimeSpecification  *)src).time).u.absolute)->endTime);
			    char *  * dst_3 = &((((*(_TimeSpecification  *)pdVal).time).u.absolute)->endTime);
			    size_t  len_3 = (size_t)sizeof(char) * (strlen(*src_3) + 1);

			    *dst_3 = (char * )_oss_dec_getmem_internal(_g, (long)len_3);
			    strcpy(*dst_3, *src_3);
			}
		    }   break;
		    case 2: {
			((*(_TimeSpecification  *)pdVal).time).u.periodic = nullptr;
			if (((*(_TimeSpecification  *)src).time).u.periodic) {
			    _setof10 *  s_oss_tmp_3 = ((*(_TimeSpecification  *)src).time).u.periodic;
			    _setof10 *  d_oss_tmp_3;

			    ((*(_TimeSpecification  *)pdVal).time).u.periodic = d_oss_tmp_3 = (_setof10 *)_oss_dec_getmem_internal(_g, sizeof(_setof10));
			    do {
				memcpy(d_oss_tmp_3, s_oss_tmp_3, sizeof(_setof10));
				{
				    _Period  * src_3 = &(s_oss_tmp_3->value);
				    _Period  * dst_3 = &(d_oss_tmp_3->value);

				    if ((*src_3).bit_mask & 0x80000000) {
					_oss_cpy_link_obj(_g, (void**)(&((*src_3).timesOfDay)), (void**)(&((*dst_3).timesOfDay)), sizeof(_setof8));
				    }
				    if ((*src_3).bit_mask & 0x40000000) {
					switch (((*src_3).days).choice) {
					    case 1: {
						_oss_cpy_unbnd_octet_ia(_g, &(((*src_3).days).u.bitDay), &(((*dst_3).days).u.bitDay), sizeof((((*dst_3).days).u.bitDay).length), -1L, (unsigned int)((char *)&(((*src_3).days).u.bitDay).value - (char *)&(((*src_3).days).u.bitDay)));
					    }   break;
					    case 2: {
						_oss_cpy_link_obj(_g, (void**)(&(((*src_3).days).u.intDay)), (void**)(&(((*dst_3).days).u.intDay)), sizeof(_Presentation_context_deletion_list));
					    }   break;
					    case 3: {
						((*dst_3).days).u.dayOf = (_XDayOf  *)_oss_dec_const_alloc(_g, sizeof(_XDayOf ));
						memcpy(((*dst_3).days).u.dayOf, ((*src_3).days).u.dayOf, sizeof(*((*dst_3).days).u.dayOf));
						switch ((*((*src_3).days).u.dayOf).choice) {
						    case 1: {
							(*((*dst_3).days).u.dayOf).u.first = nullptr;
							(*((*dst_3).days).u.dayOf).u.first = _cpNamedDay(_g, (*((*src_3).days).u.dayOf).u.first, (*((*dst_3).days).u.dayOf).u.first);
						    }   break;
						    case 2: {
							(*((*dst_3).days).u.dayOf).u.second = nullptr;
							(*((*dst_3).days).u.dayOf).u.second = _cpNamedDay(_g, (*((*src_3).days).u.dayOf).u.second, (*((*dst_3).days).u.dayOf).u.second);
						    }   break;
						    case 3: {
							(*((*dst_3).days).u.dayOf).u.third = nullptr;
							(*((*dst_3).days).u.dayOf).u.third = _cpNamedDay(_g, (*((*src_3).days).u.dayOf).u.third, (*((*dst_3).days).u.dayOf).u.third);
						    }   break;
						    case 4: {
							(*((*dst_3).days).u.dayOf).u.fourth = nullptr;
							(*((*dst_3).days).u.dayOf).u.fourth = _cpNamedDay(_g, (*((*src_3).days).u.dayOf).u.fourth, (*((*dst_3).days).u.dayOf).u.fourth);
						    }   break;
						    case 5: {
							(*((*dst_3).days).u.dayOf).u.fifth = nullptr;
							(*((*dst_3).days).u.dayOf).u.fifth = _cpNamedDay(_g, (*((*src_3).days).u.dayOf).u.fifth, (*((*dst_3).days).u.dayOf).u.fifth);
						    }   break;
						    default:;
						}
					    }   break;
					    default:;
					}
				    }
				    if ((*src_3).bit_mask & 0x20000000) {
					switch (((*src_3).weeks).choice) {
					    case 1: {
						_oss_cpy_unbnd_octet_ia(_g, &(((*src_3).weeks).u.bitWeek), &(((*dst_3).weeks).u.bitWeek), sizeof((((*dst_3).weeks).u.bitWeek).length), -1L, (unsigned int)((char *)&(((*src_3).weeks).u.bitWeek).value - (char *)&(((*src_3).weeks).u.bitWeek)));
					    }   break;
					    case 3: {
						_oss_cpy_link_obj(_g, (void**)(&(((*src_3).weeks).u.intWeek)), (void**)(&(((*dst_3).weeks).u.intWeek)), sizeof(_Presentation_context_deletion_list));
					    }   break;
					    default:;
					}
				    }
				    if ((*src_3).bit_mask & 0x10000000) {
					switch (((*src_3).months).choice) {
					    case 1: {
						_oss_cpy_unbnd_octet_ia(_g, &(((*src_3).months).u.bitMonth), &(((*dst_3).months).u.bitMonth), sizeof((((*dst_3).months).u.bitMonth).length), -1L, (unsigned int)((char *)&(((*src_3).months).u.bitMonth).value - (char *)&(((*src_3).months).u.bitMonth)));
					    }   break;
					    case 3: {
						_oss_cpy_link_obj(_g, (void**)(&(((*src_3).months).u.intMonth)), (void**)(&(((*dst_3).months).u.intMonth)), sizeof(_Presentation_context_deletion_list));
					    }   break;
					    default:;
					}
				    }
				    if ((*src_3).bit_mask & 0x8000000) {
					_oss_cpy_link_obj(_g, (void**)(&((*src_3).years)), (void**)(&((*dst_3).years)), sizeof(_setof9));
				    }
				}
				if (s_oss_tmp_3->next)
				    d_oss_tmp_3->next = (_setof10 *)_oss_dec_getmem_internal(_g, sizeof(_setof10));
				s_oss_tmp_3 = s_oss_tmp_3->next;
				d_oss_tmp_3 = d_oss_tmp_3->next;
			    } while (s_oss_tmp_3);
			}
		    }   break;
		    default:;
		}
	    }
	} break;
	case 44: {
	    pdVal = (_TimeAssertion  *)_oss_dec_const_alloc(_g, sizeof(_TimeAssertion ));
	    memcpy((_TimeAssertion  *)pdVal, (_TimeAssertion  *)src, sizeof(*(_TimeAssertion  *)pdVal));
	    switch ((*(_TimeAssertion  *)src).choice) {
		case 2: {
		    (*(_TimeAssertion  *)pdVal).u.between = (_seq11 *)_oss_dec_const_alloc(_g, sizeof(*((*(_TimeAssertion  *)pdVal).u.between)));
		    memcpy((*(_TimeAssertion  *)pdVal).u.between, (*(_TimeAssertion  *)src).u.between, sizeof(*(*(_TimeAssertion  *)pdVal).u.between));
		    {
			size_t  len_2 = (size_t)sizeof(char) * (strlen(((*(_TimeAssertion  *)src).u.between)->startTime) + 1);

			((*(_TimeAssertion  *)pdVal).u.between)->startTime = (char * )_oss_dec_getmem_internal(_g, (long)len_2);
			strcpy(((*(_TimeAssertion  *)pdVal).u.between)->startTime, ((*(_TimeAssertion  *)src).u.between)->startTime);
		    }
		    if (((*(_TimeAssertion  *)src).u.between)->endTime) {
			size_t  len_2 = (size_t)sizeof(char) * (strlen(((*(_TimeAssertion  *)src).u.between)->endTime) + 1);

			((*(_TimeAssertion  *)pdVal).u.between)->endTime = (char * )_oss_dec_getmem_internal(_g, (long)len_2);
			strcpy(((*(_TimeAssertion  *)pdVal).u.between)->endTime, ((*(_TimeAssertion  *)src).u.between)->endTime);
		    }
		}   break;
		case 3: {
		    size_t  len_1 = (size_t)sizeof(char) * (strlen((*(_TimeAssertion  *)src).u.at) + 1);

		    (*(_TimeAssertion  *)pdVal).u.at = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
		    strcpy((*(_TimeAssertion  *)pdVal).u.at, (*(_TimeAssertion  *)src).u.at);
		}   break;
		default:;
	    }
	} break;
	case 45: {
	    pdVal = (_LocaleContextSyntax  *)_oss_dec_const_alloc(_g, sizeof(_LocaleContextSyntax ));
	    memcpy((_LocaleContextSyntax  *)pdVal, (_LocaleContextSyntax  *)src, sizeof(*(_LocaleContextSyntax  *)pdVal));
	    switch ((*(_LocaleContextSyntax  *)src).choice) {
		case 1: {
		    _oss_cpy_unbnd_octet_ia(_g, &((*(_LocaleContextSyntax  *)src).u.localeID1), &((*(_LocaleContextSyntax  *)pdVal).u.localeID1), sizeof(((*(_LocaleContextSyntax  *)pdVal).u.localeID1).length), sizeof(((*(_LocaleContextSyntax  *)pdVal).u.localeID1).value[0]), (unsigned int)((char *)&((*(_LocaleContextSyntax  *)src).u.localeID1).value - (char *)&((*(_LocaleContextSyntax  *)src).u.localeID1)));
		}   break;
		case 2: {
		    (*(_LocaleContextSyntax  *)pdVal).u.localeID2 = nullptr;
		    (*(_LocaleContextSyntax  *)pdVal).u.localeID2 = _cpUnboundedDirectoryString(_g, (*(_LocaleContextSyntax  *)src).u.localeID2, (*(_LocaleContextSyntax  *)pdVal).u.localeID2);
		}   break;
		default:;
	    }
	} break;
	case 46: {
	    pdVal = (_setof3 * *)_oss_dec_const_alloc(_g, sizeof(_setof3 *));
	    *(_setof3 * *)pdVal = nullptr;
	    if (*(_setof3 * *)src) {
		_setof3 *  s_oss_tmp_1 = *(_setof3 * *)src;
		_setof3 *  d_oss_tmp_1;

		*(_setof3 * *)pdVal = d_oss_tmp_1 = (_setof3 *)_oss_dec_getmem_internal(_g, sizeof(_setof3));
		do {
		    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_setof3));
		    {
			_oss_cpy_unbnd_octet_ia(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value), sizeof((d_oss_tmp_1->value).length), sizeof((d_oss_tmp_1->value).value[0]), (unsigned int)((char *)&(s_oss_tmp_1->value).value - (char *)&(s_oss_tmp_1->value)));
		    }
		    if (s_oss_tmp_1->next)
			d_oss_tmp_1->next = (_setof3 *)_oss_dec_getmem_internal(_g, sizeof(_setof3));
		    s_oss_tmp_1 = s_oss_tmp_1->next;
		    d_oss_tmp_1 = d_oss_tmp_1->next;
		} while (s_oss_tmp_1);
	    }
	} break;
	case 47: {
	    pdVal = (OSSC::COssEncOID  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssEncOID  *)src, (OSSC::COssEncOID  *)pdVal, sizeof((*(OSSC::COssEncOID  *)pdVal).length), sizeof((*(OSSC::COssEncOID  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssEncOID  *)src).value - (char *)(OSSC::COssEncOID  *)src));
	} break;
	case 48: {
	    pdVal = (OSSC::COssOpen  *)_oss_cpy_open_type(_g, (OpenType *)(OSSC::COssOpen  *)src, (OpenType *)(OSSC::COssOpen  *)pdVal);
	} break;
	case 49: {
	    pdVal = _cpContextAssertion(_g, (_ContextAssertion  *)src, (_ContextAssertion  *)pdVal);
	} break;
	case 50: {
	    pdVal = (_AttributeTypeAssertion  *)_oss_dec_const_alloc(_g, sizeof(_AttributeTypeAssertion ));
	    memcpy((_AttributeTypeAssertion  *)pdVal, (_AttributeTypeAssertion  *)src, sizeof(*(_AttributeTypeAssertion  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_AttributeTypeAssertion  *)src).type), &((*(_AttributeTypeAssertion  *)pdVal).type), sizeof(((*(_AttributeTypeAssertion  *)pdVal).type).length), sizeof(((*(_AttributeTypeAssertion  *)pdVal).type).value[0]), (unsigned int)((char *)&((*(_AttributeTypeAssertion  *)src).type).value - (char *)&((*(_AttributeTypeAssertion  *)src).type)));
	    }
	    if ((*(_AttributeTypeAssertion  *)src).bit_mask & 0x80000000) {
		(*(_AttributeTypeAssertion  *)pdVal).assertedContexts = nullptr;
		if ((*(_AttributeTypeAssertion  *)src).assertedContexts) {
		    _setof6 *  s_oss_tmp_2 = (*(_AttributeTypeAssertion  *)src).assertedContexts;
		    _setof6 *  d_oss_tmp_2;

		    (*(_AttributeTypeAssertion  *)pdVal).assertedContexts = d_oss_tmp_2 = (_setof6 *)_oss_dec_getmem_internal(_g, sizeof(_setof6));
		    do {
			memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_setof6));
			{
			    _cpContextAssertion(_g, &(s_oss_tmp_2->value), &(d_oss_tmp_2->value));
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_setof6 *)_oss_dec_getmem_internal(_g, sizeof(_setof6));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	} break;
	case 51: {
	    pdVal = _cpRDNSequence(_g, (_RDNSequence * *)src, (_RDNSequence * *)pdVal);
	} break;
	case 52: {
	    pdVal = (_SubtreeSpecification  *)_oss_dec_const_alloc(_g, sizeof(_SubtreeSpecification ));
	    memcpy((_SubtreeSpecification  *)pdVal, (_SubtreeSpecification  *)src, sizeof(*(_SubtreeSpecification  *)pdVal));
	    if ((*(_SubtreeSpecification  *)src).bit_mask & 0x80000000) {
		_cpRDNSequence(_g, &((*(_SubtreeSpecification  *)src).base), &((*(_SubtreeSpecification  *)pdVal).base));
	    }
	    if ((*(_SubtreeSpecification  *)src).bit_mask & 0x40000000) {
		(*(_SubtreeSpecification  *)pdVal).specificExclusions = nullptr;
		if ((*(_SubtreeSpecification  *)src).specificExclusions) {
		    _setof19 *  s_oss_tmp_2 = (*(_SubtreeSpecification  *)src).specificExclusions;
		    _setof19 *  d_oss_tmp_2;

		    (*(_SubtreeSpecification  *)pdVal).specificExclusions = d_oss_tmp_2 = (_setof19 *)_oss_dec_getmem_internal(_g, sizeof(_setof19));
		    do {
			memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_setof19));
			{
			    switch ((s_oss_tmp_2->value).choice) {
				case 1: {
				    _cpRDNSequence(_g, &((s_oss_tmp_2->value).u.chopBefore), &((d_oss_tmp_2->value).u.chopBefore));
				}   break;
				case 2: {
				    _cpRDNSequence(_g, &((s_oss_tmp_2->value).u.chopAfter), &((d_oss_tmp_2->value).u.chopAfter));
				}   break;
				default:;
			    }
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_setof19 *)_oss_dec_getmem_internal(_g, sizeof(_setof19));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	    if ((*(_SubtreeSpecification  *)src).bit_mask & 0x8000000) {
		_cpRefinement(_g, &((*(_SubtreeSpecification  *)src).specificationFilter), &((*(_SubtreeSpecification  *)pdVal).specificationFilter));
	    }
	} break;
	case 53: {
	    pdVal = (_DITStructureRule  *)_oss_dec_const_alloc(_g, sizeof(_DITStructureRule ));
	    memcpy((_DITStructureRule  *)pdVal, (_DITStructureRule  *)src, sizeof(*(_DITStructureRule  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_DITStructureRule  *)src).nameForm), &((*(_DITStructureRule  *)pdVal).nameForm), sizeof(((*(_DITStructureRule  *)pdVal).nameForm).length), sizeof(((*(_DITStructureRule  *)pdVal).nameForm).value[0]), (unsigned int)((char *)&((*(_DITStructureRule  *)src).nameForm).value - (char *)&((*(_DITStructureRule  *)src).nameForm)));
	    }
	    if ((*(_DITStructureRule  *)src).bit_mask & 0x80000000) {
		_oss_cpy_link_obj(_g, (void**)(&((*(_DITStructureRule  *)src).superiorStructureRules)), (void**)(&((*(_DITStructureRule  *)pdVal).superiorStructureRules)), sizeof(_Presentation_context_deletion_list));
	    }
	} break;
	case 54: {
	    pdVal = (_DITContentRule  *)_oss_dec_const_alloc(_g, sizeof(_DITContentRule ));
	    memcpy((_DITContentRule  *)pdVal, (_DITContentRule  *)src, sizeof(*(_DITContentRule  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_DITContentRule  *)src).structuralObjectClass), &((*(_DITContentRule  *)pdVal).structuralObjectClass), sizeof(((*(_DITContentRule  *)pdVal).structuralObjectClass).length), sizeof(((*(_DITContentRule  *)pdVal).structuralObjectClass).value[0]), (unsigned int)((char *)&((*(_DITContentRule  *)src).structuralObjectClass).value - (char *)&((*(_DITContentRule  *)src).structuralObjectClass)));
	    }
	    if ((*(_DITContentRule  *)src).bit_mask & 0x80000000) {
		(*(_DITContentRule  *)pdVal).auxiliaries = nullptr;
		if ((*(_DITContentRule  *)src).auxiliaries) {
		    _Application_context_name_list *  s_oss_tmp_2 = (*(_DITContentRule  *)src).auxiliaries;
		    _Application_context_name_list *  d_oss_tmp_2;

		    (*(_DITContentRule  *)pdVal).auxiliaries = d_oss_tmp_2 = (_Application_context_name_list *)_oss_dec_getmem_internal(_g, sizeof(_Application_context_name_list));
		    do {
			memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_Application_context_name_list));
			{
			    _oss_cpy_unbnd_octet_ia(_g, &(s_oss_tmp_2->value), &(d_oss_tmp_2->value), sizeof((d_oss_tmp_2->value).length), sizeof((d_oss_tmp_2->value).value[0]), (unsigned int)((char *)&(s_oss_tmp_2->value).value - (char *)&(s_oss_tmp_2->value)));
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_Application_context_name_list *)_oss_dec_getmem_internal(_g, sizeof(_Application_context_name_list));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	    if ((*(_DITContentRule  *)src).bit_mask & 0x40000000) {
		(*(_DITContentRule  *)pdVal).mandatory = nullptr;
		if ((*(_DITContentRule  *)src).mandatory) {
		    _Application_context_name_list *  s_oss_tmp_2 = (*(_DITContentRule  *)src).mandatory;
		    _Application_context_name_list *  d_oss_tmp_2;

		    (*(_DITContentRule  *)pdVal).mandatory = d_oss_tmp_2 = (_Application_context_name_list *)_oss_dec_getmem_internal(_g, sizeof(_Application_context_name_list));
		    do {
			memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_Application_context_name_list));
			{
			    _oss_cpy_unbnd_octet_ia(_g, &(s_oss_tmp_2->value), &(d_oss_tmp_2->value), sizeof((d_oss_tmp_2->value).length), sizeof((d_oss_tmp_2->value).value[0]), (unsigned int)((char *)&(s_oss_tmp_2->value).value - (char *)&(s_oss_tmp_2->value)));
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_Application_context_name_list *)_oss_dec_getmem_internal(_g, sizeof(_Application_context_name_list));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	    if ((*(_DITContentRule  *)src).bit_mask & 0x20000000) {
		(*(_DITContentRule  *)pdVal).optional = nullptr;
		if ((*(_DITContentRule  *)src).optional) {
		    _Application_context_name_list *  s_oss_tmp_2 = (*(_DITContentRule  *)src).optional;
		    _Application_context_name_list *  d_oss_tmp_2;

		    (*(_DITContentRule  *)pdVal).optional = d_oss_tmp_2 = (_Application_context_name_list *)_oss_dec_getmem_internal(_g, sizeof(_Application_context_name_list));
		    do {
			memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_Application_context_name_list));
			{
			    _oss_cpy_unbnd_octet_ia(_g, &(s_oss_tmp_2->value), &(d_oss_tmp_2->value), sizeof((d_oss_tmp_2->value).length), sizeof((d_oss_tmp_2->value).value[0]), (unsigned int)((char *)&(s_oss_tmp_2->value).value - (char *)&(s_oss_tmp_2->value)));
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_Application_context_name_list *)_oss_dec_getmem_internal(_g, sizeof(_Application_context_name_list));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	    if ((*(_DITContentRule  *)src).bit_mask & 0x10000000) {
		(*(_DITContentRule  *)pdVal).precluded = nullptr;
		if ((*(_DITContentRule  *)src).precluded) {
		    _Application_context_name_list *  s_oss_tmp_2 = (*(_DITContentRule  *)src).precluded;
		    _Application_context_name_list *  d_oss_tmp_2;

		    (*(_DITContentRule  *)pdVal).precluded = d_oss_tmp_2 = (_Application_context_name_list *)_oss_dec_getmem_internal(_g, sizeof(_Application_context_name_list));
		    do {
			memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_Application_context_name_list));
			{
			    _oss_cpy_unbnd_octet_ia(_g, &(s_oss_tmp_2->value), &(d_oss_tmp_2->value), sizeof((d_oss_tmp_2->value).length), sizeof((d_oss_tmp_2->value).value[0]), (unsigned int)((char *)&(s_oss_tmp_2->value).value - (char *)&(s_oss_tmp_2->value)));
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_Application_context_name_list *)_oss_dec_getmem_internal(_g, sizeof(_Application_context_name_list));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	} break;
	case 55: {
	    pdVal = (_DITContextUse  *)_oss_dec_const_alloc(_g, sizeof(_DITContextUse ));
	    memcpy((_DITContextUse  *)pdVal, (_DITContextUse  *)src, sizeof(*(_DITContextUse  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_DITContextUse  *)src).attributeType), &((*(_DITContextUse  *)pdVal).attributeType), sizeof(((*(_DITContextUse  *)pdVal).attributeType).length), sizeof(((*(_DITContextUse  *)pdVal).attributeType).value[0]), (unsigned int)((char *)&((*(_DITContextUse  *)src).attributeType).value - (char *)&((*(_DITContextUse  *)src).attributeType)));
	    }
	    if ((*(_DITContextUse  *)src).bit_mask & 0x80000000) {
		(*(_DITContextUse  *)pdVal).mandatoryContexts = nullptr;
		if ((*(_DITContextUse  *)src).mandatoryContexts) {
		    _Application_context_name_list *  s_oss_tmp_2 = (*(_DITContextUse  *)src).mandatoryContexts;
		    _Application_context_name_list *  d_oss_tmp_2;

		    (*(_DITContextUse  *)pdVal).mandatoryContexts = d_oss_tmp_2 = (_Application_context_name_list *)_oss_dec_getmem_internal(_g, sizeof(_Application_context_name_list));
		    do {
			memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_Application_context_name_list));
			{
			    _oss_cpy_unbnd_octet_ia(_g, &(s_oss_tmp_2->value), &(d_oss_tmp_2->value), sizeof((d_oss_tmp_2->value).length), sizeof((d_oss_tmp_2->value).value[0]), (unsigned int)((char *)&(s_oss_tmp_2->value).value - (char *)&(s_oss_tmp_2->value)));
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_Application_context_name_list *)_oss_dec_getmem_internal(_g, sizeof(_Application_context_name_list));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	    if ((*(_DITContextUse  *)src).bit_mask & 0x40000000) {
		(*(_DITContextUse  *)pdVal).optionalContexts = nullptr;
		if ((*(_DITContextUse  *)src).optionalContexts) {
		    _Application_context_name_list *  s_oss_tmp_2 = (*(_DITContextUse  *)src).optionalContexts;
		    _Application_context_name_list *  d_oss_tmp_2;

		    (*(_DITContextUse  *)pdVal).optionalContexts = d_oss_tmp_2 = (_Application_context_name_list *)_oss_dec_getmem_internal(_g, sizeof(_Application_context_name_list));
		    do {
			memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_Application_context_name_list));
			{
			    _oss_cpy_unbnd_octet_ia(_g, &(s_oss_tmp_2->value), &(d_oss_tmp_2->value), sizeof((d_oss_tmp_2->value).length), sizeof((d_oss_tmp_2->value).value[0]), (unsigned int)((char *)&(s_oss_tmp_2->value).value - (char *)&(s_oss_tmp_2->value)));
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_Application_context_name_list *)_oss_dec_getmem_internal(_g, sizeof(_Application_context_name_list));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	} break;
	case 56: {
	    pdVal = (OSS_INT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_INT32 ));
	    *(OSS_INT32  *)pdVal = *(OSS_INT32  *)src;
	} break;
	case 57: {
	    pdVal = (ossBoolean  *)_oss_dec_const_alloc(_g, sizeof(ossBoolean ));
	    *(ossBoolean  *)pdVal = *(ossBoolean  *)src;
	} break;
	case 58: {
	    pdVal = (_RealizationParameter  *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter ));
	    memcpy((_RealizationParameter  *)pdVal, (_RealizationParameter  *)src, sizeof(*(_RealizationParameter  *)pdVal));
	} break;
	case 59: {
	    pdVal = (_RealizationParameter  *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter ));
	    memcpy((_RealizationParameter  *)pdVal, (_RealizationParameter  *)src, sizeof(*(_RealizationParameter  *)pdVal));
	} break;
	case 60: {
	    pdVal = (_RealizationParameter  *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter ));
	    memcpy((_RealizationParameter  *)pdVal, (_RealizationParameter  *)src, sizeof(*(_RealizationParameter  *)pdVal));
	} break;
	case 61: {
	    pdVal = (_RealizationParameter  *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter ));
	    memcpy((_RealizationParameter  *)pdVal, (_RealizationParameter  *)src, sizeof(*(_RealizationParameter  *)pdVal));
	} break;
	case 62: {
	    pdVal = (_RealizationParameter  *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter ));
	    memcpy((_RealizationParameter  *)pdVal, (_RealizationParameter  *)src, sizeof(*(_RealizationParameter  *)pdVal));
	} break;
	case 63: {
	    pdVal = (_RealizationParameter  *)_oss_dec_const_alloc(_g, sizeof(_RealizationParameter ));
	    memcpy((_RealizationParameter  *)pdVal, (_RealizationParameter  *)src, sizeof(*(_RealizationParameter  *)pdVal));
	} break;
	case 64: {
	    pdVal = (OSSC::COssBitString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssBitString  *)src, (OSSC::COssBitString  *)pdVal, sizeof((*(OSSC::COssBitString  *)pdVal).length), -1L, (unsigned int)((char *)&(*(OSSC::COssBitString  *)src).value - (char *)(OSSC::COssBitString  *)src));
	} break;
	case 65: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 66: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 67: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 68: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 69: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 70: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 71: {
	    pdVal = (ossBoolean  *)_oss_dec_const_alloc(_g, sizeof(ossBoolean ));
	    *(ossBoolean  *)pdVal = *(ossBoolean  *)src;
	} break;
	case 72: {
	    pdVal = (OSS_INT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_INT32 ));
	    *(OSS_INT32  *)pdVal = *(OSS_INT32  *)src;
	} break;
	case 73: {
	    pdVal = (OSS_INT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_INT32 ));
	    *(OSS_INT32  *)pdVal = *(OSS_INT32  *)src;
	} break;
	case 74: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 75: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 76: {
	    size_t  len_0 = (size_t)sizeof(char) * (strlen(*(char *  *)src) + 1);

	    pdVal = (char *  *)_oss_dec_const_alloc(_g, sizeof(char * ));
	    *(char *  *)pdVal = (char * )_oss_dec_getmem_internal(_g, (long)len_0);
	    strcpy(*(char *  *)pdVal, *(char *  *)src);
	} break;
	case 77: {
	    size_t  len_0 = (size_t)sizeof(char) * (strlen(*(char *  *)src) + 1);

	    pdVal = (char *  *)_oss_dec_const_alloc(_g, sizeof(char * ));
	    *(char *  *)pdVal = (char * )_oss_dec_getmem_internal(_g, (long)len_0);
	    strcpy(*(char *  *)pdVal, *(char *  *)src);
	} break;
	case 78: {
	    size_t  len_0 = (size_t)sizeof(char) * (strlen(*(char *  *)src) + 1);

	    pdVal = (char *  *)_oss_dec_const_alloc(_g, sizeof(char * ));
	    *(char *  *)pdVal = (char * )_oss_dec_getmem_internal(_g, (long)len_0);
	    strcpy(*(char *  *)pdVal, *(char *  *)src);
	} break;
	case 79: {
	    size_t  len_0 = (size_t)sizeof(char) * (strlen(*(char *  *)src) + 1);

	    pdVal = (char *  *)_oss_dec_const_alloc(_g, sizeof(char * ));
	    *(char *  *)pdVal = (char * )_oss_dec_getmem_internal(_g, (long)len_0);
	    strcpy(*(char *  *)pdVal, *(char *  *)src);
	} break;
	case 80: {
	    pdVal = (OSS_INT32  *)_oss_dec_const_alloc(_g, sizeof(OSS_INT32 ));
	    *(OSS_INT32  *)pdVal = *(OSS_INT32  *)src;
	} break;
	case 81: {
	    pdVal = (OSSC::COssEncOID  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssEncOID  *)src, (OSSC::COssEncOID  *)pdVal, sizeof((*(OSSC::COssEncOID  *)pdVal).length), sizeof((*(OSSC::COssEncOID  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssEncOID  *)src).value - (char *)(OSSC::COssEncOID  *)src));
	} break;
	case 82: {
	    size_t  len_0 = (size_t)sizeof(char) * (strlen(*(char *  *)src) + 1);

	    pdVal = (char *  *)_oss_dec_const_alloc(_g, sizeof(char * ));
	    *(char *  *)pdVal = (char * )_oss_dec_getmem_internal(_g, (long)len_0);
	    strcpy(*(char *  *)pdVal, *(char *  *)src);
	} break;
	case 83: {
	    size_t  len_0 = (size_t)sizeof(char) * (strlen(*(char *  *)src) + 1);

	    pdVal = (char *  *)_oss_dec_const_alloc(_g, sizeof(char * ));
	    *(char *  *)pdVal = (char * )_oss_dec_getmem_internal(_g, (long)len_0);
	    strcpy(*(char *  *)pdVal, *(char *  *)src);
	} break;
	case 84: {
	    size_t  len_0 = (size_t)sizeof(char) * (strlen(*(char *  *)src) + 1);

	    pdVal = (char *  *)_oss_dec_const_alloc(_g, sizeof(char * ));
	    *(char *  *)pdVal = (char * )_oss_dec_getmem_internal(_g, (long)len_0);
	    strcpy(*(char *  *)pdVal, *(char *  *)src);
	} break;
	case 85: {
	    pdVal = (ossBoolean  *)_oss_dec_const_alloc(_g, sizeof(ossBoolean ));
	    *(ossBoolean  *)pdVal = *(ossBoolean  *)src;
	} break;
	default:
	    res = PDU_RANGE;
    }
    *pdst = pdVal;
    return res;
}
#undef _oss_c

void _oss_cpy_new_open_type (OssGlobal *_g, int *_pduNum,
		OssBuf *_obuf, OssBuf *_cbuf, void *_odecoded, void **_cdecoded)
{
    unsigned long   apiFlags = _g->decodingFlags | _g->encodingFlags;

    if (_obuf->length && _obuf->value) {
	if (apiFlags & DONT_DO_ENCODED) {
	    _cbuf->length = 0L;
	    _cbuf->value = nullptr;
	} else {
	    _cbuf->value = (unsigned char *)_oss_dec_getmem_internal(_g, _obuf->length);
	    memcpy(_cbuf->value, _obuf->value, _obuf->length);
	    _cbuf->length = _obuf->length;
	}
    } else {
	_cbuf->length = 0L;
	_cbuf->value = nullptr;
    }
    if (*_pduNum && _odecoded && !(apiFlags & DONT_DO_DECODED)) {
	_CPUpperBounds_(_g, *_pduNum, _odecoded, _cdecoded);
    } else {
	*_pduNum = 0;
	*_cdecoded = nullptr;
    }
}
#endif /* OSS_COPY_VALUE */

#ifdef OSS_COMPARE_VALUE
static int _cmUnboundedDirectoryString(OssGlobal * _g, _UnboundedDirectoryString  * _odata, _UnboundedDirectoryString  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    if (_oss_cmp_unbnd_octet_ia(&((*_odata).u.uTF8String), &((*_cdata).u.uTF8String), sizeof(((*_cdata).u.uTF8String).length), sizeof(((*_cdata).u.uTF8String).value[0]), (unsigned int)((char *)&((*_odata).u.uTF8String).value - (char *)&((*_odata).u.uTF8String))))
		return 1;
	}   break;
	case 2: {
	    if (_oss_cmp_unbnd_octet_ia(&((*_odata).u.printableString), &((*_cdata).u.printableString), sizeof(((*_cdata).u.printableString).length), sizeof(((*_cdata).u.printableString).value[0]), (unsigned int)((char *)&((*_odata).u.printableString).value - (char *)&((*_odata).u.printableString))))
		return 1;
	}   break;
	case 3: {
	    if (_oss_cmp_unbnd_octet_ia(&((*_odata).u.teletexString), &((*_cdata).u.teletexString), sizeof(((*_cdata).u.teletexString).length), sizeof(((*_cdata).u.teletexString).value[0]), (unsigned int)((char *)&((*_odata).u.teletexString).value - (char *)&((*_odata).u.teletexString))))
		return 1;
	}   break;
	case 4: {
	    if (_oss_cmp_unbnd_octet_ia(&((*_odata).u.universalString), &((*_cdata).u.universalString), sizeof(((*_cdata).u.universalString).length), sizeof(((*_cdata).u.universalString).value[0]), (unsigned int)((char *)&((*_odata).u.universalString).value - (char *)&((*_odata).u.universalString))))
		return 1;
	}   break;
	case 5: {
	    if (_oss_cmp_unbnd_octet_ia(&((*_odata).u.bmpString), &((*_cdata).u.bmpString), sizeof(((*_cdata).u.bmpString).length), sizeof(((*_cdata).u.bmpString).value[0]), (unsigned int)((char *)&((*_odata).u.bmpString).value - (char *)&((*_odata).u.bmpString))))
		return 1;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}


static int _cmContextAssertion(OssGlobal * _g, _ContextAssertion  * _odata, _ContextAssertion  * _cdata)
{
    int _res = 0;

    if (!((*_cdata).contextType).length)
	return 1;
    if (_oss_cmp_unbnd_octet_ia(&((*_odata).contextType), &((*_cdata).contextType), sizeof(((*_cdata).contextType).length), sizeof(((*_cdata).contextType).value[0]), (unsigned int)((char *)&((*_odata).contextType).value - (char *)&((*_odata).contextType))))
	return 1;
    {
	_setof11 *  _s_2 = (*_odata).contextValues;
	_setof11 *  _d_2 = (*_cdata).contextValues;
	long        *_a, _i, _i_next, _c = 0L;

	while (_s_2 && _d_2) {
	    ++ _c;
	    _s_2 = _s_2->next;
	    _d_2 = _d_2->next;
	}
	if (_s_2 || _d_2)
	    return 1;
	if (_c) {
	    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
	    for (_i = 0; _i < _c; _i ++)
		_a[_i] = _i;
	    _a[_c] = -1L;
	    for (_s_2 = (*_odata).contextValues; _s_2; _s_2 = _s_2->next) {
		_i_next = _a[0]; _res = 1;
		for (_d_2 = (*_cdata).contextValues, _i = 0L; _d_2 && _i_next >= 0L && _a[_i_next] >= 0L; _d_2 = _d_2->next,
			_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
		    if (_i < _i_next)
			continue;
		    _res = _oss_cmp_new_open_type(_g, (_s_2->value).pduNum, (_d_2->value).pduNum, &((_s_2->value).encoded), &((_d_2->value).encoded), *(void **)&((_s_2->value).decoded), *(void **)&((_d_2->value).decoded));
		    if (_res)
			continue;
		    _res = 0; _a[_i] = _a[_i+1];
		    break;
		}
		if (_res)
		    break;
	    }
	    _oss_dec_freetempmem(_g, _a);
	    if (_res)
		return _res;
	}
    }

    return _res;
}


static int _cm_choice1(OssGlobal * _g, _choice1  * _odata, _choice1  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    _res = _oss_cmp_open_type(_g, (OpenType *)&((*_odata).u.single_ASN1_type), (OpenType *)&((*_cdata).u.single_ASN1_type));
	    if (_res)
		return _res;
	}   break;
	case 2: {
	    if (_oss_cmp_unbnd_octet_ia(&((*_odata).u.octet_aligned), &((*_cdata).u.octet_aligned), sizeof(((*_cdata).u.octet_aligned).length), sizeof(((*_cdata).u.octet_aligned).value[0]), (unsigned int)((char *)&((*_odata).u.octet_aligned).value - (char *)&((*_odata).u.octet_aligned))))
		return 1;
	}   break;
	case 3: {
	    if (_oss_cmp_arrbits(((*_odata).u.arbitrary).value, ((*_cdata).u.arbitrary).value, ((*_odata).u.arbitrary).length, ((*_cdata).u.arbitrary).length))
		return 1;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}


static int _cmExternal(OssGlobal * _g, _External  * _odata, _External  * _cdata)
{
    int _res = 0;

    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x80000000)
	return 1;
    if ((*_odata).bit_mask & 0x80000000) {
	if (!((*_cdata).direct_reference).length)
	    return 1;
	if (_oss_cmp_unbnd_octet_ia(&((*_odata).direct_reference), &((*_cdata).direct_reference), sizeof(((*_cdata).direct_reference).length), sizeof(((*_cdata).direct_reference).value[0]), (unsigned int)((char *)&((*_odata).direct_reference).value - (char *)&((*_odata).direct_reference))))
	    return 1;
    }
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x40000000)
	return 1;
    if ((*_odata).bit_mask & 0x40000000) {
	if ((*_cdata).indirect_reference != (*_odata).indirect_reference)
	    return 1;
    }
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x20000000)
	return 1;
    if ((*_odata).bit_mask & 0x20000000) {
	if (_oss_cmp_unbnd_octet_ia(&((*_odata).data_value_descriptor), &((*_cdata).data_value_descriptor), sizeof(((*_cdata).data_value_descriptor).length), sizeof(((*_cdata).data_value_descriptor).value[0]), (unsigned int)((char *)&((*_odata).data_value_descriptor).value - (char *)&((*_odata).data_value_descriptor))))
	    return 1;
    }
    _res = _cm_choice1(_g, &((*_odata).encoding), &((*_cdata).encoding));
    if (_res)
	return _res;

    return _res;
}


static int _cmName(OssGlobal * _g, _Name  * _odata, _Name  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    _res = _cmRDNSequence(_g, &((*_odata).u.rdnSequence), &((*_cdata).u.rdnSequence));
	    if (_res)
		return _res;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}


static int _cmAP_title(OssGlobal * _g, _AP_title  * _odata, _AP_title  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    if (!((*_cdata).u.ap_title_form2).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*_odata).u.ap_title_form2), &((*_cdata).u.ap_title_form2), sizeof(((*_cdata).u.ap_title_form2).length), sizeof(((*_cdata).u.ap_title_form2).value[0]), (unsigned int)((char *)&((*_odata).u.ap_title_form2).value - (char *)&((*_odata).u.ap_title_form2))))
		return 1;
	}   break;
	case 2: {
	    _res = _cmName(_g, (*_odata).u.ap_title_form1, (*_cdata).u.ap_title_form1);
	    if (_res)
		return _res;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}


static int _cmAE_qualifier(OssGlobal * _g, _AE_qualifier  * _odata, _AE_qualifier  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    if ((*_cdata).u.ae_qualifier_form2 != (*_odata).u.ae_qualifier_form2)
		return 1;
	}   break;
	case 2: {
	    _res = _cmRelativeDistinguishedName(_g, &((*_odata).u.ae_qualifier_form1), &((*_cdata).u.ae_qualifier_form1));
	    if (_res)
		return _res;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}


static int _cmRealizationParameter(OssGlobal * _g, _RealizationParameter  * _odata, _RealizationParameter  * _cdata)
{
    int _res = 0;

    if ((*_cdata).realization_type != (*_odata).realization_type)
	return 1;
    if (((*_odata).bit_mask & (*_cdata).bit_mask) & 0x80000000) {
	if (((*_cdata).concatenation ^ (*_odata).concatenation) & 0x01)
	    return 1;
    } else {
	if ((*_odata).bit_mask & 0x80000000) {
	    if ((Context::default_fallback ^ (*_odata).concatenation) & 0x01)
		return 1;
	}
	if ((*_cdata).bit_mask & 0x80000000) {
	    if (((*_cdata).concatenation ^ Context::default_fallback) & 0x01)
		return 1;
	}
    }

    return _res;
}


static int _cm_seq1(OssGlobal * _g, _seq1 * * _odata, _seq1 * * _cdata)
{
    int _res = 0;

    if (!((*_cdata)->other_mechanism_name).length)
	return 1;
    if (_oss_cmp_unbnd_octet_ia(&((*_odata)->other_mechanism_name), &((*_cdata)->other_mechanism_name), sizeof(((*_cdata)->other_mechanism_name).length), sizeof(((*_cdata)->other_mechanism_name).value[0]), (unsigned int)((char *)&((*_odata)->other_mechanism_name).value - (char *)&((*_odata)->other_mechanism_name))))
	return 1;
    _res = _oss_cmp_new_open_type(_g, ((*_odata)->other_mechanism_value).pduNum, ((*_cdata)->other_mechanism_value).pduNum, &(((*_odata)->other_mechanism_value).encoded), &(((*_cdata)->other_mechanism_value).encoded), *(void **)&(((*_odata)->other_mechanism_value).decoded), *(void **)&(((*_cdata)->other_mechanism_value).decoded));
    if (_res)
	return _res;

    return _res;
}


static int _cmAuthentication_value(OssGlobal * _g, _Authentication_value  * _odata, _Authentication_value  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    if (_oss_cmp_unbnd_octet_ia(&((*_odata).u.charstring), &((*_cdata).u.charstring), sizeof(((*_cdata).u.charstring).length), sizeof(((*_cdata).u.charstring).value[0]), (unsigned int)((char *)&((*_odata).u.charstring).value - (char *)&((*_odata).u.charstring))))
		return 1;
	}   break;
	case 2: {
	    if (_oss_cmp_arrbits(((*_odata).u.bitstring).value, ((*_cdata).u.bitstring).value, ((*_odata).u.bitstring).length, ((*_cdata).u.bitstring).length))
		return 1;
	}   break;
	case 3: {
	    _res = _cmExternal(_g, (*_odata).u.external, (*_cdata).u.external);
	    if (_res)
		return _res;
	}   break;
	case 4: {
	    _res = _cm_seq1(_g, &(*_odata).u.other, &(*_cdata).u.other);
	    if (_res)
		return _res;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}


static int _cm13Application_context_name_l(OssGlobal * _g, _Application_context_name_list * * _odata, _Application_context_name_list * * _cdata)
{
    int _res = 0;

    {
	_Application_context_name_list *  _s_oss_tmp_1 = *_odata;
	_Application_context_name_list *  _d_oss_tmp_1 = *_cdata;

	while (_s_oss_tmp_1 && _d_oss_tmp_1) {
	    if (!(_d_oss_tmp_1->value).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value), sizeof((_d_oss_tmp_1->value).length), sizeof((_d_oss_tmp_1->value).value[0]), (unsigned int)((char *)&(_s_oss_tmp_1->value).value - (char *)&(_s_oss_tmp_1->value))))
		return 1;
	    _s_oss_tmp_1 = _s_oss_tmp_1->next;
	    _d_oss_tmp_1 = _d_oss_tmp_1->next;
	}
	if (_s_oss_tmp_1 || _d_oss_tmp_1)
	    return 1;
    }

    return _res;
}


static int _cmAssociation_information(OssGlobal * _g, _Association_information * * _odata, _Association_information * * _cdata)
{
    int _res = 0;

    {
	_Association_information *  _s_oss_tmp_1 = *_odata;
	_Association_information *  _d_oss_tmp_1 = *_cdata;

	while (_s_oss_tmp_1 && _d_oss_tmp_1) {
	    _res = _cmExternal(_g, &(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value));
	    if (_res)
		return _res;
	    _s_oss_tmp_1 = _s_oss_tmp_1->next;
	    _d_oss_tmp_1 = _d_oss_tmp_1->next;
	}
	if (_s_oss_tmp_1 || _d_oss_tmp_1)
	    return 1;
    }

    return _res;
}


static int _cmMode_selector(OssGlobal * _g, _Mode_selector  * _odata, _Mode_selector  * _cdata)
{
    int _res = 0;

    if ((*_cdata).mode_value != (*_odata).mode_value)
	return 1;

    return _res;
}


static int _cmConnectionData(OssGlobal * _g, _ConnectionData  * _odata, _ConnectionData  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    _res = _oss_cmp_open_type(_g, (OpenType *)&((*_odata).u.open), (OpenType *)&((*_cdata).u.open));
	    if (_res)
		return _res;
	}   break;
	case 2: {
	    _res = _cmSessionConnectionIdentifier(_g, (*_odata).u.recover, (*_cdata).u.recover);
	    if (_res)
		return _res;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}


static int _cmUser_data(OssGlobal * _g, _User_data  * _odata, _User_data  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    if (_oss_cmp_unbnd_octet_ia(&((*_odata).u.simply_encoded_data), &((*_cdata).u.simply_encoded_data), sizeof(((*_cdata).u.simply_encoded_data).length), sizeof(((*_cdata).u.simply_encoded_data).value[0]), (unsigned int)((char *)&((*_odata).u.simply_encoded_data).value - (char *)&((*_odata).u.simply_encoded_data))))
		return 1;
	}   break;
	case 2: {
	    _res = _cmFully_encoded_data(_g, &((*_odata).u.fully_encoded_data), &((*_cdata).u.fully_encoded_data));
	    if (_res)
		return _res;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}


static int _cm_seq7(OssGlobal * _g, _seq7  * _odata, _seq7  * _cdata)
{
    int _res = 0;

    if ((*_cdata).presentation_context_identifier != (*_odata).presentation_context_identifier)
	return 1;
    if (!((*_cdata).abstract_syntax_name).length)
	return 1;
    if (_oss_cmp_unbnd_octet_ia(&((*_odata).abstract_syntax_name), &((*_cdata).abstract_syntax_name), sizeof(((*_cdata).abstract_syntax_name).length), sizeof(((*_cdata).abstract_syntax_name).value[0]), (unsigned int)((char *)&((*_odata).abstract_syntax_name).value - (char *)&((*_odata).abstract_syntax_name))))
	return 1;
    {
	_Application_context_name_list *  _s_oss_tmp_2 = (*_odata).transfer_syntax_name_list;
	_Application_context_name_list *  _d_oss_tmp_2 = (*_cdata).transfer_syntax_name_list;

	while (_s_oss_tmp_2 && _d_oss_tmp_2) {
	    if (!(_d_oss_tmp_2->value).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&(_s_oss_tmp_2->value), &(_d_oss_tmp_2->value), sizeof((_d_oss_tmp_2->value).length), sizeof((_d_oss_tmp_2->value).value[0]), (unsigned int)((char *)&(_s_oss_tmp_2->value).value - (char *)&(_s_oss_tmp_2->value))))
		return 1;
	    _s_oss_tmp_2 = _s_oss_tmp_2->next;
	    _d_oss_tmp_2 = _d_oss_tmp_2->next;
	}
	if (_s_oss_tmp_2 || _d_oss_tmp_2)
	    return 1;
    }

    return _res;
}


static int _cmContext_list(OssGlobal * _g, _Context_list * * _odata, _Context_list * * _cdata)
{
    int _res = 0;

    {
	_Context_list *  _s_oss_tmp_1 = *_odata;
	_Context_list *  _d_oss_tmp_1 = *_cdata;

	while (_s_oss_tmp_1 && _d_oss_tmp_1) {
	    _res = _cm_seq7(_g, &(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value));
	    if (_res)
		return _res;
	    _s_oss_tmp_1 = _s_oss_tmp_1->next;
	    _d_oss_tmp_1 = _d_oss_tmp_1->next;
	}
	if (_s_oss_tmp_1 || _d_oss_tmp_1)
	    return 1;
    }

    return _res;
}


static int _cm_seq8(OssGlobal * _g, _seq8  * _odata, _seq8  * _cdata)
{
    int _res = 0;

    if ((*_cdata).presentation_context_identifier != (*_odata).presentation_context_identifier)
	return 1;
    if (!((*_cdata).transfer_syntax_name).length)
	return 1;
    if (_oss_cmp_unbnd_octet_ia(&((*_odata).transfer_syntax_name), &((*_cdata).transfer_syntax_name), sizeof(((*_cdata).transfer_syntax_name).length), sizeof(((*_cdata).transfer_syntax_name).value[0]), (unsigned int)((char *)&((*_odata).transfer_syntax_name).value - (char *)&((*_odata).transfer_syntax_name))))
	return 1;

    return _res;
}


static int _cm14Presentation_context_ident(OssGlobal * _g, _Presentation_context_identifier_list * * _odata, _Presentation_context_identifier_list * * _cdata)
{
    int _res = 0;

    {
	_Presentation_context_identifier_list *  _s_oss_tmp_1 = *_odata;
	_Presentation_context_identifier_list *  _d_oss_tmp_1 = *_cdata;

	while (_s_oss_tmp_1 && _d_oss_tmp_1) {
	    _res = _cm_seq8(_g, &(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value));
	    if (_res)
		return _res;
	    _s_oss_tmp_1 = _s_oss_tmp_1->next;
	    _d_oss_tmp_1 = _d_oss_tmp_1->next;
	}
	if (_s_oss_tmp_1 || _d_oss_tmp_1)
	    return 1;
    }

    return _res;
}


static int _cm_seq9(OssGlobal * _g, _seq9  * _odata, _seq9  * _cdata)
{
    int _res = 0;

    if ((*_cdata).result != (*_odata).result)
	return 1;
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x80000000)
	return 1;
    if ((*_odata).bit_mask & 0x80000000) {
	if (!((*_cdata).transfer_syntax_name).length)
	    return 1;
	if (_oss_cmp_unbnd_octet_ia(&((*_odata).transfer_syntax_name), &((*_cdata).transfer_syntax_name), sizeof(((*_cdata).transfer_syntax_name).length), sizeof(((*_cdata).transfer_syntax_name).value[0]), (unsigned int)((char *)&((*_odata).transfer_syntax_name).value - (char *)&((*_odata).transfer_syntax_name))))
	    return 1;
    }
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x40000000)
	return 1;
    if ((*_odata).bit_mask & 0x40000000) {
	if ((*_cdata).provider_reason != (*_odata).provider_reason)
	    return 1;
    }

    return _res;
}


static int _cmResult_list(OssGlobal * _g, _Result_list * * _odata, _Result_list * * _cdata)
{
    int _res = 0;

    {
	_Result_list *  _s_oss_tmp_1 = *_odata;
	_Result_list *  _d_oss_tmp_1 = *_cdata;

	while (_s_oss_tmp_1 && _d_oss_tmp_1) {
	    _res = _cm_seq9(_g, &(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value));
	    if (_res)
		return _res;
	    _s_oss_tmp_1 = _s_oss_tmp_1->next;
	    _d_oss_tmp_1 = _d_oss_tmp_1->next;
	}
	if (_s_oss_tmp_1 || _d_oss_tmp_1)
	    return 1;
    }

    return _res;
}


static int _cmPDV_list(OssGlobal * _g, _PDV_list  * _odata, _PDV_list  * _cdata)
{
    int _res = 0;

    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x80000000)
	return 1;
    if ((*_odata).bit_mask & 0x80000000) {
	if (!((*_cdata).transfer_syntax_name).length)
	    return 1;
	if (_oss_cmp_unbnd_octet_ia(&((*_odata).transfer_syntax_name), &((*_cdata).transfer_syntax_name), sizeof(((*_cdata).transfer_syntax_name).length), sizeof(((*_cdata).transfer_syntax_name).value[0]), (unsigned int)((char *)&((*_odata).transfer_syntax_name).value - (char *)&((*_odata).transfer_syntax_name))))
	    return 1;
    }
    if ((*_cdata).presentation_context_identifier != (*_odata).presentation_context_identifier)
	return 1;
    if (((*_odata).presentation_data_values).choice != ((*_cdata).presentation_data_values).choice)
	return 1;
    switch (((*_odata).presentation_data_values).choice) {
	case 1: {
	    _res = _oss_cmp_open_type(_g, (OpenType *)&(((*_odata).presentation_data_values).u.single_ASN1_type), (OpenType *)&(((*_cdata).presentation_data_values).u.single_ASN1_type));
	    if (_res)
		return _res;
	}   break;
	case 2: {
	    if (_oss_cmp_unbnd_octet_ia(&(((*_odata).presentation_data_values).u.octet_aligned), &(((*_cdata).presentation_data_values).u.octet_aligned), sizeof((((*_cdata).presentation_data_values).u.octet_aligned).length), sizeof((((*_cdata).presentation_data_values).u.octet_aligned).value[0]), (unsigned int)((char *)&(((*_odata).presentation_data_values).u.octet_aligned).value - (char *)&(((*_odata).presentation_data_values).u.octet_aligned))))
		return 1;
	}   break;
	case 3: {
	    if (_oss_cmp_arrbits((((*_odata).presentation_data_values).u.arbitrary).value, (((*_cdata).presentation_data_values).u.arbitrary).value, (((*_odata).presentation_data_values).u.arbitrary).length, (((*_cdata).presentation_data_values).u.arbitrary).length))
		return 1;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}


static int _cmFully_encoded_data(OssGlobal * _g, _Fully_encoded_data * * _odata, _Fully_encoded_data * * _cdata)
{
    int _res = 0;

    {
	_Fully_encoded_data *  _s_oss_tmp_1 = *_odata;
	_Fully_encoded_data *  _d_oss_tmp_1 = *_cdata;

	while (_s_oss_tmp_1 && _d_oss_tmp_1) {
	    _res = _cmPDV_list(_g, &(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value));
	    if (_res)
		return _res;
	    _s_oss_tmp_1 = _s_oss_tmp_1->next;
	    _d_oss_tmp_1 = _d_oss_tmp_1->next;
	}
	if (_s_oss_tmp_1 || _d_oss_tmp_1)
	    return 1;
    }

    return _res;
}


static int _cmRTORQapdu(OssGlobal * _g, _set1  * _odata, _set1  * _cdata)
{
    int _res = 0;

    if (((*_odata).bit_mask & (*_cdata).bit_mask) & 0x80000000) {
	if ((*_cdata).checkpointSize != (*_odata).checkpointSize)
	    return 1;
    } else {
	if ((*_odata).bit_mask & 0x80000000) {
	    if (__shared15::default_checkpointSize != (*_odata).checkpointSize)
		return 1;
	}
	if ((*_cdata).bit_mask & 0x80000000) {
	    if ((*_cdata).checkpointSize != __shared15::default_checkpointSize)
		return 1;
	}
    }
    if (((*_odata).bit_mask & (*_cdata).bit_mask) & 0x40000000) {
	if ((*_cdata).windowSize != (*_odata).windowSize)
	    return 1;
    } else {
	if ((*_odata).bit_mask & 0x40000000) {
	    if (__shared15::default_windowSize != (*_odata).windowSize)
		return 1;
	}
	if ((*_cdata).bit_mask & 0x40000000) {
	    if ((*_cdata).windowSize != __shared15::default_windowSize)
		return 1;
	}
    }
    if (((*_odata).bit_mask & (*_cdata).bit_mask) & 0x20000000) {
	if ((*_cdata).dialogueMode != (*_odata).dialogueMode)
	    return 1;
    } else {
	if ((*_odata).bit_mask & 0x20000000) {
	    if (__shared15::default_checkpointSize != (*_odata).dialogueMode)
		return 1;
	}
	if ((*_cdata).bit_mask & 0x20000000) {
	    if ((*_cdata).dialogueMode != __shared15::default_checkpointSize)
		return 1;
	}
    }
    _res = _cmConnectionData(_g, &((*_odata).connectionDataRQ), &((*_cdata).connectionDataRQ));
    if (_res)
	return _res;
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x10000000)
	return 1;
    if ((*_odata).bit_mask & 0x10000000) {
	if ((*_cdata).applicationProtocol != (*_odata).applicationProtocol)
	    return 1;
    }

    return _res;
}


static int _cmRTOACapdu(OssGlobal * _g, _set2  * _odata, _set2  * _cdata)
{
    int _res = 0;

    if (((*_odata).bit_mask & (*_cdata).bit_mask) & 0x80000000) {
	if ((*_cdata).checkpointSize != (*_odata).checkpointSize)
	    return 1;
    } else {
	if ((*_odata).bit_mask & 0x80000000) {
	    if (__shared15::default_checkpointSize != (*_odata).checkpointSize)
		return 1;
	}
	if ((*_cdata).bit_mask & 0x80000000) {
	    if ((*_cdata).checkpointSize != __shared15::default_checkpointSize)
		return 1;
	}
    }
    if (((*_odata).bit_mask & (*_cdata).bit_mask) & 0x40000000) {
	if ((*_cdata).windowSize != (*_odata).windowSize)
	    return 1;
    } else {
	if ((*_odata).bit_mask & 0x40000000) {
	    if (__shared15::default_windowSize != (*_odata).windowSize)
		return 1;
	}
	if ((*_cdata).bit_mask & 0x40000000) {
	    if ((*_cdata).windowSize != __shared15::default_windowSize)
		return 1;
	}
    }
    _res = _cmConnectionData(_g, &((*_odata).connectionDataAC), &((*_cdata).connectionDataAC));
    if (_res)
	return _res;

    return _res;
}


static int _cmRTORJapdu(OssGlobal * _g, _set3  * _odata, _set3  * _cdata)
{
    int _res = 0;

    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x80000000)
	return 1;
    if ((*_odata).bit_mask & 0x80000000) {
	if ((*_cdata).refuseReason != (*_odata).refuseReason)
	    return 1;
    }
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x40000000)
	return 1;
    if ((*_odata).bit_mask & 0x40000000) {
	_res = _oss_cmp_open_type(_g, (OpenType *)&((*_odata).userDataRJ), (OpenType *)&((*_cdata).userDataRJ));
	if (_res)
	    return _res;
    }

    return _res;
}


static int _cmCallingSSuserReference(OssGlobal * _g, _CallingSSuserReference  * _odata, _CallingSSuserReference  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    if (_oss_cmp_unbnd_octet_ia(&((*_odata).u.octetString), &((*_cdata).u.octetString), sizeof(((*_cdata).u.octetString).length), sizeof(((*_cdata).u.octetString).value[0]), (unsigned int)((char *)&((*_odata).u.octetString).value - (char *)&((*_odata).u.octetString))))
		return 1;
	}   break;
	case 2: {
	    if (_oss_cmp_unbnd_octet_ia(&((*_odata).u.t61String), &((*_cdata).u.t61String), sizeof(((*_cdata).u.t61String).length), sizeof(((*_cdata).u.t61String).value[0]), (unsigned int)((char *)&((*_odata).u.t61String).value - (char *)&((*_odata).u.t61String))))
		return 1;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}


static int _cmSessionConnectionIdentifier(OssGlobal * _g, _SessionConnectionIdentifier  * _odata, _SessionConnectionIdentifier  * _cdata)
{
    int _res = 0;

    _res = _cmCallingSSuserReference(_g, &((*_odata).callingSSuserReference), &((*_cdata).callingSSuserReference));
    if (_res)
	return _res;
    if (strcmp((*_cdata).commonReference, (*_odata).commonReference))
#ifdef BAD_OID_IRI
	if (_oss_cmp_str2time((*_cdata).commonReference, (*_odata).commonReference, 1))
#endif
	    return 1;
    if (((*_odata).bit_mask ^ (*_cdata).bit_mask) & 0x80000000)
	return 1;
    if ((*_odata).bit_mask & 0x80000000) {
	if (_oss_cmp_unbnd_octet_ia(&((*_odata).additionalReferenceInformation), &((*_cdata).additionalReferenceInformation), sizeof(((*_cdata).additionalReferenceInformation).length), sizeof(((*_cdata).additionalReferenceInformation).value[0]), (unsigned int)((char *)&((*_odata).additionalReferenceInformation).value - (char *)&((*_odata).additionalReferenceInformation))))
	    return 1;
    }

    return _res;
}


static int _cmInvokeId(OssGlobal * _g, _InvokeId  * _odata, _InvokeId  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    if ((*_cdata).u.present != (*_odata).u.present)
		return 1;
	}   break;
	case 2: {
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}


static int _cmCriteria(OssGlobal * _g, _Criteria  * _odata, _Criteria  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    _res = _cmCriteriaItem(_g, (*_odata).u.type, (*_cdata).u.type);
	    if (_res)
		return _res;
	}   break;
	case 2: {
	    _res = _cm_setof1(_g, &((*_odata).u.Criteria_and), &((*_cdata).u.Criteria_and));
	    if (_res)
		return _res;
	}   break;
	case 3: {
	    _res = _cm_setof2(_g, &((*_odata).u.Criteria_or), &((*_cdata).u.Criteria_or));
	    if (_res)
		return _res;
	}   break;
	case 4: {
	    _res = _cmCriteria(_g, (*_odata).u.Criteria_not, (*_cdata).u.Criteria_not);
	    if (_res)
		return _res;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}


static int _cm_setof2(OssGlobal * _g, _setof1 * * _odata, _setof1 * * _cdata)
{
    int _res = 0;

    {
	_setof1 *  _s_1 = *_odata;
	_setof1 *  _d_1 = *_cdata;
	long        *_a, _i, _i_next, _c = 0L;

	while (_s_1 && _d_1) {
	    ++ _c;
	    _s_1 = _s_1->next;
	    _d_1 = _d_1->next;
	}
	if (_s_1 || _d_1)
	    return 1;
	if (_c) {
	    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
	    for (_i = 0; _i < _c; _i ++)
		_a[_i] = _i;
	    _a[_c] = -1L;
	    for (_s_1 = *_odata; _s_1; _s_1 = _s_1->next) {
		_i_next = _a[0]; _res = 1;
		for (_d_1 = *_cdata, _i = 0L; _d_1 && _i_next >= 0L && _a[_i_next] >= 0L; _d_1 = _d_1->next,
			_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
		    if (_i < _i_next)
			continue;
		    _res = _cmCriteria(_g, &(_s_1->value), &(_d_1->value));
		    if (_res)
			continue;
		    _res = 0; _a[_i] = _a[_i+1];
		    break;
		}
		if (_res)
		    break;
	    }
	    _oss_dec_freetempmem(_g, _a);
	    if (_res)
		return _res;
	}
    }

    return _res;
}


static int _cm_setof1(OssGlobal * _g, _setof1 * * _odata, _setof1 * * _cdata)
{
    int _res = 0;

    {
	_setof1 *  _s_1 = *_odata;
	_setof1 *  _d_1 = *_cdata;
	long        *_a, _i, _i_next, _c = 0L;

	while (_s_1 && _d_1) {
	    ++ _c;
	    _s_1 = _s_1->next;
	    _d_1 = _d_1->next;
	}
	if (_s_1 || _d_1)
	    return 1;
	if (_c) {
	    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
	    for (_i = 0; _i < _c; _i ++)
		_a[_i] = _i;
	    _a[_c] = -1L;
	    for (_s_1 = *_odata; _s_1; _s_1 = _s_1->next) {
		_i_next = _a[0]; _res = 1;
		for (_d_1 = *_cdata, _i = 0L; _d_1 && _i_next >= 0L && _a[_i_next] >= 0L; _d_1 = _d_1->next,
			_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
		    if (_i < _i_next)
			continue;
		    _res = _cmCriteria(_g, &(_s_1->value), &(_d_1->value));
		    if (_res)
			continue;
		    _res = 0; _a[_i] = _a[_i+1];
		    break;
		}
		if (_res)
		    break;
	    }
	    _oss_dec_freetempmem(_g, _a);
	    if (_res)
		return _res;
	}
    }

    return _res;
}


static int _cmCriteriaItem(OssGlobal * _g, _CriteriaItem  * _odata, _CriteriaItem  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    if (!((*_cdata).u.equality).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*_odata).u.equality), &((*_cdata).u.equality), sizeof(((*_cdata).u.equality).length), sizeof(((*_cdata).u.equality).value[0]), (unsigned int)((char *)&((*_odata).u.equality).value - (char *)&((*_odata).u.equality))))
		return 1;
	}   break;
	case 2: {
	    if (!((*_cdata).u.substrings).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*_odata).u.substrings), &((*_cdata).u.substrings), sizeof(((*_cdata).u.substrings).length), sizeof(((*_cdata).u.substrings).value[0]), (unsigned int)((char *)&((*_odata).u.substrings).value - (char *)&((*_odata).u.substrings))))
		return 1;
	}   break;
	case 3: {
	    if (!((*_cdata).u.greaterOrEqual).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*_odata).u.greaterOrEqual), &((*_cdata).u.greaterOrEqual), sizeof(((*_cdata).u.greaterOrEqual).length), sizeof(((*_cdata).u.greaterOrEqual).value[0]), (unsigned int)((char *)&((*_odata).u.greaterOrEqual).value - (char *)&((*_odata).u.greaterOrEqual))))
		return 1;
	}   break;
	case 4: {
	    if (!((*_cdata).u.lessOrEqual).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*_odata).u.lessOrEqual), &((*_cdata).u.lessOrEqual), sizeof(((*_cdata).u.lessOrEqual).length), sizeof(((*_cdata).u.lessOrEqual).value[0]), (unsigned int)((char *)&((*_odata).u.lessOrEqual).value - (char *)&((*_odata).u.lessOrEqual))))
		return 1;
	}   break;
	case 5: {
	    if (!((*_cdata).u.approximateMatch).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*_odata).u.approximateMatch), &((*_cdata).u.approximateMatch), sizeof(((*_cdata).u.approximateMatch).length), sizeof(((*_cdata).u.approximateMatch).value[0]), (unsigned int)((char *)&((*_odata).u.approximateMatch).value - (char *)&((*_odata).u.approximateMatch))))
		return 1;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}


static int _cm_setof7(OssGlobal * _g, _Presentation_context_deletion_list * * _odata, _Presentation_context_deletion_list * * _cdata)
{
    int _res = 0;

    {
	_Presentation_context_deletion_list *  _s_1 = *_odata;
	_Presentation_context_deletion_list *  _d_1 = *_cdata;
	long        *_a, _i, _i_next, _c = 0L;

	while (_s_1 && _d_1) {
	    ++ _c;
	    _s_1 = _s_1->next;
	    _d_1 = _d_1->next;
	}
	if (_s_1 || _d_1)
	    return 1;
	if (_c) {
	    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
	    for (_i = 0; _i < _c; _i ++)
		_a[_i] = _i;
	    _a[_c] = -1L;
	    for (_s_1 = *_odata; _s_1; _s_1 = _s_1->next) {
		_i_next = _a[0]; _res = 1;
		for (_d_1 = *_cdata, _i = 0L; _d_1 && _i_next >= 0L && _a[_i_next] >= 0L; _d_1 = _d_1->next,
			_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
		    if (_i < _i_next)
			continue;
		    if (_d_1->value != _s_1->value)
			continue;
		    _res = 0; _a[_i] = _a[_i+1];
		    break;
		}
		if (_res)
		    break;
	    }
	    _oss_dec_freetempmem(_g, _a);
	    if (_res)
		return _res;
	}
    }

    return _res;
}


static int _cmNamedDay(OssGlobal * _g, _NamedDay  * _odata, _NamedDay  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    if (_oss_cmp_arrbits(((*_odata).u.bitNamedDays).value, ((*_cdata).u.bitNamedDays).value, ((*_odata).u.bitNamedDays).length, ((*_cdata).u.bitNamedDays).length))
		return 1;
	}   break;
	case 2: {
	    if ((*_cdata).u.intNamedDays != (*_odata).u.intNamedDays)
		return 1;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}


static int _cmRefinement(OssGlobal * _g, _Refinement  * _odata, _Refinement  * _cdata)
{
    int _res = 0;

    if ((*_odata).choice != (*_cdata).choice)
	return 1;
    switch ((*_odata).choice) {
	case 1: {
	    if (!((*_cdata).u.item).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*_odata).u.item), &((*_cdata).u.item), sizeof(((*_cdata).u.item).length), sizeof(((*_cdata).u.item).value[0]), (unsigned int)((char *)&((*_odata).u.item).value - (char *)&((*_odata).u.item))))
		return 1;
	}   break;
	case 2: {
	    _res = _cm_setof17(_g, &((*_odata).u.Refinement_and), &((*_cdata).u.Refinement_and));
	    if (_res)
		return _res;
	}   break;
	case 3: {
	    _res = _cm_setof18(_g, &((*_odata).u.Refinement_or), &((*_cdata).u.Refinement_or));
	    if (_res)
		return _res;
	}   break;
	case 4: {
	    _res = _cmRefinement(_g, (*_odata).u.Refinement_not, (*_cdata).u.Refinement_not);
	    if (_res)
		return _res;
	}   break;
	case 0:
	    break;
	default:
	    return 1;
    }

    return _res;
}


static int _cm_setof18(OssGlobal * _g, _setof17 * * _odata, _setof17 * * _cdata)
{
    int _res = 0;

    {
	_setof17 *  _s_1 = *_odata;
	_setof17 *  _d_1 = *_cdata;
	long        *_a, _i, _i_next, _c = 0L;

	while (_s_1 && _d_1) {
	    ++ _c;
	    _s_1 = _s_1->next;
	    _d_1 = _d_1->next;
	}
	if (_s_1 || _d_1)
	    return 1;
	if (_c) {
	    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
	    for (_i = 0; _i < _c; _i ++)
		_a[_i] = _i;
	    _a[_c] = -1L;
	    for (_s_1 = *_odata; _s_1; _s_1 = _s_1->next) {
		_i_next = _a[0]; _res = 1;
		for (_d_1 = *_cdata, _i = 0L; _d_1 && _i_next >= 0L && _a[_i_next] >= 0L; _d_1 = _d_1->next,
			_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
		    if (_i < _i_next)
			continue;
		    _res = _cmRefinement(_g, &(_s_1->value), &(_d_1->value));
		    if (_res)
			continue;
		    _res = 0; _a[_i] = _a[_i+1];
		    break;
		}
		if (_res)
		    break;
	    }
	    _oss_dec_freetempmem(_g, _a);
	    if (_res)
		return _res;
	}
    }

    return _res;
}


static int _cm_setof17(OssGlobal * _g, _setof17 * * _odata, _setof17 * * _cdata)
{
    int _res = 0;

    {
	_setof17 *  _s_1 = *_odata;
	_setof17 *  _d_1 = *_cdata;
	long        *_a, _i, _i_next, _c = 0L;

	while (_s_1 && _d_1) {
	    ++ _c;
	    _s_1 = _s_1->next;
	    _d_1 = _d_1->next;
	}
	if (_s_1 || _d_1)
	    return 1;
	if (_c) {
	    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
	    for (_i = 0; _i < _c; _i ++)
		_a[_i] = _i;
	    _a[_c] = -1L;
	    for (_s_1 = *_odata; _s_1; _s_1 = _s_1->next) {
		_i_next = _a[0]; _res = 1;
		for (_d_1 = *_cdata, _i = 0L; _d_1 && _i_next >= 0L && _a[_i_next] >= 0L; _d_1 = _d_1->next,
			_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
		    if (_i < _i_next)
			continue;
		    _res = _cmRefinement(_g, &(_s_1->value), &(_d_1->value));
		    if (_res)
			continue;
		    _res = 0; _a[_i] = _a[_i+1];
		    break;
		}
		if (_res)
		    break;
	    }
	    _oss_dec_freetempmem(_g, _a);
	    if (_res)
		return _res;
	}
    }

    return _res;
}


int DLL_ENTRY_FDEF _CMUpperBounds_(struct ossGlobal * _g, int _pduNum, void * _odata, void * _cdata)
{
    int _res = 0;

    if (_pduNum <= 0 || _pduNum > 86)
	return PDU_RANGE;
    switch (_pduNum) {
	case 1: {
	    if (!(*(OSSC::COssEncOID  *)_cdata).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssEncOID  *)_odata, (OSSC::COssEncOID  *)_cdata, sizeof((*(OSSC::COssEncOID  *)_cdata).length), sizeof((*(OSSC::COssEncOID  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssEncOID  *)_odata).value - (char *)(OSSC::COssEncOID  *)_odata)))
		return 1;
	} break;
	case 2: {
	    if ((*(_ACSE_apdu  *)_odata).choice != (*(_ACSE_apdu  *)_cdata).choice)
		return 1;
	    switch ((*(_ACSE_apdu  *)_odata).choice) {
		case 1: {
		    if (((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask & (*(*(_ACSE_apdu  *)_cdata).u.aarq).bit_mask) & 0x80000000) {
			if (_oss_cmp_arrbits(((*(*(_ACSE_apdu  *)_odata).u.aarq).protocol_version).value, ((*(*(_ACSE_apdu  *)_cdata).u.aarq).protocol_version).value, ((*(*(_ACSE_apdu  *)_odata).u.aarq).protocol_version).length, ((*(*(_ACSE_apdu  *)_cdata).u.aarq).protocol_version).length))
			    return 1;
		    } else {
			if ((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask & 0x80000000) {
			    if (_oss_cmp_arrbits(((*(*(_ACSE_apdu  *)_odata).u.aarq).protocol_version).value, (_v628).value, ((*(*(_ACSE_apdu  *)_odata).u.aarq).protocol_version).length, (_v628).length))
				return 1;
			}
			if ((*(*(_ACSE_apdu  *)_cdata).u.aarq).bit_mask & 0x80000000) {
			    if (_oss_cmp_arrbits((_v628).value, ((*(*(_ACSE_apdu  *)_cdata).u.aarq).protocol_version).value, (_v628).length, ((*(*(_ACSE_apdu  *)_cdata).u.aarq).protocol_version).length))
				return 1;
			}
		    }
		    if (!((*(*(_ACSE_apdu  *)_cdata).u.aarq).application_context_name).length)
			return 1;
		    if (_oss_cmp_unbnd_octet_ia(&((*(*(_ACSE_apdu  *)_odata).u.aarq).application_context_name), &((*(*(_ACSE_apdu  *)_cdata).u.aarq).application_context_name), sizeof(((*(*(_ACSE_apdu  *)_cdata).u.aarq).application_context_name).length), sizeof(((*(*(_ACSE_apdu  *)_cdata).u.aarq).application_context_name).value[0]), (unsigned int)((char *)&((*(*(_ACSE_apdu  *)_odata).u.aarq).application_context_name).value - (char *)&((*(*(_ACSE_apdu  *)_odata).u.aarq).application_context_name))))
			return 1;
		    if (((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.aarq).bit_mask) & 0x40000000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask & 0x40000000) {
			_res = _cmAP_title(_g, &((*(*(_ACSE_apdu  *)_odata).u.aarq).called_AP_title), &((*(*(_ACSE_apdu  *)_cdata).u.aarq).called_AP_title));
			if (_res)
			    return _res;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.aarq).bit_mask) & 0x20000000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask & 0x20000000) {
			_res = _cmAE_qualifier(_g, &((*(*(_ACSE_apdu  *)_odata).u.aarq).called_AE_qualifier), &((*(*(_ACSE_apdu  *)_cdata).u.aarq).called_AE_qualifier));
			if (_res)
			    return _res;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.aarq).bit_mask) & 0x10000000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask & 0x10000000) {
			if ((*(*(_ACSE_apdu  *)_cdata).u.aarq).called_AP_invocation_identifier != (*(*(_ACSE_apdu  *)_odata).u.aarq).called_AP_invocation_identifier)
			    return 1;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.aarq).bit_mask) & 0x8000000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask & 0x8000000) {
			if ((*(*(_ACSE_apdu  *)_cdata).u.aarq).called_AE_invocation_identifier != (*(*(_ACSE_apdu  *)_odata).u.aarq).called_AE_invocation_identifier)
			    return 1;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.aarq).bit_mask) & 0x4000000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask & 0x4000000) {
			_res = _cmAP_title(_g, &((*(*(_ACSE_apdu  *)_odata).u.aarq).calling_AP_title), &((*(*(_ACSE_apdu  *)_cdata).u.aarq).calling_AP_title));
			if (_res)
			    return _res;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.aarq).bit_mask) & 0x2000000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask & 0x2000000) {
			_res = _cmAE_qualifier(_g, &((*(*(_ACSE_apdu  *)_odata).u.aarq).calling_AE_qualifier), &((*(*(_ACSE_apdu  *)_cdata).u.aarq).calling_AE_qualifier));
			if (_res)
			    return _res;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.aarq).bit_mask) & 0x1000000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask & 0x1000000) {
			if ((*(*(_ACSE_apdu  *)_cdata).u.aarq).calling_AP_invocation_identifier != (*(*(_ACSE_apdu  *)_odata).u.aarq).calling_AP_invocation_identifier)
			    return 1;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.aarq).bit_mask) & 0x800000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask & 0x800000) {
			if ((*(*(_ACSE_apdu  *)_cdata).u.aarq).calling_AE_invocation_identifier != (*(*(_ACSE_apdu  *)_odata).u.aarq).calling_AE_invocation_identifier)
			    return 1;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.aarq).bit_mask) & 0x400000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask & 0x400000) {
			if (_oss_cmp_arrbits(((*(*(_ACSE_apdu  *)_odata).u.aarq).sender_acse_requirements).value, ((*(*(_ACSE_apdu  *)_cdata).u.aarq).sender_acse_requirements).value, ((*(*(_ACSE_apdu  *)_odata).u.aarq).sender_acse_requirements).length, ((*(*(_ACSE_apdu  *)_cdata).u.aarq).sender_acse_requirements).length))
			    return 1;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.aarq).bit_mask) & 0x200000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask & 0x200000) {
			if (!((*(*(_ACSE_apdu  *)_cdata).u.aarq).mechanism_name).length)
			    return 1;
			if (_oss_cmp_unbnd_octet_ia(&((*(*(_ACSE_apdu  *)_odata).u.aarq).mechanism_name), &((*(*(_ACSE_apdu  *)_cdata).u.aarq).mechanism_name), sizeof(((*(*(_ACSE_apdu  *)_cdata).u.aarq).mechanism_name).length), sizeof(((*(*(_ACSE_apdu  *)_cdata).u.aarq).mechanism_name).value[0]), (unsigned int)((char *)&((*(*(_ACSE_apdu  *)_odata).u.aarq).mechanism_name).value - (char *)&((*(*(_ACSE_apdu  *)_odata).u.aarq).mechanism_name))))
			    return 1;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.aarq).bit_mask) & 0x100000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask & 0x100000) {
			_res = _cmAuthentication_value(_g, &((*(*(_ACSE_apdu  *)_odata).u.aarq).calling_authentication_value), &((*(*(_ACSE_apdu  *)_cdata).u.aarq).calling_authentication_value));
			if (_res)
			    return _res;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.aarq).bit_mask) & 0x80000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask & 0x80000) {
			_res = _cm13Application_context_name_l(_g, &((*(*(_ACSE_apdu  *)_odata).u.aarq).application_context_name_list), &((*(*(_ACSE_apdu  *)_cdata).u.aarq).application_context_name_list));
			if (_res)
			    return _res;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.aarq).bit_mask) & 0x40000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask & 0x40000) {
			if (_oss_cmp_unbnd_octet_ia(&((*(*(_ACSE_apdu  *)_odata).u.aarq).implementation_information), &((*(*(_ACSE_apdu  *)_cdata).u.aarq).implementation_information), sizeof(((*(*(_ACSE_apdu  *)_cdata).u.aarq).implementation_information).length), sizeof(((*(*(_ACSE_apdu  *)_cdata).u.aarq).implementation_information).value[0]), (unsigned int)((char *)&((*(*(_ACSE_apdu  *)_odata).u.aarq).implementation_information).value - (char *)&((*(*(_ACSE_apdu  *)_odata).u.aarq).implementation_information))))
			    return 1;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.aarq).bit_mask) & 0x20000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.aarq).bit_mask & 0x20000) {
			_res = _cmAssociation_information(_g, &((*(*(_ACSE_apdu  *)_odata).u.aarq).user_information), &((*(*(_ACSE_apdu  *)_cdata).u.aarq).user_information));
			if (_res)
			    return _res;
		    }
		}   break;
		case 2: {
		    if (((*(*(_ACSE_apdu  *)_odata).u.aare).bit_mask & (*(*(_ACSE_apdu  *)_cdata).u.aare).bit_mask) & 0x80000000) {
			if (_oss_cmp_arrbits(((*(*(_ACSE_apdu  *)_odata).u.aare).protocol_version).value, ((*(*(_ACSE_apdu  *)_cdata).u.aare).protocol_version).value, ((*(*(_ACSE_apdu  *)_odata).u.aare).protocol_version).length, ((*(*(_ACSE_apdu  *)_cdata).u.aare).protocol_version).length))
			    return 1;
		    } else {
			if ((*(*(_ACSE_apdu  *)_odata).u.aare).bit_mask & 0x80000000) {
			    if (_oss_cmp_arrbits(((*(*(_ACSE_apdu  *)_odata).u.aare).protocol_version).value, (_v630).value, ((*(*(_ACSE_apdu  *)_odata).u.aare).protocol_version).length, (_v630).length))
				return 1;
			}
			if ((*(*(_ACSE_apdu  *)_cdata).u.aare).bit_mask & 0x80000000) {
			    if (_oss_cmp_arrbits((_v630).value, ((*(*(_ACSE_apdu  *)_cdata).u.aare).protocol_version).value, (_v630).length, ((*(*(_ACSE_apdu  *)_cdata).u.aare).protocol_version).length))
				return 1;
			}
		    }
		    if (!((*(*(_ACSE_apdu  *)_cdata).u.aare).application_context_name).length)
			return 1;
		    if (_oss_cmp_unbnd_octet_ia(&((*(*(_ACSE_apdu  *)_odata).u.aare).application_context_name), &((*(*(_ACSE_apdu  *)_cdata).u.aare).application_context_name), sizeof(((*(*(_ACSE_apdu  *)_cdata).u.aare).application_context_name).length), sizeof(((*(*(_ACSE_apdu  *)_cdata).u.aare).application_context_name).value[0]), (unsigned int)((char *)&((*(*(_ACSE_apdu  *)_odata).u.aare).application_context_name).value - (char *)&((*(*(_ACSE_apdu  *)_odata).u.aare).application_context_name))))
			return 1;
		    if ((*(*(_ACSE_apdu  *)_cdata).u.aare).result != (*(*(_ACSE_apdu  *)_odata).u.aare).result)
			return 1;
		    if (((*(*(_ACSE_apdu  *)_odata).u.aare).result_source_diagnostic).choice != ((*(*(_ACSE_apdu  *)_cdata).u.aare).result_source_diagnostic).choice)
			return 1;
		    switch (((*(*(_ACSE_apdu  *)_odata).u.aare).result_source_diagnostic).choice) {
			case 1: {
			    if (((*(*(_ACSE_apdu  *)_cdata).u.aare).result_source_diagnostic).u.acse_service_user != ((*(*(_ACSE_apdu  *)_odata).u.aare).result_source_diagnostic).u.acse_service_user)
				return 1;
			}   break;
			case 2: {
			    if (((*(*(_ACSE_apdu  *)_cdata).u.aare).result_source_diagnostic).u.acse_service_provider != ((*(*(_ACSE_apdu  *)_odata).u.aare).result_source_diagnostic).u.acse_service_provider)
				return 1;
			}   break;
			case 0:
			    break;
			default:
			    return 1;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.aare).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.aare).bit_mask) & 0x40000000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.aare).bit_mask & 0x40000000) {
			_res = _cmAP_title(_g, &((*(*(_ACSE_apdu  *)_odata).u.aare).responding_AP_title), &((*(*(_ACSE_apdu  *)_cdata).u.aare).responding_AP_title));
			if (_res)
			    return _res;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.aare).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.aare).bit_mask) & 0x20000000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.aare).bit_mask & 0x20000000) {
			_res = _cmAE_qualifier(_g, &((*(*(_ACSE_apdu  *)_odata).u.aare).responding_AE_qualifier), &((*(*(_ACSE_apdu  *)_cdata).u.aare).responding_AE_qualifier));
			if (_res)
			    return _res;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.aare).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.aare).bit_mask) & 0x10000000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.aare).bit_mask & 0x10000000) {
			if ((*(*(_ACSE_apdu  *)_cdata).u.aare).responding_AP_invocation_identifier != (*(*(_ACSE_apdu  *)_odata).u.aare).responding_AP_invocation_identifier)
			    return 1;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.aare).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.aare).bit_mask) & 0x8000000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.aare).bit_mask & 0x8000000) {
			if ((*(*(_ACSE_apdu  *)_cdata).u.aare).responding_AE_invocation_identifier != (*(*(_ACSE_apdu  *)_odata).u.aare).responding_AE_invocation_identifier)
			    return 1;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.aare).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.aare).bit_mask) & 0x4000000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.aare).bit_mask & 0x4000000) {
			if (_oss_cmp_arrbits(((*(*(_ACSE_apdu  *)_odata).u.aare).responder_acse_requirements).value, ((*(*(_ACSE_apdu  *)_cdata).u.aare).responder_acse_requirements).value, ((*(*(_ACSE_apdu  *)_odata).u.aare).responder_acse_requirements).length, ((*(*(_ACSE_apdu  *)_cdata).u.aare).responder_acse_requirements).length))
			    return 1;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.aare).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.aare).bit_mask) & 0x2000000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.aare).bit_mask & 0x2000000) {
			if (!((*(*(_ACSE_apdu  *)_cdata).u.aare).mechanism_name).length)
			    return 1;
			if (_oss_cmp_unbnd_octet_ia(&((*(*(_ACSE_apdu  *)_odata).u.aare).mechanism_name), &((*(*(_ACSE_apdu  *)_cdata).u.aare).mechanism_name), sizeof(((*(*(_ACSE_apdu  *)_cdata).u.aare).mechanism_name).length), sizeof(((*(*(_ACSE_apdu  *)_cdata).u.aare).mechanism_name).value[0]), (unsigned int)((char *)&((*(*(_ACSE_apdu  *)_odata).u.aare).mechanism_name).value - (char *)&((*(*(_ACSE_apdu  *)_odata).u.aare).mechanism_name))))
			    return 1;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.aare).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.aare).bit_mask) & 0x1000000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.aare).bit_mask & 0x1000000) {
			_res = _cmAuthentication_value(_g, &((*(*(_ACSE_apdu  *)_odata).u.aare).responding_authentication_value), &((*(*(_ACSE_apdu  *)_cdata).u.aare).responding_authentication_value));
			if (_res)
			    return _res;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.aare).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.aare).bit_mask) & 0x800000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.aare).bit_mask & 0x800000) {
			_res = _cm13Application_context_name_l(_g, &((*(*(_ACSE_apdu  *)_odata).u.aare).application_context_name_list), &((*(*(_ACSE_apdu  *)_cdata).u.aare).application_context_name_list));
			if (_res)
			    return _res;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.aare).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.aare).bit_mask) & 0x400000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.aare).bit_mask & 0x400000) {
			if (_oss_cmp_unbnd_octet_ia(&((*(*(_ACSE_apdu  *)_odata).u.aare).implementation_information), &((*(*(_ACSE_apdu  *)_cdata).u.aare).implementation_information), sizeof(((*(*(_ACSE_apdu  *)_cdata).u.aare).implementation_information).length), sizeof(((*(*(_ACSE_apdu  *)_cdata).u.aare).implementation_information).value[0]), (unsigned int)((char *)&((*(*(_ACSE_apdu  *)_odata).u.aare).implementation_information).value - (char *)&((*(*(_ACSE_apdu  *)_odata).u.aare).implementation_information))))
			    return 1;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.aare).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.aare).bit_mask) & 0x200000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.aare).bit_mask & 0x200000) {
			_res = _cmAssociation_information(_g, &((*(*(_ACSE_apdu  *)_odata).u.aare).user_information), &((*(*(_ACSE_apdu  *)_cdata).u.aare).user_information));
			if (_res)
			    return _res;
		    }
		}   break;
		case 3: {
		    if (((*(*(_ACSE_apdu  *)_odata).u.rlrq).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.rlrq).bit_mask) & 0x80000000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.rlrq).bit_mask & 0x80000000) {
			if ((*(*(_ACSE_apdu  *)_cdata).u.rlrq).reason != (*(*(_ACSE_apdu  *)_odata).u.rlrq).reason)
			    return 1;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.rlrq).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.rlrq).bit_mask) & 0x40000000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.rlrq).bit_mask & 0x40000000) {
			_res = _cmAssociation_information(_g, &((*(*(_ACSE_apdu  *)_odata).u.rlrq).user_information), &((*(*(_ACSE_apdu  *)_cdata).u.rlrq).user_information));
			if (_res)
			    return _res;
		    }
		}   break;
		case 4: {
		    if (((*(*(_ACSE_apdu  *)_odata).u.rlre).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.rlre).bit_mask) & 0x80000000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.rlre).bit_mask & 0x80000000) {
			if ((*(*(_ACSE_apdu  *)_cdata).u.rlre).reason != (*(*(_ACSE_apdu  *)_odata).u.rlre).reason)
			    return 1;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.rlre).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.rlre).bit_mask) & 0x40000000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.rlre).bit_mask & 0x40000000) {
			_res = _cmAssociation_information(_g, &((*(*(_ACSE_apdu  *)_odata).u.rlre).user_information), &((*(*(_ACSE_apdu  *)_cdata).u.rlre).user_information));
			if (_res)
			    return _res;
		    }
		}   break;
		case 5: {
		    if ((*(*(_ACSE_apdu  *)_cdata).u.abrt).abort_source != (*(*(_ACSE_apdu  *)_odata).u.abrt).abort_source)
			return 1;
		    if (((*(*(_ACSE_apdu  *)_odata).u.abrt).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.abrt).bit_mask) & 0x80000000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.abrt).bit_mask & 0x80000000) {
			if ((*(*(_ACSE_apdu  *)_cdata).u.abrt).abort_diagnostic != (*(*(_ACSE_apdu  *)_odata).u.abrt).abort_diagnostic)
			    return 1;
		    }
		    if (((*(*(_ACSE_apdu  *)_odata).u.abrt).bit_mask ^ (*(*(_ACSE_apdu  *)_cdata).u.abrt).bit_mask) & 0x40000000)
			return 1;
		    if ((*(*(_ACSE_apdu  *)_odata).u.abrt).bit_mask & 0x40000000) {
			_res = _cmAssociation_information(_g, &((*(*(_ACSE_apdu  *)_odata).u.abrt).user_information), &((*(*(_ACSE_apdu  *)_cdata).u.abrt).user_information));
			if (_res)
			    return _res;
		    }
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 3: {
	    if ((*(_AE_title  *)_odata).choice != (*(_AE_title  *)_cdata).choice)
		return 1;
	    switch ((*(_AE_title  *)_odata).choice) {
		case 1: {
		    if (!((*(_AE_title  *)_cdata).u.ae_title_form2).length)
			return 1;
		    if (_oss_cmp_unbnd_octet_ia(&((*(_AE_title  *)_odata).u.ae_title_form2), &((*(_AE_title  *)_cdata).u.ae_title_form2), sizeof(((*(_AE_title  *)_cdata).u.ae_title_form2).length), sizeof(((*(_AE_title  *)_cdata).u.ae_title_form2).value[0]), (unsigned int)((char *)&((*(_AE_title  *)_odata).u.ae_title_form2).value - (char *)&((*(_AE_title  *)_odata).u.ae_title_form2))))
			return 1;
		}   break;
		case 2: {
		    _res = _cmName(_g, (*(_AE_title  *)_odata).u.ae_title_form1, (*(_AE_title  *)_cdata).u.ae_title_form1);
		    if (_res)
			return _res;
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 4: {
	    _res = _cmMode_selector(_g, &((*(_CP_type  *)_odata).mode_selector), &((*(_CP_type  *)_cdata).mode_selector));
	    if (_res)
		return _res;
	    if (((*(_CP_type  *)_odata).bit_mask ^ (*(_CP_type  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_CP_type  *)_odata).bit_mask & 0x80000000) {
		if ((((*(_CP_type  *)_odata).x410_mode_parameters).bit_mask & ((*(_CP_type  *)_cdata).x410_mode_parameters).bit_mask) & 0x80000000) {
		    if (((*(_CP_type  *)_cdata).x410_mode_parameters).checkpointSize != ((*(_CP_type  *)_odata).x410_mode_parameters).checkpointSize)
			return 1;
		} else {
		    if (((*(_CP_type  *)_odata).x410_mode_parameters).bit_mask & 0x80000000) {
			if (__shared15::default_checkpointSize != ((*(_CP_type  *)_odata).x410_mode_parameters).checkpointSize)
			    return 1;
		    }
		    if (((*(_CP_type  *)_cdata).x410_mode_parameters).bit_mask & 0x80000000) {
			if (((*(_CP_type  *)_cdata).x410_mode_parameters).checkpointSize != __shared15::default_checkpointSize)
			    return 1;
		    }
		}
		if ((((*(_CP_type  *)_odata).x410_mode_parameters).bit_mask & ((*(_CP_type  *)_cdata).x410_mode_parameters).bit_mask) & 0x40000000) {
		    if (((*(_CP_type  *)_cdata).x410_mode_parameters).windowSize != ((*(_CP_type  *)_odata).x410_mode_parameters).windowSize)
			return 1;
		} else {
		    if (((*(_CP_type  *)_odata).x410_mode_parameters).bit_mask & 0x40000000) {
			if (__shared15::default_windowSize != ((*(_CP_type  *)_odata).x410_mode_parameters).windowSize)
			    return 1;
		    }
		    if (((*(_CP_type  *)_cdata).x410_mode_parameters).bit_mask & 0x40000000) {
			if (((*(_CP_type  *)_cdata).x410_mode_parameters).windowSize != __shared15::default_windowSize)
			    return 1;
		    }
		}
		if ((((*(_CP_type  *)_odata).x410_mode_parameters).bit_mask & ((*(_CP_type  *)_cdata).x410_mode_parameters).bit_mask) & 0x20000000) {
		    if (((*(_CP_type  *)_cdata).x410_mode_parameters).dialogueMode != ((*(_CP_type  *)_odata).x410_mode_parameters).dialogueMode)
			return 1;
		} else {
		    if (((*(_CP_type  *)_odata).x410_mode_parameters).bit_mask & 0x20000000) {
			if (__shared15::default_checkpointSize != ((*(_CP_type  *)_odata).x410_mode_parameters).dialogueMode)
			    return 1;
		    }
		    if (((*(_CP_type  *)_cdata).x410_mode_parameters).bit_mask & 0x20000000) {
			if (((*(_CP_type  *)_cdata).x410_mode_parameters).dialogueMode != __shared15::default_checkpointSize)
			    return 1;
		    }
		}
		_res = _cmConnectionData(_g, &(((*(_CP_type  *)_odata).x410_mode_parameters).connectionDataRQ), &(((*(_CP_type  *)_cdata).x410_mode_parameters).connectionDataRQ));
		if (_res)
		    return _res;
		if ((((*(_CP_type  *)_odata).x410_mode_parameters).bit_mask ^ ((*(_CP_type  *)_cdata).x410_mode_parameters).bit_mask) & 0x10000000)
		    return 1;
		if (((*(_CP_type  *)_odata).x410_mode_parameters).bit_mask & 0x10000000) {
		    if (((*(_CP_type  *)_cdata).x410_mode_parameters).applicationProtocol != ((*(_CP_type  *)_odata).x410_mode_parameters).applicationProtocol)
			return 1;
		}
	    }
	    if (((*(_CP_type  *)_odata).bit_mask ^ (*(_CP_type  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_CP_type  *)_odata).bit_mask & 0x40000000) {
		if ((((*(_CP_type  *)_odata).normal_mode_parameters).bit_mask & ((*(_CP_type  *)_cdata).normal_mode_parameters).bit_mask) & 0x80000000) {
		    if (_oss_cmp_arrbits((((*(_CP_type  *)_odata).normal_mode_parameters).protocol_version).value, (((*(_CP_type  *)_cdata).normal_mode_parameters).protocol_version).value, (((*(_CP_type  *)_odata).normal_mode_parameters).protocol_version).length, (((*(_CP_type  *)_cdata).normal_mode_parameters).protocol_version).length))
			return 1;
		} else {
		    if (((*(_CP_type  *)_odata).normal_mode_parameters).bit_mask & 0x80000000) {
			if (_oss_cmp_arrbits((((*(_CP_type  *)_odata).normal_mode_parameters).protocol_version).value, (_v631).value, (((*(_CP_type  *)_odata).normal_mode_parameters).protocol_version).length, (_v631).length))
			    return 1;
		    }
		    if (((*(_CP_type  *)_cdata).normal_mode_parameters).bit_mask & 0x80000000) {
			if (_oss_cmp_arrbits((_v631).value, (((*(_CP_type  *)_cdata).normal_mode_parameters).protocol_version).value, (_v631).length, (((*(_CP_type  *)_cdata).normal_mode_parameters).protocol_version).length))
			    return 1;
		    }
		}
		if ((((*(_CP_type  *)_odata).normal_mode_parameters).bit_mask ^ ((*(_CP_type  *)_cdata).normal_mode_parameters).bit_mask) & 0x40000000)
		    return 1;
		if (((*(_CP_type  *)_odata).normal_mode_parameters).bit_mask & 0x40000000) {
		    if (_oss_cmp_unbnd_octet_ia(&(((*(_CP_type  *)_odata).normal_mode_parameters).calling_presentation_selector), &(((*(_CP_type  *)_cdata).normal_mode_parameters).calling_presentation_selector), sizeof((((*(_CP_type  *)_cdata).normal_mode_parameters).calling_presentation_selector).length), sizeof((((*(_CP_type  *)_cdata).normal_mode_parameters).calling_presentation_selector).value[0]), (unsigned int)((char *)&(((*(_CP_type  *)_odata).normal_mode_parameters).calling_presentation_selector).value - (char *)&(((*(_CP_type  *)_odata).normal_mode_parameters).calling_presentation_selector))))
			return 1;
		}
		if ((((*(_CP_type  *)_odata).normal_mode_parameters).bit_mask ^ ((*(_CP_type  *)_cdata).normal_mode_parameters).bit_mask) & 0x20000000)
		    return 1;
		if (((*(_CP_type  *)_odata).normal_mode_parameters).bit_mask & 0x20000000) {
		    if (_oss_cmp_unbnd_octet_ia(&(((*(_CP_type  *)_odata).normal_mode_parameters).called_presentation_selector), &(((*(_CP_type  *)_cdata).normal_mode_parameters).called_presentation_selector), sizeof((((*(_CP_type  *)_cdata).normal_mode_parameters).called_presentation_selector).length), sizeof((((*(_CP_type  *)_cdata).normal_mode_parameters).called_presentation_selector).value[0]), (unsigned int)((char *)&(((*(_CP_type  *)_odata).normal_mode_parameters).called_presentation_selector).value - (char *)&(((*(_CP_type  *)_odata).normal_mode_parameters).called_presentation_selector))))
			return 1;
		}
		if ((((*(_CP_type  *)_odata).normal_mode_parameters).bit_mask ^ ((*(_CP_type  *)_cdata).normal_mode_parameters).bit_mask) & 0x10000000)
		    return 1;
		if (((*(_CP_type  *)_odata).normal_mode_parameters).bit_mask & 0x10000000) {
		    _res = _cmContext_list(_g, &(((*(_CP_type  *)_odata).normal_mode_parameters).presentation_context_definition_list), &(((*(_CP_type  *)_cdata).normal_mode_parameters).presentation_context_definition_list));
		    if (_res)
			return _res;
		}
		if ((((*(_CP_type  *)_odata).normal_mode_parameters).bit_mask ^ ((*(_CP_type  *)_cdata).normal_mode_parameters).bit_mask) & 0x8000000)
		    return 1;
		if (((*(_CP_type  *)_odata).normal_mode_parameters).bit_mask & 0x8000000) {
		    if (!((((*(_CP_type  *)_cdata).normal_mode_parameters).default_context_name).abstract_syntax_name).length)
			return 1;
		    if (_oss_cmp_unbnd_octet_ia(&((((*(_CP_type  *)_odata).normal_mode_parameters).default_context_name).abstract_syntax_name), &((((*(_CP_type  *)_cdata).normal_mode_parameters).default_context_name).abstract_syntax_name), sizeof(((((*(_CP_type  *)_cdata).normal_mode_parameters).default_context_name).abstract_syntax_name).length), sizeof(((((*(_CP_type  *)_cdata).normal_mode_parameters).default_context_name).abstract_syntax_name).value[0]), (unsigned int)((char *)&((((*(_CP_type  *)_odata).normal_mode_parameters).default_context_name).abstract_syntax_name).value - (char *)&((((*(_CP_type  *)_odata).normal_mode_parameters).default_context_name).abstract_syntax_name))))
			return 1;
		    if (!((((*(_CP_type  *)_cdata).normal_mode_parameters).default_context_name).transfer_syntax_name).length)
			return 1;
		    if (_oss_cmp_unbnd_octet_ia(&((((*(_CP_type  *)_odata).normal_mode_parameters).default_context_name).transfer_syntax_name), &((((*(_CP_type  *)_cdata).normal_mode_parameters).default_context_name).transfer_syntax_name), sizeof(((((*(_CP_type  *)_cdata).normal_mode_parameters).default_context_name).transfer_syntax_name).length), sizeof(((((*(_CP_type  *)_cdata).normal_mode_parameters).default_context_name).transfer_syntax_name).value[0]), (unsigned int)((char *)&((((*(_CP_type  *)_odata).normal_mode_parameters).default_context_name).transfer_syntax_name).value - (char *)&((((*(_CP_type  *)_odata).normal_mode_parameters).default_context_name).transfer_syntax_name))))
			return 1;
		}
		if ((((*(_CP_type  *)_odata).normal_mode_parameters).bit_mask ^ ((*(_CP_type  *)_cdata).normal_mode_parameters).bit_mask) & 0x4000000)
		    return 1;
		if (((*(_CP_type  *)_odata).normal_mode_parameters).bit_mask & 0x4000000) {
		    if (_oss_cmp_arrbits((((*(_CP_type  *)_odata).normal_mode_parameters).presentation_requirements).value, (((*(_CP_type  *)_cdata).normal_mode_parameters).presentation_requirements).value, (((*(_CP_type  *)_odata).normal_mode_parameters).presentation_requirements).length, (((*(_CP_type  *)_cdata).normal_mode_parameters).presentation_requirements).length))
			return 1;
		}
		if ((((*(_CP_type  *)_odata).normal_mode_parameters).bit_mask ^ ((*(_CP_type  *)_cdata).normal_mode_parameters).bit_mask) & 0x2000000)
		    return 1;
		if (((*(_CP_type  *)_odata).normal_mode_parameters).bit_mask & 0x2000000) {
		    if (_oss_cmp_arrbits((((*(_CP_type  *)_odata).normal_mode_parameters).user_session_requirements).value, (((*(_CP_type  *)_cdata).normal_mode_parameters).user_session_requirements).value, (((*(_CP_type  *)_odata).normal_mode_parameters).user_session_requirements).length, (((*(_CP_type  *)_cdata).normal_mode_parameters).user_session_requirements).length))
			return 1;
		}
		if ((((*(_CP_type  *)_odata).normal_mode_parameters).bit_mask & ((*(_CP_type  *)_cdata).normal_mode_parameters).bit_mask) & 0x1000000) {
		    if (_oss_cmp_arrbits((((*(_CP_type  *)_odata).normal_mode_parameters).protocol_options).value, (((*(_CP_type  *)_cdata).normal_mode_parameters).protocol_options).value, (((*(_CP_type  *)_odata).normal_mode_parameters).protocol_options).length, (((*(_CP_type  *)_cdata).normal_mode_parameters).protocol_options).length))
			return 1;
		} else {
		    if (((*(_CP_type  *)_odata).normal_mode_parameters).bit_mask & 0x1000000) {
			if (_oss_cmp_arrbits((((*(_CP_type  *)_odata).normal_mode_parameters).protocol_options).value, (_v632).value, (((*(_CP_type  *)_odata).normal_mode_parameters).protocol_options).length, (_v632).length))
			    return 1;
		    }
		    if (((*(_CP_type  *)_cdata).normal_mode_parameters).bit_mask & 0x1000000) {
			if (_oss_cmp_arrbits((_v632).value, (((*(_CP_type  *)_cdata).normal_mode_parameters).protocol_options).value, (_v632).length, (((*(_CP_type  *)_cdata).normal_mode_parameters).protocol_options).length))
			    return 1;
		    }
		}
		if ((((*(_CP_type  *)_odata).normal_mode_parameters).bit_mask ^ ((*(_CP_type  *)_cdata).normal_mode_parameters).bit_mask) & 0x800000)
		    return 1;
		if (((*(_CP_type  *)_odata).normal_mode_parameters).bit_mask & 0x800000) {
		    if (((*(_CP_type  *)_cdata).normal_mode_parameters).initiators_nominated_context != ((*(_CP_type  *)_odata).normal_mode_parameters).initiators_nominated_context)
			return 1;
		}
		if ((((*(_CP_type  *)_odata).normal_mode_parameters).bit_mask ^ ((*(_CP_type  *)_cdata).normal_mode_parameters).bit_mask) & 0x400000)
		    return 1;
		if (((*(_CP_type  *)_odata).normal_mode_parameters).bit_mask & 0x400000) {
		}
		if ((((*(_CP_type  *)_odata).normal_mode_parameters).bit_mask ^ ((*(_CP_type  *)_cdata).normal_mode_parameters).bit_mask) & 0x200000)
		    return 1;
		if (((*(_CP_type  *)_odata).normal_mode_parameters).bit_mask & 0x200000) {
		    _res = _cmUser_data(_g, &(((*(_CP_type  *)_odata).normal_mode_parameters).user_data), &(((*(_CP_type  *)_cdata).normal_mode_parameters).user_data));
		    if (_res)
			return _res;
		}
	    }
	} break;
	case 5: {
	    _res = _cmUser_data(_g, (_User_data  *)_odata, (_User_data  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 6: {
	    _res = _cmMode_selector(_g, &((*(_CPA_PPDU  *)_odata).mode_selector), &((*(_CPA_PPDU  *)_cdata).mode_selector));
	    if (_res)
		return _res;
	    if (((*(_CPA_PPDU  *)_odata).bit_mask ^ (*(_CPA_PPDU  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_CPA_PPDU  *)_odata).bit_mask & 0x80000000) {
		if ((((*(_CPA_PPDU  *)_odata).x410_mode_parameters).bit_mask & ((*(_CPA_PPDU  *)_cdata).x410_mode_parameters).bit_mask) & 0x80000000) {
		    if (((*(_CPA_PPDU  *)_cdata).x410_mode_parameters).checkpointSize != ((*(_CPA_PPDU  *)_odata).x410_mode_parameters).checkpointSize)
			return 1;
		} else {
		    if (((*(_CPA_PPDU  *)_odata).x410_mode_parameters).bit_mask & 0x80000000) {
			if (__shared15::default_checkpointSize != ((*(_CPA_PPDU  *)_odata).x410_mode_parameters).checkpointSize)
			    return 1;
		    }
		    if (((*(_CPA_PPDU  *)_cdata).x410_mode_parameters).bit_mask & 0x80000000) {
			if (((*(_CPA_PPDU  *)_cdata).x410_mode_parameters).checkpointSize != __shared15::default_checkpointSize)
			    return 1;
		    }
		}
		if ((((*(_CPA_PPDU  *)_odata).x410_mode_parameters).bit_mask & ((*(_CPA_PPDU  *)_cdata).x410_mode_parameters).bit_mask) & 0x40000000) {
		    if (((*(_CPA_PPDU  *)_cdata).x410_mode_parameters).windowSize != ((*(_CPA_PPDU  *)_odata).x410_mode_parameters).windowSize)
			return 1;
		} else {
		    if (((*(_CPA_PPDU  *)_odata).x410_mode_parameters).bit_mask & 0x40000000) {
			if (__shared15::default_windowSize != ((*(_CPA_PPDU  *)_odata).x410_mode_parameters).windowSize)
			    return 1;
		    }
		    if (((*(_CPA_PPDU  *)_cdata).x410_mode_parameters).bit_mask & 0x40000000) {
			if (((*(_CPA_PPDU  *)_cdata).x410_mode_parameters).windowSize != __shared15::default_windowSize)
			    return 1;
		    }
		}
		_res = _cmConnectionData(_g, &(((*(_CPA_PPDU  *)_odata).x410_mode_parameters).connectionDataAC), &(((*(_CPA_PPDU  *)_cdata).x410_mode_parameters).connectionDataAC));
		if (_res)
		    return _res;
	    }
	    if (((*(_CPA_PPDU  *)_odata).bit_mask ^ (*(_CPA_PPDU  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_CPA_PPDU  *)_odata).bit_mask & 0x40000000) {
		if ((((*(_CPA_PPDU  *)_odata).normal_mode_parameters).bit_mask & ((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).bit_mask) & 0x80000000) {
		    if (_oss_cmp_arrbits((((*(_CPA_PPDU  *)_odata).normal_mode_parameters).protocol_version).value, (((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).protocol_version).value, (((*(_CPA_PPDU  *)_odata).normal_mode_parameters).protocol_version).length, (((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).protocol_version).length))
			return 1;
		} else {
		    if (((*(_CPA_PPDU  *)_odata).normal_mode_parameters).bit_mask & 0x80000000) {
			if (_oss_cmp_arrbits((((*(_CPA_PPDU  *)_odata).normal_mode_parameters).protocol_version).value, (_v633).value, (((*(_CPA_PPDU  *)_odata).normal_mode_parameters).protocol_version).length, (_v633).length))
			    return 1;
		    }
		    if (((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).bit_mask & 0x80000000) {
			if (_oss_cmp_arrbits((_v633).value, (((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).protocol_version).value, (_v633).length, (((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).protocol_version).length))
			    return 1;
		    }
		}
		if ((((*(_CPA_PPDU  *)_odata).normal_mode_parameters).bit_mask ^ ((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).bit_mask) & 0x40000000)
		    return 1;
		if (((*(_CPA_PPDU  *)_odata).normal_mode_parameters).bit_mask & 0x40000000) {
		    if (_oss_cmp_unbnd_octet_ia(&(((*(_CPA_PPDU  *)_odata).normal_mode_parameters).responding_presentation_selector), &(((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).responding_presentation_selector), sizeof((((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).responding_presentation_selector).length), sizeof((((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).responding_presentation_selector).value[0]), (unsigned int)((char *)&(((*(_CPA_PPDU  *)_odata).normal_mode_parameters).responding_presentation_selector).value - (char *)&(((*(_CPA_PPDU  *)_odata).normal_mode_parameters).responding_presentation_selector))))
			return 1;
		}
		if ((((*(_CPA_PPDU  *)_odata).normal_mode_parameters).bit_mask ^ ((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).bit_mask) & 0x20000000)
		    return 1;
		if (((*(_CPA_PPDU  *)_odata).normal_mode_parameters).bit_mask & 0x20000000) {
		    _res = _cmResult_list(_g, &(((*(_CPA_PPDU  *)_odata).normal_mode_parameters).presentation_context_definition_result_list), &(((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).presentation_context_definition_result_list));
		    if (_res)
			return _res;
		}
		if ((((*(_CPA_PPDU  *)_odata).normal_mode_parameters).bit_mask ^ ((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).bit_mask) & 0x10000000)
		    return 1;
		if (((*(_CPA_PPDU  *)_odata).normal_mode_parameters).bit_mask & 0x10000000) {
		    if (_oss_cmp_arrbits((((*(_CPA_PPDU  *)_odata).normal_mode_parameters).presentation_requirements).value, (((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).presentation_requirements).value, (((*(_CPA_PPDU  *)_odata).normal_mode_parameters).presentation_requirements).length, (((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).presentation_requirements).length))
			return 1;
		}
		if ((((*(_CPA_PPDU  *)_odata).normal_mode_parameters).bit_mask ^ ((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).bit_mask) & 0x8000000)
		    return 1;
		if (((*(_CPA_PPDU  *)_odata).normal_mode_parameters).bit_mask & 0x8000000) {
		    if (_oss_cmp_arrbits((((*(_CPA_PPDU  *)_odata).normal_mode_parameters).user_session_requirements).value, (((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).user_session_requirements).value, (((*(_CPA_PPDU  *)_odata).normal_mode_parameters).user_session_requirements).length, (((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).user_session_requirements).length))
			return 1;
		}
		if ((((*(_CPA_PPDU  *)_odata).normal_mode_parameters).bit_mask & ((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).bit_mask) & 0x4000000) {
		    if (_oss_cmp_arrbits((((*(_CPA_PPDU  *)_odata).normal_mode_parameters).protocol_options).value, (((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).protocol_options).value, (((*(_CPA_PPDU  *)_odata).normal_mode_parameters).protocol_options).length, (((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).protocol_options).length))
			return 1;
		} else {
		    if (((*(_CPA_PPDU  *)_odata).normal_mode_parameters).bit_mask & 0x4000000) {
			if (_oss_cmp_arrbits((((*(_CPA_PPDU  *)_odata).normal_mode_parameters).protocol_options).value, (_v634).value, (((*(_CPA_PPDU  *)_odata).normal_mode_parameters).protocol_options).length, (_v634).length))
			    return 1;
		    }
		    if (((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).bit_mask & 0x4000000) {
			if (_oss_cmp_arrbits((_v634).value, (((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).protocol_options).value, (_v634).length, (((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).protocol_options).length))
			    return 1;
		    }
		}
		if ((((*(_CPA_PPDU  *)_odata).normal_mode_parameters).bit_mask ^ ((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).bit_mask) & 0x2000000)
		    return 1;
		if (((*(_CPA_PPDU  *)_odata).normal_mode_parameters).bit_mask & 0x2000000) {
		    if (((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).responders_nominated_context != ((*(_CPA_PPDU  *)_odata).normal_mode_parameters).responders_nominated_context)
			return 1;
		}
		if ((((*(_CPA_PPDU  *)_odata).normal_mode_parameters).bit_mask ^ ((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).bit_mask) & 0x1000000)
		    return 1;
		if (((*(_CPA_PPDU  *)_odata).normal_mode_parameters).bit_mask & 0x1000000) {
		    _res = _cmUser_data(_g, &(((*(_CPA_PPDU  *)_odata).normal_mode_parameters).user_data), &(((*(_CPA_PPDU  *)_cdata).normal_mode_parameters).user_data));
		    if (_res)
			return _res;
		}
	    }
	} break;
	case 7: {
	    if ((*(_CPR_PPDU  *)_odata).choice != (*(_CPR_PPDU  *)_cdata).choice)
		return 1;
	    switch ((*(_CPR_PPDU  *)_odata).choice) {
		case 1: {
		    if ((((*(_CPR_PPDU  *)_odata).u.normal_mode_parameters)->bit_mask & ((*(_CPR_PPDU  *)_cdata).u.normal_mode_parameters)->bit_mask) & 0x80000000) {
			if (_oss_cmp_arrbits((((*(_CPR_PPDU  *)_odata).u.normal_mode_parameters)->protocol_version).value, (((*(_CPR_PPDU  *)_cdata).u.normal_mode_parameters)->protocol_version).value, (((*(_CPR_PPDU  *)_odata).u.normal_mode_parameters)->protocol_version).length, (((*(_CPR_PPDU  *)_cdata).u.normal_mode_parameters)->protocol_version).length))
			    return 1;
		    } else {
			if (((*(_CPR_PPDU  *)_odata).u.normal_mode_parameters)->bit_mask & 0x80000000) {
			    if (_oss_cmp_arrbits((((*(_CPR_PPDU  *)_odata).u.normal_mode_parameters)->protocol_version).value, (_v635).value, (((*(_CPR_PPDU  *)_odata).u.normal_mode_parameters)->protocol_version).length, (_v635).length))
				return 1;
			}
			if (((*(_CPR_PPDU  *)_cdata).u.normal_mode_parameters)->bit_mask & 0x80000000) {
			    if (_oss_cmp_arrbits((_v635).value, (((*(_CPR_PPDU  *)_cdata).u.normal_mode_parameters)->protocol_version).value, (_v635).length, (((*(_CPR_PPDU  *)_cdata).u.normal_mode_parameters)->protocol_version).length))
				return 1;
			}
		    }
		    if ((((*(_CPR_PPDU  *)_odata).u.normal_mode_parameters)->bit_mask ^ ((*(_CPR_PPDU  *)_cdata).u.normal_mode_parameters)->bit_mask) & 0x40000000)
			return 1;
		    if (((*(_CPR_PPDU  *)_odata).u.normal_mode_parameters)->bit_mask & 0x40000000) {
			if (_oss_cmp_unbnd_octet_ia(&(((*(_CPR_PPDU  *)_odata).u.normal_mode_parameters)->responding_presentation_selector), &(((*(_CPR_PPDU  *)_cdata).u.normal_mode_parameters)->responding_presentation_selector), sizeof((((*(_CPR_PPDU  *)_cdata).u.normal_mode_parameters)->responding_presentation_selector).length), sizeof((((*(_CPR_PPDU  *)_cdata).u.normal_mode_parameters)->responding_presentation_selector).value[0]), (unsigned int)((char *)&(((*(_CPR_PPDU  *)_odata).u.normal_mode_parameters)->responding_presentation_selector).value - (char *)&(((*(_CPR_PPDU  *)_odata).u.normal_mode_parameters)->responding_presentation_selector))))
			    return 1;
		    }
		    if ((((*(_CPR_PPDU  *)_odata).u.normal_mode_parameters)->bit_mask ^ ((*(_CPR_PPDU  *)_cdata).u.normal_mode_parameters)->bit_mask) & 0x20000000)
			return 1;
		    if (((*(_CPR_PPDU  *)_odata).u.normal_mode_parameters)->bit_mask & 0x20000000) {
			_res = _cmResult_list(_g, &(((*(_CPR_PPDU  *)_odata).u.normal_mode_parameters)->presentation_context_definition_result_list), &(((*(_CPR_PPDU  *)_cdata).u.normal_mode_parameters)->presentation_context_definition_result_list));
			if (_res)
			    return _res;
		    }
		    if ((((*(_CPR_PPDU  *)_odata).u.normal_mode_parameters)->bit_mask ^ ((*(_CPR_PPDU  *)_cdata).u.normal_mode_parameters)->bit_mask) & 0x10000000)
			return 1;
		    if (((*(_CPR_PPDU  *)_odata).u.normal_mode_parameters)->bit_mask & 0x10000000) {
			if (((*(_CPR_PPDU  *)_cdata).u.normal_mode_parameters)->default_context_result != ((*(_CPR_PPDU  *)_odata).u.normal_mode_parameters)->default_context_result)
			    return 1;
		    }
		    if ((((*(_CPR_PPDU  *)_odata).u.normal_mode_parameters)->bit_mask ^ ((*(_CPR_PPDU  *)_cdata).u.normal_mode_parameters)->bit_mask) & 0x8000000)
			return 1;
		    if (((*(_CPR_PPDU  *)_odata).u.normal_mode_parameters)->bit_mask & 0x8000000) {
			if (((*(_CPR_PPDU  *)_cdata).u.normal_mode_parameters)->provider_reason != ((*(_CPR_PPDU  *)_odata).u.normal_mode_parameters)->provider_reason)
			    return 1;
		    }
		    if ((((*(_CPR_PPDU  *)_odata).u.normal_mode_parameters)->bit_mask ^ ((*(_CPR_PPDU  *)_cdata).u.normal_mode_parameters)->bit_mask) & 0x4000000)
			return 1;
		    if (((*(_CPR_PPDU  *)_odata).u.normal_mode_parameters)->bit_mask & 0x4000000) {
			_res = _cmUser_data(_g, &(((*(_CPR_PPDU  *)_odata).u.normal_mode_parameters)->user_data), &(((*(_CPR_PPDU  *)_cdata).u.normal_mode_parameters)->user_data));
			if (_res)
			    return _res;
		    }
		}   break;
		case 2: {
		    if ((((*(_CPR_PPDU  *)_odata).u.x400_mode_parameters)->bit_mask ^ ((*(_CPR_PPDU  *)_cdata).u.x400_mode_parameters)->bit_mask) & 0x80000000)
			return 1;
		    if (((*(_CPR_PPDU  *)_odata).u.x400_mode_parameters)->bit_mask & 0x80000000) {
			if (((*(_CPR_PPDU  *)_cdata).u.x400_mode_parameters)->refuseReason != ((*(_CPR_PPDU  *)_odata).u.x400_mode_parameters)->refuseReason)
			    return 1;
		    }
		    if ((((*(_CPR_PPDU  *)_odata).u.x400_mode_parameters)->bit_mask ^ ((*(_CPR_PPDU  *)_cdata).u.x400_mode_parameters)->bit_mask) & 0x40000000)
			return 1;
		    if (((*(_CPR_PPDU  *)_odata).u.x400_mode_parameters)->bit_mask & 0x40000000) {
			_res = _oss_cmp_open_type(_g, (OpenType *)&(((*(_CPR_PPDU  *)_odata).u.x400_mode_parameters)->userDataRJ), (OpenType *)&(((*(_CPR_PPDU  *)_cdata).u.x400_mode_parameters)->userDataRJ));
			if (_res)
			    return _res;
		    }
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 8: {
	    if ((*(_Abort_type  *)_odata).choice != (*(_Abort_type  *)_cdata).choice)
		return 1;
	    switch ((*(_Abort_type  *)_odata).choice) {
		case 1: {
		    if (((*(*(_Abort_type  *)_odata).u.arp_ppdu).bit_mask ^ (*(*(_Abort_type  *)_cdata).u.arp_ppdu).bit_mask) & 0x80000000)
			return 1;
		    if ((*(*(_Abort_type  *)_odata).u.arp_ppdu).bit_mask & 0x80000000) {
			if ((*(*(_Abort_type  *)_cdata).u.arp_ppdu).provider_reason != (*(*(_Abort_type  *)_odata).u.arp_ppdu).provider_reason)
			    return 1;
		    }
		    if (((*(*(_Abort_type  *)_odata).u.arp_ppdu).bit_mask ^ (*(*(_Abort_type  *)_cdata).u.arp_ppdu).bit_mask) & 0x40000000)
			return 1;
		    if ((*(*(_Abort_type  *)_odata).u.arp_ppdu).bit_mask & 0x40000000) {
			if ((*(*(_Abort_type  *)_cdata).u.arp_ppdu).event_identifier != (*(*(_Abort_type  *)_odata).u.arp_ppdu).event_identifier)
			    return 1;
		    }
		}   break;
		case 2: {
		    if ((*(*(_Abort_type  *)_odata).u.aru_ppdu).choice != (*(*(_Abort_type  *)_cdata).u.aru_ppdu).choice)
			return 1;
		    switch ((*(*(_Abort_type  *)_odata).u.aru_ppdu).choice) {
			case 1: {
			    if ((((*(*(_Abort_type  *)_odata).u.aru_ppdu).u.x400_mode_parameters)->bit_mask ^ ((*(*(_Abort_type  *)_cdata).u.aru_ppdu).u.x400_mode_parameters)->bit_mask) & 0x80000000)
				return 1;
			    if (((*(*(_Abort_type  *)_odata).u.aru_ppdu).u.x400_mode_parameters)->bit_mask & 0x80000000) {
				if (((*(*(_Abort_type  *)_cdata).u.aru_ppdu).u.x400_mode_parameters)->abortReason != ((*(*(_Abort_type  *)_odata).u.aru_ppdu).u.x400_mode_parameters)->abortReason)
				    return 1;
			    }
			    if ((((*(*(_Abort_type  *)_odata).u.aru_ppdu).u.x400_mode_parameters)->bit_mask ^ ((*(*(_Abort_type  *)_cdata).u.aru_ppdu).u.x400_mode_parameters)->bit_mask) & 0x40000000)
				return 1;
			    if (((*(*(_Abort_type  *)_odata).u.aru_ppdu).u.x400_mode_parameters)->bit_mask & 0x40000000) {
				if (_oss_cmp_arrbits((((*(*(_Abort_type  *)_odata).u.aru_ppdu).u.x400_mode_parameters)->reflectedParameter).value, (((*(*(_Abort_type  *)_cdata).u.aru_ppdu).u.x400_mode_parameters)->reflectedParameter).value, (((*(*(_Abort_type  *)_odata).u.aru_ppdu).u.x400_mode_parameters)->reflectedParameter).length, (((*(*(_Abort_type  *)_cdata).u.aru_ppdu).u.x400_mode_parameters)->reflectedParameter).length))
				    return 1;
			    }
			    if ((((*(*(_Abort_type  *)_odata).u.aru_ppdu).u.x400_mode_parameters)->bit_mask ^ ((*(*(_Abort_type  *)_cdata).u.aru_ppdu).u.x400_mode_parameters)->bit_mask) & 0x20000000)
				return 1;
			    if (((*(*(_Abort_type  *)_odata).u.aru_ppdu).u.x400_mode_parameters)->bit_mask & 0x20000000) {
				_res = _oss_cmp_open_type(_g, (OpenType *)&(((*(*(_Abort_type  *)_odata).u.aru_ppdu).u.x400_mode_parameters)->userdataAB), (OpenType *)&(((*(*(_Abort_type  *)_cdata).u.aru_ppdu).u.x400_mode_parameters)->userdataAB));
				if (_res)
				    return _res;
			    }
			}   break;
			case 2: {
			    if ((((*(*(_Abort_type  *)_odata).u.aru_ppdu).u.normal_mode_parameters)->bit_mask ^ ((*(*(_Abort_type  *)_cdata).u.aru_ppdu).u.normal_mode_parameters)->bit_mask) & 0x80000000)
				return 1;
			    if (((*(*(_Abort_type  *)_odata).u.aru_ppdu).u.normal_mode_parameters)->bit_mask & 0x80000000) {
				_res = _cm14Presentation_context_ident(_g, &(((*(*(_Abort_type  *)_odata).u.aru_ppdu).u.normal_mode_parameters)->presentation_context_identifier_list), &(((*(*(_Abort_type  *)_cdata).u.aru_ppdu).u.normal_mode_parameters)->presentation_context_identifier_list));
				if (_res)
				    return _res;
			    }
			    if ((((*(*(_Abort_type  *)_odata).u.aru_ppdu).u.normal_mode_parameters)->bit_mask ^ ((*(*(_Abort_type  *)_cdata).u.aru_ppdu).u.normal_mode_parameters)->bit_mask) & 0x40000000)
				return 1;
			    if (((*(*(_Abort_type  *)_odata).u.aru_ppdu).u.normal_mode_parameters)->bit_mask & 0x40000000) {
				_res = _cmUser_data(_g, &(((*(*(_Abort_type  *)_odata).u.aru_ppdu).u.normal_mode_parameters)->user_data), &(((*(*(_Abort_type  *)_cdata).u.aru_ppdu).u.normal_mode_parameters)->user_data));
				if (_res)
				    return _res;
			    }
			}   break;
			case 0:
			    break;
			default:
			    return 1;
		    }
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 9: {
	    if ((*(_Typed_data_type  *)_odata).choice != (*(_Typed_data_type  *)_cdata).choice)
		return 1;
	    switch ((*(_Typed_data_type  *)_odata).choice) {
		case 1: {
		    _res = _cmUser_data(_g, (*(_Typed_data_type  *)_odata).u.ttdPPDU, (*(_Typed_data_type  *)_cdata).u.ttdPPDU);
		    if (_res)
			return _res;
		}   break;
		case 2: {
		    if (((*(*(_Typed_data_type  *)_odata).u.acPPDU).bit_mask ^ (*(*(_Typed_data_type  *)_cdata).u.acPPDU).bit_mask) & 0x80000000)
			return 1;
		    if ((*(*(_Typed_data_type  *)_odata).u.acPPDU).bit_mask & 0x80000000) {
			_res = _cmContext_list(_g, &((*(*(_Typed_data_type  *)_odata).u.acPPDU).presentation_context_addition_list), &((*(*(_Typed_data_type  *)_cdata).u.acPPDU).presentation_context_addition_list));
			if (_res)
			    return _res;
		    }
		    if (((*(*(_Typed_data_type  *)_odata).u.acPPDU).bit_mask ^ (*(*(_Typed_data_type  *)_cdata).u.acPPDU).bit_mask) & 0x40000000)
			return 1;
		    if ((*(*(_Typed_data_type  *)_odata).u.acPPDU).bit_mask & 0x40000000) {
			{
			    _Presentation_context_deletion_list *  _s_oss_tmp_3 = (_Presentation_context_deletion_list *)(*(*(_Typed_data_type  *)_odata).u.acPPDU).presentation_context_deletion_list;
			    _Presentation_context_deletion_list *  _d_oss_tmp_3 = (_Presentation_context_deletion_list *)(*(*(_Typed_data_type  *)_cdata).u.acPPDU).presentation_context_deletion_list;

			    while (_s_oss_tmp_3 && _d_oss_tmp_3) {
				if (_d_oss_tmp_3->value != _s_oss_tmp_3->value)
				    return 1;
				_s_oss_tmp_3 = _s_oss_tmp_3->next;
				_d_oss_tmp_3 = _d_oss_tmp_3->next;
			    }
			    if (_s_oss_tmp_3 || _d_oss_tmp_3)
				return 1;
			}
		    }
		    if (((*(*(_Typed_data_type  *)_odata).u.acPPDU).bit_mask ^ (*(*(_Typed_data_type  *)_cdata).u.acPPDU).bit_mask) & 0x20000000)
			return 1;
		    if ((*(*(_Typed_data_type  *)_odata).u.acPPDU).bit_mask & 0x20000000) {
			_res = _cmUser_data(_g, &((*(*(_Typed_data_type  *)_odata).u.acPPDU).user_data), &((*(*(_Typed_data_type  *)_cdata).u.acPPDU).user_data));
			if (_res)
			    return _res;
		    }
		}   break;
		case 3: {
		    if (((*(*(_Typed_data_type  *)_odata).u.acaPPDU).bit_mask ^ (*(*(_Typed_data_type  *)_cdata).u.acaPPDU).bit_mask) & 0x80000000)
			return 1;
		    if ((*(*(_Typed_data_type  *)_odata).u.acaPPDU).bit_mask & 0x80000000) {
			_res = _cmResult_list(_g, &((*(*(_Typed_data_type  *)_odata).u.acaPPDU).presentation_context_addition_result_list), &((*(*(_Typed_data_type  *)_cdata).u.acaPPDU).presentation_context_addition_result_list));
			if (_res)
			    return _res;
		    }
		    if (((*(*(_Typed_data_type  *)_odata).u.acaPPDU).bit_mask ^ (*(*(_Typed_data_type  *)_cdata).u.acaPPDU).bit_mask) & 0x40000000)
			return 1;
		    if ((*(*(_Typed_data_type  *)_odata).u.acaPPDU).bit_mask & 0x40000000) {
			{
			    _Presentation_context_deletion_list *  _s_oss_tmp_3 = (_Presentation_context_deletion_list *)(*(*(_Typed_data_type  *)_odata).u.acaPPDU).presentation_context_deletion_result_list;
			    _Presentation_context_deletion_list *  _d_oss_tmp_3 = (_Presentation_context_deletion_list *)(*(*(_Typed_data_type  *)_cdata).u.acaPPDU).presentation_context_deletion_result_list;

			    while (_s_oss_tmp_3 && _d_oss_tmp_3) {
				if (_d_oss_tmp_3->value != _s_oss_tmp_3->value)
				    return 1;
				_s_oss_tmp_3 = _s_oss_tmp_3->next;
				_d_oss_tmp_3 = _d_oss_tmp_3->next;
			    }
			    if (_s_oss_tmp_3 || _d_oss_tmp_3)
				return 1;
			}
		    }
		    if (((*(*(_Typed_data_type  *)_odata).u.acaPPDU).bit_mask ^ (*(*(_Typed_data_type  *)_cdata).u.acaPPDU).bit_mask) & 0x20000000)
			return 1;
		    if ((*(*(_Typed_data_type  *)_odata).u.acaPPDU).bit_mask & 0x20000000) {
			_res = _cmUser_data(_g, &((*(*(_Typed_data_type  *)_odata).u.acaPPDU).user_data), &((*(*(_Typed_data_type  *)_cdata).u.acaPPDU).user_data));
			if (_res)
			    return _res;
		    }
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 10: {
	    if (((*(_seq6  *)_odata).bit_mask ^ (*(_seq6  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_seq6  *)_odata).bit_mask & 0x80000000) {
		_res = _cm14Presentation_context_ident(_g, &((*(_seq6  *)_odata).presentation_context_identifier_list), &((*(_seq6  *)_cdata).presentation_context_identifier_list));
		if (_res)
		    return _res;
	    }
	    if (((*(_seq6  *)_odata).bit_mask ^ (*(_seq6  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_seq6  *)_odata).bit_mask & 0x40000000) {
		_res = _cmUser_data(_g, &((*(_seq6  *)_odata).user_data), &((*(_seq6  *)_cdata).user_data));
		if (_res)
		    return _res;
	    }
	} break;
	case 11: {
	    if (((*(_seq6  *)_odata).bit_mask ^ (*(_seq6  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_seq6  *)_odata).bit_mask & 0x80000000) {
		_res = _cm14Presentation_context_ident(_g, &((*(_seq6  *)_odata).presentation_context_identifier_list), &((*(_seq6  *)_cdata).presentation_context_identifier_list));
		if (_res)
		    return _res;
	    }
	    if (((*(_seq6  *)_odata).bit_mask ^ (*(_seq6  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_seq6  *)_odata).bit_mask & 0x40000000) {
		_res = _cmUser_data(_g, &((*(_seq6  *)_odata).user_data), &((*(_seq6  *)_cdata).user_data));
		if (_res)
		    return _res;
	    }
	} break;
	case 12: {
	    if ((*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).choice != (*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).choice)
		return 1;
	    switch ((*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).choice) {
		case 1: {
		    if ((*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rttp_apdu != (*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rttp_apdu)
			return 1;
		}   break;
		case 2: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rttr_apdu), &((*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rttr_apdu), sizeof(((*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rttr_apdu).length), sizeof(((*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rttr_apdu).value[0]), (unsigned int)((char *)&((*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rttr_apdu).value - (char *)&((*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rttr_apdu))))
			return 1;
		}   break;
		case 3: {
		    _res = _cmRTORQapdu(_g, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtorq_apdu, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rtorq_apdu);
		    if (_res)
			return _res;
		}   break;
		case 4: {
		    _res = _cmRTOACapdu(_g, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtoac_apdu, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rtoac_apdu);
		    if (_res)
			return _res;
		}   break;
		case 5: {
		    _res = _cmRTORJapdu(_g, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtorj_apdu, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rtorj_apdu);
		    if (_res)
			return _res;
		}   break;
		case 6: {
		    if (((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtab_apdu).bit_mask ^ (*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rtab_apdu).bit_mask) & 0x80000000)
			return 1;
		    if ((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtab_apdu).bit_mask & 0x80000000) {
			if ((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rtab_apdu).abortReason != (*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtab_apdu).abortReason)
			    return 1;
		    }
		    if (((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtab_apdu).bit_mask ^ (*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rtab_apdu).bit_mask) & 0x40000000)
			return 1;
		    if ((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtab_apdu).bit_mask & 0x40000000) {
			if (_oss_cmp_arrbits(((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtab_apdu).reflectedParameter).value, ((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rtab_apdu).reflectedParameter).value, ((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtab_apdu).reflectedParameter).length, ((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rtab_apdu).reflectedParameter).length))
			    return 1;
		    }
		    if (((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtab_apdu).bit_mask ^ (*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rtab_apdu).bit_mask) & 0x20000000)
			return 1;
		    if ((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtab_apdu).bit_mask & 0x20000000) {
			_res = _oss_cmp_open_type(_g, (OpenType *)&((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtab_apdu).userdataAB), (OpenType *)&((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rtab_apdu).userdataAB));
			if (_res)
			    return _res;
		    }
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 13: {
	    if ((*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).choice != (*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).choice)
		return 1;
	    switch ((*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).choice) {
		case 1: {
		    if ((*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rttp_apdu != (*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rttp_apdu)
			return 1;
		}   break;
		case 2: {
		    if (_oss_cmp_unbnd_octet_ia(&((*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rttr_apdu), &((*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rttr_apdu), sizeof(((*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rttr_apdu).length), sizeof(((*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rttr_apdu).value[0]), (unsigned int)((char *)&((*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rttr_apdu).value - (char *)&((*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rttr_apdu))))
			return 1;
		}   break;
		case 3: {
		    _res = _cmRTORQapdu(_g, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtorq_apdu, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rtorq_apdu);
		    if (_res)
			return _res;
		}   break;
		case 4: {
		    _res = _cmRTOACapdu(_g, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtoac_apdu, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rtoac_apdu);
		    if (_res)
			return _res;
		}   break;
		case 5: {
		    _res = _cmRTORJapdu(_g, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtorj_apdu, (*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rtorj_apdu);
		    if (_res)
			return _res;
		}   break;
		case 6: {
		    if (((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtab_apdu).bit_mask ^ (*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rtab_apdu).bit_mask) & 0x80000000)
			return 1;
		    if ((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtab_apdu).bit_mask & 0x80000000) {
			if ((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rtab_apdu).abortReason != (*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtab_apdu).abortReason)
			    return 1;
		    }
		    if (((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtab_apdu).bit_mask ^ (*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rtab_apdu).bit_mask) & 0x40000000)
			return 1;
		    if ((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtab_apdu).bit_mask & 0x40000000) {
			if (_oss_cmp_arrbits(((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtab_apdu).reflectedParameter).value, ((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rtab_apdu).reflectedParameter).value, ((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtab_apdu).reflectedParameter).length, ((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rtab_apdu).reflectedParameter).length))
			    return 1;
		    }
		    if (((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtab_apdu).bit_mask ^ (*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rtab_apdu).bit_mask) & 0x20000000)
			return 1;
		    if ((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtab_apdu).bit_mask & 0x20000000) {
			_res = _oss_cmp_open_type(_g, (OpenType *)&((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_odata).u.rtab_apdu).userdataAB), (OpenType *)&((*(*(_Reliable_Transfer_APDU_RTSE_apdus  *)_cdata).u.rtab_apdu).userdataAB));
			if (_res)
			    return _res;
		    }
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 14: {
	    _res = _cmInvokeId(_g, (_InvokeId  *)_odata, (_InvokeId  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 15: {
	    _res = _cmInvokeId(_g, &((*(_Reject  *)_odata).invokeId), &((*(_Reject  *)_cdata).invokeId));
	    if (_res)
		return _res;
	    if (((*(_Reject  *)_odata).problem).choice != ((*(_Reject  *)_cdata).problem).choice)
		return 1;
	    switch (((*(_Reject  *)_odata).problem).choice) {
		case 1: {
		    if (((*(_Reject  *)_cdata).problem).u.general != ((*(_Reject  *)_odata).problem).u.general)
			return 1;
		}   break;
		case 2: {
		    if (((*(_Reject  *)_cdata).problem).u.invoke != ((*(_Reject  *)_odata).problem).u.invoke)
			return 1;
		}   break;
		case 3: {
		    if (((*(_Reject  *)_cdata).problem).u.returnResult != ((*(_Reject  *)_odata).problem).u.returnResult)
			return 1;
		}   break;
		case 4: {
		    if (((*(_Reject  *)_cdata).problem).u.returnError != ((*(_Reject  *)_odata).problem).u.returnError)
			return 1;
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 16: {
	    _res = _cmInvokeId(_g, (_InvokeId  *)_odata, (_InvokeId  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 17: {
	    _res = _cmUnboundedDirectoryString(_g, (_UnboundedDirectoryString  *)_odata, (_UnboundedDirectoryString  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 18: {
	    if (_oss_cmp_arrbits((*(OSSC::COssBitString  *)_odata).value, (*(OSSC::COssBitString  *)_cdata).value, (*(OSSC::COssBitString  *)_odata).length, (*(OSSC::COssBitString  *)_cdata).length))
		return 1;
	} break;
	case 19: {
	    if (_oss_cmp_unbnd_octet_ia(&((*(_UUIDPair  *)_odata).issuerUUID), &((*(_UUIDPair  *)_cdata).issuerUUID), sizeof(((*(_UUIDPair  *)_cdata).issuerUUID).length), sizeof(((*(_UUIDPair  *)_cdata).issuerUUID).value[0]), (unsigned int)((char *)&((*(_UUIDPair  *)_odata).issuerUUID).value - (char *)&((*(_UUIDPair  *)_odata).issuerUUID))))
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*(_UUIDPair  *)_odata).subjectUUID), &((*(_UUIDPair  *)_cdata).subjectUUID), sizeof(((*(_UUIDPair  *)_cdata).subjectUUID).length), sizeof(((*(_UUIDPair  *)_cdata).subjectUUID).value[0]), (unsigned int)((char *)&((*(_UUIDPair  *)_odata).subjectUUID).value - (char *)&((*(_UUIDPair  *)_odata).subjectUUID))))
		return 1;
	} break;
	case 20: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 21: {
	    if (((*(_Guide  *)_odata).bit_mask ^ (*(_Guide  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_Guide  *)_odata).bit_mask & 0x80000000) {
		if (!((*(_Guide  *)_cdata).objectClass).length)
		    return 1;
		if (_oss_cmp_unbnd_octet_ia(&((*(_Guide  *)_odata).objectClass), &((*(_Guide  *)_cdata).objectClass), sizeof(((*(_Guide  *)_cdata).objectClass).length), sizeof(((*(_Guide  *)_cdata).objectClass).value[0]), (unsigned int)((char *)&((*(_Guide  *)_odata).objectClass).value - (char *)&((*(_Guide  *)_odata).objectClass))))
		    return 1;
	    }
	    _res = _cmCriteria(_g, &((*(_Guide  *)_odata).criteria), &((*(_Guide  *)_cdata).criteria));
	    if (_res)
		return _res;
	} break;
	case 22: {
	    if (!((*(_EnhancedGuide  *)_cdata).objectClass).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*(_EnhancedGuide  *)_odata).objectClass), &((*(_EnhancedGuide  *)_cdata).objectClass), sizeof(((*(_EnhancedGuide  *)_cdata).objectClass).length), sizeof(((*(_EnhancedGuide  *)_cdata).objectClass).value[0]), (unsigned int)((char *)&((*(_EnhancedGuide  *)_odata).objectClass).value - (char *)&((*(_EnhancedGuide  *)_odata).objectClass))))
		return 1;
	    _res = _cmCriteria(_g, &((*(_EnhancedGuide  *)_odata).criteria), &((*(_EnhancedGuide  *)_cdata).criteria));
	    if (_res)
		return _res;
	    if (((*(_EnhancedGuide  *)_odata).bit_mask & (*(_EnhancedGuide  *)_cdata).bit_mask) & 0x80000000) {
		if ((*(_EnhancedGuide  *)_cdata).subset != (*(_EnhancedGuide  *)_odata).subset)
		    return 1;
	    } else {
		if ((*(_EnhancedGuide  *)_odata).bit_mask & 0x80000000) {
		    if (EnhancedGuide::default_subset != (*(_EnhancedGuide  *)_odata).subset)
			return 1;
		}
		if ((*(_EnhancedGuide  *)_cdata).bit_mask & 0x80000000) {
		    if ((*(_EnhancedGuide  *)_cdata).subset != EnhancedGuide::default_subset)
			return 1;
		}
	    }
	} break;
	case 23: {
	    {
		_PostalAddress *  _s_oss_tmp_1 = *(_PostalAddress * *)_odata;
		_PostalAddress *  _d_oss_tmp_1 = *(_PostalAddress * *)_cdata;

		while (_s_oss_tmp_1 && _d_oss_tmp_1) {
		    _res = _cmUnboundedDirectoryString(_g, &(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value));
		    if (_res)
			return _res;
		    _s_oss_tmp_1 = _s_oss_tmp_1->next;
		    _d_oss_tmp_1 = _d_oss_tmp_1->next;
		}
		if (_s_oss_tmp_1 || _d_oss_tmp_1)
		    return 1;
	    }
	} break;
	case 24: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 25: {
	    if (_oss_cmp_unbnd_octet_ia(&((*(_TelexNumber  *)_odata).telexNumber), &((*(_TelexNumber  *)_cdata).telexNumber), sizeof(((*(_TelexNumber  *)_cdata).telexNumber).length), sizeof(((*(_TelexNumber  *)_cdata).telexNumber).value[0]), (unsigned int)((char *)&((*(_TelexNumber  *)_odata).telexNumber).value - (char *)&((*(_TelexNumber  *)_odata).telexNumber))))
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*(_TelexNumber  *)_odata).countryCode), &((*(_TelexNumber  *)_cdata).countryCode), sizeof(((*(_TelexNumber  *)_cdata).countryCode).length), sizeof(((*(_TelexNumber  *)_cdata).countryCode).value[0]), (unsigned int)((char *)&((*(_TelexNumber  *)_odata).countryCode).value - (char *)&((*(_TelexNumber  *)_odata).countryCode))))
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*(_TelexNumber  *)_odata).answerback), &((*(_TelexNumber  *)_cdata).answerback), sizeof(((*(_TelexNumber  *)_cdata).answerback).length), sizeof(((*(_TelexNumber  *)_cdata).answerback).value[0]), (unsigned int)((char *)&((*(_TelexNumber  *)_odata).answerback).value - (char *)&((*(_TelexNumber  *)_odata).answerback))))
		return 1;
	} break;
	case 26: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 27: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 28: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 29: {
	    if (!(*(OSSC::COssEncOID  *)_cdata).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssEncOID  *)_odata, (OSSC::COssEncOID  *)_cdata, sizeof((*(OSSC::COssEncOID  *)_cdata).length), sizeof((*(OSSC::COssEncOID  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssEncOID  *)_odata).value - (char *)(OSSC::COssEncOID  *)_odata)))
		return 1;
	} break;
	case 30: {
	    if (!(*(OSSC::COssEncOID  *)_cdata).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssEncOID  *)_odata, (OSSC::COssEncOID  *)_cdata, sizeof((*(OSSC::COssEncOID  *)_cdata).length), sizeof((*(OSSC::COssEncOID  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssEncOID  *)_odata).value - (char *)(OSSC::COssEncOID  *)_odata)))
		return 1;
	} break;
	case 31: {
	    {
		_Presentation_context_deletion_list *  _s_oss_tmp_1 = *(_Presentation_context_deletion_list * *)_odata;
		_Presentation_context_deletion_list *  _d_oss_tmp_1 = *(_Presentation_context_deletion_list * *)_cdata;

		while (_s_oss_tmp_1 && _d_oss_tmp_1) {
		    if (_d_oss_tmp_1->value != _s_oss_tmp_1->value)
			return 1;
		    _s_oss_tmp_1 = _s_oss_tmp_1->next;
		    _d_oss_tmp_1 = _d_oss_tmp_1->next;
		}
		if (_s_oss_tmp_1 || _d_oss_tmp_1)
		    return 1;
	    }
	} break;
	case 32: {
	    if (((*(_PresentationAddress  *)_odata).bit_mask ^ (*(_PresentationAddress  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_PresentationAddress  *)_odata).bit_mask & 0x80000000) {
		if (_oss_cmp_unbnd_octet_ia(&((*(_PresentationAddress  *)_odata).pSelector), &((*(_PresentationAddress  *)_cdata).pSelector), sizeof(((*(_PresentationAddress  *)_cdata).pSelector).length), sizeof(((*(_PresentationAddress  *)_cdata).pSelector).value[0]), (unsigned int)((char *)&((*(_PresentationAddress  *)_odata).pSelector).value - (char *)&((*(_PresentationAddress  *)_odata).pSelector))))
		    return 1;
	    }
	    if (((*(_PresentationAddress  *)_odata).bit_mask ^ (*(_PresentationAddress  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_PresentationAddress  *)_odata).bit_mask & 0x40000000) {
		if (_oss_cmp_unbnd_octet_ia(&((*(_PresentationAddress  *)_odata).sSelector), &((*(_PresentationAddress  *)_cdata).sSelector), sizeof(((*(_PresentationAddress  *)_cdata).sSelector).length), sizeof(((*(_PresentationAddress  *)_cdata).sSelector).value[0]), (unsigned int)((char *)&((*(_PresentationAddress  *)_odata).sSelector).value - (char *)&((*(_PresentationAddress  *)_odata).sSelector))))
		    return 1;
	    }
	    if (((*(_PresentationAddress  *)_odata).bit_mask ^ (*(_PresentationAddress  *)_cdata).bit_mask) & 0x20000000)
		return 1;
	    if ((*(_PresentationAddress  *)_odata).bit_mask & 0x20000000) {
		if (_oss_cmp_unbnd_octet_ia(&((*(_PresentationAddress  *)_odata).tSelector), &((*(_PresentationAddress  *)_cdata).tSelector), sizeof(((*(_PresentationAddress  *)_cdata).tSelector).length), sizeof(((*(_PresentationAddress  *)_cdata).tSelector).value[0]), (unsigned int)((char *)&((*(_PresentationAddress  *)_odata).tSelector).value - (char *)&((*(_PresentationAddress  *)_odata).tSelector))))
		    return 1;
	    }
	    {
		_setof3 *  _s_2 = (*(_PresentationAddress  *)_odata).nAddresses;
		_setof3 *  _d_2 = (*(_PresentationAddress  *)_cdata).nAddresses;
		long        *_a, _i, _i_next, _c = 0L;

		while (_s_2 && _d_2) {
		    ++ _c;
		    _s_2 = _s_2->next;
		    _d_2 = _d_2->next;
		}
		if (_s_2 || _d_2)
		    return 1;
		if (_c) {
		    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
		    for (_i = 0; _i < _c; _i ++)
			_a[_i] = _i;
		    _a[_c] = -1L;
		    for (_s_2 = (*(_PresentationAddress  *)_odata).nAddresses; _s_2; _s_2 = _s_2->next) {
			_i_next = _a[0]; _res = 1;
			for (_d_2 = (*(_PresentationAddress  *)_cdata).nAddresses, _i = 0L; _d_2 && _i_next >= 0L && _a[_i_next] >= 0L; _d_2 = _d_2->next,
				_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
			    if (_i < _i_next)
				continue;
			    if (_oss_cmp_unbnd_octet_ia(&(_s_2->value), &(_d_2->value), sizeof((_d_2->value).length), sizeof((_d_2->value).value[0]), (unsigned int)((char *)&(_s_2->value).value - (char *)&(_s_2->value))))
				continue;
			    _res = 0; _a[_i] = _a[_i+1];
			    break;
			}
			if (_res)
			    break;
		    }
		    _oss_dec_freetempmem(_g, _a);
		    if (_res)
			return _res;
		}
	    }
	} break;
	case 33: {
	    if (_oss_cmp_unbnd_octet_ia(&((*(_ProtocolInformation  *)_odata).nAddress), &((*(_ProtocolInformation  *)_cdata).nAddress), sizeof(((*(_ProtocolInformation  *)_cdata).nAddress).length), sizeof(((*(_ProtocolInformation  *)_cdata).nAddress).value[0]), (unsigned int)((char *)&((*(_ProtocolInformation  *)_odata).nAddress).value - (char *)&((*(_ProtocolInformation  *)_odata).nAddress))))
		return 1;
	    {
		_Application_context_name_list *  _s_2 = (*(_ProtocolInformation  *)_odata).profiles;
		_Application_context_name_list *  _d_2 = (*(_ProtocolInformation  *)_cdata).profiles;
		long        *_a, _i, _i_next, _c = 0L;

		while (_s_2 && _d_2) {
		    ++ _c;
		    _s_2 = _s_2->next;
		    _d_2 = _d_2->next;
		}
		if (_s_2 || _d_2)
		    return 1;
		if (_c) {
		    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
		    for (_i = 0; _i < _c; _i ++)
			_a[_i] = _i;
		    _a[_c] = -1L;
		    for (_s_2 = (*(_ProtocolInformation  *)_odata).profiles; _s_2; _s_2 = _s_2->next) {
			_i_next = _a[0]; _res = 1;
			for (_d_2 = (*(_ProtocolInformation  *)_cdata).profiles, _i = 0L; _d_2 && _i_next >= 0L && _a[_i_next] >= 0L; _d_2 = _d_2->next,
				_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
			    if (_i < _i_next)
				continue;
			    if (!(_d_2->value).length)
				continue;
			    if (_oss_cmp_unbnd_octet_ia(&(_s_2->value), &(_d_2->value), sizeof((_d_2->value).length), sizeof((_d_2->value).value[0]), (unsigned int)((char *)&(_s_2->value).value - (char *)&(_s_2->value))))
				continue;
			    _res = 0; _a[_i] = _a[_i+1];
			    break;
			}
			if (_res)
			    break;
		    }
		    _oss_dec_freetempmem(_g, _a);
		    if (_res)
			return _res;
		}
	    }
	} break;
	case 34: {
	    _res = _cmRDNSequence(_g, &((*(_NameAndOptionalUID  *)_odata).dn), &((*(_NameAndOptionalUID  *)_cdata).dn));
	    if (_res)
		return _res;
	    if (((*(_NameAndOptionalUID  *)_odata).bit_mask ^ (*(_NameAndOptionalUID  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_NameAndOptionalUID  *)_odata).bit_mask & 0x80000000) {
		if (_oss_cmp_arrbits(((*(_NameAndOptionalUID  *)_odata).uid).value, ((*(_NameAndOptionalUID  *)_cdata).uid).value, ((*(_NameAndOptionalUID  *)_odata).uid).length, ((*(_NameAndOptionalUID  *)_cdata).uid).length))
		    return 1;
	    }
	} break;
	case 35: {
	    if (((*(_MultipleMatchingLocalities  *)_odata).bit_mask ^ (*(_MultipleMatchingLocalities  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_MultipleMatchingLocalities  *)_odata).bit_mask & 0x80000000) {
		if (!((*(_MultipleMatchingLocalities  *)_cdata).matchingRuleUsed).length)
		    return 1;
		if (_oss_cmp_unbnd_octet_ia(&((*(_MultipleMatchingLocalities  *)_odata).matchingRuleUsed), &((*(_MultipleMatchingLocalities  *)_cdata).matchingRuleUsed), sizeof(((*(_MultipleMatchingLocalities  *)_cdata).matchingRuleUsed).length), sizeof(((*(_MultipleMatchingLocalities  *)_cdata).matchingRuleUsed).value[0]), (unsigned int)((char *)&((*(_MultipleMatchingLocalities  *)_odata).matchingRuleUsed).value - (char *)&((*(_MultipleMatchingLocalities  *)_odata).matchingRuleUsed))))
		    return 1;
	    }
	    {
		_seqof2 *  _s_oss_tmp_2 = (*(_MultipleMatchingLocalities  *)_odata).attributeList;
		_seqof2 *  _d_oss_tmp_2 = (*(_MultipleMatchingLocalities  *)_cdata).attributeList;

		while (_s_oss_tmp_2 && _d_oss_tmp_2) {
		    if (!((_d_oss_tmp_2->value).type).length)
			return 1;
		    if (_oss_cmp_unbnd_octet_ia(&((_s_oss_tmp_2->value).type), &((_d_oss_tmp_2->value).type), sizeof(((_d_oss_tmp_2->value).type).length), sizeof(((_d_oss_tmp_2->value).type).value[0]), (unsigned int)((char *)&((_s_oss_tmp_2->value).type).value - (char *)&((_s_oss_tmp_2->value).type))))
			return 1;
		    _res = _oss_cmp_new_open_type(_g, ((_s_oss_tmp_2->value).assertion).pduNum, ((_d_oss_tmp_2->value).assertion).pduNum, &(((_s_oss_tmp_2->value).assertion).encoded), &(((_d_oss_tmp_2->value).assertion).encoded), *(void **)&(((_s_oss_tmp_2->value).assertion).decoded), *(void **)&(((_d_oss_tmp_2->value).assertion).decoded));
		    if (_res)
			return _res;
		    if (((_s_oss_tmp_2->value).bit_mask ^ (_d_oss_tmp_2->value).bit_mask) & 0x80000000)
			return 1;
		    if ((_s_oss_tmp_2->value).bit_mask & 0x80000000) {
			{
			    _choice4  * _odata_3 = &((_s_oss_tmp_2->value).assertedContexts);
			    _choice4  * _cdata_3 = &((_d_oss_tmp_2->value).assertedContexts);

			    if ((*_odata_3).choice != (*_cdata_3).choice)
				return 1;
			    switch ((*_odata_3).choice) {
				case 1: {
				}   break;
				case 2: {
				    {
					_setof6 *  _s_5 = (*_odata_3).u.selectedContexts;
					_setof6 *  _d_5 = (*_cdata_3).u.selectedContexts;
					long        *_a, _i, _i_next, _c = 0L;

					while (_s_5 && _d_5) {
					    ++ _c;
					    _s_5 = _s_5->next;
					    _d_5 = _d_5->next;
					}
					if (_s_5 || _d_5)
					    return 1;
					if (_c) {
					    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
					    for (_i = 0; _i < _c; _i ++)
						_a[_i] = _i;
					    _a[_c] = -1L;
					    for (_s_5 = (*_odata_3).u.selectedContexts; _s_5; _s_5 = _s_5->next) {
						_i_next = _a[0]; _res = 1;
						for (_d_5 = (*_cdata_3).u.selectedContexts, _i = 0L; _d_5 && _i_next >= 0L && _a[_i_next] >= 0L; _d_5 = _d_5->next,
							_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
						    if (_i < _i_next)
							continue;
						    _res = _cmContextAssertion(_g, &(_s_5->value), &(_d_5->value));
						    if (_res)
							continue;
						    _res = 0; _a[_i] = _a[_i+1];
						    break;
						}
						if (_res)
						    break;
					    }
					    _oss_dec_freetempmem(_g, _a);
					    if (_res)
						return _res;
					}
				    }
				}   break;
				case 0:
				    break;
				default:
				    return 1;
			    }
			}
		    }
		    _s_oss_tmp_2 = _s_oss_tmp_2->next;
		    _d_oss_tmp_2 = _d_oss_tmp_2->next;
		}
		if (_s_oss_tmp_2 || _d_oss_tmp_2)
		    return 1;
	    }
	} break;
	case 36: {
	    {
		_SubstringAssertion *  _s_oss_tmp_1 = *(_SubstringAssertion * *)_odata;
		_SubstringAssertion *  _d_oss_tmp_1 = *(_SubstringAssertion * *)_cdata;

		while (_s_oss_tmp_1 && _d_oss_tmp_1) {
		    if ((_s_oss_tmp_1->value).choice != (_d_oss_tmp_1->value).choice)
			return 1;
		    switch ((_s_oss_tmp_1->value).choice) {
			case 1: {
			    if (!((*(_d_oss_tmp_1->value).u.control).type).length)
				return 1;
			    if (_oss_cmp_unbnd_octet_ia(&((*(_s_oss_tmp_1->value).u.control).type), &((*(_d_oss_tmp_1->value).u.control).type), sizeof(((*(_d_oss_tmp_1->value).u.control).type).length), sizeof(((*(_d_oss_tmp_1->value).u.control).type).value[0]), (unsigned int)((char *)&((*(_s_oss_tmp_1->value).u.control).type).value - (char *)&((*(_s_oss_tmp_1->value).u.control).type))))
				return 1;
			    {
				_setof13 * * _odata_3 = &((*(_s_oss_tmp_1->value).u.control).values);
				_setof13 * * _cdata_3 = &((*(_d_oss_tmp_1->value).u.control).values);

				{
				    _setof13 *  _s_4 = *_odata_3;
				    _setof13 *  _d_4 = *_cdata_3;
				    long        *_a, _i, _i_next, _c = 0L;

				    while (_s_4 && _d_4) {
					++ _c;
					_s_4 = _s_4->next;
					_d_4 = _d_4->next;
				    }
				    if (_s_4 || _d_4)
					return 1;
				    if (_c) {
					_a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
					for (_i = 0; _i < _c; _i ++)
					    _a[_i] = _i;
					_a[_c] = -1L;
					for (_s_4 = *_odata_3; _s_4; _s_4 = _s_4->next) {
					    _i_next = _a[0]; _res = 1;
					    for (_d_4 = *_cdata_3, _i = 0L; _d_4 && _i_next >= 0L && _a[_i_next] >= 0L; _d_4 = _d_4->next,
						    _i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
						if (_i < _i_next)
						    continue;
						_res = _oss_cmp_new_open_type(_g, (_s_4->value).pduNum, (_d_4->value).pduNum, &((_s_4->value).encoded), &((_d_4->value).encoded), *(void **)&((_s_4->value).decoded), *(void **)&((_d_4->value).decoded));
						if (_res)
						    continue;
						_res = 0; _a[_i] = _a[_i+1];
						break;
					    }
					    if (_res)
						break;
					}
					_oss_dec_freetempmem(_g, _a);
					if (_res)
					    return _res;
				    }
				}
			    }
			    if (((*(_s_oss_tmp_1->value).u.control).bit_mask ^ (*(_d_oss_tmp_1->value).u.control).bit_mask) & 0x80000000)
				return 1;
			    if ((*(_s_oss_tmp_1->value).u.control).bit_mask & 0x80000000) {
				{
				    _setof14 * * _odata_3 = &((*(_s_oss_tmp_1->value).u.control).valuesWithContext);
				    _setof14 * * _cdata_3 = &((*(_d_oss_tmp_1->value).u.control).valuesWithContext);

				    {
					_setof14 *  _s_4 = *_odata_3;
					_setof14 *  _d_4 = *_cdata_3;
					long        *_a, _i, _i_next, _c = 0L;

					while (_s_4 && _d_4) {
					    ++ _c;
					    _s_4 = _s_4->next;
					    _d_4 = _d_4->next;
					}
					if (_s_4 || _d_4)
					    return 1;
					if (_c) {
					    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
					    for (_i = 0; _i < _c; _i ++)
						_a[_i] = _i;
					    _a[_c] = -1L;
					    for (_s_4 = *_odata_3; _s_4; _s_4 = _s_4->next) {
						_i_next = _a[0]; _res = 1;
						for (_d_4 = *_cdata_3, _i = 0L; _d_4 && _i_next >= 0L && _a[_i_next] >= 0L; _d_4 = _d_4->next,
							_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
						    if (_i < _i_next)
							continue;
						    _res = _oss_cmp_new_open_type(_g, ((_s_4->value).value).pduNum, ((_d_4->value).value).pduNum, &(((_s_4->value).value).encoded), &(((_d_4->value).value).encoded), *(void **)&(((_s_4->value).value).decoded), *(void **)&(((_d_4->value).value).decoded));
						    if (_res)
							continue;
						    {
							_setof15 *  _s_6 = (_s_4->value).contextList;
							_setof15 *  _d_6 = (_d_4->value).contextList;
							long        *_a, _i, _i_next, _c = 0L;

							while (_s_6 && _d_6) {
							    ++ _c;
							    _s_6 = _s_6->next;
							    _d_6 = _d_6->next;
							}
							if (_s_6 || _d_6)
							    continue;
							if (_c) {
							    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
							    for (_i = 0; _i < _c; _i ++)
								_a[_i] = _i;
							    _a[_c] = -1L;
							    for (_s_6 = (_s_4->value).contextList; _s_6; _s_6 = _s_6->next) {
								_i_next = _a[0]; _res = 1;
								for (_d_6 = (_d_4->value).contextList, _i = 0L; _d_6 && _i_next >= 0L && _a[_i_next] >= 0L; _d_6 = _d_6->next,
									_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
								    if (_i < _i_next)
									continue;
								    _res = _cmContext(_g, &(_s_6->value), &(_d_6->value));
								    if (_res)
									continue;
								    _res = 0; _a[_i] = _a[_i+1];
								    break;
								}
								if (_res)
								    break;
							    }
							    _oss_dec_freetempmem(_g, _a);
							    if (_res)
								continue;
							}
						    }
						    _res = 0; _a[_i] = _a[_i+1];
						    break;
						}
						if (_res)
						    break;
					    }
					    _oss_dec_freetempmem(_g, _a);
					    if (_res)
						return _res;
					}
				    }
				}
			    }
			}   break;
			case 2: {
			    _res = _cmUnboundedDirectoryString(_g, (_s_oss_tmp_1->value).u.initial, (_d_oss_tmp_1->value).u.initial);
			    if (_res)
				return _res;
			}   break;
			case 3: {
			    _res = _cmUnboundedDirectoryString(_g, (_s_oss_tmp_1->value).u.any, (_d_oss_tmp_1->value).u.any);
			    if (_res)
				return _res;
			}   break;
			case 4: {
			    _res = _cmUnboundedDirectoryString(_g, (_s_oss_tmp_1->value).u.final, (_d_oss_tmp_1->value).u.final);
			    if (_res)
				return _res;
			}   break;
			case 0:
			    break;
			default:
			    return 1;
		    }
		    _s_oss_tmp_1 = _s_oss_tmp_1->next;
		    _d_oss_tmp_1 = _d_oss_tmp_1->next;
		}
		if (_s_oss_tmp_1 || _d_oss_tmp_1)
		    return 1;
	    }
	} break;
	case 37: {
	    {
		_PostalAddress *  _s_oss_tmp_1 = *(_PostalAddress * *)_odata;
		_PostalAddress *  _d_oss_tmp_1 = *(_PostalAddress * *)_cdata;

		while (_s_oss_tmp_1 && _d_oss_tmp_1) {
		    _res = _cmUnboundedDirectoryString(_g, &(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value));
		    if (_res)
			return _res;
		    _s_oss_tmp_1 = _s_oss_tmp_1->next;
		    _d_oss_tmp_1 = _d_oss_tmp_1->next;
		}
		if (_s_oss_tmp_1 || _d_oss_tmp_1)
		    return 1;
	    }
	} break;
	case 38: {
	    {
		_OctetSubstringAssertion *  _s_oss_tmp_1 = *(_OctetSubstringAssertion * *)_odata;
		_OctetSubstringAssertion *  _d_oss_tmp_1 = *(_OctetSubstringAssertion * *)_cdata;

		while (_s_oss_tmp_1 && _d_oss_tmp_1) {
		    if ((_s_oss_tmp_1->value).choice != (_d_oss_tmp_1->value).choice)
			return 1;
		    switch ((_s_oss_tmp_1->value).choice) {
			case 1: {
			    if (_oss_cmp_unbnd_octet_ia(&((_s_oss_tmp_1->value).u.initial), &((_d_oss_tmp_1->value).u.initial), sizeof(((_d_oss_tmp_1->value).u.initial).length), sizeof(((_d_oss_tmp_1->value).u.initial).value[0]), (unsigned int)((char *)&((_s_oss_tmp_1->value).u.initial).value - (char *)&((_s_oss_tmp_1->value).u.initial))))
				return 1;
			}   break;
			case 2: {
			    if (_oss_cmp_unbnd_octet_ia(&((_s_oss_tmp_1->value).u.any), &((_d_oss_tmp_1->value).u.any), sizeof(((_d_oss_tmp_1->value).u.any).length), sizeof(((_d_oss_tmp_1->value).u.any).value[0]), (unsigned int)((char *)&((_s_oss_tmp_1->value).u.any).value - (char *)&((_s_oss_tmp_1->value).u.any))))
				return 1;
			}   break;
			case 3: {
			    if (_oss_cmp_unbnd_octet_ia(&((_s_oss_tmp_1->value).u.final), &((_d_oss_tmp_1->value).u.final), sizeof(((_d_oss_tmp_1->value).u.final).length), sizeof(((_d_oss_tmp_1->value).u.final).value[0]), (unsigned int)((char *)&((_s_oss_tmp_1->value).u.final).value - (char *)&((_s_oss_tmp_1->value).u.final))))
				return 1;
			}   break;
			case 0:
			    break;
			default:
			    return 1;
		    }
		    _s_oss_tmp_1 = _s_oss_tmp_1->next;
		    _d_oss_tmp_1 = _d_oss_tmp_1->next;
		}
		if (_s_oss_tmp_1 || _d_oss_tmp_1)
		    return 1;
	    }
	} break;
	case 39: {
	    if (*(enum SequenceMatchType  *)_cdata != *(enum SequenceMatchType  *)_odata)
		return 1;
	} break;
	case 40: {
	    if (*(enum WordMatchTypes  *)_cdata != *(enum WordMatchTypes  *)_odata)
		return 1;
	} break;
	case 41: {
	    if (*(enum CharacterMatchTypes  *)_cdata != *(enum CharacterMatchTypes  *)_odata)
		return 1;
	} break;
	case 42: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 43: {
	    if (((*(_TimeSpecification  *)_odata).time).choice != ((*(_TimeSpecification  *)_cdata).time).choice)
		return 1;
	    switch (((*(_TimeSpecification  *)_odata).time).choice) {
		case 1: {
		    if (!(((*(_TimeSpecification  *)_odata).time).u.absolute)->startTime != !(((*(_TimeSpecification  *)_cdata).time).u.absolute)->startTime)
			return 1;
		    if ((((*(_TimeSpecification  *)_odata).time).u.absolute)->startTime) {
			if (strcmp((((*(_TimeSpecification  *)_cdata).time).u.absolute)->startTime, (((*(_TimeSpecification  *)_odata).time).u.absolute)->startTime))
#ifdef BAD_OID_IRI
			    if (_oss_cmp_str2time((((*(_TimeSpecification  *)_cdata).time).u.absolute)->startTime, (((*(_TimeSpecification  *)_odata).time).u.absolute)->startTime, 0))
#endif
				return 1;
		    }
		    if (!(((*(_TimeSpecification  *)_odata).time).u.absolute)->endTime != !(((*(_TimeSpecification  *)_cdata).time).u.absolute)->endTime)
			return 1;
		    if ((((*(_TimeSpecification  *)_odata).time).u.absolute)->endTime) {
			if (strcmp((((*(_TimeSpecification  *)_cdata).time).u.absolute)->endTime, (((*(_TimeSpecification  *)_odata).time).u.absolute)->endTime))
#ifdef BAD_OID_IRI
			    if (_oss_cmp_str2time((((*(_TimeSpecification  *)_cdata).time).u.absolute)->endTime, (((*(_TimeSpecification  *)_odata).time).u.absolute)->endTime, 0))
#endif
				return 1;
		    }
		}   break;
		case 2: {
		    {
			_setof10 *  _s_3 = ((*(_TimeSpecification  *)_odata).time).u.periodic;
			_setof10 *  _d_3 = ((*(_TimeSpecification  *)_cdata).time).u.periodic;
			long        *_a, _i, _i_next, _c = 0L;

			while (_s_3 && _d_3) {
			    ++ _c;
			    _s_3 = _s_3->next;
			    _d_3 = _d_3->next;
			}
			if (_s_3 || _d_3)
			    return 1;
			if (_c) {
			    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
			    for (_i = 0; _i < _c; _i ++)
				_a[_i] = _i;
			    _a[_c] = -1L;
			    for (_s_3 = ((*(_TimeSpecification  *)_odata).time).u.periodic; _s_3; _s_3 = _s_3->next) {
				_i_next = _a[0]; _res = 1;
				for (_d_3 = ((*(_TimeSpecification  *)_cdata).time).u.periodic, _i = 0L; _d_3 && _i_next >= 0L && _a[_i_next] >= 0L; _d_3 = _d_3->next,
					_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
				    if (_i < _i_next)
					continue;
				    {
					_Period  * _odata_3 = &(_s_3->value);
					_Period  * _cdata_3 = &(_d_3->value);

					if (((*_odata_3).bit_mask ^ (*_cdata_3).bit_mask) & 0x80000000)
					    continue;
					if ((*_odata_3).bit_mask & 0x80000000) {
					    {
						_setof8 *  _s_5 = (*_odata_3).timesOfDay;
						_setof8 *  _d_5 = (*_cdata_3).timesOfDay;
						long        *_a, _i, _i_next, _c = 0L;

						while (_s_5 && _d_5) {
						    ++ _c;
						    _s_5 = _s_5->next;
						    _d_5 = _d_5->next;
						}
						if (_s_5 || _d_5)
						    continue;
						if (_c) {
						    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
						    for (_i = 0; _i < _c; _i ++)
							_a[_i] = _i;
						    _a[_c] = -1L;
						    for (_s_5 = (*_odata_3).timesOfDay; _s_5; _s_5 = _s_5->next) {
							_i_next = _a[0]; _res = 1;
							for (_d_5 = (*_cdata_3).timesOfDay, _i = 0L; _d_5 && _i_next >= 0L && _a[_i_next] >= 0L; _d_5 = _d_5->next,
								_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
							    if (_i < _i_next)
								continue;
							    if (((_s_5->value).bit_mask & (_d_5->value).bit_mask) & 0x80000000) {
								_res = _cmDayTime(_g, &((_s_5->value).startDayTime), &((_d_5->value).startDayTime));
								if (_res)
								    continue;
							    } else {
								if ((_s_5->value).bit_mask & 0x80000000) {
								    {
									_res = _cmDayTime(_g, &((_s_5->value).startDayTime), (_DayTime  *)&_v636);
									if (_res)
									    continue;
								    }
								}
								if ((_d_5->value).bit_mask & 0x80000000) {
								    {
									_res = _cmDayTime(_g, (_DayTime  *)&_v636, &((_d_5->value).startDayTime));
									if (_res)
									    continue;
								    }
								}
							    }
							    if (((_s_5->value).bit_mask & (_d_5->value).bit_mask) & 0x40000000) {
								_res = _cmDayTime(_g, &((_s_5->value).endDayTime), &((_d_5->value).endDayTime));
								if (_res)
								    continue;
							    } else {
								if ((_s_5->value).bit_mask & 0x40000000) {
								    {
									_res = _cmDayTime(_g, &((_s_5->value).endDayTime), (_DayTime  *)&_v637);
									if (_res)
									    continue;
								    }
								}
								if ((_d_5->value).bit_mask & 0x40000000) {
								    {
									_res = _cmDayTime(_g, (_DayTime  *)&_v637, &((_d_5->value).endDayTime));
									if (_res)
									    continue;
								    }
								}
							    }
							    _res = 0; _a[_i] = _a[_i+1];
							    break;
							}
							if (_res)
							    break;
						    }
						    _oss_dec_freetempmem(_g, _a);
						    if (_res)
							continue;
						}
					    }
					}
					if (((*_odata_3).bit_mask ^ (*_cdata_3).bit_mask) & 0x40000000)
					    continue;
					if ((*_odata_3).bit_mask & 0x40000000) {
					    if (((*_odata_3).days).choice != ((*_cdata_3).days).choice)
						continue;
					    switch (((*_odata_3).days).choice) {
						case 1: {
						    if (_oss_cmp_arrbits((((*_odata_3).days).u.bitDay).value, (((*_cdata_3).days).u.bitDay).value, (((*_odata_3).days).u.bitDay).length, (((*_cdata_3).days).u.bitDay).length))
							continue;
						}   break;
						case 2: {
						    _res = _cm_setof7(_g, &(((*_odata_3).days).u.intDay), &(((*_cdata_3).days).u.intDay));
						    if (_res)
							continue;
						}   break;
						case 3: {
						    if ((*((*_odata_3).days).u.dayOf).choice != (*((*_cdata_3).days).u.dayOf).choice)
							continue;
						    switch ((*((*_odata_3).days).u.dayOf).choice) {
							case 1: {
							    _res = _cmNamedDay(_g, (*((*_odata_3).days).u.dayOf).u.first, (*((*_cdata_3).days).u.dayOf).u.first);
							    if (_res)
								continue;
							}   break;
							case 2: {
							    _res = _cmNamedDay(_g, (*((*_odata_3).days).u.dayOf).u.second, (*((*_cdata_3).days).u.dayOf).u.second);
							    if (_res)
								continue;
							}   break;
							case 3: {
							    _res = _cmNamedDay(_g, (*((*_odata_3).days).u.dayOf).u.third, (*((*_cdata_3).days).u.dayOf).u.third);
							    if (_res)
								continue;
							}   break;
							case 4: {
							    _res = _cmNamedDay(_g, (*((*_odata_3).days).u.dayOf).u.fourth, (*((*_cdata_3).days).u.dayOf).u.fourth);
							    if (_res)
								continue;
							}   break;
							case 5: {
							    _res = _cmNamedDay(_g, (*((*_odata_3).days).u.dayOf).u.fifth, (*((*_cdata_3).days).u.dayOf).u.fifth);
							    if (_res)
								continue;
							}   break;
							case 0:
							    break;
							default:
							    continue;
						    }
						}   break;
						case 0:
						    break;
						default:
						    continue;
					    }
					}
					if (((*_odata_3).bit_mask ^ (*_cdata_3).bit_mask) & 0x20000000)
					    continue;
					if ((*_odata_3).bit_mask & 0x20000000) {
					    if (((*_odata_3).weeks).choice != ((*_cdata_3).weeks).choice)
						continue;
					    switch (((*_odata_3).weeks).choice) {
						case 1: {
						    if (_oss_cmp_arrbits((((*_odata_3).weeks).u.bitWeek).value, (((*_cdata_3).weeks).u.bitWeek).value, (((*_odata_3).weeks).u.bitWeek).length, (((*_cdata_3).weeks).u.bitWeek).length))
							continue;
						}   break;
						case 2: {
						}   break;
						case 3: {
						    _res = _cm_setof7(_g, &(((*_odata_3).weeks).u.intWeek), &(((*_cdata_3).weeks).u.intWeek));
						    if (_res)
							continue;
						}   break;
						case 0:
						    break;
						default:
						    continue;
					    }
					}
					if (((*_odata_3).bit_mask ^ (*_cdata_3).bit_mask) & 0x10000000)
					    continue;
					if ((*_odata_3).bit_mask & 0x10000000) {
					    if (((*_odata_3).months).choice != ((*_cdata_3).months).choice)
						continue;
					    switch (((*_odata_3).months).choice) {
						case 1: {
						    if (_oss_cmp_arrbits((((*_odata_3).months).u.bitMonth).value, (((*_cdata_3).months).u.bitMonth).value, (((*_odata_3).months).u.bitMonth).length, (((*_cdata_3).months).u.bitMonth).length))
							continue;
						}   break;
						case 2: {
						}   break;
						case 3: {
						    _res = _cm_setof7(_g, &(((*_odata_3).months).u.intMonth), &(((*_cdata_3).months).u.intMonth));
						    if (_res)
							continue;
						}   break;
						case 0:
						    break;
						default:
						    continue;
					    }
					}
					if (((*_odata_3).bit_mask ^ (*_cdata_3).bit_mask) & 0x8000000)
					    continue;
					if ((*_odata_3).bit_mask & 0x8000000) {
					    {
						_setof9 *  _s_5 = (*_odata_3).years;
						_setof9 *  _d_5 = (*_cdata_3).years;
						long        *_a, _i, _i_next, _c = 0L;

						while (_s_5 && _d_5) {
						    ++ _c;
						    _s_5 = _s_5->next;
						    _d_5 = _d_5->next;
						}
						if (_s_5 || _d_5)
						    continue;
						if (_c) {
						    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
						    for (_i = 0; _i < _c; _i ++)
							_a[_i] = _i;
						    _a[_c] = -1L;
						    for (_s_5 = (*_odata_3).years; _s_5; _s_5 = _s_5->next) {
							_i_next = _a[0]; _res = 1;
							for (_d_5 = (*_cdata_3).years, _i = 0L; _d_5 && _i_next >= 0L && _a[_i_next] >= 0L; _d_5 = _d_5->next,
								_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
							    if (_i < _i_next)
								continue;
							    if (_d_5->value != _s_5->value)
								continue;
							    _res = 0; _a[_i] = _a[_i+1];
							    break;
							}
							if (_res)
							    break;
						    }
						    _oss_dec_freetempmem(_g, _a);
						    if (_res)
							continue;
						}
					    }
					}
				    }
				    _res = 0; _a[_i] = _a[_i+1];
				    break;
				}
				if (_res)
				    break;
			    }
			    _oss_dec_freetempmem(_g, _a);
			    if (_res)
				return _res;
			}
		    }
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	    if (((*(_TimeSpecification  *)_odata).bit_mask & (*(_TimeSpecification  *)_cdata).bit_mask) & 0x80000000) {
		if (((*(_TimeSpecification  *)_cdata).notThisTime ^ (*(_TimeSpecification  *)_odata).notThisTime) & 0x01)
		    return 1;
	    } else {
		if ((*(_TimeSpecification  *)_odata).bit_mask & 0x80000000) {
		    if ((Context::default_fallback ^ (*(_TimeSpecification  *)_odata).notThisTime) & 0x01)
			return 1;
		}
		if ((*(_TimeSpecification  *)_cdata).bit_mask & 0x80000000) {
		    if (((*(_TimeSpecification  *)_cdata).notThisTime ^ Context::default_fallback) & 0x01)
			return 1;
		}
	    }
	    if (((*(_TimeSpecification  *)_odata).bit_mask ^ (*(_TimeSpecification  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_TimeSpecification  *)_odata).bit_mask & 0x40000000) {
		if ((*(_TimeSpecification  *)_cdata).timeZone != (*(_TimeSpecification  *)_odata).timeZone)
		    return 1;
	    }
	} break;
	case 44: {
	    if ((*(_TimeAssertion  *)_odata).choice != (*(_TimeAssertion  *)_cdata).choice)
		return 1;
	    switch ((*(_TimeAssertion  *)_odata).choice) {
		case 1: {
		}   break;
		case 2: {
		    if (strcmp(((*(_TimeAssertion  *)_cdata).u.between)->startTime, ((*(_TimeAssertion  *)_odata).u.between)->startTime))
#ifdef BAD_OID_IRI
			if (_oss_cmp_str2time(((*(_TimeAssertion  *)_cdata).u.between)->startTime, ((*(_TimeAssertion  *)_odata).u.between)->startTime, 0))
#endif
			    return 1;
		    if (!((*(_TimeAssertion  *)_odata).u.between)->endTime != !((*(_TimeAssertion  *)_cdata).u.between)->endTime)
			return 1;
		    if (((*(_TimeAssertion  *)_odata).u.between)->endTime) {
			if (strcmp(((*(_TimeAssertion  *)_cdata).u.between)->endTime, ((*(_TimeAssertion  *)_odata).u.between)->endTime))
#ifdef BAD_OID_IRI
			    if (_oss_cmp_str2time(((*(_TimeAssertion  *)_cdata).u.between)->endTime, ((*(_TimeAssertion  *)_odata).u.between)->endTime, 0))
#endif
				return 1;
		    }
		    if ((((*(_TimeAssertion  *)_odata).u.between)->bit_mask & ((*(_TimeAssertion  *)_cdata).u.between)->bit_mask) & 0x80000000) {
			if ((((*(_TimeAssertion  *)_cdata).u.between)->entirely ^ ((*(_TimeAssertion  *)_odata).u.between)->entirely) & 0x01)
			    return 1;
		    } else {
			if (((*(_TimeAssertion  *)_odata).u.between)->bit_mask & 0x80000000) {
			    if ((Context::default_fallback ^ ((*(_TimeAssertion  *)_odata).u.between)->entirely) & 0x01)
				return 1;
			}
			if (((*(_TimeAssertion  *)_cdata).u.between)->bit_mask & 0x80000000) {
			    if ((((*(_TimeAssertion  *)_cdata).u.between)->entirely ^ Context::default_fallback) & 0x01)
				return 1;
			}
		    }
		}   break;
		case 3: {
		    if (strcmp((*(_TimeAssertion  *)_cdata).u.at, (*(_TimeAssertion  *)_odata).u.at))
#ifdef BAD_OID_IRI
			if (_oss_cmp_str2time((*(_TimeAssertion  *)_cdata).u.at, (*(_TimeAssertion  *)_odata).u.at, 0))
#endif
			    return 1;
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 45: {
	    if ((*(_LocaleContextSyntax  *)_odata).choice != (*(_LocaleContextSyntax  *)_cdata).choice)
		return 1;
	    switch ((*(_LocaleContextSyntax  *)_odata).choice) {
		case 1: {
		    if (!((*(_LocaleContextSyntax  *)_cdata).u.localeID1).length)
			return 1;
		    if (_oss_cmp_unbnd_octet_ia(&((*(_LocaleContextSyntax  *)_odata).u.localeID1), &((*(_LocaleContextSyntax  *)_cdata).u.localeID1), sizeof(((*(_LocaleContextSyntax  *)_cdata).u.localeID1).length), sizeof(((*(_LocaleContextSyntax  *)_cdata).u.localeID1).value[0]), (unsigned int)((char *)&((*(_LocaleContextSyntax  *)_odata).u.localeID1).value - (char *)&((*(_LocaleContextSyntax  *)_odata).u.localeID1))))
			return 1;
		}   break;
		case 2: {
		    _res = _cmUnboundedDirectoryString(_g, (*(_LocaleContextSyntax  *)_odata).u.localeID2, (*(_LocaleContextSyntax  *)_cdata).u.localeID2);
		    if (_res)
			return _res;
		}   break;
		case 0:
		    break;
		default:
		    return 1;
	    }
	} break;
	case 46: {
	    {
		_setof3 *  _s_oss_tmp_1 = *(_setof3 * *)_odata;
		_setof3 *  _d_oss_tmp_1 = *(_setof3 * *)_cdata;

		while (_s_oss_tmp_1 && _d_oss_tmp_1) {
		    if (_oss_cmp_unbnd_octet_ia(&(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value), sizeof((_d_oss_tmp_1->value).length), sizeof((_d_oss_tmp_1->value).value[0]), (unsigned int)((char *)&(_s_oss_tmp_1->value).value - (char *)&(_s_oss_tmp_1->value))))
			return 1;
		    _s_oss_tmp_1 = _s_oss_tmp_1->next;
		    _d_oss_tmp_1 = _d_oss_tmp_1->next;
		}
		if (_s_oss_tmp_1 || _d_oss_tmp_1)
		    return 1;
	    }
	} break;
	case 47: {
	    if (!(*(OSSC::COssEncOID  *)_cdata).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssEncOID  *)_odata, (OSSC::COssEncOID  *)_cdata, sizeof((*(OSSC::COssEncOID  *)_cdata).length), sizeof((*(OSSC::COssEncOID  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssEncOID  *)_odata).value - (char *)(OSSC::COssEncOID  *)_odata)))
		return 1;
	} break;
	case 48: {
	    _res = _oss_cmp_open_type(_g, (OpenType *)(OSSC::COssOpen  *)_odata, (OpenType *)(OSSC::COssOpen  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 49: {
	    _res = _cmContextAssertion(_g, (_ContextAssertion  *)_odata, (_ContextAssertion  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 50: {
	    if (!((*(_AttributeTypeAssertion  *)_cdata).type).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*(_AttributeTypeAssertion  *)_odata).type), &((*(_AttributeTypeAssertion  *)_cdata).type), sizeof(((*(_AttributeTypeAssertion  *)_cdata).type).length), sizeof(((*(_AttributeTypeAssertion  *)_cdata).type).value[0]), (unsigned int)((char *)&((*(_AttributeTypeAssertion  *)_odata).type).value - (char *)&((*(_AttributeTypeAssertion  *)_odata).type))))
		return 1;
	    if (((*(_AttributeTypeAssertion  *)_odata).bit_mask ^ (*(_AttributeTypeAssertion  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_AttributeTypeAssertion  *)_odata).bit_mask & 0x80000000) {
		{
		    _setof6 *  _s_oss_tmp_2 = (*(_AttributeTypeAssertion  *)_odata).assertedContexts;
		    _setof6 *  _d_oss_tmp_2 = (*(_AttributeTypeAssertion  *)_cdata).assertedContexts;

		    while (_s_oss_tmp_2 && _d_oss_tmp_2) {
			_res = _cmContextAssertion(_g, &(_s_oss_tmp_2->value), &(_d_oss_tmp_2->value));
			if (_res)
			    return _res;
			_s_oss_tmp_2 = _s_oss_tmp_2->next;
			_d_oss_tmp_2 = _d_oss_tmp_2->next;
		    }
		    if (_s_oss_tmp_2 || _d_oss_tmp_2)
			return 1;
		}
	    }
	} break;
	case 51: {
	    _res = _cmRDNSequence(_g, (_RDNSequence * *)_odata, (_RDNSequence * *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 52: {
	    if (((*(_SubtreeSpecification  *)_odata).bit_mask & (*(_SubtreeSpecification  *)_cdata).bit_mask) & 0x80000000) {
		_res = _cmRDNSequence(_g, &((*(_SubtreeSpecification  *)_odata).base), &((*(_SubtreeSpecification  *)_cdata).base));
		if (_res)
		    return _res;
	    } else {
		if ((*(_SubtreeSpecification  *)_odata).bit_mask & 0x80000000) {
		    {
			_RDNSequence * _cdata_1 = _v642;
			_res = _cmRDNSequence(_g, &((*(_SubtreeSpecification  *)_odata).base), &_cdata_1);
			if (_res)
			    return _res;
		    }
		}
		if ((*(_SubtreeSpecification  *)_cdata).bit_mask & 0x80000000) {
		    {
			_RDNSequence * _odata_1 = _v642;
			_res = _cmRDNSequence(_g, &_odata_1, &((*(_SubtreeSpecification  *)_cdata).base));
			if (_res)
			    return _res;
		    }
		}
	    }
	    if (((*(_SubtreeSpecification  *)_odata).bit_mask ^ (*(_SubtreeSpecification  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_SubtreeSpecification  *)_odata).bit_mask & 0x40000000) {
		{
		    _setof19 *  _s_2 = (*(_SubtreeSpecification  *)_odata).specificExclusions;
		    _setof19 *  _d_2 = (*(_SubtreeSpecification  *)_cdata).specificExclusions;
		    long        *_a, _i, _i_next, _c = 0L;

		    while (_s_2 && _d_2) {
			++ _c;
			_s_2 = _s_2->next;
			_d_2 = _d_2->next;
		    }
		    if (_s_2 || _d_2)
			return 1;
		    if (_c) {
			_a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
			for (_i = 0; _i < _c; _i ++)
			    _a[_i] = _i;
			_a[_c] = -1L;
			for (_s_2 = (*(_SubtreeSpecification  *)_odata).specificExclusions; _s_2; _s_2 = _s_2->next) {
			    _i_next = _a[0]; _res = 1;
			    for (_d_2 = (*(_SubtreeSpecification  *)_cdata).specificExclusions, _i = 0L; _d_2 && _i_next >= 0L && _a[_i_next] >= 0L; _d_2 = _d_2->next,
				    _i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
				if (_i < _i_next)
				    continue;
				if ((_s_2->value).choice != (_d_2->value).choice)
				    continue;
				switch ((_s_2->value).choice) {
				    case 1: {
					_res = _cmRDNSequence(_g, &((_s_2->value).u.chopBefore), &((_d_2->value).u.chopBefore));
					if (_res)
					    continue;
				    }   break;
				    case 2: {
					_res = _cmRDNSequence(_g, &((_s_2->value).u.chopAfter), &((_d_2->value).u.chopAfter));
					if (_res)
					    continue;
				    }   break;
				    case 0:
					break;
				    default:
					continue;
				}
				_res = 0; _a[_i] = _a[_i+1];
				break;
			    }
			    if (_res)
				break;
			}
			_oss_dec_freetempmem(_g, _a);
			if (_res)
			    return _res;
		    }
		}
	    }
	    if (((*(_SubtreeSpecification  *)_odata).bit_mask & (*(_SubtreeSpecification  *)_cdata).bit_mask) & 0x20000000) {
		if ((*(_SubtreeSpecification  *)_cdata).minimum != (*(_SubtreeSpecification  *)_odata).minimum)
		    return 1;
	    } else {
		if ((*(_SubtreeSpecification  *)_odata).bit_mask & 0x20000000) {
		    if (SubtreeSpecification::default_minimum != (*(_SubtreeSpecification  *)_odata).minimum)
			return 1;
		}
		if ((*(_SubtreeSpecification  *)_cdata).bit_mask & 0x20000000) {
		    if ((*(_SubtreeSpecification  *)_cdata).minimum != SubtreeSpecification::default_minimum)
			return 1;
		}
	    }
	    if (((*(_SubtreeSpecification  *)_odata).bit_mask ^ (*(_SubtreeSpecification  *)_cdata).bit_mask) & 0x10000000)
		return 1;
	    if ((*(_SubtreeSpecification  *)_odata).bit_mask & 0x10000000) {
		if ((*(_SubtreeSpecification  *)_cdata).maximum != (*(_SubtreeSpecification  *)_odata).maximum)
		    return 1;
	    }
	    if (((*(_SubtreeSpecification  *)_odata).bit_mask ^ (*(_SubtreeSpecification  *)_cdata).bit_mask) & 0x8000000)
		return 1;
	    if ((*(_SubtreeSpecification  *)_odata).bit_mask & 0x8000000) {
		_res = _cmRefinement(_g, &((*(_SubtreeSpecification  *)_odata).specificationFilter), &((*(_SubtreeSpecification  *)_cdata).specificationFilter));
		if (_res)
		    return _res;
	    }
	} break;
	case 53: {
	    if ((*(_DITStructureRule  *)_cdata).ruleIdentifier != (*(_DITStructureRule  *)_odata).ruleIdentifier)
		return 1;
	    if (!((*(_DITStructureRule  *)_cdata).nameForm).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*(_DITStructureRule  *)_odata).nameForm), &((*(_DITStructureRule  *)_cdata).nameForm), sizeof(((*(_DITStructureRule  *)_cdata).nameForm).length), sizeof(((*(_DITStructureRule  *)_cdata).nameForm).value[0]), (unsigned int)((char *)&((*(_DITStructureRule  *)_odata).nameForm).value - (char *)&((*(_DITStructureRule  *)_odata).nameForm))))
		return 1;
	    if (((*(_DITStructureRule  *)_odata).bit_mask ^ (*(_DITStructureRule  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_DITStructureRule  *)_odata).bit_mask & 0x80000000) {
		{
		    _Presentation_context_deletion_list *  _s_2 = (*(_DITStructureRule  *)_odata).superiorStructureRules;
		    _Presentation_context_deletion_list *  _d_2 = (*(_DITStructureRule  *)_cdata).superiorStructureRules;
		    long        *_a, _i, _i_next, _c = 0L;

		    while (_s_2 && _d_2) {
			++ _c;
			_s_2 = _s_2->next;
			_d_2 = _d_2->next;
		    }
		    if (_s_2 || _d_2)
			return 1;
		    if (_c) {
			_a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
			for (_i = 0; _i < _c; _i ++)
			    _a[_i] = _i;
			_a[_c] = -1L;
			for (_s_2 = (*(_DITStructureRule  *)_odata).superiorStructureRules; _s_2; _s_2 = _s_2->next) {
			    _i_next = _a[0]; _res = 1;
			    for (_d_2 = (*(_DITStructureRule  *)_cdata).superiorStructureRules, _i = 0L; _d_2 && _i_next >= 0L && _a[_i_next] >= 0L; _d_2 = _d_2->next,
				    _i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
				if (_i < _i_next)
				    continue;
				if (_d_2->value != _s_2->value)
				    continue;
				_res = 0; _a[_i] = _a[_i+1];
				break;
			    }
			    if (_res)
				break;
			}
			_oss_dec_freetempmem(_g, _a);
			if (_res)
			    return _res;
		    }
		}
	    }
	} break;
	case 54: {
	    if (!((*(_DITContentRule  *)_cdata).structuralObjectClass).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*(_DITContentRule  *)_odata).structuralObjectClass), &((*(_DITContentRule  *)_cdata).structuralObjectClass), sizeof(((*(_DITContentRule  *)_cdata).structuralObjectClass).length), sizeof(((*(_DITContentRule  *)_cdata).structuralObjectClass).value[0]), (unsigned int)((char *)&((*(_DITContentRule  *)_odata).structuralObjectClass).value - (char *)&((*(_DITContentRule  *)_odata).structuralObjectClass))))
		return 1;
	    if (((*(_DITContentRule  *)_odata).bit_mask ^ (*(_DITContentRule  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_DITContentRule  *)_odata).bit_mask & 0x80000000) {
		{
		    _Application_context_name_list *  _s_2 = (*(_DITContentRule  *)_odata).auxiliaries;
		    _Application_context_name_list *  _d_2 = (*(_DITContentRule  *)_cdata).auxiliaries;
		    long        *_a, _i, _i_next, _c = 0L;

		    while (_s_2 && _d_2) {
			++ _c;
			_s_2 = _s_2->next;
			_d_2 = _d_2->next;
		    }
		    if (_s_2 || _d_2)
			return 1;
		    if (_c) {
			_a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
			for (_i = 0; _i < _c; _i ++)
			    _a[_i] = _i;
			_a[_c] = -1L;
			for (_s_2 = (*(_DITContentRule  *)_odata).auxiliaries; _s_2; _s_2 = _s_2->next) {
			    _i_next = _a[0]; _res = 1;
			    for (_d_2 = (*(_DITContentRule  *)_cdata).auxiliaries, _i = 0L; _d_2 && _i_next >= 0L && _a[_i_next] >= 0L; _d_2 = _d_2->next,
				    _i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
				if (_i < _i_next)
				    continue;
				if (!(_d_2->value).length)
				    continue;
				if (_oss_cmp_unbnd_octet_ia(&(_s_2->value), &(_d_2->value), sizeof((_d_2->value).length), sizeof((_d_2->value).value[0]), (unsigned int)((char *)&(_s_2->value).value - (char *)&(_s_2->value))))
				    continue;
				_res = 0; _a[_i] = _a[_i+1];
				break;
			    }
			    if (_res)
				break;
			}
			_oss_dec_freetempmem(_g, _a);
			if (_res)
			    return _res;
		    }
		}
	    }
	    if (((*(_DITContentRule  *)_odata).bit_mask ^ (*(_DITContentRule  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_DITContentRule  *)_odata).bit_mask & 0x40000000) {
		{
		    _Application_context_name_list *  _s_2 = (*(_DITContentRule  *)_odata).mandatory;
		    _Application_context_name_list *  _d_2 = (*(_DITContentRule  *)_cdata).mandatory;
		    long        *_a, _i, _i_next, _c = 0L;

		    while (_s_2 && _d_2) {
			++ _c;
			_s_2 = _s_2->next;
			_d_2 = _d_2->next;
		    }
		    if (_s_2 || _d_2)
			return 1;
		    if (_c) {
			_a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
			for (_i = 0; _i < _c; _i ++)
			    _a[_i] = _i;
			_a[_c] = -1L;
			for (_s_2 = (*(_DITContentRule  *)_odata).mandatory; _s_2; _s_2 = _s_2->next) {
			    _i_next = _a[0]; _res = 1;
			    for (_d_2 = (*(_DITContentRule  *)_cdata).mandatory, _i = 0L; _d_2 && _i_next >= 0L && _a[_i_next] >= 0L; _d_2 = _d_2->next,
				    _i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
				if (_i < _i_next)
				    continue;
				if (!(_d_2->value).length)
				    continue;
				if (_oss_cmp_unbnd_octet_ia(&(_s_2->value), &(_d_2->value), sizeof((_d_2->value).length), sizeof((_d_2->value).value[0]), (unsigned int)((char *)&(_s_2->value).value - (char *)&(_s_2->value))))
				    continue;
				_res = 0; _a[_i] = _a[_i+1];
				break;
			    }
			    if (_res)
				break;
			}
			_oss_dec_freetempmem(_g, _a);
			if (_res)
			    return _res;
		    }
		}
	    }
	    if (((*(_DITContentRule  *)_odata).bit_mask ^ (*(_DITContentRule  *)_cdata).bit_mask) & 0x20000000)
		return 1;
	    if ((*(_DITContentRule  *)_odata).bit_mask & 0x20000000) {
		{
		    _Application_context_name_list *  _s_2 = (*(_DITContentRule  *)_odata).optional;
		    _Application_context_name_list *  _d_2 = (*(_DITContentRule  *)_cdata).optional;
		    long        *_a, _i, _i_next, _c = 0L;

		    while (_s_2 && _d_2) {
			++ _c;
			_s_2 = _s_2->next;
			_d_2 = _d_2->next;
		    }
		    if (_s_2 || _d_2)
			return 1;
		    if (_c) {
			_a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
			for (_i = 0; _i < _c; _i ++)
			    _a[_i] = _i;
			_a[_c] = -1L;
			for (_s_2 = (*(_DITContentRule  *)_odata).optional; _s_2; _s_2 = _s_2->next) {
			    _i_next = _a[0]; _res = 1;
			    for (_d_2 = (*(_DITContentRule  *)_cdata).optional, _i = 0L; _d_2 && _i_next >= 0L && _a[_i_next] >= 0L; _d_2 = _d_2->next,
				    _i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
				if (_i < _i_next)
				    continue;
				if (!(_d_2->value).length)
				    continue;
				if (_oss_cmp_unbnd_octet_ia(&(_s_2->value), &(_d_2->value), sizeof((_d_2->value).length), sizeof((_d_2->value).value[0]), (unsigned int)((char *)&(_s_2->value).value - (char *)&(_s_2->value))))
				    continue;
				_res = 0; _a[_i] = _a[_i+1];
				break;
			    }
			    if (_res)
				break;
			}
			_oss_dec_freetempmem(_g, _a);
			if (_res)
			    return _res;
		    }
		}
	    }
	    if (((*(_DITContentRule  *)_odata).bit_mask ^ (*(_DITContentRule  *)_cdata).bit_mask) & 0x10000000)
		return 1;
	    if ((*(_DITContentRule  *)_odata).bit_mask & 0x10000000) {
		{
		    _Application_context_name_list *  _s_2 = (*(_DITContentRule  *)_odata).precluded;
		    _Application_context_name_list *  _d_2 = (*(_DITContentRule  *)_cdata).precluded;
		    long        *_a, _i, _i_next, _c = 0L;

		    while (_s_2 && _d_2) {
			++ _c;
			_s_2 = _s_2->next;
			_d_2 = _d_2->next;
		    }
		    if (_s_2 || _d_2)
			return 1;
		    if (_c) {
			_a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
			for (_i = 0; _i < _c; _i ++)
			    _a[_i] = _i;
			_a[_c] = -1L;
			for (_s_2 = (*(_DITContentRule  *)_odata).precluded; _s_2; _s_2 = _s_2->next) {
			    _i_next = _a[0]; _res = 1;
			    for (_d_2 = (*(_DITContentRule  *)_cdata).precluded, _i = 0L; _d_2 && _i_next >= 0L && _a[_i_next] >= 0L; _d_2 = _d_2->next,
				    _i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
				if (_i < _i_next)
				    continue;
				if (!(_d_2->value).length)
				    continue;
				if (_oss_cmp_unbnd_octet_ia(&(_s_2->value), &(_d_2->value), sizeof((_d_2->value).length), sizeof((_d_2->value).value[0]), (unsigned int)((char *)&(_s_2->value).value - (char *)&(_s_2->value))))
				    continue;
				_res = 0; _a[_i] = _a[_i+1];
				break;
			    }
			    if (_res)
				break;
			}
			_oss_dec_freetempmem(_g, _a);
			if (_res)
			    return _res;
		    }
		}
	    }
	} break;
	case 55: {
	    if (!((*(_DITContextUse  *)_cdata).attributeType).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*(_DITContextUse  *)_odata).attributeType), &((*(_DITContextUse  *)_cdata).attributeType), sizeof(((*(_DITContextUse  *)_cdata).attributeType).length), sizeof(((*(_DITContextUse  *)_cdata).attributeType).value[0]), (unsigned int)((char *)&((*(_DITContextUse  *)_odata).attributeType).value - (char *)&((*(_DITContextUse  *)_odata).attributeType))))
		return 1;
	    if (((*(_DITContextUse  *)_odata).bit_mask ^ (*(_DITContextUse  *)_cdata).bit_mask) & 0x80000000)
		return 1;
	    if ((*(_DITContextUse  *)_odata).bit_mask & 0x80000000) {
		{
		    _Application_context_name_list *  _s_2 = (*(_DITContextUse  *)_odata).mandatoryContexts;
		    _Application_context_name_list *  _d_2 = (*(_DITContextUse  *)_cdata).mandatoryContexts;
		    long        *_a, _i, _i_next, _c = 0L;

		    while (_s_2 && _d_2) {
			++ _c;
			_s_2 = _s_2->next;
			_d_2 = _d_2->next;
		    }
		    if (_s_2 || _d_2)
			return 1;
		    if (_c) {
			_a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
			for (_i = 0; _i < _c; _i ++)
			    _a[_i] = _i;
			_a[_c] = -1L;
			for (_s_2 = (*(_DITContextUse  *)_odata).mandatoryContexts; _s_2; _s_2 = _s_2->next) {
			    _i_next = _a[0]; _res = 1;
			    for (_d_2 = (*(_DITContextUse  *)_cdata).mandatoryContexts, _i = 0L; _d_2 && _i_next >= 0L && _a[_i_next] >= 0L; _d_2 = _d_2->next,
				    _i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
				if (_i < _i_next)
				    continue;
				if (!(_d_2->value).length)
				    continue;
				if (_oss_cmp_unbnd_octet_ia(&(_s_2->value), &(_d_2->value), sizeof((_d_2->value).length), sizeof((_d_2->value).value[0]), (unsigned int)((char *)&(_s_2->value).value - (char *)&(_s_2->value))))
				    continue;
				_res = 0; _a[_i] = _a[_i+1];
				break;
			    }
			    if (_res)
				break;
			}
			_oss_dec_freetempmem(_g, _a);
			if (_res)
			    return _res;
		    }
		}
	    }
	    if (((*(_DITContextUse  *)_odata).bit_mask ^ (*(_DITContextUse  *)_cdata).bit_mask) & 0x40000000)
		return 1;
	    if ((*(_DITContextUse  *)_odata).bit_mask & 0x40000000) {
		{
		    _Application_context_name_list *  _s_2 = (*(_DITContextUse  *)_odata).optionalContexts;
		    _Application_context_name_list *  _d_2 = (*(_DITContextUse  *)_cdata).optionalContexts;
		    long        *_a, _i, _i_next, _c = 0L;

		    while (_s_2 && _d_2) {
			++ _c;
			_s_2 = _s_2->next;
			_d_2 = _d_2->next;
		    }
		    if (_s_2 || _d_2)
			return 1;
		    if (_c) {
			_a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
			for (_i = 0; _i < _c; _i ++)
			    _a[_i] = _i;
			_a[_c] = -1L;
			for (_s_2 = (*(_DITContextUse  *)_odata).optionalContexts; _s_2; _s_2 = _s_2->next) {
			    _i_next = _a[0]; _res = 1;
			    for (_d_2 = (*(_DITContextUse  *)_cdata).optionalContexts, _i = 0L; _d_2 && _i_next >= 0L && _a[_i_next] >= 0L; _d_2 = _d_2->next,
				    _i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
				if (_i < _i_next)
				    continue;
				if (!(_d_2->value).length)
				    continue;
				if (_oss_cmp_unbnd_octet_ia(&(_s_2->value), &(_d_2->value), sizeof((_d_2->value).length), sizeof((_d_2->value).value[0]), (unsigned int)((char *)&(_s_2->value).value - (char *)&(_s_2->value))))
				    continue;
				_res = 0; _a[_i] = _a[_i+1];
				break;
			    }
			    if (_res)
				break;
			}
			_oss_dec_freetempmem(_g, _a);
			if (_res)
			    return _res;
		    }
		}
	    }
	} break;
	case 56: {
	    if (*(OSS_INT32  *)_cdata != *(OSS_INT32  *)_odata)
		return 1;
	} break;
	case 57: {
	    if ((*(ossBoolean  *)_cdata ^ *(ossBoolean  *)_odata) & 0x01)
		return 1;
	} break;
	case 58: {
	    _res = _cmRealizationParameter(_g, (_RealizationParameter  *)_odata, (_RealizationParameter  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 59: {
	    _res = _cmRealizationParameter(_g, (_RealizationParameter  *)_odata, (_RealizationParameter  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 60: {
	    _res = _cmRealizationParameter(_g, (_RealizationParameter  *)_odata, (_RealizationParameter  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 61: {
	    _res = _cmRealizationParameter(_g, (_RealizationParameter  *)_odata, (_RealizationParameter  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 62: {
	    _res = _cmRealizationParameter(_g, (_RealizationParameter  *)_odata, (_RealizationParameter  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 63: {
	    _res = _cmRealizationParameter(_g, (_RealizationParameter  *)_odata, (_RealizationParameter  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 64: {
	    if (_oss_cmp_arrbits((*(OSSC::COssBitString  *)_odata).value, (*(OSSC::COssBitString  *)_cdata).value, (*(OSSC::COssBitString  *)_odata).length, (*(OSSC::COssBitString  *)_cdata).length))
		return 1;
	} break;
	case 65: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 66: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 67: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 68: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 69: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 70: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 71: {
	    if ((*(ossBoolean  *)_cdata ^ *(ossBoolean  *)_odata) & 0x01)
		return 1;
	} break;
	case 72: {
	    if (*(OSS_INT32  *)_cdata != *(OSS_INT32  *)_odata)
		return 1;
	} break;
	case 73: {
	    if (*(OSS_INT32  *)_cdata != *(OSS_INT32  *)_odata)
		return 1;
	} break;
	case 74: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 75: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 76: {
	    if (strcmp(*(char *  *)_cdata, *(char *  *)_odata))
#ifdef BAD_OID_IRI
		if (_oss_cmp_str2time(*(char *  *)_cdata, *(char *  *)_odata, 1))
#endif
		    return 1;
	} break;
	case 77: {
	    if (strcmp(*(char *  *)_cdata, *(char *  *)_odata))
#ifdef BAD_OID_IRI
		if (_oss_cmp_str2time(*(char *  *)_cdata, *(char *  *)_odata, 1))
#endif
		    return 1;
	} break;
	case 78: {
	    if (strcmp(*(char *  *)_cdata, *(char *  *)_odata))
#ifdef BAD_OID_IRI
		if (_oss_cmp_str2time(*(char *  *)_cdata, *(char *  *)_odata, 0))
#endif
		    return 1;
	} break;
	case 79: {
	    if (strcmp(*(char *  *)_cdata, *(char *  *)_odata))
#ifdef BAD_OID_IRI
		if (_oss_cmp_str2time(*(char *  *)_cdata, *(char *  *)_odata, 0))
#endif
		    return 1;
	} break;
	case 80: {
	    if (*(OSS_INT32  *)_cdata != *(OSS_INT32  *)_odata)
		return 1;
	} break;
	case 81: {
	    if (!(*(OSSC::COssEncOID  *)_cdata).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssEncOID  *)_odata, (OSSC::COssEncOID  *)_cdata, sizeof((*(OSSC::COssEncOID  *)_cdata).length), sizeof((*(OSSC::COssEncOID  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssEncOID  *)_odata).value - (char *)(OSSC::COssEncOID  *)_odata)))
		return 1;
	} break;
	case 82: {
	    if (strcmp(*(char *  *)_cdata, *(char *  *)_odata))
#ifdef BAD_OID_IRI
		if (_oss_cmp_str2time(*(char *  *)_cdata, *(char *  *)_odata, 0))
#endif
		    return 1;
	} break;
	case 83: {
	    if (strcmp(*(char *  *)_cdata, *(char *  *)_odata))
#ifdef BAD_OID_IRI
		if (_oss_cmp_str2time(*(char *  *)_cdata, *(char *  *)_odata, 0))
#endif
		    return 1;
	} break;
	case 84: {
	    if (strcmp(*(char *  *)_cdata, *(char *  *)_odata))
#ifdef BAD_OID_IRI
		if (_oss_cmp_str2time(*(char *  *)_cdata, *(char *  *)_odata, 0))
#endif
		    return 1;
	} break;
	case 85: {
	    if ((*(ossBoolean  *)_cdata ^ *(ossBoolean  *)_odata) & 0x01)
		return 1;
	} break;
	default:
	    return PDU_RANGE;
    }
    return _res;
}
#endif /* OSS_COMPARE_VALUE */

int _oss_cmp_new_open_type (OssGlobal *_g, int _pduNum1, int _pduNum2,
		OssBuf *_obuf1, OssBuf *_obuf2, void *_decoded1, void *_decoded2)
{
    unsigned long   apiFlags = _g->decodingFlags | _g->encodingFlags;

    if (!(apiFlags & DONT_DO_DECODED) && (_decoded1 || _decoded2)) {
	if (!_decoded1 || !_decoded2 || _pduNum1 != _pduNum2 || _pduNum1 == 0)
	    return VALUES_NOT_EQUAL;
#ifdef OSS_COMPARE_VALUE
	if (_CMUpperBounds_(_g, _pduNum1, _decoded1, _decoded2))
	    return VALUES_NOT_EQUAL;
#else
	_oss_toed_error(_g, _cmp_code_not_linked, nullptr);
#endif
    } else if (!(apiFlags & DONT_DO_ENCODED) && (_obuf1->value || _obuf2->value)) {
	if (!_obuf1->value || !_obuf2->value || _obuf1->length != _obuf2->length ||
		memcmp(_obuf1->value, _obuf2->value, _obuf1->length))
	    return VALUES_NOT_EQUAL;
    }

    return VALUES_EQUAL;
}
/* Entry points */
static const _entry_point_struct _entry_points = {_ossinit_UpperBounds, _emUpperBounds_, _dmUpperBounds_, 
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
_fmUpperBounds_,
#else
nullptr, 
#endif
117,
_peUpperBounds_, _pdUpperBounds_, 116, 0, nullptr,
#ifdef OSSPRINT
_pmUpperBounds_
#else
nullptr
#endif
};
static void _oss_post_init(struct ossGlobal *world) {
    static const unsigned char _oss_typeinfo[] = {
        0x00, 0x54, 0x34, 0x93, 0x10, 0x6e, 0xe8, 0x8a, 0x4a, 0xbd,
        0xc4, 0x88, 0x4a, 0xbe, 0xc4, 0x3a, 0x77, 0x49, 0x20, 0xe5,
        0x71, 0x8d, 0x3d, 0x91, 0xd8, 0xc7, 0xff, 0x8e, 0x8c, 0xcb,
        0x63, 0x22, 0x9f, 0x53, 0xed, 0xf8, 0x2c, 0xae, 0x62, 0x22,
        0x8c, 0x7f, 0xfa, 0xae, 0x73, 0xf9, 0xa3, 0x0b, 0x28, 0x15,
        0x15, 0x57, 0x85, 0x71, 0x62, 0x4f, 0x88, 0x2f, 0x04, 0x5d,
        0xf7, 0x3b, 0xe9, 0xf6, 0xca, 0xbe, 0xbd, 0xfe, 0x53, 0x12,
        0xa8, 0xca, 0xf4, 0xa2, 0xb5, 0x7d, 0x4e, 0x20, 0x8c, 0xe6,
        0xf9, 0xae, 0x2e, 0x06, 0x16, 0x13
    };
    ossInitRootContext1(world, (unsigned char *)_oss_typeinfo);
}

} /* extern "C" */

void *UpperBounds_TableType::internal = (void *)&_entry_points;
} // namespace ASN
